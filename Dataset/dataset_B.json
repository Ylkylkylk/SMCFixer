[
  {
    "Changes1": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Functions can now only be overridden when they are either marked with the\n<code>virtual</code> keyword or defined in an interface. Functions without\nimplementation outside an interface have to be marked <code>virtual</code>.\nWhen overriding a function or modifier, the new keyword <code>override</code>\nmust be used. When overriding a function or modifier defined in multiple\nparallel bases, all bases must be listed in parentheses after the keyword\nlike so: <code>override(Base1, Base2)</code>.Add virtual to every non-interface function you intend to override.Add <code>virtual</code> to every non-interface function you intend to override. Add <code>virtual</code>to all functions without implementation outside interfaces. For single inheritance, add <code>override</code> to every overriding function. For multiple inheritance, add <code>override(A, B, ..)</code>,where you list all contracts that define the overridden function in the parentheses. When multiple bases define the same function, the inheriting contract must override all conflicting functions.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract A {\n    function foo() public pure returns (string memory) {\n        return \"A\";\n    }\n}\n\ncontract B is A {\n    function foo() public pure returns (string memory) {\n        return \"B\";\n    }\n}",
          "error message": ":1:146: TypeError: Overriding function is missing \"override\" specifier.\n ... A\";     } }  contract B is A {     function foo() public pure returns (string memory) {         return \"B\";     } }\n                                        ^----------------------------------------------------------------------------^\n:1:42: Overridden function is here:\n ...  solidity^0.6.0;  contract A {     function foo() public pure returns (string memory) {         return \"A\";     } }  contract B is A {     function  ...\n                                        ^----------------------------------------------------------------------------^\n:1:42: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ...  solidity^0.6.0;  contract A {     function foo() public pure returns (string memory) {         return \"A\";     } }  contract B is A {     function  ...\n                                        ^----------------------------------------------------------------------------^\n:1:146: Overriding function is here:\n ... A\";     } }  contract B is A {     function foo() public pure returns (string memory) {         return \"B\";     } }\n                                        ^----------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract X {\n    function bar() public pure returns (string memory) {\n        return \"X\";\n    }\n    \n    function baz() public pure returns (string memory) {\n        return \"Baz\";\n    }\n}\n\ncontract Y is X {\n    function bar() public pure returns (string memory) {\n        return \"Y\";\n    }\n}",
          "error message": ":1:236: TypeError: Overriding function is missing \"override\" specifier.\n ... z\";     } }  contract Y is X {     function bar() public pure returns (string memory) {         return \"Y\";     } }\n                                        ^----------------------------------------------------------------------------^\n:1:42: Overridden function is here:\n ...  solidity^0.6.0;  contract X {     function bar() public pure returns (string memory) {         return \"X\";     }          function baz() public pur ...\n                                        ^----------------------------------------------------------------------------^\n:1:42: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ...  solidity^0.6.0;  contract X {     function bar() public pure returns (string memory) {         return \"X\";     }          function baz() public pur ...\n                                        ^----------------------------------------------------------------------------^\n:1:236: Overriding function is here:\n ... z\";     } }  contract Y is X {     function bar() public pure returns (string memory) {         return \"Y\";     } }\n                                        ^----------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Parent {\n    function greetParent() public pure returns (string memory) {\n        return \"Hello Parent\";\n    }\n}\n\ncontract Child is Parent {\n    function greetParent() public pure returns (string memory) {\n        return \"Hello Child\";\n    }\n}",
          "error message": ":1:179: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Child is Parent {     function greetParent() public pure returns (string memory) {         return \"Hello Child\";     } }\n                                        ^----------------------------------------------------------------------------------------------^\n:1:47: Overridden function is here:\n ... dity^0.6.0;  contract Parent {     function greetParent() public pure returns (string memory) {         return \"Hello Parent\";     } }  contract Child is Parent {      ...\n                                        ^-----------------------------------------------------------------------------------------------^\n:1:47: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... dity^0.6.0;  contract Parent {     function greetParent() public pure returns (string memory) {         return \"Hello Parent\";     } }  contract Child is Parent {      ...\n                                        ^-----------------------------------------------------------------------------------------------^\n:1:179: Overriding function is here:\n ...  }  contract Child is Parent {     function greetParent() public pure returns (string memory) {         return \"Hello Child\";     } }\n                                        ^----------------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract M {\n    function sayM() public pure returns (string memory) {\n        return \"M\";\n    }\n    \n    function additionalFunction() public pure returns (uint) {\n        return 42;\n    }\n}\n\ncontract N is M {\n    function sayM() public pure returns (string memory) {\n        return \"N\";\n    }\n}",
          "error message": ":1:240: TypeError: Overriding function is missing \"override\" specifier.\n ... 42;     } }  contract N is M {     function sayM() public pure returns (string memory) {         return \"N\";     } }\n                                        ^-----------------------------------------------------------------------------^\n:1:42: Overridden function is here:\n ...  solidity^0.6.0;  contract M {     function sayM() public pure returns (string memory) {         return \"M\";     }          function additionalFuncti ...\n                                        ^-----------------------------------------------------------------------------^\n:1:42: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ...  solidity^0.6.0;  contract M {     function sayM() public pure returns (string memory) {         return \"M\";     }          function additionalFuncti ...\n                                        ^-----------------------------------------------------------------------------^\n:1:240: Overriding function is here:\n ... 42;     } }  contract N is M {     function sayM() public pure returns (string memory) {         return \"N\";     } }\n                                        ^-----------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Alpha {\n    function alphaFunction() public pure returns (string memory) {\n        return \"Alpha\";\n    }\n}\n\ncontract Beta is Alpha {\n    function alphaFunction() public pure returns (string memory) {\n        return \"Beta\";\n    }\n}",
          "error message": ":1:171: TypeError: Overriding function is missing \"override\" specifier.\n ...  } }  contract Beta is Alpha {     function alphaFunction() public pure returns (string memory) {         return \"Beta\";     } }\n                                        ^-----------------------------------------------------------------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Alpha {     function alphaFunction() public pure returns (string memory) {         return \"Alpha\";     } }  contract Beta is Alpha {     fu ...\n                                        ^------------------------------------------------------------------------------------------^\n:1:46: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... idity^0.6.0;  contract Alpha {     function alphaFunction() public pure returns (string memory) {         return \"Alpha\";     } }  contract Beta is Alpha {     fu ...\n                                        ^------------------------------------------------------------------------------------------^\n:1:171: Overriding function is here:\n ...  } }  contract Beta is Alpha {     function alphaFunction() public pure returns (string memory) {         return \"Beta\";     } }\n                                        ^-----------------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Base {\n    function getValue() public pure returns (uint) {\n        return 100;\n    }\n}\n\ncontract Derived is Base {\n    function getValue() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": ":1:154: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Derived is Base {     function getValue() public pure returns (uint) {         return 200;     } }\n                                        ^------------------------------------------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Base {     function getValue() public pure returns (uint) {         return 100;     } }  contract Derived is Base {      ...\n                                        ^------------------------------------------------------------------------^\n:1:45: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... lidity^0.6.0;  contract Base {     function getValue() public pure returns (uint) {         return 100;     } }  contract Derived is Base {      ...\n                                        ^------------------------------------------------------------------------^\n:1:154: Overriding function is here:\n ...  }  contract Derived is Base {     function getValue() public pure returns (uint) {         return 200;     } }\n                                        ^------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Super {\n    function message() public pure returns (string memory) {\n        return \"Super\";\n    }\n    \n    function anotherMessage() public pure returns (string memory) {\n        return \"Another\";\n    }\n}\n\ncontract Sub is Super {\n    function message() public pure returns (string memory) {\n        return \"Sub\";\n    }\n}",
          "error message": ":1:269: TypeError: Overriding function is missing \"override\" specifier.\n ...   } }  contract Sub is Super {     function message() public pure returns (string memory) {         return \"Sub\";     } }\n                                        ^----------------------------------------------------------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Super {     function message() public pure returns (string memory) {         return \"Super\";     }          function anotherMessage() ...\n                                        ^------------------------------------------------------------------------------------^\n:1:46: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... idity^0.6.0;  contract Super {     function message() public pure returns (string memory) {         return \"Super\";     }          function anotherMessage() ...\n                                        ^------------------------------------------------------------------------------------^\n:1:269: Overriding function is here:\n ...   } }  contract Sub is Super {     function message() public pure returns (string memory) {         return \"Sub\";     } }\n                                        ^----------------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract First {\n    function firstFunc() public pure returns (string memory) {\n        return \"First\";\n    }\n}\n\ncontract Second is First {\n    function firstFunc() public pure returns (string memory) {\n        return \"Second\";\n    }\n}",
          "error message": ":1:169: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Second is First {     function firstFunc() public pure returns (string memory) {         return \"Second\";     } }\n                                        ^---------------------------------------------------------------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract First {     function firstFunc() public pure returns (string memory) {         return \"First\";     } }  contract Second is First {      ...\n                                        ^--------------------------------------------------------------------------------------^\n:1:46: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... idity^0.6.0;  contract First {     function firstFunc() public pure returns (string memory) {         return \"First\";     } }  contract Second is First {      ...\n                                        ^--------------------------------------------------------------------------------------^\n:1:169: Overriding function is here:\n ...  }  contract Second is First {     function firstFunc() public pure returns (string memory) {         return \"Second\";     } }\n                                        ^---------------------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Original {\n    function originalMethod() public pure returns (string memory) {\n        return \"Original\";\n    }\n}\n\ncontract Duplicate is Original {\n    function originalMethod() public pure returns (string memory) {\n        return \"Duplicate\";\n    }\n}",
          "error message": ":1:186: TypeError: Overriding function is missing \"override\" specifier.\n ... ntract Duplicate is Original {     function originalMethod() public pure returns (string memory) {         return \"Duplicate\";     } }\n                                        ^-----------------------------------------------------------------------------------------------^\n:1:49: Overridden function is here:\n ... ty^0.6.0;  contract Original {     function originalMethod() public pure returns (string memory) {         return \"Original\";     } }  contract Duplicate is Original  ...\n                                        ^----------------------------------------------------------------------------------------------^\n:1:49: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... ty^0.6.0;  contract Original {     function originalMethod() public pure returns (string memory) {         return \"Original\";     } }  contract Duplicate is Original  ...\n                                        ^----------------------------------------------------------------------------------------------^\n:1:186: Overriding function is here:\n ... ntract Duplicate is Original {     function originalMethod() public pure returns (string memory) {         return \"Duplicate\";     } }\n                                        ^-----------------------------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract BaseClass {\n    function compute() public pure returns (uint) {\n        return 10;\n    }\n    \n    function extra() public pure returns (uint) {\n        return 20;\n    }\n}\n\ncontract DerivedClass is BaseClass {\n    function compute() public pure returns (uint) {\n        return 30;\n    }\n}",
          "error message": ":1:247: TypeError: Overriding function is missing \"override\" specifier.\n ... ct DerivedClass is BaseClass {     function compute() public pure returns (uint) {         return 30;     } }\n                                        ^----------------------------------------------------------------------^\n:1:50: Overridden function is here:\n ... y^0.6.0;  contract BaseClass {     function compute() public pure returns (uint) {         return 10;     }          function extra() public p ...\n                                        ^----------------------------------------------------------------------^\n:1:50: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... y^0.6.0;  contract BaseClass {     function compute() public pure returns (uint) {         return 10;     }          function extra() public p ...\n                                        ^----------------------------------------------------------------------^\n:1:247: Overriding function is here:\n ... ct DerivedClass is BaseClass {     function compute() public pure returns (uint) {         return 30;     } }\n                                        ^----------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract A {\n    function foo() public virtual pure returns (string memory) {\n        return \"A\";\n    }\n}\n\ncontract B is A {\n    function foo() public override pure returns (string memory) {\n        return \"B\";\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract X {\n    function bar() public virtual pure returns (string memory) {\n        return \"X\";\n    }\n    \n    function baz() public pure returns (string memory) {\n        return \"Baz\";\n    }\n}\n\ncontract Y is X {\n    function bar() public override pure returns (string memory) {\n        return \"Y\";\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Parent {\n    function greetParent() public virtual pure returns (string memory) {\n        return \"Hello Parent\";\n    }\n}\n\ncontract Child is Parent {\n    function greetParent() public override pure returns (string memory) {\n        return \"Hello Child\";\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract M {\n    function sayM() public virtual pure returns (string memory) {\n        return \"M\";\n    }\n    \n    function additionalFunction() public pure returns (uint) {\n        return 42;\n    }\n}\n\ncontract N is M {\n    function sayM() public override pure returns (string memory) {\n        return \"N\";\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Alpha {\n    function alphaFunction() public virtual pure returns (string memory) {\n        return \"Alpha\";\n    }\n}\n\ncontract Beta is Alpha {\n    function alphaFunction() public override pure returns (string memory) {\n        return \"Beta\";\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Base {\n    function getValue() public virtual pure returns (uint) {\n        return 100;\n    }\n}\n\ncontract Derived is Base {\n    function getValue() public override pure returns (uint) {\n        return 200;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Super {\n    function message() public virtual pure returns (string memory) {\n        return \"Super\";\n    }\n    \n    function anotherMessage() public pure returns (string memory) {\n        return \"Another\";\n    }\n}\n\ncontract Sub is Super {\n    function message() public override pure returns (string memory) {\n        return \"Sub\";\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract First {\n    function firstFunc() public virtual pure returns (string memory) {\n        return \"First\";\n    }\n}\n\ncontract Second is First {\n    function firstFunc() public override pure returns (string memory) {\n        return \"Second\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Original {\n    function originalMethod() public virtual pure returns (string memory) {\n        return \"Original\";\n    }\n}\n\ncontract Duplicate is Original {\n    function originalMethod() public override pure returns (string memory) {\n        return \"Duplicate\";\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract BaseClass {\n    function compute() public virtual pure returns (uint) {\n        return 10;\n    }\n    \n    function extra() public pure returns (uint) {\n        return 20;\n    }\n}\n\ncontract DerivedClass is BaseClass {\n    function compute() public override pure returns (uint) {\n        return 30;\n    }\n}"
      }
    }
  },
  {
    "Changes2": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Member-access to <code>length</code> of arrays is now always read-only, even for storage arrays. It is no\nlonger possible to resize storage arrays by assigning a new value to their length. Use <code>push()</code>,\n<code>push(value)</code> or <code>pop()</code> instead, or assign a full array, which will of course overwrite the existing content.\nThe reason behind this is to prevent storage collisions of gigantic\nstorage arrays.Change <code>uint length = array.push(value)</code> to <code>array.push(value);</code>. The new length can be accessed via <code>array.length</code>. ",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract TestContract1 {\n    uint[] public data;\n\n    function append(uint value) public {\n        data.push(value);\n    }\n\n    function adjustSize(uint newSize) public {\n        data.length = newSize;\n    }\n\n    function count() public view returns (uint) {\n        return data.length;\n    }\n}",
          "error message": ":1:204: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ize(uint newSize) public {         data.length = newSize;     }      function cou ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleContract2 {\n    uint[] public elements;\n\n    function insert(uint element) public {\n        elements.push(element);\n    }\n\n    function setArrayLength(uint newLength) public {\n        elements.length = newLength;\n    }\n\n    function getElementCount() public view returns (uint) {\n        return elements.length;\n    }\n\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a random function\";\n    }\n}",
          "error message": ":1:225: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         elements.length = newLength;     }      function g ...\n                                        ^-------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract SampleContract3 {\n    uint[] public numbersArray;\n\n    function addNumber(uint num) public {\n        numbersArray.push(num);\n    }\n\n    function resizeNumbers(uint newSize) public {\n        numbersArray.length = newSize;\n    }\n\n    function lengthOfNumbers() public view returns (uint) {\n        return numbersArray.length;\n    }\n}",
          "error message": ":1:224: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ers(uint newSize) public {         numbersArray.length = newSize;     }      function len ...\n                                        ^-----------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint[] public list;\n\n    function add(uint item) public {\n        list.push(item);\n    }\n\n    function modifyLength(uint length) public {\n        list.length = length;\n    }\n}",
          "error message": ":1:203: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         list.length = length;     } }\n                                        ^---------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractSample5 {\n    uint[] public queue;\n\n    function enqueue(uint item) public {\n        queue.push(item);\n    }\n\n    function setQueueSize(uint size) public {\n        queue.length = size;\n    }\n\n    function sizeOfQueue() public view returns (uint) {\n        return queue.length;\n    }\n}",
          "error message": ":1:206: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ueSize(uint size) public {         queue.length = size;     }      function sizeOf ...\n                                        ^----------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractTest6 {\n    uint[] public storageArray;\n\n    function addToStorage(uint value) public {\n        storageArray.push(value);\n    }\n\n    function changeLength(uint newLength) public {\n        storageArray.length = newLength;\n    }\n}",
          "error message": ":1:230: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         storageArray.length = newLength;     } }\n                                        ^-----------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ArrayHandling7 {\n    uint[] public dataList;\n\n    function pushData(uint data) public {\n        dataList.push(data);\n    }\n\n    function alterLength(uint length) public {\n        dataList.length = length;\n    }\n\n    function retrieveLength() public view returns (uint) {\n        return dataList.length;\n    }\n\n    function dummyFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:213: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         dataList.length = length;     }      function retr ...\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ResizeArray8 {\n    uint[] public bigArray;\n\n    function addEntry(uint entry) public {\n        bigArray.push(entry);\n    }\n\n    function updateArraySize(uint size) public {\n        bigArray.length = size;\n    }\n\n    function getArraySize() public view returns (uint) {\n        return bigArray.length;\n    }\n}",
          "error message": ":1:215: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... aySize(uint size) public {         bigArray.length = size;     }      function getArr ...\n                                        ^-------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract CustomContract9 {\n    uint[] public entries;\n\n    function addValue(uint val) public {\n        entries.push(val);\n    }\n\n    function adjustArrayLength(uint newLength) public {\n        entries.length = newLength;\n    }\n\n    function lengthOfEntries() public view returns (uint) {\n        return entries.length;\n    }\n\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:219: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         entries.length = newLength;     }      function l ...\n                                        ^------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract RandomContract10 {\n    uint[] public collection;\n\n    function pushValue(uint value) public {\n        collection.push(value);\n    }\n\n    function setCollectionLength(uint length) public {\n        collection.length = length;\n    }\n}",
          "error message": ":1:230: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         collection.length = length;     } }\n                                        ^---------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract TestContract1 {\n    uint[] public data;\n\n    function append(uint value) public {\n        data.push(value);\n    }\n\n    function adjustSize(uint newSize) public {\n        if (newSize > data.length) {\n            while (data.length < newSize) {\n                data.push(0);\n            }\n        } else {\n            while (data.length > newSize) {\n                data.pop();\n            }\n        }\n    }\n\n    function count() public view returns (uint) {\n        return data.length;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ExampleContract2 {\n    uint[] public elements;\n\n    function insert(uint element) public {\n        elements.push(element);\n    }\n\n    function setArrayLength(uint newLength) public {\n        if (newLength > elements.length) {\n            while (elements.length < newLength) {\n                elements.push(0);\n            }\n        } else {\n            while (elements.length > newLength) {\n                elements.pop();\n            }\n        }\n    }\n\n    function getElementCount() public view returns (uint) {\n        return elements.length;\n    }\n\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a random function\";\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract SampleContract3 {\n    uint[] public numbersArray;\n\n    function addNumber(uint num) public {\n        numbersArray.push(num);\n    }\n\n    function resizeNumbers(uint newSize) public {\n        if (newSize > numbersArray.length) {\n            while (numbersArray.length < newSize) {\n                numbersArray.push(0);\n            }\n        } else {\n            while (numbersArray.length > newSize) {\n                numbersArray.pop();\n            }\n        }\n    }\n\n    function lengthOfNumbers() public view returns (uint) {\n        return numbersArray.length;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint[] public list;\n\n    function add(uint item) public {\n        list.push(item);\n    }\n\n    function modifyLength(uint length) public {\n        if (length > list.length) {\n            while (list.length < length) {\n                list.push(0);\n            }\n        } else {\n            while (list.length > length) {\n                list.pop();\n            }\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ContractSample5 {\n    uint[] public queue;\n\n    function enqueue(uint item) public {\n        queue.push(item);\n    }\n\n    function setQueueSize(uint size) public {\n        if (size > queue.length) {\n            while (queue.length < size) {\n                queue.push(0);\n            }\n        } else {\n            while (queue.length > size) {\n                queue.pop();\n            }\n        }\n    }\n\n    function sizeOfQueue() public view returns (uint) {\n        return queue.length;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ContractTest6 {\n    uint[] public storageArray;\n\n    function addToStorage(uint value) public {\n        storageArray.push(value);\n    }\n\n    function changeLength(uint newLength) public {\n        if (newLength > storageArray.length) {\n            while (storageArray.length < newLength) {\n                storageArray.push(0);\n            }\n        } else {\n            while (storageArray.length > newLength) {\n                storageArray.pop();\n            }\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ArrayHandling7 {\n    uint[] public dataList;\n\n    function pushData(uint data) public {\n        dataList.push(data);\n    }\n\n    function alterLength(uint length) public {\n        if (length > dataList.length) {\n            while (dataList.length < length) {\n                dataList.push(0);\n            }\n        } else {\n            while (dataList.length > length) {\n                dataList.pop();\n            }\n        }\n    }\n\n    function retrieveLength() public view returns (uint) {\n        return dataList.length;\n    }\n\n    function dummyFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ResizeArray8 {\n    uint[] public bigArray;\n\n    function addEntry(uint entry) public {\n        bigArray.push(entry);\n    }\n\n    function updateArraySize(uint size) public {\n        if (size > bigArray.length) {\n            while (bigArray.length < size) {\n                bigArray.push(0);\n            }\n        } else {\n            while (bigArray.length > size) {\n                bigArray.pop();\n            }\n        }\n    }\n\n    function getArraySize() public view returns (uint) {\n        return bigArray.length;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract CustomContract9 {\n    uint[] public entries;\n\n    function addValue(uint val) public {\n        entries.push(val);\n    }\n\n    function adjustArrayLength(uint newLength) public {\n        if (newLength > entries.length) {\n            while (entries.length < newLength) {\n                entries.push(0);\n            }\n        } else {\n            while (entries.length > newLength) {\n                entries.pop();\n            }\n        }\n    }\n\n    function lengthOfEntries() public view returns (uint) {\n        return entries.length;\n    }\n\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract RandomContract10 {\n    uint[] public collection;\n\n    function pushValue(uint value) public {\n        collection.push(value);\n    }\n\n    function setCollectionLength(uint length) public {\n        if (length > collection.length) {\n            while (collection.length < length) {\n                collection.push(0);\n            }\n        } else {\n            while (collection.length > length) {\n                collection.pop();\n            }\n        }\n    }\n}"
      }
    }
  },
  {
    "Changes3": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The new keyword <code>abstract</code> can be used to mark contracts as abstract. It has to be used\nif a contract does not implement all its functions. Abstract contracts cannot be created using the <code>new</code> operator,\nand it is not possible to generate bytecode for them during compilation.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    function unimplementedFunction() public;\n    function implementedFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example1\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example1 {     function un ... (uint) {         return 42;     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example1 {     function unimplementedFunction() public;     function implementedFunction() ...\n                                        ^--------------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example1 {     function unimplementedFunction() public;     function implementedFunction() ...\n                                        ^--------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    function missingImplementation() public;\n    function additionalFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example2\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example2 {     function mi ... ool) {         return true;     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example2 {     function missingImplementation() public;     function additionalFunction1() ...\n                                        ^--------------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example2 {     function missingImplementation() public;     function additionalFunction1() ...\n                                        ^--------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    function undefinedBehavior() public;\n    function usefulFunction() public pure returns (string memory) {\n        return \"Completed\";\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example3\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example3 {     function un ...         return \"Completed\";     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example3 {     function undefinedBehavior() public;     function usefulFunction() publ ...\n                                        ^----------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example3 {     function undefinedBehavior() public;     function usefulFunction() publ ...\n                                        ^----------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    function unhandledCase() public;\n    function anotherFunction() public pure returns (address) {\n        return address(0);\n    }\n    function extraFunction() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example4\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example4 {     function un ...  (int) {         return -1;     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example4 {     function unhandledCase() public;     function anotherFunction() pub ...\n                                        ^------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example4 {     function unhandledCase() public;     function anotherFunction() pub ...\n                                        ^------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    function notImplementedYet() public;\n    function finishedFunction() public pure returns (bytes32) {\n        return keccak256(\"Hello\");\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example5\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example5 {     function no ...  return keccak256(\"Hello\");     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example5 {     function notImplementedYet() public;     function finishedFunction() pu ...\n                                        ^----------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example5 {     function notImplementedYet() public;     function finishedFunction() pu ...\n                                        ^----------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    function noCodeHere() public;\n    function compute() public pure returns (uint256) {\n        return 100;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example6\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example6 {     function noCodeHere() public;     function compute() public pure returns (uint256) {         return 100;     } }\n                        ^--------------------------------------------------------------------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example6 {     function noCodeHere() public;     function compute() public pure ...\n                                        ^---------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example6 {     function noCodeHere() public;     function compute() public pure ...\n                                        ^---------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    function actionNeeded() public;\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n    function extraHelper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example7\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example7 {     function ac ... ol) {         return false;     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example7 {     function actionNeeded() public;     function helperFunction() publ ...\n                                        ^-----------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example7 {     function actionNeeded() public;     function helperFunction() publ ...\n                                        ^-----------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    function needsImplementation() public;\n    function getData() public pure returns (bytes memory) {\n        return \"data\";\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example8\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example8 {     function ne ... y) {         return \"data\";     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example8 {     function needsImplementation() public;     function getData() public pure ...\n                                        ^------------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example8 {     function needsImplementation() public;     function getData() public pure ...\n                                        ^------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    function toBeDone() public;\n    function anotherTask() public pure returns (uint8) {\n        return 255;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example9\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example9 {     function toBeDone() public;     function anotherTask() public pure returns (uint8) {         return 255;     } }\n                        ^--------------------------------------------------------------------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example9 {     function toBeDone() public;     function anotherTask() public  ...\n                                        ^-------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example9 {     function toBeDone() public;     function anotherTask() public  ...\n                                        ^-------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    function pendingWork() public;\n    function process() public pure returns (uint16) {\n        return 1024;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example10\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example10 {     function pendingWork() public;     function process() public pure returns (uint16) {         return 1024;     } }\n                        ^----------------------------------------------------------------------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example10 {     function pendingWork() public;     function process() public pure ...\n                                        ^----------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example10 {     function pendingWork() public;     function process() public pure ...\n                                        ^----------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\nabstract contract Example1 {\n    function unimplementedFunction() public virtual;\n    function implementedFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\nabstract contract Example2 {\n    function missingImplementation() public virtual;\n    function additionalFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\nabstract contract Example3 {\n    function undefinedBehavior() public virtual;\n    function usefulFunction() public pure returns (string memory) {\n        return \"Completed\";\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\nabstract contract Example4 {\n    function unhandledCase() public virtual;\n    function anotherFunction() public pure returns (address) {\n        return address(0);\n    }\n    function extraFunction() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\nabstract contract Example5 {\n    function notImplementedYet() public virtual;\n    function finishedFunction() public pure returns (bytes32) {\n        return keccak256(\"Hello\");\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\nabstract contract Example6 {\n    function noCodeHere() public virtual;\n    function compute() public pure returns (uint256) {\n        return 100;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\nabstract contract Example7 {\n    function actionNeeded() public virtual;\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n    function extraHelper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\nabstract contract Example8 {\n    function needsImplementation() public virtual;\n    function getData() public pure returns (bytes memory) {\n        return \"data\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\nabstract contract Example9 {\n    function toBeDone() public virtual;\n    function anotherTask() public pure returns (uint8) {\n        return 255;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\nabstract contract Example10 {\n    function pendingWork() public virtual;\n    function process() public pure returns (uint16) {\n        return 1024;\n    }\n}"
      }
    }
  },
  {
    "Changes4": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Libraries have to implement all their functions, not only the internal ones.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary StringLibrary {\n    function internalConcat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n\n    function publicLength(string memory a) public pure returns (uint);\n}\n\ncontract TextProcessor {\n    using StringLibrary for string;\n\n    function combineStrings(string memory a, string memory b) public pure returns (string memory) {\n        return StringLibrary.internalConcat(a, b);\n    }\n}",
          "error message": ":1:209: TypeError: Library functions must be implemented if declared.\n ... bi.encodePacked(a, b));     }      function publicLength(string memory a) public pure returns (uint); }  contract TextProcessor {     us ...\n                                        ^----------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary MathOperations {\n    function internalSubtract(uint x, uint y) internal pure returns (uint) {\n        return x - y;\n    }\n\n    function publicDivide(uint x, uint y) public pure returns (uint);\n}\n\ncontract Arithmetic {\n    using MathOperations for uint;\n\n    function subtractNumbers(uint x, uint y) public pure returns (uint) {\n        return MathOperations.internalSubtract(x, y);\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:160: TypeError: Library functions must be implemented if declared.\n ... {         return x - y;     }      function publicDivide(uint x, uint y) public pure returns (uint); }  contract Arithmetic {     using ...\n                                        ^---------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary ArrayUtils {\n    function internalMax(uint[] memory array) internal pure returns (uint) {\n        uint max = array[0];\n        for (uint i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n\n    function publicMin(uint[] memory array) public pure returns (uint);\n}\n\ncontract ArrayProcessor {\n    using ArrayUtils for uint[];\n\n    function findMax(uint[] memory array) public pure returns (uint) {\n        return ArrayUtils.internalMax(array);\n    }\n\n    function dummyProcess() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": ":1:323: TypeError: Library functions must be implemented if declared.\n ...   }         return max;     }      function publicMin(uint[] memory array) public pure returns (uint); }  contract ArrayProcessor {     u ...\n                                        ^-----------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary TokenUtils {\n    function internalTransfer(address from, address to, uint amount) internal pure returns (bool) {\n        return true;\n    }\n\n    function publicBalance(address account) public view returns (uint);\n}\n\ncontract TokenManager {\n    using TokenUtils for address;\n\n    function transferTokens(address from, address to, uint amount) public pure returns (bool) {\n        return TokenUtils.internalTransfer(from, to, amount);\n    }\n}",
          "error message": ":1:178: TypeError: Library functions must be implemented if declared.\n ...  {         return true;     }      function publicBalance(address account) public view returns (uint); }  contract TokenManager {     usi ...\n                                        ^-----------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary HashingLib {\n    function internalHash(string memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(data));\n    }\n\n    function publicVerify(bytes32 hash, string memory data) public pure returns (bool);\n}\n\ncontract HashingContract {\n    using HashingLib for string;\n\n    function getHash(string memory data) public pure returns (bytes32) {\n        return HashingLib.internalHash(data);\n    }\n}",
          "error message": ":1:187: TypeError: Library functions must be implemented if declared.\n ... bi.encodePacked(data));     }      function publicVerify(bytes32 hash, string memory data) public pure returns (bool); }  contract HashingContract {      ...\n                                        ^---------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary FinancialLib {\n    function internalCalculateInterest(uint principal, uint rate) internal pure returns (uint) {\n        return (principal * rate) / 100;\n    }\n\n    function publicGetPrincipal() public pure returns (uint);\n}\n\ncontract FinancialContract {\n    using FinancialLib for uint;\n\n    function calculate(uint principal, uint rate) public pure returns (uint) {\n        return FinancialLib.internalCalculateInterest(principal, rate);\n    }\n}",
          "error message": ":1:197: TypeError: Library functions must be implemented if declared.\n ... rincipal * rate) / 100;     }      function publicGetPrincipal() public pure returns (uint); }  contract FinancialContract {    ...\n                                        ^-------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary CryptoLib {\n    function internalEncrypt(uint data) internal pure returns (uint) {\n        return data + 1;\n    }\n\n    function publicDecrypt(uint encryptedData) public pure returns (uint);\n}\n\ncontract CryptoContract {\n    using CryptoLib for uint;\n\n    function encryptData(uint data) public pure returns (uint) {\n        return CryptoLib.internalEncrypt(data);\n    }\n\n    function dummyFunction2() public pure returns (string memory) {\n        return \"dummy\";\n    }\n}",
          "error message": ":1:152: TypeError: Library functions must be implemented if declared.\n ...        return data + 1;     }      function publicDecrypt(uint encryptedData) public pure returns (uint); }  contract CryptoContract {     u ...\n                                        ^--------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary VotingLib {\n    function internalVote(uint proposalId) internal pure returns (bool) {\n        return true;\n    }\n\n    function publicResult(uint proposalId) public view returns (uint);\n}\n\ncontract VotingContract {\n    using VotingLib for uint;\n\n    function voteOnProposal(uint proposalId) public pure returns (bool) {\n        return VotingLib.internalVote(proposalId);\n    }\n\n    function getProposal() public view returns (string memory) {\n        return \"Proposal details\";\n    }\n}",
          "error message": ":1:151: TypeError: Library functions must be implemented if declared.\n ...  {         return true;     }      function publicResult(uint proposalId) public view returns (uint); }  contract VotingContract {     u ...\n                                        ^----------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary MappingLib {\n    function internalGetKey(bytes32 key) internal pure returns (uint) {\n        return uint(key);\n    }\n\n    function publicSetKey(bytes32 key, uint value) public pure returns (bool);\n}\n\ncontract MappingContract {\n    using MappingLib for bytes32;\n\n    function getKey(bytes32 key) public pure returns (uint) {\n        return MappingLib.internalGetKey(key);\n    }\n\n    function dummyFunction3() public pure returns (address) {\n        return address(0);\n    }\n}",
          "error message": ":1:155: TypeError: Library functions must be implemented if declared.\n ...       return uint(key);     }      function publicSetKey(bytes32 key, uint value) public pure returns (bool); }  contract MappingContract {      ...\n                                        ^------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary QueueLib {\n    function internalEnqueue(uint item) internal pure returns (uint) {\n        return item;\n    }\n\n    function publicDequeue() public pure returns (uint);\n}\n\ncontract QueueContract {\n    using QueueLib for uint;\n\n    function enqueueItem(uint item) public pure returns (uint) {\n        return QueueLib.internalEnqueue(item);\n    }\n}",
          "error message": ":1:147: TypeError: Library functions must be implemented if declared.\n ...  {         return item;     }      function publicDequeue() public pure returns (uint); }  contract QueueContract {     us ...\n                                        ^--------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\nlibrary StringLibrary {\n    function internalConcat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n\n    function publicLength(string memory a) public pure returns (uint) {\n        return bytes(a).length;\n    }\n}\n\ncontract TextProcessor {\n    using StringLibrary for string;\n\n    function combineStrings(string memory a, string memory b) public pure returns (string memory) {\n        return StringLibrary.internalConcat(a, b);\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\nlibrary MathOperations {\n    function internalSubtract(uint x, uint y) internal pure returns (uint) {\n        return x - y;\n    }\n\n    function publicDivide(uint x, uint y) public pure returns (uint) {\n        require(y != 0, \"Cannot divide by zero\");\n        return x / y;\n    }\n}\n\ncontract Arithmetic {\n    using MathOperations for uint;\n\n    function subtractNumbers(uint x, uint y) public pure returns (uint) {\n        return MathOperations.internalSubtract(x, y);\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\nlibrary ArrayUtils {\n    function internalMax(uint[] memory array) internal pure returns (uint) {\n        uint max = array[0];\n        for (uint i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n\n    function publicMin(uint[] memory array) public pure returns (uint) {\n        uint min = array[0];\n        for (uint i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}\n\ncontract ArrayProcessor {\n    using ArrayUtils for uint[];\n\n    function findMax(uint[] memory array) public pure returns (uint) {\n        return ArrayUtils.internalMax(array);\n    }\n\n    function dummyProcess() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\nlibrary TokenUtils {\n    function internalTransfer(address from, address to, uint amount) internal pure returns (bool) {\n        return true;\n    }\n\n    function publicBalance(address account) public view returns (uint) {\n        return 1000;\n    }\n}\n\ncontract TokenManager {\n    using TokenUtils for address;\n\n    function transferTokens(address from, address to, uint amount) public pure returns (bool) {\n        return TokenUtils.internalTransfer(from, to, amount);\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\nlibrary HashingLib {\n    function internalHash(string memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(data));\n    }\n\n    function publicVerify(bytes32 hash, string memory data) public pure returns (bool) {\n        return hash == keccak256(abi.encodePacked(data));\n    }\n}\n\ncontract HashingContract {\n    using HashingLib for string;\n\n    function getHash(string memory data) public pure returns (bytes32) {\n        return HashingLib.internalHash(data);\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\nlibrary FinancialLib {\n    function internalCalculateInterest(uint principal, uint rate) internal pure returns (uint) {\n        return (principal * rate) / 100;\n    }\n\n    function publicGetPrincipal() public pure returns (uint) {\n        return 1000;\n    }\n}\n\ncontract FinancialContract {\n    using FinancialLib for uint;\n\n    function calculate(uint principal, uint rate) public pure returns (uint) {\n        return FinancialLib.internalCalculateInterest(principal, rate);\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\nlibrary CryptoLib {\n    function internalEncrypt(uint data) internal pure returns (uint) {\n        return data + 1;\n    }\n\n    function publicDecrypt(uint encryptedData) public pure returns (uint) {\n        return encryptedData - 1;\n    }\n}\n\ncontract CryptoContract {\n    using CryptoLib for uint;\n\n    function encryptData(uint data) public pure returns (uint) {\n        return CryptoLib.internalEncrypt(data);\n    }\n\n    function dummyFunction2() public pure returns (string memory) {\n        return \"dummy\";\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\nlibrary VotingLib {\n    function internalVote(uint proposalId) internal pure returns (bool) {\n        return true;\n    }\n\n    function publicResult(uint proposalId) public view returns (uint) {\n        return proposalId % 100;\n    }\n}\n\ncontract VotingContract {\n    using VotingLib for uint;\n\n    function voteOnProposal(uint proposalId) public pure returns (bool) {\n        return VotingLib.internalVote(proposalId);\n    }\n\n    function getProposal() public view returns (string memory) {\n        return \"Proposal details\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\nlibrary MappingLib {\n    function internalGetKey(bytes32 key) internal pure returns (uint) {\n        return uint(key);\n    }\n\n    function publicSetKey(bytes32 key, uint value) public pure returns (bool) {\n        return true;\n    }\n}\n\ncontract MappingContract {\n    using MappingLib for bytes32;\n\n    function getKey(bytes32 key) public pure returns (uint) {\n        return MappingLib.internalGetKey(key);\n    }\n\n    function dummyFunction3() public pure returns (address) {\n        return address(0);\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\nlibrary QueueLib {\n    function internalEnqueue(uint item) internal pure returns (uint) {\n        return item;\n    }\n\n    function publicDequeue() public pure returns (uint) {\n        return 0;\n    }\n}\n\ncontract QueueContract {\n    using QueueLib for uint;\n\n    function enqueueItem(uint item) public pure returns (uint) {\n        return QueueLib.internalEnqueue(item);\n    }\n}"
      }
    }
  },
  {
    "Changes5": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The names of variables declared in inline assembly may no longer end in <code>_slot</code> or <code>_offset</code>.Choose unique identifiers for variable declarations in inline assembly that do not conflict with declarations outside the inline assembly block.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractA {\n    uint256 public amount;\n\n    function setAmount(uint256 _value) public {\n        assembly {\n            let amount_slot := _value\n            sstore(amount_slot, _value)\n        }\n    }\n}",
          "error message": ":1:157: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let amount_slot := _value             sstore(amoun ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractB {\n    uint256 public balance;\n\n    function updateBalance(uint256 _newBalance) public {\n        assembly {\n            let balance_offset := _newBalance\n            sstore(balance_offset, _newBalance)\n        }\n    }\n}",
          "error message": ":1:167: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let balance_offset := _newBalance             sstore( ...\n                                        ^------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractC {\n    address public owner;\n\n    function setOwner(address _owner) public {\n        assembly {\n            let owner_slot := _owner\n            sstore(owner_slot, _owner)\n        }\n    }\n}",
          "error message": ":1:155: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let owner_slot := _owner             sstore(owner ...\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractD {\n    bytes32 public dataHash;\n\n    function storeDataHash(bytes32 _hash) public {\n        assembly {\n            let dataHash_slot := _hash\n            sstore(dataHash_slot, _hash)\n        }\n    }\n}",
          "error message": ":1:162: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let dataHash_slot := _hash             sstore(dataHa ...\n                                        ^-----------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractE {\n    uint256 public totalSupply;\n\n    function updateSupply(uint256 _supply) public {\n        assembly {\n            let supply_offset := _supply\n            sstore(supply_offset, _supply)\n        }\n    }\n\n}",
          "error message": ":1:166: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let supply_offset := _supply             sstore(supp ...\n                                        ^-----------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractF {\n    uint256 public value;\n\n    function modifyValue(uint256 _val) public {\n        assembly {\n            let value_slot := _val\n            sstore(value_slot, _val)\n        }\n    }\n}",
          "error message": ":1:156: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let value_slot := _val             sstore(value_s ...\n                                        ^--------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractG {\n    bool public isActive;\n\n    function setActive(bool _active) public {\n        assembly {\n            let active_flag_slot := _active\n            sstore(active_flag_slot, _active)\n        }\n    }\n\n}",
          "error message": ":1:154: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let active_flag_slot := _active             sstore(acti ...\n                                        ^--------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractH {\n    uint256 public count;\n\n    function setCount(uint256 _count) public {\n        assembly {\n            let count_offset := _count\n            sstore(count_offset, _count)\n        }\n    }\n}",
          "error message": ":1:155: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let count_offset := _count             sstore(count ...\n                                        ^----------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractI {\n    bytes32 public secret;\n\n    function saveSecret(bytes32 _secret) public {\n        assembly {\n            let secret_slot := _secret\n            sstore(secret_slot, _secret)\n        }\n    }\n}",
          "error message": ":1:159: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let secret_slot := _secret             sstore(secr ...\n                                        ^---------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractJ {\n    address public admin;\n\n    function assignAdmin(address _admin) public {\n        assembly {\n            let admin_offset := _admin\n            sstore(admin_offset, _admin)\n        }\n    }\n}",
          "error message": ":1:158: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let admin_offset := _admin             sstore(admin ...\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ContractA {\n    uint256 public amount;\n\n    function setAmount(uint256 _value) public {\n        assembly {\n            let amountLoc := _value\n            sstore(amountLoc, _value)\n        }\n    }\n\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ContractB {\n    uint256 public balance;\n\n    function updateBalance(uint256 _newBalance) public {\n        assembly {\n            let balanceLoc := _newBalance\n            sstore(balanceLoc, _newBalance)\n        }\n    }\n\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ContractC {\n    address public owner;\n\n    function setOwner(address _owner) public {\n        assembly {\n            let ownerLoc := _owner\n            sstore(ownerLoc, _owner)\n        }\n    }\n\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractD {\n    bytes32 public dataHash;\n\n    function storeDataHash(bytes32 _hash) public {\n        assembly {\n            let dataHashLoc := _hash\n            sstore(dataHashLoc, _hash)\n        }\n    }\n\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ContractE {\n    uint256 public totalSupply;\n\n    function updateSupply(uint256 _supply) public {\n        assembly {\n            let supplyLoc := _supply\n            sstore(supplyLoc, _supply)\n        }\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ContractF {\n    uint256 public value;\n\n    function modifyValue(uint256 _val) public {\n        assembly {\n            let valueLoc := _val\n            sstore(valueLoc, _val)\n        }\n    }\n\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ContractG {\n    bool public isActive;\n\n    function setActive(bool _active) public {\n        assembly {\n            let activeFlagLoc := _active\n            sstore(activeFlagLoc, _active)\n        }\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ContractH {\n    uint256 public count;\n\n    function setCount(uint256 _count) public {\n        assembly {\n            let countLoc := _count\n            sstore(countLoc, _count)\n        }\n    }\n\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ContractI {\n    bytes32 public secret;\n\n    function saveSecret(bytes32 _secret) public {\n        assembly {\n            let secretLoc := _secret\n            sstore(secretLoc, _secret)\n        }\n    }\n\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ContractJ {\n    address public admin;\n\n    function assignAdmin(address _admin) public {\n        assembly {\n            let adminLoc := _admin\n            sstore(adminLoc, _admin)\n        }\n    }\n\n}"
      }
    }
  },
  {
    "Changes6": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Variable declarations in inline assembly may no longer shadow any declaration outside the inline assembly block.\nIf the name contains a dot, its prefix up to the dot may not conflict with any declaration outside the inline\nassembly block.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    uint256 public amount = 50;\n\n    function calculate() public {\n        uint256 amount = 100;\n        assembly {\n            let amount := 200\n        }\n    }\n}",
          "error message": ":1:177: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let amount := 200         }     } }\n                                        ^----^\n:1:120: The shadowed declaration is here:\n ... ction calculate() public {         uint256 amount = 100;         assembly {          ...\n                                        ^------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    string public name = \"Alice\";\n\n    function changeName() public {\n        string memory name = \"Bob\";\n        assembly {\n            let name := \"Charlie\"\n        }\n    }\n}",
          "error message": ":1:186: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let name := \"Charlie\"         }     } }\n                                        ^--^\n:1:123: The shadowed declaration is here:\n ... tion changeName() public {         string memory name = \"Bob\";         assembly {        ...\n                                        ^----------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public owner;\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n        assembly {\n            let owner := newOwner\n        }\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
          "error message": ":1:182: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let owner := newOwner         }     }      f ...\n                                        ^---^\n:1:49: The shadowed declaration is here:\n ... ty^0.6.0;  contract Example3 {     address public owner;      function setOwner(address ne ...\n                                        ^------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    bool public isActive = true;\n\n    function toggle() public {\n        bool isActive = false;\n        assembly {\n            let isActive := 1\n        }\n    }\n}",
          "error message": ":1:176: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let isActive := 1         }     } }\n                                        ^------^\n:1:118: The shadowed declaration is here:\n ... function toggle() public {         bool isActive = false;         assembly {        ...\n                                        ^-----------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    uint256 public counter = 1;\n\n    function increment() public {\n        uint256 counter = 2;\n        assembly {\n            let counter := 3\n        }\n    }\n\n    function reset() public {\n        counter = 0;\n    }\n}",
          "error message": ":1:176: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let counter := 3         }     }      function ...\n                                        ^-----^\n:1:120: The shadowed declaration is here:\n ... ction increment() public {         uint256 counter = 2;         assembly {            ...\n                                        ^-------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    bytes32 public data = keccak256(\"Initial\");\n\n    function updateData() public {\n        bytes32 data = keccak256(\"Updated\");\n        assembly {\n            let data := keccak256(add(\"New\", 0x20), 0x20)\n        }\n    }\n}",
          "error message": ":1:209: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let data := keccak256(add(\"New\", 0x20), 0x2 ...\n                                        ^--^\n:1:137: The shadowed declaration is here:\n ... tion updateData() public {         bytes32 data = keccak256(\"Updated\");         as ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    uint256 public rate = 10;\n\n    function adjustRate() public {\n        uint256 rate = 15;\n        assembly {\n            let rate := 20\n        }\n    }\n\n    function getRate() public view returns (uint256) {\n        return rate;\n    }\n}",
          "error message": ":1:173: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let rate := 20         }     }      functio ...\n                                        ^--^\n:1:119: The shadowed declaration is here:\n ... tion adjustRate() public {         uint256 rate = 15;         assembly {           ...\n                                        ^----------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    int256 public balance = 100;\n\n    function setGreeting(string memory newGreeting) public {\n        string memory greeting = newGreeting;\n        assembly {\n            let greeting := \"Hi\"\n        }\n    }\n}",
          "error message": ":1:221: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let greeting := \"Hi\"         }     } }\n                                        ^------^\n:1:148: The shadowed declaration is here:\n ... mory newGreeting) public {         string memory greeting = newGreeting;         assembly {  ...\n                                        ^--------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    string public greeting = \"Hello\";\n\n    function setGreeting(string memory newGreeting) public {\n        string memory greeting = newGreeting;\n        assembly {\n            let greeting := \"Hi\"\n        }\n    }\n}",
          "error message": ":1:226: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let greeting := \"Hi\"         }     } }\n                                        ^------^\n:1:153: The shadowed declaration is here:\n ... mory newGreeting) public {         string memory greeting = newGreeting;         assembly {  ...\n                                        ^--------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    uint256 public totalSupply = 1000;\n\n    function adjustSupply() public {\n        uint256 totalSupply = 500;\n        assembly {\n            let totalSupply := 250\n        }\n    }\n\n    function dummyFunction1() public pure returns (uint256) {\n        return 1;\n    }\n\n    function dummyFunction2() public pure returns (uint256) {\n        return 2;\n    }\n}",
          "error message": ":1:193: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let totalSupply := 250         }     }      functi ...\n                                        ^---------^\n:1:131: The shadowed declaration is here:\n ... on adjustSupply() public {         uint256 totalSupply = 500;         assembly {          ...\n                                        ^-----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    uint256 public amount = 50;\n\n    function calculate() public {\n        uint256 amountLocal = 100;\n        assembly {\n            let amountAsm := 200\n        }\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    string public name = \"Alice\";\n\n    function changeName() public {\n        string memory nameLocal = \"Bob\";\n        assembly {\n            let nameAsm := \"Charlie\"\n        }\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public owner;\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n        assembly {\n            let ownerAsm := newOwner\n        }\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    bool public isActive = true;\n\n    function toggle() public {\n        bool isActiveLocal = false;\n        assembly {\n            let isActiveAsm := 1\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    uint256 public counter = 1;\n\n    function increment() public {\n        uint256 counterLocal = 2;\n        assembly {\n            let counterAsm := 3\n        }\n    }\n\n    function reset() public {\n        counter = 0;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    bytes32 public data = keccak256(\"Initial\");\n\n    function updateData() public {\n        bytes32 dataLocal = keccak256(\"Updated\");\n        assembly {\n            let dataAsm := keccak256(add(\"New\", 0x20), 0x20)\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    uint256 public rate = 10;\n\n    function adjustRate() public {\n        uint256 rateLocal = 15;\n        assembly {\n            let rateAsm := 20\n        }\n    }\n\n    function getRate() public view returns (uint256) {\n        return rate;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    int256 public balance = 100;\n\n    function setGreeting(string memory newGreeting) public {\n        string memory greetingLocal = newGreeting;\n        assembly {\n            let greetingAsm := \"Hi\"\n        }\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    string public greeting = \"Hello\";\n\n    function setGreeting(string memory newGreeting) public {\n        string memory greetingLocal = newGreeting;\n        assembly {\n            let greetingAsm := \"Hi\"\n        }\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    uint256 public totalSupply = 1000;\n\n    function adjustSupply() public {\n        uint256 totalSupplyLocal = 500;\n        assembly {\n            let totalSupplyAsm := 250\n        }\n    }\n\n    function dummyFunction1() public pure returns (uint256) {\n        return 1;\n    }\n\n    function dummyFunction2() public pure returns (uint256) {\n        return 2;\n    }\n}"
      }
    }
  },
  {
    "Changes7": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "In inline assembly, opcodes that do not take arguments are now represented as \u201cbuilt-in functions\u201d instead of standalone identifiers. So <code>gas</code> is now <code>gas()</code>.In inline assembly, add <code>()</code> to all opcodes that do not otherwise accept an argument.For example, change <code>pc</code> to <code>pc()</code>, and <code>gas</code> to <code>gas()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample1 {\n    uint256 public storedGas;\n\n    function executeAssembly() public {\n        assembly {\n            let g := gas\n            sstore(storedGas_slot, g)\n        }\n    }\n}",
          "error message": ":1:180: ParserError: Expected '(' but got identifier\n ...           let g := gas             sstore(storedGas_slot, g)         }     } ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample2 {\n    uint256 public lastPcValue;\n\n    function trackPC() public {\n        assembly {\n            let p := pc\n            sstore(lastPcValue_slot, p)\n        }\n    }\n}",
          "error message": ":1:173: ParserError: Expected '(' but got identifier\n ...            let p := pc             sstore(lastPcValue_slot, p)         }     ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample3 {\n    uint256 public finalGas;\n\n    function calculateGas() public {\n        assembly {\n            let gasLeft := gas\n            sstore(finalGas_slot, gasLeft)\n        }\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 123;\n    }\n}",
          "error message": ":1:182: ParserError: Expected '(' but got identifier\n ...     let gasLeft := gas             sstore(finalGas_slot, gasLeft)         }  ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint256 public codePosition;\n\n    function getPosition() public {\n        assembly {\n            let position := pc\n            sstore(codePosition_slot, position)\n        }\n    }\n}",
          "error message": ":1:185: ParserError: Expected '(' but got identifier\n ...     let position := pc             sstore(codePosition_slot, position)       ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample5 {\n    uint256 public gasValue;\n\n    function retrieveGas() public {\n        assembly {\n            let remainingGas := gas\n            sstore(gasValue_slot, remainingGas)\n        }\n    }\n\n    function additionalFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:186: ParserError: Expected '(' but got identifier\n ... et remainingGas := gas             sstore(gasValue_slot, remainingGas)       ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample6 {\n    uint256 public pcValue;\n\n    function storePC() public {\n        assembly {\n            let programCounter := pc\n            sstore(pcValue_slot, programCounter)\n        }\n    }\n}",
          "error message": ":1:182: ParserError: Expected '(' but got identifier\n ... t programCounter := pc             sstore(pcValue_slot, programCounter)      ...\n                                        ^----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample7 {\n    uint256 public gasLeft;\n\n    function checkGas() public {\n        assembly {\n            let remaining := gas\n            sstore(gasLeft_slot, remaining)\n        }\n    }\n}",
          "error message": ":1:179: ParserError: Expected '(' but got identifier\n ...   let remaining := gas             sstore(gasLeft_slot, remaining)         } ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample8 {\n    uint256 public currentPC;\n\n    function fetchPC() public {\n        assembly {\n            let current := pc\n            sstore(currentPC_slot, current)\n        }\n    }\n\n    function placeholderFunction() public pure returns (string memory) {\n        return \"test\";\n    }\n}",
          "error message": ":1:177: ParserError: Expected '(' but got identifier\n ...      let current := pc             sstore(currentPC_slot, current)         } ...\n                                        ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample9 {\n    uint256 public latestGas;\n\n    function measureGas() public {\n        assembly {\n            let gasNow := gas\n            sstore(latestGas_slot, gasNow)\n        }\n    }\n}",
          "error message": ":1:180: ParserError: Expected '(' but got identifier\n ...      let gasNow := gas             sstore(latestGas_slot, gasNow)         }  ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample10 {\n    uint256 public programCounter;\n\n    function pcValue() public {\n        assembly {\n            let pcCounter := pc\n            sstore(programCounter_slot, pcCounter)\n        }\n    }\n}",
          "error message": ":1:185: ParserError: Expected '(' but got identifier\n ...    let pcCounter := pc             sstore(programCounter_slot, pcCounter)    ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ContractExample1 {\n    uint256 public storedGas;\n\n    function executeAssembly() public {\n        assembly {\n            let g := gas()\n            sstore(storedGas_slot, g)\n        }\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ContractExample2 {\n    uint256 public lastPcValue;\n\n    function trackPC() public {\n        assembly {\n            let p := pc()\n            sstore(lastPcValue_slot, p)\n        }\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ContractExample3 {\n    uint256 public finalGas;\n\n    function calculateGas() public {\n        assembly {\n            let gasLeft := gas()\n            sstore(finalGas_slot, gasLeft)\n        }\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 123;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint256 public codePosition;\n\n    function getPosition() public {\n        assembly {\n            let position := pc()\n            sstore(codePosition_slot, position)\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ContractExample5 {\n    uint256 public gasValue;\n\n    function retrieveGas() public {\n        assembly {\n            let remainingGas := gas()\n            sstore(gasValue_slot, remainingGas)\n        }\n    }\n\n    function additionalFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ContractExample6 {\n    uint256 public pcValue;\n\n    function storePC() public {\n        assembly {\n            let programCounter := pc()\n            sstore(pcValue_slot, programCounter)\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ContractExample7 {\n    uint256 public gasLeft;\n\n    function checkGas() public {\n        assembly {\n            let remaining := gas()\n            sstore(gasLeft_slot, remaining)\n        }\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ContractExample8 {\n    uint256 public currentPC;\n\n    function fetchPC() public {\n        assembly {\n            let current := pc()\n            sstore(currentPC_slot, current)\n        }\n    }\n\n    function placeholderFunction() public pure returns (string memory) {\n        return \"test\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ContractExample9 {\n    uint256 public latestGas;\n\n    function measureGas() public {\n        assembly {\n            let gasNow := gas()\n            sstore(latestGas_slot, gasNow)\n        }\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ContractExample10 {\n    uint256 public programCounter;\n\n    function pcValue() public {\n        assembly {\n            let pcCounter := pc()\n            sstore(programCounter_slot, pcCounter)\n        }\n    }\n}"
      }
    }
  },
  {
    "Changes8": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "State variable shadowing is now disallowed.  A derived contract can only\ndeclare a state variable <code>x</code>, if there is no visible state variable with\nthe same name in any of its bases.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Alpha {\n    uint public alphaValue = 10;\n}\n\ncontract Beta is Alpha {\n    uint public alphaValue = 20;\n    \n    function getBetaValue() public view returns (uint) {\n        return alphaValue;\n    }\n}",
          "error message": ":1:107: DeclarationError: Identifier already declared.\n ... 0; }  contract Beta is Alpha {     uint public alphaValue = 20;          function getBetaValue()  ...\n                                        ^-------------------------^\n:1:46: The previous declaration is here:\n ... idity^0.6.0;  contract Alpha {     uint public alphaValue = 10; }  contract Beta is Alpha {     u ...\n                                        ^-------------------------^\n:1:107: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... 0; }  contract Beta is Alpha {     uint public alphaValue = 20;          function getBetaValue()  ...\n                                        ^-------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Alpha {     uint public alphaValue = 10; }  contract Beta is Alpha {     u ...\n                                        ^-------------------------^\n:1:46: TypeError: Cannot override public state variable.\n ... idity^0.6.0;  contract Alpha {     uint public alphaValue = 10; }  contract Beta is Alpha {     u ...\n                                        ^-------------------------^\n:1:107: Overriding public state variable is here:\n ... 0; }  contract Beta is Alpha {     uint public alphaValue = 20;          function getBetaValue()  ...\n                                        ^-------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Gamma {\n    string public name = \"Gamma\";\n}\n\ncontract Delta is Gamma {\n    string public name = \"Delta\";\n    \n    function getDeltaName() public view returns (string memory) {\n        return name;\n    }\n}",
          "error message": ":1:109: DeclarationError: Identifier already declared.\n ... ; }  contract Delta is Gamma {     string public name = \"Delta\";          function getDeltaName()  ...\n                                        ^--------------------------^\n:1:46: The previous declaration is here:\n ... idity^0.6.0;  contract Gamma {     string public name = \"Gamma\"; }  contract Delta is Gamma {      ...\n                                        ^--------------------------^\n:1:109: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ; }  contract Delta is Gamma {     string public name = \"Delta\";          function getDeltaName()  ...\n                                        ^--------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Gamma {     string public name = \"Gamma\"; }  contract Delta is Gamma {      ...\n                                        ^--------------------------^\n:1:46: TypeError: Cannot override public state variable.\n ... idity^0.6.0;  contract Gamma {     string public name = \"Gamma\"; }  contract Delta is Gamma {      ...\n                                        ^--------------------------^\n:1:109: Overriding public state variable is here:\n ... ; }  contract Delta is Gamma {     string public name = \"Delta\";          function getDeltaName()  ...\n                                        ^--------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract BaseA {\n    address public owner = msg.sender;\n}\n\ncontract DerivedA is BaseA {\n    address public owner = address(0);\n    \n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}",
          "error message": ":1:117: DeclarationError: Identifier already declared.\n ...   contract DerivedA is BaseA {     address public owner = address(0);          function getOwner() publ ...\n                                        ^-------------------------------^\n:1:46: The previous declaration is here:\n ... idity^0.6.0;  contract BaseA {     address public owner = msg.sender; }  contract DerivedA is BaseA {   ...\n                                        ^-------------------------------^\n:1:117: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract DerivedA is BaseA {     address public owner = address(0);          function getOwner() publ ...\n                                        ^-------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract BaseA {     address public owner = msg.sender; }  contract DerivedA is BaseA {   ...\n                                        ^-------------------------------^\n:1:46: TypeError: Cannot override public state variable.\n ... idity^0.6.0;  contract BaseA {     address public owner = msg.sender; }  contract DerivedA is BaseA {   ...\n                                        ^-------------------------------^\n:1:117: Overriding public state variable is here:\n ...   contract DerivedA is BaseA {     address public owner = address(0);          function getOwner() publ ...\n                                        ^-------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract BaseB {\n    uint public count = 1;\n}\n\ncontract DerivedB is BaseB {\n    uint public count = 2;\n    \n    function getCount() public view returns (uint) {\n        return count;\n    }\n}",
          "error message": ":1:105: DeclarationError: Identifier already declared.\n ...   contract DerivedB is BaseB {     uint public count = 2;          function getCount() publ ...\n                                        ^-------------------^\n:1:46: The previous declaration is here:\n ... idity^0.6.0;  contract BaseB {     uint public count = 1; }  contract DerivedB is BaseB {   ...\n                                        ^-------------------^\n:1:105: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract DerivedB is BaseB {     uint public count = 2;          function getCount() publ ...\n                                        ^-------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract BaseB {     uint public count = 1; }  contract DerivedB is BaseB {   ...\n                                        ^-------------------^\n:1:46: TypeError: Cannot override public state variable.\n ... idity^0.6.0;  contract BaseB {     uint public count = 1; }  contract DerivedB is BaseB {   ...\n                                        ^-------------------^\n:1:105: Overriding public state variable is here:\n ...   contract DerivedB is BaseB {     uint public count = 2;          function getCount() publ ...\n                                        ^-------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Parent1 {\n    bool public isActive = true;\n}\n\ncontract Child1 is Parent1 {\n    bool public isActive = false;\n    \n    function isChildActive() public view returns (bool) {\n        return isActive;\n    }\n}",
          "error message": ":1:113: DeclarationError: Identifier already declared.\n ...   contract Child1 is Parent1 {     bool public isActive = false;          function isChildActive() ...\n                                        ^--------------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Parent1 {     bool public isActive = true; }  contract Child1 is Parent1 {   ...\n                                        ^-------------------------^\n:1:113: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract Child1 is Parent1 {     bool public isActive = false;          function isChildActive() ...\n                                        ^--------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Parent1 {     bool public isActive = true; }  contract Child1 is Parent1 {   ...\n                                        ^-------------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Parent1 {     bool public isActive = true; }  contract Child1 is Parent1 {   ...\n                                        ^-------------------------^\n:1:113: Overriding public state variable is here:\n ...   contract Child1 is Parent1 {     bool public isActive = false;          function isChildActive() ...\n                                        ^--------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Main {\n    bytes32 public hash = keccak256(\"hello\");\n}\n\ncontract SubMain is Main {\n    bytes32 public hash = keccak256(\"world\");\n    \n    function getHash() public view returns (bytes32) {\n        return hash;\n    }\n}",
          "error message": ":1:121: DeclarationError: Identifier already declared.\n ...  }  contract SubMain is Main {     bytes32 public hash = keccak256(\"world\");          function getHash() publi ...\n                                        ^--------------------------------------^\n:1:45: The previous declaration is here:\n ... lidity^0.6.0;  contract Main {     bytes32 public hash = keccak256(\"hello\"); }  contract SubMain is Main {     ...\n                                        ^--------------------------------------^\n:1:121: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...  }  contract SubMain is Main {     bytes32 public hash = keccak256(\"world\");          function getHash() publi ...\n                                        ^--------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Main {     bytes32 public hash = keccak256(\"hello\"); }  contract SubMain is Main {     ...\n                                        ^--------------------------------------^\n:1:45: TypeError: Cannot override public state variable.\n ... lidity^0.6.0;  contract Main {     bytes32 public hash = keccak256(\"hello\"); }  contract SubMain is Main {     ...\n                                        ^--------------------------------------^\n:1:121: Overriding public state variable is here:\n ...  }  contract SubMain is Main {     bytes32 public hash = keccak256(\"world\");          function getHash() publi ...\n                                        ^--------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Parent2 {\n    int public temperature = 25;\n}\n\ncontract Child2 is Parent2 {\n    int public temperature = 30;\n    \n    function getTemperature() public view returns (int) {\n        return temperature;\n    }\n}",
          "error message": ":1:113: DeclarationError: Identifier already declared.\n ...   contract Child2 is Parent2 {     int public temperature = 30;          function getTemperature( ...\n                                        ^-------------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Parent2 {     int public temperature = 25; }  contract Child2 is Parent2 {   ...\n                                        ^-------------------------^\n:1:113: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract Child2 is Parent2 {     int public temperature = 30;          function getTemperature( ...\n                                        ^-------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Parent2 {     int public temperature = 25; }  contract Child2 is Parent2 {   ...\n                                        ^-------------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Parent2 {     int public temperature = 25; }  contract Child2 is Parent2 {   ...\n                                        ^-------------------------^\n:1:113: Overriding public state variable is here:\n ...   contract Child2 is Parent2 {     int public temperature = 30;          function getTemperature( ...\n                                        ^-------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Root {\n    uint8 public version = 1;\n}\n\ncontract Branch is Root {\n    uint8 public version = 2;\n    \n    function getVersion() public view returns (uint8) {\n        return version;\n    }\n}",
          "error message": ":1:104: DeclarationError: Identifier already declared.\n ... ; }  contract Branch is Root {     uint8 public version = 2;          function getVersion() pu ...\n                                        ^----------------------^\n:1:45: The previous declaration is here:\n ... lidity^0.6.0;  contract Root {     uint8 public version = 1; }  contract Branch is Root {      ...\n                                        ^----------------------^\n:1:104: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ; }  contract Branch is Root {     uint8 public version = 2;          function getVersion() pu ...\n                                        ^----------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Root {     uint8 public version = 1; }  contract Branch is Root {      ...\n                                        ^----------------------^\n:1:45: TypeError: Cannot override public state variable.\n ... lidity^0.6.0;  contract Root {     uint8 public version = 1; }  contract Branch is Root {      ...\n                                        ^----------------------^\n:1:104: Overriding public state variable is here:\n ... ; }  contract Branch is Root {     uint8 public version = 2;          function getVersion() pu ...\n                                        ^----------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Foundation {\n    uint public height = 100;\n}\n\ncontract Building is Foundation {\n    uint public height = 200;\n    \n    function getHeight() public view returns (uint) {\n        return height;\n    }\n}",
          "error message": ":1:118: DeclarationError: Identifier already declared.\n ... tract Building is Foundation {     uint public height = 200;          function getHeight() pub ...\n                                        ^----------------------^\n:1:51: The previous declaration is here:\n ... ^0.6.0;  contract Foundation {     uint public height = 100; }  contract Building is Foundatio ...\n                                        ^----------------------^\n:1:118: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... tract Building is Foundation {     uint public height = 200;          function getHeight() pub ...\n                                        ^----------------------^\n:1:51: Overridden function is here:\n ... ^0.6.0;  contract Foundation {     uint public height = 100; }  contract Building is Foundatio ...\n                                        ^----------------------^\n:1:51: TypeError: Cannot override public state variable.\n ... ^0.6.0;  contract Foundation {     uint public height = 100; }  contract Building is Foundatio ...\n                                        ^----------------------^\n:1:118: Overriding public state variable is here:\n ... tract Building is Foundation {     uint public height = 200;          function getHeight() pub ...\n                                        ^----------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Core {\n    string public coreName = \"CoreContract\";\n}\n\ncontract Extension is Core {\n    string public coreName = \"ExtensionContract\";\n    \n    function getCoreName() public view returns (string memory) {\n        return coreName;\n    }\n}",
          "error message": ":1:122: DeclarationError: Identifier already declared.\n ...   contract Extension is Core {     string public coreName = \"ExtensionContract\";          function getCoreName() p ...\n                                        ^------------------------------------------^\n:1:45: The previous declaration is here:\n ... lidity^0.6.0;  contract Core {     string public coreName = \"CoreContract\"; }  contract Extension is Core {   ...\n                                        ^-------------------------------------^\n:1:122: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract Extension is Core {     string public coreName = \"ExtensionContract\";          function getCoreName() p ...\n                                        ^------------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Core {     string public coreName = \"CoreContract\"; }  contract Extension is Core {   ...\n                                        ^-------------------------------------^\n:1:45: TypeError: Cannot override public state variable.\n ... lidity^0.6.0;  contract Core {     string public coreName = \"CoreContract\"; }  contract Extension is Core {   ...\n                                        ^-------------------------------------^\n:1:122: Overriding public state variable is here:\n ...   contract Extension is Core {     string public coreName = \"ExtensionContract\";          function getCoreName() p ...\n                                        ^------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Alpha {\n    uint public alphaValue = 10;\n}\n\ncontract Beta is Alpha {\n    uint public betaValue = 20;\n    \n    function getBetaValue() public view returns (uint) {\n        return betaValue;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Gamma {\n    string public name = \"Gamma\";\n}\n\ncontract Delta is Gamma {\n    string public deltaName = \"Delta\";\n    \n    function getDeltaName() public view returns (string memory) {\n        return deltaName;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract BaseA {\n    address public owner = msg.sender;\n}\n\ncontract DerivedA is BaseA {\n    address public derivedOwner = address(0);\n    \n    function getOwner() public view returns (address) {\n        return derivedOwner;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract BaseB {\n    uint public count = 1;\n}\n\ncontract DerivedB is BaseB {\n    uint public derivedCount = 2;\n    \n    function getCount() public view returns (uint) {\n        return derivedCount;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Parent1 {\n    bool public isActive = true;\n}\n\ncontract Child1 is Parent1 {\n    bool public childIsActive = false;\n    \n    function isChildActive() public view returns (bool) {\n        return childIsActive;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Main {\n    bytes32 public hash = keccak256(\"hello\");\n}\n\ncontract SubMain is Main {\n    bytes32 public subHash = keccak256(\"world\");\n    \n    function getHash() public view returns (bytes32) {\n        return subHash;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Parent2 {\n    int public temperature = 25;\n}\n\ncontract Child2 is Parent2 {\n    int public childTemperature = 30;\n    \n    function getTemperature() public view returns (int) {\n        return childTemperature;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Root {\n    uint8 public version = 1;\n}\n\ncontract Branch is Root {\n    uint8 public branchVersion = 2;\n    \n    function getVersion() public view returns (uint8) {\n        return branchVersion;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Foundation {\n    uint public height = 100;\n}\n\ncontract Building is Foundation {\n    uint public buildingHeight = 200;\n    \n    function getHeight() public view returns (uint) {\n        return buildingHeight;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Core {\n    string public coreName = \"CoreContract\";\n}\n\ncontract Extension is Core {\n    string public extensionName = \"ExtensionContract\";\n    \n    function getCoreName() public view returns (string memory) {\n        return extensionName;\n    }\n}"
      }
    }
  },
  {
    "Changes9": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Conversions from external function types to <code>address</code> are now disallowed. Instead external\nfunction types have a member called <code>address</code>, similar to the existing <code>selector</code> member.Change <code>address(f)</code> to <code>f.address</code> for <code>f</code> being of external function type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    address public contractAddress;\n\n    function sampleFunction() external {\n    }\n\n    function setContractAddress() public {\n        address addr = address(this.sampleFunction);\n        contractAddress = addr;\n    }\n}",
          "error message": ":1:196: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         address addr = address(this.sampleFunction);         contractAddress = addr;   ...\n                                        ^--------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    address public storedAddress;\n\n    function externalCall() external {\n    }\n\n    function saveAddress() public {\n        storedAddress = address(this.externalCall);\n    }\n}",
          "error message": ":1:186: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ) public {         storedAddress = address(this.externalCall);     } }\n                                        ^------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public latestAddress;\n\n    function invokeExternal() external {\n    }\n\n    function updateAddress() public {\n        address addr = address(this.invokeExternal);\n        latestAddress = addr;\n    }\n\n    function additionalFunction() public {\n    }\n}",
          "error message": ":1:189: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         address addr = address(this.invokeExternal);         latestAddress = addr;     ...\n                                        ^--------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    address public callerAddress;\n\n    function someExternal() external {\n    }\n\n    function recordCaller() public {\n        callerAddress = address(this.someExternal);\n    }\n}",
          "error message": ":1:187: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ) public {         callerAddress = address(this.someExternal);     } }\n                                        ^------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    address public addrStored;\n\n    function extFunc() external {\n    }\n\n    function storeAddress() public {\n        addrStored = address(this.extFunc);\n    }\n}",
          "error message": ":1:176: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ss() public {         addrStored = address(this.extFunc);     } }\n                                        ^-------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    address public currentAddress;\n\n    function extFunctionality() external {\n    }\n\n    function logCurrentAddress() public {\n        currentAddress = address(this.extFunctionality);\n    }\n}",
          "error message": ":1:198: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ...  public {         currentAddress = address(this.extFunctionality);     } }\n                                        ^----------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    address public registeredAddress;\n\n    function someFunction() external {\n    }\n\n    function registerAddress() public {\n        registeredAddress = address(this.someFunction);\n    }\n\n    function randomFunction() public {\n    }\n}",
          "error message": ":1:198: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... blic {         registeredAddress = address(this.someFunction);     }      function randomFunctio ...\n                                        ^------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    address public savedAddress;\n\n    function extFuncLogic() external {\n    }\n\n    function saveExtAddress() public {\n        savedAddress = address(this.extFuncLogic);\n    }\n}",
          "error message": ":1:187: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         savedAddress = address(this.extFuncLogic);     } }\n                                        ^------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    address public retrievedAddress;\n\n    function extInvoke() external {\n    }\n\n    function retrieveAddress() public {\n        retrievedAddress = address(this.extInvoke);\n    }\n}",
          "error message": ":1:193: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ublic {         retrievedAddress = address(this.extInvoke);     } }\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address public functionAddress;\n\n    function externalExecutor() external {\n    }\n\n    function setFunctionAddress() public {\n        functionAddress = address(this.externalExecutor);\n    }\n}",
          "error message": ":1:202: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... public {         functionAddress = address(this.externalExecutor);     } }\n                                        ^----------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    address public contractAddress;\n    bytes4 public functionSelector;\n\n    function sampleFunction() external {\n    }\n\n    function setContractAddress() public {\n        contractAddress = address(this);\n        functionSelector = this.sampleFunction.selector;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    address public storedAddress;\n    bytes4 public functionSelector;\n\n    function externalCall() external {\n    }\n\n    function saveAddress() public {\n        storedAddress = address(this);\n        functionSelector = this.externalCall.selector;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public latestAddress;\n    bytes4 public functionSelector;\n\n    function invokeExternal() external {\n    }\n\n    function updateAddress() public {\n        latestAddress = address(this);\n        functionSelector = this.invokeExternal.selector;\n    }\n\n    function additionalFunction() public {\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    address public callerAddress;\n    bytes4 public functionSelector;\n\n    function someExternal() external {\n    }\n\n    function recordCaller() public {\n        callerAddress = address(this);\n        functionSelector = this.someExternal.selector;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    address public addrStored;\n    bytes4 public functionSelector;\n\n    function extFunc() external {\n    }\n\n    function storeAddress() public {\n        addrStored = address(this);\n        functionSelector = this.extFunc.selector;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    address public currentAddress;\n    bytes4 public functionSelector;\n\n    function extFunctionality() external {\n    }\n\n    function logCurrentAddress() public {\n        currentAddress = address(this);\n        functionSelector = this.extFunctionality.selector;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    address public registeredAddress;\n    bytes4 public functionSelector;\n\n    function someFunction() external {\n    }\n\n    function registerAddress() public {\n        registeredAddress = address(this);\n        functionSelector = this.someFunction.selector;\n    }\n\n    function randomFunction() public {\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    address public savedAddress;\n    bytes4 public functionSelector;\n\n    function extFuncLogic() external {\n    }\n\n    function saveExtAddress() public {\n        savedAddress = address(this);\n        functionSelector = this.extFuncLogic.selector;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    address public retrievedAddress;\n    bytes4 public functionSelector;\n\n    function extInvoke() external {\n    }\n\n    function retrieveAddress() public {\n        retrievedAddress = address(this);\n        functionSelector = this.extInvoke.selector;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address public functionAddress;\n    bytes4 public functionSelector;\n\n    function externalExecutor() external {\n    }\n\n    function setFunctionAddress() public {\n        functionAddress = address(this);\n        functionSelector = this.externalExecutor.selector;\n    }\n}"
      }
    }
  },
  {
    "Changes10": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The function <code>push(value)</code> for dynamic storage arrays does not return the new length anymore (it returns nothing).Change <code>uint length = array.push(value)</code> to <code>array.push(value);</code>. The new length can be accessed via <code>array.length</code>.Change <code>array.length++</code> to <code>array.push()</code> to increase, and use <code>pop()</code> to decrease the length of a storage array.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    uint[] public data;\n\n    function appendData(uint _value) public returns (uint) {\n        uint length = data.push(_value);\n        return length;\n    }\n}",
          "error message": ":1:139: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... e) public returns (uint) {         uint length = data.push(_value);         return length;     } }\n                                        ^-----------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    string[] public words;\n\n    function addWord(string memory _word) public returns (uint) {\n        uint newLength = words.push(_word);\n        return newLength;\n    }\n\n    function getWord(uint index) public view returns (string memory) {\n        return words[index];\n    }\n}",
          "error message": ":1:147: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... d) public returns (uint) {         uint newLength = words.push(_word);         return newLength;     }   ...\n                                        ^--------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address[] public addresses;\n\n    function addAddress(address _addr) public returns (uint) {\n        uint len = addresses.push(_addr);\n        return len;\n    }\n}",
          "error message": ":1:149: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... r) public returns (uint) {         uint len = addresses.push(_addr);         return len;     } }\n                                        ^------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    bytes32[] public hashes;\n\n    function pushHash(bytes32 _hash) public returns (uint) {\n        uint length = hashes.push(_hash);\n        return length;\n    }\n}",
          "error message": ":1:144: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... h) public returns (uint) {         uint length = hashes.push(_hash);         return length;     } }\n                                        ^------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    uint[] public numbers;\n\n    function insertNumber(uint _num) public returns (uint) {\n        uint len = numbers.push(_num);\n        return len;\n    }\n}",
          "error message": ":1:142: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... m) public returns (uint) {         uint len = numbers.push(_num);         return len;     } }\n                                        ^---------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    int[] public values;\n\n    function addValue(int _val) public returns (uint) {\n        uint length = values.push(_val);\n        return length;\n    }\n\n    function getValue(uint index) public view returns (int) {\n        return values[index];\n    }\n}",
          "error message": ":1:135: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... l) public returns (uint) {         uint length = values.push(_val);         return length;     }      ...\n                                        ^-----------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    bytes[] public blobs;\n\n    function addBlob(bytes memory _blob) public returns (uint) {\n        uint len = blobs.push(_blob);\n        return len;\n    }\n}",
          "error message": ":1:145: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... b) public returns (uint) {         uint len = blobs.push(_blob);         return len;     } }\n                                        ^--------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    uint[] public counts;\n\n    function incrementCount(uint _count) public returns (uint) {\n        uint newLength = counts.push(_count);\n        return newLength;\n    }\n}",
          "error message": ":1:145: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... t) public returns (uint) {         uint newLength = counts.push(_count);         return newLength;     } }\n                                        ^----------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    uint[] public elements;\n\n    function addElement(uint _element) public returns (uint) {\n        uint len = elements.push(_element);\n        return len;\n    }\n\n    function getElement(uint index) public view returns (uint) {\n        return elements[index];\n    }\n}",
          "error message": ":1:145: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... t) public returns (uint) {         uint len = elements.push(_element);         return len;     }      fu ...\n                                        ^--------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address[] public participants;\n\n    function addParticipant(address _participant) public returns (uint) {\n        uint newLength = participants.push(_participant);\n        return newLength;\n    }\n}",
          "error message": ":1:164: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... t) public returns (uint) {         uint newLength = participants.push(_participant);         return newLength;     } }\n                                        ^----------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    uint[] public data;\n\n    function appendData(uint _value) public returns (uint) {\n        data.push(_value);\n        return data.length;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    string[] public words;\n\n    function addWord(string memory _word) public returns (uint) {\n        words.push(_word);\n        return words.length;\n    }\n\n    function getWord(uint index) public view returns (string memory) {\n        return words[index];\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address[] public addresses;\n\n    function addAddress(address _addr) public returns (uint) {\n        addresses.push(_addr);\n        return addresses.length;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    bytes32[] public hashes;\n\n    function pushHash(bytes32 _hash) public returns (uint) {\n        hashes.push(_hash);\n        return hashes.length;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    uint[] public numbers;\n\n    function insertNumber(uint _num) public returns (uint) {\n        numbers.push(_num);\n        return numbers.length;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    int[] public values;\n\n    function addValue(int _val) public returns (uint) {\n        values.push(_val);\n        return values.length;\n    }\n\n    function getValue(uint index) public view returns (int) {\n        return values[index];\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    bytes[] public blobs;\n\n    function addBlob(bytes memory _blob) public returns (uint) {\n        blobs.push(_blob);\n        return blobs.length;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    uint[] public counts;\n\n    function incrementCount(uint _count) public returns (uint) {\n        counts.push(_count);\n        return counts.length;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    uint[] public elements;\n\n    function addElement(uint _element) public returns (uint) {\n        elements.push(_element);\n        return elements.length;\n    }\n\n    function getElement(uint index) public view returns (uint) {\n        return elements[index];\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address[] public participants;\n\n    function addParticipant(address _participant) public returns (uint) {\n        participants.push(_participant);\n        return participants.length;\n    }\n}"
      }
    }
  },
  {
    "Changes11": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The unnamed function commonly referred to as \u201cfallback function\u201d was split up into a new\nfallback function that is defined using the <code>fallback</code> keyword and a receive ether function\ndefined using the <code>receive</code> keyword.Replace <code>function () external [payable] { ... }</code> by either <code>receive() external payable { ... }</code>,<code>fallback() external [payable] { ... }</code> or both. Prefer using a <code>receive</code> function only, whenever possible.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    function () external payable {}\n\n    function randomFunction1(uint x) public pure returns (uint) {\n        return x * 2;\n    }\n}",
          "error message": ":1:78: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function randomFunction1(uin ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    function deposit() public payable {}\n\n    function () external {}\n\n    function randomFunction2() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:112: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... yable {}      function () external {}      function randomFunction2() p ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    function () external payable {}\n\n    function withdraw(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction3(address addr) public pure returns (address) {\n        return addr;\n    }\n}",
          "error message": ":1:78: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function withdraw(uint amoun ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    function () external {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction4() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... xample4 {     function () external {}      function getBalance() public ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    function () external payable {}\n\n    function balance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction5() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"data\"));\n    }\n}",
          "error message": ":1:78: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function balance() public vi ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    function receiveFunds() public payable {}\n\n    function () external {}\n\n    function randomFunction6(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
          "error message": ":1:117: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... yable {}      function () external {}      function randomFunction6(uin ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    function () external payable {}\n\n    function transferOwnership(address newOwner) public {}\n\n    function randomFunction7() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:78: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function transferOwnership(a ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    function depositEther() public payable {}\n\n    function () external payable {}\n\n    function getOwner() public view returns (address) {\n        return msg.sender;\n    }\n\n    function randomFunction8(uint x) public pure returns (uint) {\n        return x * x;\n    }\n}",
          "error message": ":1:125: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ...       function () external payable {}      function getOwner() public v ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    function () external {}\n\n    function withdrawFunds(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction9() public pure returns (string memory) {\n        return \"World\";\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... xample9 {     function () external {}      function withdrawFunds(uint  ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    function () external payable {}\n\n    function setOwner(address newOwner) public {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction10(bytes memory input) public pure returns (bytes memory) {\n        return input;\n    }\n}",
          "error message": ":1:79: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function setOwner(address ne ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    fallback() external payable {}\n\n    function randomFunction1(uint x) public pure returns (uint) {\n        return x * 2;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    function deposit() public payable {}\n\n    fallback() external {}\n\n    function randomFunction2() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    fallback() external payable {}\n\n    function withdraw(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction3(address addr) public pure returns (address) {\n        return addr;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    fallback() external {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction4() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    fallback() external payable {}\n\n    function balance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction5() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"data\"));\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    function receiveFunds() public payable {}\n\n    fallback() external {}\n\n    function randomFunction6(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    fallback() external payable {}\n\n    function transferOwnership(address newOwner) public {}\n\n    function randomFunction7() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    function depositEther() public payable {}\n\n    fallback() external payable {}\n\n    function getOwner() public view returns (address) {\n        return msg.sender;\n    }\n\n    function randomFunction8(uint x) public pure returns (uint) {\n        return x * x;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    fallback() external {}\n\n    function withdrawFunds(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction9() public pure returns (string memory) {\n        return \"World\";\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    fallback() external payable {}\n\n    function setOwner(address newOwner) public {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction10(bytes memory input) public pure returns (bytes memory) {\n        return input;\n    }\n}"
      }
    }
  },
  {
    "Changes12": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "If present, the receive ether function is called whenever the call data is empty (whether\nor not ether is received). This function is implicitly <code>payable</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract1 {\n    function() external {\n    }\n    \n    function getValue() public pure returns (uint) {\n        return 42;\n    }\n    \n    function randomFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract1 {     function() external {     }          function getValue() ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract2 {\n    function() external {\n    }\n    \n    function computeSum(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract2 {     function() external {     }          function computeSum ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract3 {\n    function() external {\n    }\n    \n    function calculate(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n    \n    function extraFunc() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract3 {     function() external {     }          function calculate( ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract4 {\n    function() external {\n    }\n    \n    function randomFunction() public pure returns (string memory) {\n        return \"Hello, Solidity!\";\n    }\n    \n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract4 {     function() external {     }          function randomFunc ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract5 {\n    function() external {\n    }\n    \n    function check(uint num) public pure returns (bool) {\n        return num > 10;\n    }\n    \n    function anotherCheck(uint num) public pure returns (bool) {\n        return num == 0;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract5 {     function() external {     }          function check(uint ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract6 {\n    function() external {\n    }\n    \n    function concatenate(string memory a, string memory b) public pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n    \n    function anotherFunction(uint num) public pure returns (uint) {\n        return num * 2;\n    }\n    \n    function auxiliaryFunc() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"test\"));\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract6 {     function() external {     }          function concatenat ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract7 {\n    function() external {\n    }\n    \n    function add(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n    \n    function auxiliaryFunc2() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract7 {     function() external {     }          function add(uint a ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract8 {\n    function() external {\n    }\n    \n    function greet() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n    \n    function combine(uint x, uint y) public pure returns (uint) {\n        return x + y;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract8 {     function() external {     }          function greet() pu ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract9 {\n    function() external {\n    }\n    \n    function isEven(uint number) public pure returns (bool) {\n        return number % 2 == 0;\n    }\n    \n    function randomOperation(uint a, uint b) public pure returns (uint) {\n        return a - b;\n    }\n    \n    function anotherCheck(uint a) public pure returns (bool) {\n        return a > 100;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract9 {     function() external {     }          function isEven(uin ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract10 {\n    function() external {\n    }\n    \n    function multiply(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function checkCondition(uint value) public pure returns (bool) {\n        return value > 1000;\n    }\n    \n    function dummyFunction() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": ":1:71: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ntract10 {     function() external {     }          function multiply(u ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Contract1 {\n    fallback() external payable {\n    }\n    \n    function getValue() public pure returns (uint) {\n        return 42;\n    }\n    \n    function randomFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Contract2 {\n    fallback() external payable {\n    }\n    \n    function computeSum(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Contract3 {\n    fallback() external payable {\n    }\n    \n    function calculate(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n    \n    function extraFunc() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Contract4 {\n    fallback() external payable {\n    }\n    \n    function randomFunction() public pure returns (string memory) {\n        return \"Hello, Solidity!\";\n    }\n    \n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Contract5 {\n    fallback() external payable {\n    }\n    \n    function check(uint num) public pure returns (bool) {\n        return num > 10;\n    }\n    \n    function anotherCheck(uint num) public pure returns (bool) {\n        return num == 0;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Contract6 {\n    fallback() external payable {\n    }\n    \n    function concatenate(string memory a, string memory b) public pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n    \n    function anotherFunction(uint num) public pure returns (uint) {\n        return num * 2;\n    }\n    \n    function auxiliaryFunc() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"test\"));\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Contract7 {\n    fallback() external payable {\n    }\n    \n    function add(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n    \n    function auxiliaryFunc2() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Contract8 {\n    fallback() external payable {\n    }\n    \n    function greet() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n    \n    function combine(uint x, uint y) public pure returns (uint) {\n        return x + y;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Contract9 {\n    fallback() external payable {\n    }\n    \n    function isEven(uint number) public pure returns (bool) {\n        return number % 2 == 0;\n    }\n    \n    function randomOperation(uint a, uint b) public pure returns (uint) {\n        return a - b;\n    }\n    \n    function anotherCheck(uint a) public pure returns (bool) {\n        return a > 100;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Contract10 {\n    fallback() external payable {\n    }\n    \n    function multiply(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function checkCondition(uint value) public pure returns (bool) {\n        return value > 1000;\n    }\n    \n    function dummyFunction() public pure returns (uint) {\n        return 123;\n    }\n}"
      }
    }
  },
  {
    "Changes13": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The new fallback function is called when no other function matches (if the receive ether\nfunction does not exist then this includes calls with empty call data).\nYou can make this function <code>payable</code> or not. If it is not <code>payable</code> then transactions\nnot matching any other function which send value will revert. You should only need to\nimplement the new fallback function if you are following an upgrade or proxy pattern.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleOne {\n    uint256 public total;\n\n    function() external {\n        total += 1;\n    }\n\n    function getTotal() public view returns (uint256) {\n        return total;\n    }\n}",
          "error message": ":1:98: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic total;      function() external {         total += 1;     }      fun ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleTwo {\n    address public owner;\n\n    function() external {\n        owner = msg.sender;\n    }\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n}",
          "error message": ":1:98: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic owner;      function() external {         owner = msg.sender;     }  ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleThree {\n    string public message = \"Hello World\";\n\n    function() external {\n        message = \"Fallback called\";\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n\n    function getMessage() public view returns (string memory) {\n        return message;\n    }\n}",
          "error message": ":1:117: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... o World\";      function() external {         message = \"Fallback called ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleFour {\n    uint public count;\n\n    function() external {\n        count++;\n    }\n\n    function resetCount() public {\n        count = 0;\n    }\n}",
          "error message": ":1:96: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic count;      function() external {         count++;     }      functi ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleFive {\n    bool public flag;\n\n    function() external {\n        flag = !flag;\n    }\n\n    function checkFlag() public view returns (bool) {\n        return flag;\n    }\n}",
          "error message": ":1:95: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... lic flag;      function() external {         flag = !flag;     }      f ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleSix {\n    bytes32 public data;\n\n    function() external {\n        data = keccak256(abi.encodePacked(msg.sender));\n    }\n\n    function getData() public view returns (bytes32) {\n        return data;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... lic data;      function() external {         data = keccak256(abi.encod ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleSeven {\n    uint public value;\n\n    function() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic value;      function() external {         value = 100;     }      fu ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleEight {\n    uint public value;\n\n    function() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic value;      function() external {         value = 100;     }      fu ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleNine {\n    string public status;\n\n    function() external {\n        status = \"Fallback activated\";\n    }\n\n    function getStatus() public view returns (string memory) {\n        return status;\n    }\n}",
          "error message": ":1:99: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... c status;      function() external {         status = \"Fallback activat ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleTen {\n    uint public counter;\n\n    function() external {\n        counter += 10;\n    }\n\n    function increment() public {\n        counter++;\n    }\n\n    function decrement() public {\n        counter--;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ...  counter;      function() external {         counter += 10;     }       ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ExampleOne {\n    uint256 public total;\n\n    fallback() external {\n        total += 1;\n    }\n\n    function getTotal() public view returns (uint256) {\n        return total;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ExampleTwo {\n    address public owner;\n\n    fallback() external {\n        owner = msg.sender;\n    }\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ExampleThree {\n    string public message = \"Hello World\";\n\n    fallback() external {\n        message = \"Fallback called\";\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n\n    function getMessage() public view returns (string memory) {\n        return message;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ExampleFour {\n    uint public count;\n\n    fallback() external {\n        count++;\n    }\n\n    function resetCount() public {\n        count = 0;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ExampleFive {\n    bool public flag;\n\n    fallback() external {\n        flag = !flag;\n    }\n\n    function checkFlag() public view returns (bool) {\n        return flag;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ExampleSix {\n    bytes32 public data;\n\n    fallback() external {\n        data = keccak256(abi.encodePacked(msg.sender));\n    }\n\n    function getData() public view returns (bytes32) {\n        return data;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ExampleSeven {\n    uint public value;\n\n    fallback() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ExampleEight {\n    uint public value;\n\n    fallback() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ExampleNine {\n    string public status;\n\n    fallback() external {\n        status = \"Fallback activated\";\n    }\n\n    function getStatus() public view returns (string memory) {\n        return status;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ExampleTen {\n    uint public counter;\n\n    fallback() external {\n        counter += 10;\n    }\n\n    function increment() public {\n        counter++;\n    }\n\n    function decrement() public {\n        counter--;\n    }\n}"
      }
    }
  },
  {
    "Changes14": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "In external function and contract creation calls, Ether and gas is now specified using a new syntax:\n<code>x.f{gas: 10000, value: 2 ether}(arg1, arg2)</code>.\nThe old syntax \u2013 <code>x.f.gas(10000).value(2 ether)(arg1, arg2)</code> \u2013 will cause an error.Change <code>x.f.value(...)()</code> to <code>x.f{value: ...}()</code>. Similarly <code>(new C).value(...)()</code> to <code>new C{value: ...}()</code> and <code>x.f.gas(...).value(...)()</code> to <code>x.f{gas: ..., value: ...}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    function actionK() external payable {\n    }\n}\n\ncontract Example11 {\n    ContractK contractK;\n\n    function triggerActionK() public {\n        contractK.actionK.value(0.3 ether)();\n    }\n\n    function miscellaneousFunction11() public pure returns(string memory) {\n        return \"Miscellaneous 11\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionK() public {         contractK.actionK.value(0.3 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    function actionL() external payable {\n    }\n}\n\ncontract Example12 {\n    ContractL contractL;\n\n    function triggerActionL() public {\n        contractL.actionL.value(0.2 ether)();\n    }\n\n    function miscellaneousFunction12() public pure returns(string memory) {\n        return \"Miscellaneous 12\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionL() public {         contractL.actionL.value(0.2 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    function actionM() external payable {\n    }\n}\n\ncontract Example13 {\n    ContractM contractM;\n\n    function triggerActionM() public {\n        contractM.actionM.value(1.5 ether)();\n    }\n\n    function miscellaneousFunction13() public pure returns(string memory) {\n        return \"Miscellaneous 13\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionM() public {         contractM.actionM.value(1.5 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    function actionN() external payable {\n    }\n}\n\ncontract Example14 {\n    ContractN contractN;\n\n    function triggerActionN() public {\n        contractN.actionN.value(0.05 ether)();\n    }\n\n    function miscellaneousFunction14() public pure returns(string memory) {\n        return \"Miscellaneous 14\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionN() public {         contractN.actionN.value(0.05 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    function actionO() external payable {\n    }\n}\n\ncontract Example15 {\n    ContractO contractO;\n\n    function triggerActionO() public {\n        contractO.actionO.value(2.5 ether)();\n    }\n\n    function miscellaneousFunction15() public pure returns(string memory) {\n        return \"Miscellaneous 15\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionO() public {         contractO.actionO.value(2.5 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    function actionP() external payable {\n    }\n}\n\ncontract Example16 {\n    ContractP contractP;\n\n    function triggerActionP() public {\n        contractP.actionP.value(0.4 ether)();\n    }\n\n    function miscellaneousFunction16() public pure returns(string memory) {\n        return \"Miscellaneous 16\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionP() public {         contractP.actionP.value(0.4 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    function actionQ() external payable {\n    }\n}\n\ncontract Example17 {\n    ContractQ contractQ;\n\n    function triggerActionQ() public {\n        contractQ.actionQ.value(3 ether)();\n    }\n\n    function miscellaneousFunction17() public pure returns(string memory) {\n        return \"Miscellaneous 17\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionQ() public {         contractQ.actionQ.value(3 ether)();     }      function mi ...\n                                        ^---------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    function actionR() external payable {\n    }\n}\n\ncontract Example18 {\n    ContractR contractR;\n\n    function triggerActionR() public {\n        contractR.actionR.value(0.75 ether)();\n    }\n\n    function miscellaneousFunction18() public pure returns(string memory) {\n        return \"Miscellaneous 18\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionR() public {         contractR.actionR.value(0.75 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    function actionS() external payable {\n    }\n}\n\ncontract Example19 {\n    ContractS contractS;\n\n    function triggerActionS() public {\n        contractS.actionS.value(1.25 ether)();\n    }\n\n    function miscellaneousFunction19() public pure returns(string memory) {\n        return \"Miscellaneous 19\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionS() public {         contractS.actionS.value(1.25 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    function actionT() external payable {\n    }\n}\n\ncontract Example20 {\n    ContractT contractT;\n\n    function triggerActionT() public {\n        contractT.actionT.value(0.125 ether)();\n    }\n\n    function miscellaneousFunction20() public pure returns(string memory) {\n        return \"Miscellaneous 20\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionT() public {         contractT.actionT.value(0.125 ether)();     }      functio ...\n                                        ^---------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    function actionK() external payable {\n    }\n}\n\ncontract Example11 {\n    ContractK contractK;\n\n    function triggerActionK() public {\n        contractK.actionK{value: 0.3 ether}();\n    }\n\n    function miscellaneousFunction11() public pure returns(string memory) {\n        return \"Miscellaneous 11\";\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    function actionL() external payable {\n    }\n}\n\ncontract Example12 {\n    ContractL contractL;\n\n    function triggerActionL() public {\n        contractL.actionL{value: 0.2 ether}();\n    }\n\n    function miscellaneousFunction12() public pure returns(string memory) {\n        return \"Miscellaneous 12\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    function actionM() external payable {\n    }\n}\n\ncontract Example13 {\n    ContractM contractM;\n\n    function triggerActionM() public {\n        contractM.actionM{value: 1.5 ether}();\n    }\n\n    function miscellaneousFunction13() public pure returns(string memory) {\n        return \"Miscellaneous 13\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    function actionN() external payable {\n    }\n}\n\ncontract Example14 {\n    ContractN contractN;\n\n    function triggerActionN() public {\n        contractN.actionN{value: 0.05 ether}();\n    }\n\n    function miscellaneousFunction14() public pure returns(string memory) {\n        return \"Miscellaneous 14\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    function actionO() external payable {\n    }\n}\n\ncontract Example15 {\n    ContractO contractO;\n\n    function triggerActionO() public {\n        contractO.actionO{value: 2.5 ether}();\n    }\n\n    function miscellaneousFunction15() public pure returns(string memory) {\n        return \"Miscellaneous 15\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    function actionP() external payable {\n    }\n}\n\ncontract Example16 {\n    ContractP contractP;\n\n    function triggerActionP() public {\n        contractP.actionP{value: 0.4 ether}();\n    }\n\n    function miscellaneousFunction16() public pure returns(string memory) {\n        return \"Miscellaneous 16\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    function actionQ() external payable {\n    }\n}\n\ncontract Example17 {\n    ContractQ contractQ;\n\n    function triggerActionQ() public {\n        contractQ.actionQ{value: 3 ether}();\n    }\n\n    function miscellaneousFunction17() public pure returns(string memory) {\n        return \"Miscellaneous 17\";\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    function actionR() external payable {\n    }\n}\n\ncontract Example18 {\n    ContractR contractR;\n\n    function triggerActionR() public {\n        contractR.actionR{value: 0.75 ether}();\n    }\n\n    function miscellaneousFunction18() public pure returns(string memory) {\n        return \"Miscellaneous 18\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    function actionS() external payable {\n    }\n}\n\ncontract Example19 {\n    ContractS contractS;\n\n    function triggerActionS() public {\n        contractS.actionS{value: 1.25 ether}();\n    }\n\n    function miscellaneousFunction19() public pure returns(string memory) {\n        return \"Miscellaneous 19\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    function actionT() external payable {\n    }\n}\n\ncontract Example20 {\n    ContractT contractT;\n\n    function triggerActionT() public {\n        contractT.actionT{value: 0.125 ether}();\n    }\n\n    function miscellaneousFunction20() public pure returns(string memory) {\n        return \"Miscellaneous 20\";\n    }\n}"
      }
    }
  },
  {
    "Changes15": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The global variable <code>now</code> is deprecated, <code>block.timestamp</code> should be used instead.\nThe single identifier <code>now</code> is too generic for a global variable and could give the impression\nthat it changes during transaction processing, whereas <code>block.timestamp</code> correctly\nreflects the fact that it is just a property of the block.Change <code>now</code> to <code>block.timestamp</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public lastCheckpoint;\n\n    function markCheckpoint() public {\n        lastCheckpoint = now;\n    }\n\n    uint public checkpointsMade;\n\n    function incrementCheckpoints() public {\n        checkpointsMade++;\n    }\n}",
          "error message": ":1:143: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ...  public {         lastCheckpoint = now;     }      uint public checkpoint ...\n                                        ^-^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public lastReset;\n\n    function reset() public {\n        lastReset = now;\n    }\n\n    uint public resetCount;\n\n    function incrementResetCount() public {\n        resetCount++;\n    }\n}",
          "error message": ":1:124: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... set() public {         lastReset = now;     }      uint public resetCount ...\n                                        ^-^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public lastEntry;\n\n    function logEntry() public {\n        lastEntry = now;\n    }\n\n    uint public entriesLogged;\n\n    function incrementEntriesLogged() public {\n        entriesLogged++;\n    }\n}",
          "error message": ":1:127: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... try() public {         lastEntry = now;     }      uint public entriesLog ...\n                                        ^-^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public lastSignIn;\n\n    function signIn() public {\n        lastSignIn = now;\n    }\n\n    uint public signInCount;\n\n    function incrementSignInCount() public {\n        signInCount++;\n    }\n}",
          "error message": ":1:127: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... In() public {         lastSignIn = now;     }      uint public signInCoun ...\n                                        ^-^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public lastRegistration;\n\n    function register() public {\n        lastRegistration = now;\n    }\n\n    uint public registrationCount;\n\n    function incrementRegistrationCount() public {\n        registrationCount++;\n    }\n}",
          "error message": ":1:141: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ublic {         lastRegistration = now;     }      uint public registrati ...\n                                        ^-^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public lastActivity;\n\n    function recordActivity() public {\n        lastActivity = now;\n    }\n\n    uint public activityCount;\n\n    function incrementActivityCount() public {\n        activityCount++;\n    }\n}",
          "error message": ":1:139: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastActivity = now;     }      uint public activityCo ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public lastPurchase;\n\n    function makePurchase() public {\n        lastPurchase = now;\n    }\n\n    uint public purchaseCount;\n\n    function incrementPurchaseCount() public {\n        purchaseCount++;\n    }\n}",
          "error message": ":1:137: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastPurchase = now;     }      uint public purchaseCo ...\n                                        ^-^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public lastDownload;\n\n    function download() public {\n        lastDownload = now;\n    }\n\n    uint public downloadCount;\n\n    function incrementDownloadCount() public {\n        downloadCount++;\n    }\n}",
          "error message": ":1:133: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastDownload = now;     }      uint public downloadCo ...\n                                        ^-^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public lastModification;\n\n    function modify() public {\n        lastModification = now;\n    }\n\n    uint public modificationsMade;\n\n    function incrementModifications() public {\n        modificationsMade++;\n    }\n}",
          "error message": ":1:139: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ublic {         lastModification = now;     }      uint public modificati ...\n                                        ^-^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public lastQuery;\n\n    function query() public {\n        lastQuery = now;\n    }\n\n    uint public queryCount;\n\n    function incrementQueryCount() public {\n        queryCount++;\n    }\n}",
          "error message": ":1:124: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ery() public {         lastQuery = now;     }      uint public queryCount ...\n                                        ^-^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public lastCheckpoint;\n\n    function markCheckpoint() public {\n        lastCheckpoint = block.timestamp;\n    }\n\n    uint public checkpointsMade;\n\n    function incrementCheckpoints() public {\n        checkpointsMade++;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public lastReset;\n\n    function reset() public {\n        lastReset = block.timestamp;\n    }\n\n    uint public resetCount;\n\n    function incrementResetCount() public {\n        resetCount++;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public lastEntry;\n\n    function logEntry() public {\n        lastEntry = block.timestamp;\n    }\n\n    uint public entriesLogged;\n\n    function incrementEntriesLogged() public {\n        entriesLogged++;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public lastSignIn;\n\n    function signIn() public {\n        lastSignIn = block.timestamp;\n    }\n\n    uint public signInCount;\n\n    function incrementSignInCount() public {\n        signInCount++;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public lastRegistration;\n\n    function register() public {\n        lastRegistration = block.timestamp;\n    }\n\n    uint public registrationCount;\n\n    function incrementRegistrationCount() public {\n        registrationCount++;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public lastActivity;\n\n    function recordActivity() public {\n        lastActivity = block.timestamp;\n    }\n\n    uint public activityCount;\n\n    function incrementActivityCount() public {\n        activityCount++;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public lastPurchase;\n\n    function makePurchase() public {\n        lastPurchase = block.timestamp;\n    }\n\n    uint public purchaseCount;\n\n    function incrementPurchaseCount() public {\n        purchaseCount++;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public lastDownload;\n\n    function download() public {\n        lastDownload = block.timestamp;\n    }\n\n    uint public downloadCount;\n\n    function incrementDownloadCount() public {\n        downloadCount++;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public lastModification;\n\n    function modify() public {\n        lastModification = block.timestamp;\n    }\n\n    uint public modificationsMade;\n\n    function incrementModifications() public {\n        modificationsMade++;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public lastQuery;\n\n    function query() public {\n        lastQuery = block.timestamp;\n    }\n\n    uint public queryCount;\n\n    function incrementQueryCount() public {\n        queryCount++;\n    }\n}"
      }
    }
  },
  {
    "Changes16": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "NatSpec comments on variables are only allowed for public state variables and not\nfor local or internal variables.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public length;\n\n    function setLength(uint256 _length) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localLength = _length;\n        length = localLength;\n    }\n\n    function getLength() public view returns (uint256) {\n        return length;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:528: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public width;\n\n    function setWidth(uint256 _width) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localWidth = _width;\n        width = localWidth;\n    }\n\n    function getWidth() public view returns (uint256) {\n        return width;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:632: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public height;\n\n    function setHeight(uint256 _height) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localHeight = _height;\n        height = localHeight;\n    }\n\n    function getHeight() public view returns (uint256) {\n        return height;\n    }\n}",
          "error message": ":1:421: ParserError: Function, variable, struct or modifier declaration expected.\n ... 6) {         return height;     } }\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public depth;\n\n    function setDepth(uint256 _depth) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localDepth = _depth;\n        depth = localDepth;\n    }\n\n    function getDepth() public view returns (uint256) {\n        return depth;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:519: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public radius;\n\n    function setRadius(uint256 _radius) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localRadius = _radius;\n        radius = localRadius;\n    }\n\n    function getRadius() public view returns (uint256) {\n        return radius;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
          "error message": ":1:531: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 1\";     } }\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public diameter;\n\n    function setDiameter(uint256 _diameter) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localDiameter = _diameter;\n        diameter = localDiameter;\n    }\n\n    function getDiameter() public view returns (uint256) {\n        return diameter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:659: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public volume;\n\n    function setVolume(uint256 _volume) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localVolume = _volume;\n        volume = localVolume;\n    }\n\n    function getVolume() public view returns (uint256) {\n        return volume;\n    }\n}",
          "error message": ":1:421: ParserError: Function, variable, struct or modifier declaration expected.\n ... 6) {         return volume;     } }\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public area;\n\n    function setArea(uint256 _area) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localArea = _area;\n        area = localArea;\n    }\n\n    function getArea() public view returns (uint256) {\n        return area;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:510: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public perimeter;\n\n    function setPerimeter(uint256 _perimeter) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localPerimeter = _perimeter;\n        perimeter = localPerimeter;\n    }\n\n    function getPerimeter() public view returns (uint256) {\n        return perimeter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
          "error message": ":1:558: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 1\";     } }\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public circumference;\n\n    function setCircumference(uint256 _circumference) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localCircumference = _circumference;\n        circumference = localCircumference;\n    }\n\n    function getCircumference() public view returns (uint256) {\n        return circumference;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:704: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    uint256 public length;\n\n    function setLength(uint256 _length) public {\n        uint256 localLength = _length;\n        length = localLength;\n    }\n\n    function getLength() public view returns (uint256) {\n        return length;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    uint256 public width;\n\n    function setWidth(uint256 _width) public {\n        uint256 localWidth = _width;\n        width = localWidth;\n    }\n\n    function getWidth() public view returns (uint256) {\n        return width;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    uint256 public height;\n\n    function setHeight(uint256 _height) public {\n        uint256 localHeight = _height;\n        height = localHeight;\n    }\n\n    function getHeight() public view returns (uint256) {\n        return height;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    uint256 public depth;\n\n    function setDepth(uint256 _depth) public {\n        uint256 localDepth = _depth;\n        depth = localDepth;\n    }\n\n    function getDepth() public view returns (uint256) {\n        return depth;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    uint256 public radius;\n\n    function setRadius(uint256 _radius) public {\n        uint256 localRadius = _radius;\n        radius = localRadius;\n    }\n\n    function getRadius() public view returns (uint256) {\n        return radius;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    uint256 public diameter;\n\n    function setDiameter(uint256 _diameter) public {\n        uint256 localDiameter = _diameter;\n        diameter = localDiameter;\n    }\n\n    function getDiameter() public view returns (uint256) {\n        return diameter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    uint256 public volume;\n\n    function setVolume(uint256 _volume) public {\n        uint256 localVolume = _volume;\n        volume = localVolume;\n    }\n\n    function getVolume() public view returns (uint256) {\n        return volume;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    uint256 public area;\n\n    function setArea(uint256 _area) public {\n        uint256 localArea = _area;\n        area = localArea;\n    }\n\n    function getArea() public view returns (uint256) {\n        return area;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    uint256 public perimeter;\n\n    function setPerimeter(uint256 _perimeter) public {\n        uint256 localPerimeter = _perimeter;\n        perimeter = localPerimeter;\n    }\n\n    function getPerimeter() public view returns (uint256) {\n        return perimeter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    uint256 public circumference;\n\n    function setCircumference(uint256 _circumference) public {\n        uint256 localCircumference = _circumference;\n        circumference = localCircumference;\n    }\n\n    function getCircumference() public view returns (uint256) {\n        return circumference;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}"
      }
    }
  },
  {
    "Changes17": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The token <code>gwei</code> is a keyword now (used to specify, e.g. <code>2 gwei</code> as a number)\nand cannot be used as an identifier.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public gwei;\n    uint public amount;\n\n    constructor(uint _amount) public {\n        gwei = 450;\n        amount = _amount;\n    }\n\n    function setGweiAmount(uint _gwei, uint _amount) public {\n        gwei = _gwei;\n        amount = _amount;\n    }\n\n    function getGweiAmount() public view returns (uint, uint) {\n        return (gwei, amount);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example11 {     uint public gwei;     uint public amount;      cons ...\n                                        ^--^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public gwei;\n    bool public isActive;\n\n    constructor() public {\n        gwei = 900;\n        isActive = true;\n    }\n\n    function toggleActive() public {\n        isActive = !isActive;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gwei, isActive);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example12 {     uint public gwei;     bool public isActive;      co ...\n                                        ^--^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public gwei;\n    uint public rate;\n\n    constructor(uint _rate) public {\n        gwei = 600;\n        rate = _rate;\n    }\n\n    function setGweiRate(uint _gwei, uint _rate) public {\n        gwei = _gwei;\n        rate = _rate;\n    }\n\n    function getGweiRate() public view returns (uint, uint) {\n        return (gwei, rate);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example13 {     uint public gwei;     uint public rate;      constr ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public gwei;\n\n    constructor() public {\n        gwei = 350;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGwei() public view returns (uint) {\n        return gwei;\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example14 {     uint public gwei;      constructor() public {       ...\n                                        ^--^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public gwei;\n    address public owner;\n\n    constructor(address _owner) public {\n        gwei = 250;\n        owner = _owner;\n    }\n\n    function setOwnerGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiOwner() public view returns (uint, address) {\n        return (gwei, owner);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example15 {     uint public gwei;     address public owner;      co ...\n                                        ^--^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public gwei;\n    string public description;\n\n    constructor(string memory _description) public {\n        gwei = 700;\n        description = _description;\n    }\n\n    function modifyGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiDescription() public view returns (uint, string memory) {\n        return (gwei, description);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example16 {     uint public gwei;     string public description;    ...\n                                        ^--^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public gwei;\n    bool public status;\n\n    constructor() public {\n        gwei = 80;\n        status = false;\n    }\n\n    function setGweiStatus(uint _gwei, bool _status) public {\n        gwei = _gwei;\n        status = _status;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gwei, status);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example17 {     uint public gwei;     bool public status;      cons ...\n                                        ^--^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public gwei;\n    uint public price;\n\n    constructor(uint _price) public {\n        gwei = 100;\n        price = _price;\n    }\n\n    function setGweiPrice(uint _gwei, uint _price) public {\n        gwei = _gwei;\n        price = _price;\n    }\n\n    function getGweiPrice() public view returns (uint, uint) {\n        return (gwei, price);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example18 {     uint public gwei;     uint public price;      const ...\n                                        ^--^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public gwei;\n    uint public count;\n\n    constructor() public {\n        gwei = 123;\n        count = 0;\n    }\n\n    function incrementCount() public {\n        count++;\n    }\n\n    function setGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiCount() public view returns (uint, uint) {\n        return (gwei, count);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example19 {     uint public gwei;     uint public count;      const ...\n                                        ^--^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public gwei;\n    string public info;\n\n    constructor(string memory _info) public {\n        gwei = 987;\n        info = _info;\n    }\n\n    function updateGweiInfo(uint _gwei, string memory _info) public {\n        gwei = _gwei;\n        info = _info;\n    }\n\n    function getGweiInfo() public view returns (uint, string memory) {\n        return (gwei, info);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example20 {     uint public gwei;     string public info;      cons ...\n                                        ^--^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public gweiValue;\n    uint public amount;\n\n    constructor(uint _amount) public {\n        gweiValue = 450;\n        amount = _amount;\n    }\n\n    function setGweiAmount(uint _gwei, uint _amount) public {\n        gweiValue = _gwei;\n        amount = _amount;\n    }\n\n    function getGweiAmount() public view returns (uint, uint) {\n        return (gweiValue, amount);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public gweiValue;\n    bool public isActive;\n\n    constructor() public {\n        gweiValue = 900;\n        isActive = true;\n    }\n\n    function toggleActive() public {\n        isActive = !isActive;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gweiValue, isActive);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public gweiValue;\n    uint public rate;\n\n    constructor(uint _rate) public {\n        gweiValue = 600;\n        rate = _rate;\n    }\n\n    function setGweiRate(uint _gwei, uint _rate) public {\n        gweiValue = _gwei;\n        rate = _rate;\n    }\n\n    function getGweiRate() public view returns (uint, uint) {\n        return (gweiValue, rate);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public gweiValue;\n\n    constructor() public {\n        gweiValue = 350;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGwei() public view returns (uint) {\n        return gweiValue;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public gweiValue;\n    address public owner;\n\n    constructor(address _owner) public {\n        gweiValue = 250;\n        owner = _owner;\n    }\n\n    function setOwnerGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiOwner() public view returns (uint, address) {\n        return (gweiValue, owner);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public gweiValue;\n    string public description;\n\n    constructor(string memory _description) public {\n        gweiValue = 700;\n        description = _description;\n    }\n\n    function modifyGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiDescription() public view returns (uint, string memory) {\n        return (gweiValue, description);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public gweiValue;\n    bool public status;\n\n    constructor() public {\n        gweiValue = 80;\n        status = false;\n    }\n\n    function setGweiStatus(uint _gwei, bool _status) public {\n        gweiValue = _gwei;\n        status = _status;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gweiValue, status);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public gweiValue;\n    uint public price;\n\n    constructor(uint _price) public {\n        gweiValue = 100;\n        price = _price;\n    }\n\n    function setGweiPrice(uint _gwei, uint _price) public {\n        gweiValue = _gwei;\n        price = _price;\n    }\n\n    function getGweiPrice() public view returns (uint, uint) {\n        return (gweiValue, price);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public gweiValue;\n    uint public count;\n\n    constructor() public {\n        gweiValue = 123;\n        count = 0;\n    }\n\n    function incrementCount() public {\n        count++;\n    }\n\n    function setGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiCount() public view returns (uint, uint) {\n        return (gweiValue, count);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public gweiValue;\n    string public info;\n\n    constructor(string memory _info) public {\n        gweiValue = 987;\n        info = _info;\n    }\n\n    function updateGweiInfo(uint _gwei, string memory _info) public {\n        gweiValue = _gwei;\n        info = _info;\n    }\n\n    function getGweiInfo() public view returns (uint, string memory) {\n        return (gweiValue, info);\n    }\n}"
      }
    }
  },
  {
    "Changes18": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Disallow <code>.</code> in user-defined function and variable names in inline assembly.\nIt is still valid if you use Solidity in Yul-only mode.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint256 public finalOutput;\n\n    function compute() public {\n        uint256 x = 17;\n        uint256 y = 27;\n        uint256 res;\n\n        assembly {\n            function sumValues(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let result.val := sumValues(x, y)\n\n            res := result.val\n        }\n\n        finalOutput = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 123;\n    }\n}",
          "error message": ":1:314: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let result.val := sumValues(x, y)              re ...\n                                        ^--------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint256 public finalResult;\n\n    function calculate() public {\n        uint256 m = 21;\n        uint256 n = 15;\n        uint256 res;\n\n        assembly {\n            function sumNumbers(a, b) -> totalSum {\n                totalSum := add(a, b)\n            }\n\n            let total.result := sumNumbers(m, n)\n\n            res := total.result\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:323: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let total.result := sumNumbers(m, n)              r ...\n                                        ^----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint256 public output;\n\n    function execute() public {\n        uint256 p = 19;\n        uint256 q = 23;\n        uint256 res;\n\n        assembly {\n            function addValues(c, d) -> sum {\n                sum := add(c, d)\n            }\n\n            let var.sum := addValues(p, q)\n\n            res := var.sum\n        }\n\n        output = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Test\";\n    }\n\n    function unrelatedFunction2() public pure returns (uint256) {\n        return 456;\n    }\n}",
          "error message": ":1:305: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  d)             }              let var.sum := addValues(p, q)              re ...\n                                        ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint256 public resultValue;\n\n    function computeResult() public {\n        uint256 w = 11;\n        uint256 z = 18;\n        uint256 res;\n\n        assembly {\n            function calculateSum(e, f) -> finalSum {\n                finalSum := add(e, f)\n            }\n\n            let res.total := calculateSum(w, z)\n\n            res := res.total\n        }\n\n        resultValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}",
          "error message": ":1:329: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  f)             }              let res.total := calculateSum(w, z)              ...\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint256 public finalOutcome;\n\n    function perform() public {\n        uint256 a = 14;\n        uint256 b = 16;\n        uint256 res;\n\n        assembly {\n            function computeTotal(x, y) -> totalSum {\n                totalSum := add(x, y)\n            }\n\n            let total.value := computeTotal(a, b)\n\n            res := total.value\n        }\n\n        finalOutcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 789;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:324: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  y)             }              let total.value := computeTotal(a, b)              ...\n                                        ^---------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint256 public result;\n\n    function calculate() public {\n        uint256 x = 13;\n        uint256 y = 14;\n        uint256 res;\n\n        assembly {\n            function addNumbers(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let calc.sum := addNumbers(x, y)\n\n            res := calc.sum\n        }\n\n        result = res;\n    }\n}",
          "error message": ":1:308: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let calc.sum := addNumbers(x, y)              r ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint256 public finalValue;\n\n    function runCalculation() public {\n        uint256 p = 10;\n        uint256 q = 30;\n        uint256 res;\n\n        assembly {\n            function getTotal(m, n) -> totalSum {\n                totalSum := add(m, n)\n            }\n\n            let sum.result := getTotal(p, q)\n\n            res := sum.result\n        }\n\n        finalValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
          "error message": ":1:325: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  n)             }              let sum.result := getTotal(p, q)              res ...\n                                        ^--------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint256 public outputValue;\n\n    function executeCalculation() public {\n        uint256 g = 12;\n        uint256 h = 24;\n        uint256 res;\n\n        assembly {\n            function findSum(i, j) -> sumResult {\n                sumResult := add(i, j)\n            }\n\n            let result.sum := findSum(g, h)\n\n            res := result.sum\n        }\n\n        outputValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 111;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:331: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  j)             }              let result.sum := findSum(g, h)              res  ...\n                                        ^--------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint256 public outcome;\n\n    function performCalculation() public {\n        uint256 w = 25;\n        uint256 z = 5;\n        uint256 res;\n\n        assembly {\n            function computeSum(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let total.result := computeSum(w, z)\n\n            res := total.result\n        }\n\n        outcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:321: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let total.result := computeSum(w, z)              r ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint256 public finalResult;\n\n    function calculateTotal() public {\n        uint256 x = 8;\n        uint256 y = 22;\n        uint256 res;\n\n        assembly {\n            function calculate(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let result.sum := calculate(x, y)\n\n            res := result.sum\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 888;\n    }\n\n    function unrelatedFunction2() public pure returns (string memory) {\n        return \"World\";\n    }\n}",
          "error message": ":1:316: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let result.sum := calculate(x, y)              re ...\n                                        ^--------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint256 public finalOutput;\n\n    function compute() public {\n        uint256 x = 17;\n        uint256 y = 27;\n        uint256 res;\n\n        assembly {\n            function sumValues(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let resultVal := sumValues(x, y)\n\n            res := resultVal\n        }\n\n        finalOutput = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 123;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint256 public finalResult;\n\n    function calculate() public {\n        uint256 m = 21;\n        uint256 n = 15;\n        uint256 res;\n\n        assembly {\n            function sumNumbers(a, b) -> totalSum {\n                totalSum := add(a, b)\n            }\n\n            let totalResult := sumNumbers(m, n)\n\n            res := totalResult\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint256 public output;\n\n    function execute() public {\n        uint256 p = 19;\n        uint256 q = 23;\n        uint256 res;\n\n        assembly {\n            function addValues(c, d) -> sum {\n                sum := add(c, d)\n            }\n\n            let varSum := addValues(p, q)\n\n            res := varSum\n        }\n\n        output = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Test\";\n    }\n\n    function unrelatedFunction2() public pure returns (uint256) {\n        return 456;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint256 public resultValue;\n\n    function computeResult() public {\n        uint256 w = 11;\n        uint256 z = 18;\n        uint256 res;\n\n        assembly {\n            function calculateSum(e, f) -> finalSum {\n                finalSum := add(e, f)\n            }\n\n            let resTotal := calculateSum(w, z)\n\n            res := resTotal\n        }\n\n        resultValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint256 public finalOutcome;\n\n    function perform() public {\n        uint256 a = 14;\n        uint256 b = 16;\n        uint256 res;\n\n        assembly {\n            function computeTotal(x, y) -> totalSum {\n                totalSum := add(x, y)\n            }\n\n            let totalValue := computeTotal(a, b)\n\n            res := totalValue\n        }\n\n        finalOutcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 789;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint256 public result;\n\n    function calculate() public {\n        uint256 x = 13;\n        uint256 y = 14;\n        uint256 res;\n\n        assembly {\n            function addNumbers(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let calcSum := addNumbers(x, y)\n\n            res := calcSum\n        }\n\n        result = res;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint256 public finalValue;\n\n    function runCalculation() public {\n        uint256 p = 10;\n        uint256 q = 30;\n        uint256 res;\n\n        assembly {\n            function getTotal(m, n) -> totalSum {\n                totalSum := add(m, n)\n            }\n\n            let sumResult := getTotal(p, q)\n\n            res := sumResult\n        }\n\n        finalValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint256 public outputValue;\n\n    function executeCalculation() public {\n        uint256 g = 12;\n        uint256 h = 24;\n        uint256 res;\n\n        assembly {\n            function findSum(i, j) -> sumResult {\n                sumResult := add(i, j)\n            }\n\n            let resultSum := findSum(g, h)\n\n            res := resultSum\n        }\n\n        outputValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 111;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint256 public outcome;\n\n    function performCalculation() public {\n        uint256 w = 25;\n        uint256 z = 5;\n        uint256 res;\n\n        assembly {\n            function computeSum(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let totalResult := computeSum(w, z)\n\n            res := totalResult\n        }\n\n        outcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint256 public finalResult;\n\n    function calculateTotal() public {\n        uint256 x = 8;\n        uint256 y = 22;\n        uint256 res;\n\n        assembly {\n            function calculate(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let resultSum := calculate(x, y)\n\n            res := resultSum\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 888;\n    }\n\n    function unrelatedFunction2() public pure returns (string memory) {\n        return \"World\";\n    }\n}"
      }
    }
  },
  {
    "Changes19": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Slot and offset of storage pointer variable <code>x</code> are accessed via <code>x.slot</code>\nand <code>x.offset</code> instead of <code>x_slot</code> and <code>x_offset</code>.Change <code>_slot</code> and <code>_offset</code> suffixes in inline assembly to <code>.slot</code> and <code>.offset</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Customer {\n        uint id;\n    }\n\n    Customer public customer;\n\n    constructor() public {\n        customer.id = 123;\n    }\n\n    function getCustomerPointer() public view returns (uint slot, uint offset) {\n        uint customerSlot;\n        uint customerOffset;\n        assembly {\n            customerSlot := customer_slot\n            customerOffset := customer_offset\n        }\n        return (customerSlot, customerOffset);\n    }\n}",
          "error message": ":1:368: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... mbly {             customerSlot := customer_slot             customerOffset := cust ...\n                                        ^-----------^\n:1:412: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... slot             customerOffset := customer_offset         }         return (customer ...\n                                        ^-------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Ticket {\n        uint number;\n    }\n\n    Ticket public ticket;\n\n    constructor() public {\n        ticket.number = 456;\n    }\n\n    function fetchTicketPointer() public view returns (uint slot, uint offset) {\n        uint ticketSlot;\n        uint ticketOffset;\n        assembly {\n            ticketSlot := ticket_slot\n            ticketOffset := ticket_offset\n        }\n        return (ticketSlot, ticketOffset);\n    }\n}",
          "error message": ":1:362: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             ticketSlot := ticket_slot             ticketOffset := ticket ...\n                                        ^---------^\n:1:402: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... t_slot             ticketOffset := ticket_offset         }         return (ticketSl ...\n                                        ^-----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Box {\n        uint size;\n    }\n\n    Box public box;\n\n    constructor() public {\n        box.size = 789;\n    }\n\n    function retrieveBoxPointer() public view returns (uint slot, uint offset) {\n        uint boxSlot;\n        uint boxOffset;\n        assembly {\n            boxSlot := box_slot\n            boxOffset := box_offset\n        }\n        return (boxSlot, boxOffset);\n    }\n\n    function dummyFunctionOne() public pure returns (uint) {\n        return 1;\n    }\n}",
          "error message": ":1:337: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  assembly {             boxSlot := box_slot             boxOffset := box_offse ...\n                                        ^------^\n:1:371: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  box_slot             boxOffset := box_offset         }         return (boxSlot, ...\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Car {\n        uint speed;\n    }\n\n    Car public car;\n\n    constructor() public {\n        car.speed = 200;\n    }\n\n    function getCarPointer() public view returns (uint slot, uint offset) {\n        uint carSlot;\n        uint carOffset;\n        assembly {\n            carSlot := car_slot\n            carOffset := car_offset\n        }\n        return (carSlot, carOffset);\n    }\n}",
          "error message": ":1:334: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  assembly {             carSlot := car_slot             carOffset := car_offse ...\n                                        ^------^\n:1:368: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  car_slot             carOffset := car_offset         }         return (carSlot, ...\n                                        ^--------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Book {\n        uint pages;\n    }\n\n    Book public book;\n\n    constructor() public {\n        book.pages = 300;\n    }\n\n    function fetchBookPointer() public view returns (uint slot, uint offset) {\n        uint bookSlot;\n        uint bookOffset;\n        assembly {\n            bookSlot := book_slot\n            bookOffset := book_offset\n        }\n        return (bookSlot, bookOffset);\n    }\n\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 2;\n    }\n\n    function extraDummyFunctionTwo() public pure returns (uint) {\n        return 3;\n    }\n}",
          "error message": ":1:344: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             bookSlot := book_slot             bookOffset := book_off ...\n                                        ^-------^\n:1:380: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ook_slot             bookOffset := book_offset         }         return (bookSlot ...\n                                        ^---------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Movie {\n        uint duration;\n    }\n\n    Movie public movie;\n\n    constructor() public {\n        movie.duration = 120;\n    }\n\n    function getMoviePointer() public view returns (uint slot, uint offset) {\n        uint movieSlot;\n        uint movieOffset;\n        assembly {\n            movieSlot := movie_slot\n            movieOffset := movie_offset\n        }\n        return (movieSlot, movieOffset);\n    }\n}",
          "error message": ":1:356: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             movieSlot := movie_slot             movieOffset := movie_o ...\n                                        ^--------^\n:1:394: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ie_slot             movieOffset := movie_offset         }         return (movieSlo ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Laptop {\n        uint ram;\n    }\n\n    Laptop public laptop;\n\n    constructor() public {\n        laptop.ram = 16;\n    }\n\n    function retrieveLaptopPointer() public view returns (uint slot, uint offset) {\n        uint laptopSlot;\n        uint laptopOffset;\n        assembly {\n            laptopSlot := laptop_slot\n            laptopOffset := laptop_offset\n        }\n        return (laptopSlot, laptopOffset);\n    }\n}",
          "error message": ":1:358: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             laptopSlot := laptop_slot             laptopOffset := laptop ...\n                                        ^---------^\n:1:398: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... p_slot             laptopOffset := laptop_offset         }         return (laptopSl ...\n                                        ^-----------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Phone {\n        uint storage;\n    }\n\n    Phone public phone;\n\n    constructor() public {\n        phone.storage = 64;\n    }\n\n    function getPhonePointer() public view returns (uint slot, uint offset) {\n        uint phoneSlot;\n        uint phoneOffset;\n        assembly {\n            phoneSlot := phone_slot\n            phoneOffset := phone_offset\n        }\n        return (phoneSlot, phoneOffset);\n    }\n}",
          "error message": ":1:78: ParserError: Expected identifier but got 'storage'\n ...  {     struct Phone {         uint storage;     }      Phone public phone;    ...\n                                        ^-----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Chair {\n        uint legs;\n    }\n\n    Chair public chair;\n\n    constructor() public {\n        chair.legs = 4;\n    }\n\n    function fetchChairPointer() public view returns (uint slot, uint offset) {\n        uint chairSlot;\n        uint chairOffset;\n        assembly {\n            chairSlot := chair_slot\n            chairOffset := chair_offset\n        }\n        return (chairSlot, chairOffset);\n    }\n\n    function extraFunctionOne() public pure returns (string memory) {\n        return \"extra1\";\n    }\n}",
          "error message": ":1:348: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             chairSlot := chair_slot             chairOffset := chair_o ...\n                                        ^--------^\n:1:386: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ir_slot             chairOffset := chair_offset         }         return (chairSlo ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct House {\n        uint rooms;\n    }\n\n    House public house;\n\n    constructor() public {\n        house.rooms = 5;\n    }\n\n    function retrieveHousePointer() public view returns (uint slot, uint offset) {\n        uint houseSlot;\n        uint houseOffset;\n        assembly {\n            houseSlot := house_slot\n            houseOffset := house_offset\n        }\n        return (houseSlot, houseOffset);\n    }\n\n    function extraFunctionTwo() public pure returns (string memory) {\n        return \"extra2\";\n    }\n}",
          "error message": ":1:353: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             houseSlot := house_slot             houseOffset := house_o ...\n                                        ^--------^\n:1:391: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... se_slot             houseOffset := house_offset         }         return (houseSlo ...\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Customer {\n        uint id;\n    }\n\n    Customer public customer;\n\n    constructor() public {\n        customer.id = 123;\n    }\n\n    function getCustomerPointer() public view returns (uint slot, uint offset) {\n        uint customerSlot;\n        uint customerOffset;\n        assembly {\n            customerSlot := customer.slot\n            customerOffset := customer.offset\n        }\n        return (customerSlot, customerOffset);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Ticket {\n        uint number;\n    }\n\n    Ticket public ticket;\n\n    constructor() public {\n        ticket.number = 456;\n    }\n\n    function fetchTicketPointer() public view returns (uint slot, uint offset) {\n        uint ticketSlot;\n        uint ticketOffset;\n        assembly {\n            ticketSlot := ticket.slot\n            ticketOffset := ticket.offset\n        }\n        return (ticketSlot, ticketOffset);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Box {\n        uint size;\n    }\n\n    Box public box;\n\n    constructor() public {\n        box.size = 789;\n    }\n\n    function retrieveBoxPointer() public view returns (uint slot, uint offset) {\n        uint boxSlot;\n        uint boxOffset;\n        assembly {\n            boxSlot := box.slot\n            boxOffset := box.offset\n        }\n        return (boxSlot, boxOffset);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Car {\n        uint speed;\n    }\n\n    Car public car;\n\n    constructor() public {\n        car.speed = 200;\n    }\n\n    function getCarPointer() public view returns (uint slot, uint offset) {\n        uint carSlot;\n        uint carOffset;\n        assembly {\n            carSlot := car.slot\n            carOffset := car.offset\n        }\n        return (carSlot, carOffset);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Book {\n        uint pages;\n    }\n\n    Book public book;\n\n    constructor() public {\n        book.pages = 300;\n    }\n\n    function fetchBookPointer() public view returns (uint slot, uint offset) {\n        uint bookSlot;\n        uint bookOffset;\n        assembly {\n            bookSlot := book.slot\n            bookOffset := book.offset\n        }\n        return (bookSlot, bookOffset);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Movie {\n        uint duration;\n    }\n\n    Movie public movie;\n\n    constructor() public {\n        movie.duration = 120;\n    }\n\n    function getMoviePointer() public view returns (uint slot, uint offset) {\n        uint movieSlot;\n        uint movieOffset;\n        assembly {\n            movieSlot := movie.slot\n            movieOffset := movie.offset\n        }\n        return (movieSlot, movieOffset);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Laptop {\n        uint ram;\n    }\n\n    Laptop public laptop;\n\n    constructor() public {\n        laptop.ram = 16;\n    }\n\n    function retrieveLaptopPointer() public view returns (uint slot, uint offset) {\n        uint laptopSlot;\n        uint laptopOffset;\n        assembly {\n            laptopSlot := laptop.slot\n            laptopOffset := laptop.offset\n        }\n        return (laptopSlot, laptopOffset);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Phone {\n        uint storage;\n    }\n\n    Phone public phone;\n\n    constructor() public {\n        phone.storage = 64;\n    }\n\n    function getPhonePointer() public view returns (uint slot, uint offset) {\n        uint phoneSlot;\n        uint phoneOffset;\n        assembly {\n            phoneSlot := phone.slot\n            phoneOffset := phone.offset\n        }\n        return (phoneSlot, phoneOffset);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Chair {\n        uint legs;\n    }\n\n    Chair public chair;\n\n    constructor() public {\n        chair.legs = 4;\n    }\n\n    function fetchChairPointer() public view returns (uint slot, uint offset) {\n        uint chairSlot;\n        uint chairOffset;\n        assembly {\n            chairSlot := chair.slot\n            chairOffset := chair.offset\n        }\n        return (chairSlot, chairOffset);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct House {\n        uint rooms;\n    }\n\n    House public house;\n\n    constructor() public {\n        house.rooms = 5;\n    }\n\n    function retrieveHousePointer() public view returns (uint slot, uint offset) {\n        uint houseSlot;\n        uint houseOffset;\n        assembly {\n            houseSlot := house.slot\n            houseOffset := house.offset\n        }\n        return (houseSlot, houseOffset);\n    }\n}"
      }
    }
  },
  {
    "Changes20": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "If a struct or array contains a mapping, it can only be used in storage.\nPreviously, mapping members were silently skipped in memory, which\nis confusing and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct11 {\n    struct ExampleStruct {\n        uint256 data;\n        mapping(address => uint256) balances;\n    }\n    \n    ExampleStruct[] public examples;\n\n    function createStruct(uint256 _data) public {\n        ExampleStruct memory newExample;\n        newExample.data = _data;\n        examples.push(newExample);\n    }\n\n    function setBalance(uint256 index, address user, uint256 amount) public {\n        examples[index].balances[user] = amount;\n    }\n\n    function getBalance(uint256 index, address user) public view returns (uint256) {\n        return examples[index].balances[user];\n    }\n\n    function dummyFuncA() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:256: TypeError: Type struct MappingInStruct11.ExampleStruct is only valid in storage because it contains a (nested) mapping.\n ... ct(uint256 _data) public {         ExampleStruct memory newExample;         newExample.data = _data;  ...\n                                        ^-----------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct12 {\n    struct InfoStruct {\n        uint256 id;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _id) public {\n        InfoStruct memory newInfo;\n        newInfo.id = _id;\n        infos.push(newInfo);\n    }\n\n    function updateHoldings(uint256 index, address user, uint256 value) public {\n        infos[index].holdings[user] = value;\n    }\n\n    function fetchHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n\n    function dummyFuncB() public pure returns (string memory) {\n        return \"DummyB\";\n    }\n\n    function dummyFuncC() public pure returns (uint256) {\n        return 256;\n    }\n}",
          "error message": ":1:238: TypeError: Type struct MappingInStruct12.InfoStruct is only valid in storage because it contains a (nested) mapping.\n ... Info(uint256 _id) public {         InfoStruct memory newInfo;         newInfo.id = _id;         ...\n                                        ^-----------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct13 {\n    struct RecordStruct {\n        uint256 identifier;\n        mapping(address => uint256) funds;\n    }\n    \n    RecordStruct[] public records;\n\n    function addRecord(uint256 _identifier) public {\n        RecordStruct memory newRecord;\n        newRecord.identifier = _identifier;\n        records.push(newRecord);\n    }\n\n    function modifyFunds(uint256 index, address user, uint256 amount) public {\n        records[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return records[index].funds[user];\n    }\n}",
          "error message": ":1:259: TypeError: Type struct MappingInStruct13.RecordStruct is only valid in storage because it contains a (nested) mapping.\n ... t256 _identifier) public {         RecordStruct memory newRecord;         newRecord.identifier = _i ...\n                                        ^---------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct14 {\n    struct AssetStruct {\n        uint256 assetId;\n        mapping(address => uint256) userBalances;\n    }\n    \n    AssetStruct[] public assets;\n\n    function registerAsset(uint256 _assetId) public {\n        AssetStruct memory newAsset;\n        newAsset.assetId = _assetId;\n        assets.push(newAsset);\n    }\n\n    function setAssetBalance(uint256 index, address user, uint256 amount) public {\n        assets[index].userBalances[user] = amount;\n    }\n\n    function getAssetBalance(uint256 index, address user) public view returns (uint256) {\n        return assets[index].userBalances[user];\n    }\n\n    function dummyFuncD() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:261: TypeError: Type struct MappingInStruct14.AssetStruct is only valid in storage because it contains a (nested) mapping.\n ... uint256 _assetId) public {         AssetStruct memory newAsset;         newAsset.assetId = _asset ...\n                                        ^-------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct15 {\n    struct ExampleData {\n        uint256 key;\n        mapping(address => uint256) accounts;\n    }\n    \n    ExampleData[] public dataCollection;\n\n    function addExample(uint256 _key) public {\n        ExampleData memory newExample;\n        newExample.key = _key;\n        dataCollection.push(newExample);\n    }\n\n    function setAccount(uint256 index, address user, uint256 value) public {\n        dataCollection[index].accounts[user] = value;\n    }\n\n    function getAccount(uint256 index, address user) public view returns (uint256) {\n        return dataCollection[index].accounts[user];\n    }\n\n    function dummyFuncE() public pure returns (uint256) {\n        return 1000;\n    }\n}",
          "error message": ":1:254: TypeError: Type struct MappingInStruct15.ExampleData is only valid in storage because it contains a (nested) mapping.\n ... ple(uint256 _key) public {         ExampleData memory newExample;         newExample.key = _key;    ...\n                                        ^---------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct16 {\n    struct CustomStruct {\n        uint256 id;\n        mapping(address => uint256) balances;\n    }\n    \n    CustomStruct[] public customStructs;\n\n    function createCustomStruct(uint256 _id) public {\n        CustomStruct memory newStruct;\n        newStruct.id = _id;\n        customStructs.push(newStruct);\n    }\n\n    function updateBalance(uint256 index, address user, uint256 amount) public {\n        customStructs[index].balances[user] = amount;\n    }\n\n    function viewBalance(uint256 index, address user) public view returns (uint256) {\n        return customStructs[index].balances[user];\n    }\n}",
          "error message": ":1:261: TypeError: Type struct MappingInStruct16.CustomStruct is only valid in storage because it contains a (nested) mapping.\n ... ruct(uint256 _id) public {         CustomStruct memory newStruct;         newStruct.id = _id;       ...\n                                        ^---------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct17 {\n    struct HolderStruct {\n        uint256 value;\n        mapping(address => uint256) funds;\n    }\n    \n    HolderStruct[] public holders;\n\n    function addHolder(uint256 _value) public {\n        HolderStruct memory newHolder;\n        newHolder.value = _value;\n        holders.push(newHolder);\n    }\n\n    function changeFunds(uint256 index, address user, uint256 amount) public {\n        holders[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return holders[index].funds[user];\n    }\n\n    function dummyFuncF() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:249: TypeError: Type struct MappingInStruct17.HolderStruct is only valid in storage because it contains a (nested) mapping.\n ... r(uint256 _value) public {         HolderStruct memory newHolder;         newHolder.value = _value; ...\n                                        ^---------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct18 {\n    struct DataStruct {\n        uint256 number;\n        mapping(address => uint256) userBalances;\n    }\n    \n    DataStruct[] public dataEntries;\n\n    function addData(uint256 _number) public {\n        DataStruct memory newData;\n        newData.number = _number;\n        dataEntries.push(newData);\n    }\n\n    function setUserBalance(uint256 index, address user, uint256 value) public {\n        dataEntries[index].userBalances[user] = value;\n    }\n\n    function getUserBalance(uint256 index, address user) public view returns (uint256) {\n        return dataEntries[index].userBalances[user];\n    }\n}",
          "error message": ":1:256: TypeError: Type struct MappingInStruct18.DataStruct is only valid in storage because it contains a (nested) mapping.\n ... (uint256 _number) public {         DataStruct memory newData;         newData.number = _number; ...\n                                        ^-----------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct19 {\n    struct ItemStruct {\n        uint256 id;\n        mapping(address => uint256) allocations;\n    }\n    \n    ItemStruct[] public items;\n\n    function createItem(uint256 _id) public {\n        ItemStruct memory newItem;\n        newItem.id = _id;\n        items.push(newItem);\n    }\n\n    function updateAllocation(uint256 index, address user, uint256 amount) public {\n        items[index].allocations[user] = amount;\n    }\n\n    function getAllocation(uint256 index, address user) public view returns (uint256) {\n        return items[index].allocations[user];\n    }\n\n    function dummyFuncG() public pure returns (uint256) {\n        return 99;\n    }\n}",
          "error message": ":1:244: TypeError: Type struct MappingInStruct19.ItemStruct is only valid in storage because it contains a (nested) mapping.\n ... Item(uint256 _id) public {         ItemStruct memory newItem;         newItem.id = _id;         ...\n                                        ^-----------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct20 {\n    struct InfoStruct {\n        uint256 value;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _value) public {\n        InfoStruct memory newInfo;\n        newInfo.value = _value;\n        infos.push(newInfo);\n    }\n\n    function setHoldings(uint256 index, address user, uint256 amount) public {\n        infos[index].holdings[user] = amount;\n    }\n\n    function getHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n\n    function dummyFuncH() public pure returns (bool) {\n        return true;\n    }\n\n    function dummyFuncI() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
          "error message": ":1:244: TypeError: Type struct MappingInStruct20.InfoStruct is only valid in storage because it contains a (nested) mapping.\n ... o(uint256 _value) public {         InfoStruct memory newInfo;         newInfo.value = _value;   ...\n                                        ^-----------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct11 {\n    struct ExampleStruct {\n        uint256 data;\n        mapping(address => uint256) balances;\n    }\n    \n    ExampleStruct[] public examples;\n\n    function createStruct(uint256 _data) public {\n        ExampleStruct storage newExample = examples.push();\n        newExample.data = _data;\n    }\n\n    function setBalance(uint256 index, address user, uint256 amount) public {\n        examples[index].balances[user] = amount;\n    }\n\n    function getBalance(uint256 index, address user) public view returns (uint256) {\n        return examples[index].balances[user];\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct12 {\n    struct InfoStruct {\n        uint256 id;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _id) public {\n        InfoStruct storage newInfo = infos.push();\n        newInfo.id = _id;\n    }\n\n    function updateHoldings(uint256 index, address user, uint256 value) public {\n        infos[index].holdings[user] = value;\n    }\n\n    function fetchHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct13 {\n    struct RecordStruct {\n        uint256 identifier;\n        mapping(address => uint256) funds;\n    }\n    \n    RecordStruct[] public records;\n\n    function addRecord(uint256 _identifier) public {\n        RecordStruct storage newRecord = records.push();\n        newRecord.identifier = _identifier;\n    }\n\n    function modifyFunds(uint256 index, address user, uint256 amount) public {\n        records[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return records[index].funds[user];\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct14 {\n    struct AssetStruct {\n        uint256 assetId;\n        mapping(address => uint256) userBalances;\n    }\n    \n    AssetStruct[] public assets;\n\n    function registerAsset(uint256 _assetId) public {\n        AssetStruct storage newAsset = assets.push();\n        newAsset.assetId = _assetId;\n    }\n\n    function setAssetBalance(uint256 index, address user, uint256 amount) public {\n        assets[index].userBalances[user] = amount;\n    }\n\n    function getAssetBalance(uint256 index, address user) public view returns (uint256) {\n        return assets[index].userBalances[user];\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct15 {\n    struct ExampleData {\n        uint256 key;\n        mapping(address => uint256) accounts;\n    }\n    \n    ExampleData[] public dataCollection;\n\n    function addExample(uint256 _key) public {\n        ExampleData storage newExample = dataCollection.push();\n        newExample.key = _key;\n    }\n\n    function setAccount(uint256 index, address user, uint256 value) public {\n        dataCollection[index].accounts[user] = value;\n    }\n\n    function getAccount(uint256 index, address user) public view returns (uint256) {\n        return dataCollection[index].accounts[user];\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct16 {\n    struct CustomStruct {\n        uint256 id;\n        mapping(address => uint256) balances;\n    }\n    \n    CustomStruct[] public customStructs;\n\n    function createCustomStruct(uint256 _id) public {\n        CustomStruct storage newStruct = customStructs.push();\n        newStruct.id = _id;\n    }\n\n    function updateBalance(uint256 index, address user, uint256 amount) public {\n        customStructs[index].balances[user] = amount;\n    }\n\n    function viewBalance(uint256 index, address user) public view returns (uint256) {\n        return customStructs[index].balances[user];\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct17 {\n    struct HolderStruct {\n        uint256 value;\n        mapping(address => uint256) funds;\n    }\n    \n    HolderStruct[] public holders;\n\n    function addHolder(uint256 _value) public {\n        HolderStruct storage newHolder = holders.push();\n        newHolder.value = _value;\n    }\n\n    function changeFunds(uint256 index, address user, uint256 amount) public {\n        holders[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return holders[index].funds[user];\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct18 {\n    struct DataStruct {\n        uint256 number;\n        mapping(address => uint256) userBalances;\n    }\n    \n    DataStruct[] public dataEntries;\n\n    function addData(uint256 _number) public {\n        DataStruct storage newData = dataEntries.push();\n        newData.number = _number;\n    }\n\n    function setUserBalance(uint256 index, address user, uint256 value) public {\n        dataEntries[index].userBalances[user] = value;\n    }\n\n    function getUserBalance(uint256 index, address user) public view returns (uint256) {\n        return dataEntries[index].userBalances[user];\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct19 {\n    struct ItemStruct {\n        uint256 id;\n        mapping(address => uint256) allocations;\n    }\n    \n    ItemStruct[] public items;\n\n    function createItem(uint256 _id) public {\n        ItemStruct storage newItem = items.push();\n        newItem.id = _id;\n    }\n\n    function updateAllocation(uint256 index, address user, uint256 amount) public {\n        items[index].allocations[user] = amount;\n    }\n\n    function getAllocation(uint256 index, address user) public view returns (uint256) {\n        return items[index].allocations[user];\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct20 {\n    struct InfoStruct {\n        uint256 value;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _value) public {\n        InfoStruct storage newInfo = infos.push();\n        newInfo.value = _value;\n    }\n\n    function setHoldings(uint256 index, address user, uint256 amount) public {\n        infos[index].holdings[user] = amount;\n    }\n\n    function getHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n}"
      }
    }
  },
  {
    "Changes21": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Assignments to structs or arrays in storage does not work if they contain\nmappings.\nPreviously, mappings were silently skipped during the copy operation, which\nis misleading and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Dataset {\n        mapping(address => uint) data;\n        uint total;\n    }\n\n    Dataset dataset1;\n    Dataset dataset2;\n\n    function addData(address _addr, uint _value) public {\n        dataset1.data[_addr] = _value;\n        dataset1.total += _value;\n    }\n\n    function cloneDataset() public {\n        dataset2 = dataset1;\n    }\n\n    function getTotal() public view returns (uint) {\n        return dataset2.total;\n    }\n}",
          "error message": ":1:361: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on cloneDataset() public {         dataset2 = dataset1;     }      function ge ...\n                                        ^------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Holder {\n        mapping(address => uint) items;\n        uint itemCount;\n    }\n\n    Holder holder1;\n    Holder holder2;\n\n    function addItem(address _addr, uint _item) public {\n        holder1.items[_addr] = _item;\n        holder1.itemCount += _item;\n    }\n\n    function duplicateHolder() public {\n        holder2 = holder1;\n    }\n\n    function getItemCount() public view returns (uint) {\n        return holder2.itemCount;\n    }\n\n    function anotherFunc() public pure returns (string memory) {\n        return \"Another\";\n    }\n}",
          "error message": ":1:364: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... duplicateHolder() public {         holder2 = holder1;     }      function get ...\n                                        ^-----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint entryCount;\n    }\n\n    Log log1;\n    Log log2;\n\n    function addEntry(address _addr, uint _entry) public {\n        log1.entries[_addr] = _entry;\n        log1.entryCount += _entry;\n    }\n\n    function copyLog() public {\n        log2 = log1;\n    }\n\n    function getEntryCount() public view returns (uint) {\n        return log2.entryCount;\n    }\n\n    function extraFunc() public pure returns (bool) {\n        return true;\n    }\n\n    function yetAnotherFunc() public pure returns (uint) {\n        return 101;\n    }\n}",
          "error message": ":1:345: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... unction copyLog() public {         log2 = log1;     }      function getEnt ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Table {\n        mapping(address => uint) values;\n        uint valueCount;\n    }\n\n    Table table1;\n    Table table2;\n\n    function setValue(address _addr, uint _value) public {\n        table1.values[_addr] = _value;\n        table1.valueCount += _value;\n    }\n\n    function cloneTable() public {\n        table2 = table1;\n    }\n\n    function getValueCount() public view returns (uint) {\n        return table2.valueCount;\n    }\n}",
          "error message": ":1:360: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... tion cloneTable() public {         table2 = table1;     }      function getV ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Registry {\n        mapping(address => uint) records;\n        uint recordTotal;\n    }\n\n    Registry registry1;\n    Registry registry2;\n\n    function addRecord(address _addr, uint _record) public {\n        registry1.records[_addr] = _record;\n        registry1.recordTotal += _record;\n    }\n\n    function copyRegistry() public {\n        registry2 = registry1;\n    }\n\n    function getRecordTotal() public view returns (uint) {\n        return registry2.recordTotal;\n    }\n\n    function func1() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:391: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on copyRegistry() public {         registry2 = registry1;     }      function g ...\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Database {\n        mapping(address => uint) entries;\n        uint entrySum;\n    }\n\n    Database db1;\n    Database db2;\n\n    function addEntry(address _addr, uint _entry) public {\n        db1.entries[_addr] = _entry;\n        db1.entrySum += _entry;\n    }\n\n    function replicateDatabase() public {\n        db2 = db1;\n    }\n\n    function getEntrySum() public view returns (uint) {\n        return db2.entrySum;\n    }\n}",
          "error message": ":1:362: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... plicateDatabase() public {         db2 = db1;     }      function getEntr ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Storage {\n        mapping(address => uint) tokens;\n        uint tokenTotal;\n    }\n\n    Storage storage1;\n    Storage storage2;\n\n    function addToken(address _addr, uint _token) public {\n        storage1.tokens[_addr] = _token;\n        storage1.tokenTotal += _token;\n    }\n\n    function copyStorage() public {\n        storage2 = storage1;\n    }\n\n    function getTokenTotal() public view returns (uint) {\n        return storage2.tokenTotal;\n    }\n\n    function dummy() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": ":1:375: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... ion copyStorage() public {         storage2 = storage1;     }      function ge ...\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Archive {\n        mapping(address => uint) files;\n        uint fileCount;\n    }\n\n    Archive archive1;\n    Archive archive2;\n\n    function addFile(address _addr, uint _file) public {\n        archive1.files[_addr] = _file;\n        archive1.fileCount += _file;\n    }\n\n    function cloneArchive() public {\n        archive2 = archive1;\n    }\n\n    function getFileCount() public view returns (uint) {\n        return archive2.fileCount;\n    }\n}",
          "error message": ":1:368: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on cloneArchive() public {         archive2 = archive1;     }      function ge ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Network {\n        mapping(address => uint) nodes;\n        uint nodeCount;\n    }\n\n    Network network1;\n    Network network2;\n\n    function addNode(address _addr, uint _node) public {\n        network1.nodes[_addr] = _node;\n        network1.nodeCount += _node;\n    }\n\n    function duplicateNetwork() public {\n        network2 = network1;\n    }\n\n    function getNodeCount() public view returns (uint) {\n        return network2.nodeCount;\n    }\n\n    function dummyFunc() public pure returns (string memory) {\n        return \"Node\";\n    }\n\n    function anotherDummyFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:372: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... uplicateNetwork() public {         network2 = network1;     }      function ge ...\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Cache {\n        mapping(address => uint) items;\n        uint itemTotal;\n    }\n\n    Cache cache1;\n    Cache cache2;\n\n    function addItem(address _addr, uint _item) public {\n        cache1.items[_addr] = _item;\n        cache1.itemTotal += _item;\n    }\n\n    function replicateCache() public {\n        cache2 = cache1;\n    }\n\n    function getItemTotal() public view returns (uint) {\n        return cache2.itemTotal;\n    }\n}",
          "error message": ":1:356: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ...  replicateCache() public {         cache2 = cache1;     }      function getI ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Dataset {\n        mapping(address => uint) data;\n        uint total;\n    }\n    Dataset dataset1;\n    Dataset dataset2;\n    function addData(address _addr, uint _value) public {\n        dataset1.data[_addr] = _value;\n        dataset1.total += _value;\n    }\n    function cloneDataset() public {\n        dataset2.total = dataset1.total;\n    }\n    function getTotal() public view returns (uint) {\n        return dataset2.total;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Holder {\n        mapping(address => uint) items;\n        uint itemCount;\n    }\n    Holder holder1;\n    Holder holder2;\n    function addItem(address _addr, uint _item) public {\n        holder1.items[_addr] = _item;\n        holder1.itemCount += _item;\n    }\n    function duplicateHolder() public {\n        holder2.itemCount = holder1.itemCount;\n    }\n    function getItemCount() public view returns (uint) {\n        return holder2.itemCount;\n    }\n    function anotherFunc() public pure returns (string memory) {\n        return \"Another\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint entryCount;\n    }\n    Log log1;\n    Log log2;\n    function addEntry(address _addr, uint _entry) public {\n        log1.entries[_addr] = _entry;\n        log1.entryCount += _entry;\n    }\n    function copyLog() public {\n        log2.entryCount = log1.entryCount;\n    }\n    function getEntryCount() public view returns (uint) {\n        return log2.entryCount;\n    }\n    function extraFunc() public pure returns (bool) {\n        return true;\n    }\n    function yetAnotherFunc() public pure returns (uint) {\n        return 101;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Table {\n        mapping(address => uint) values;\n        uint valueCount;\n    }\n    Table table1;\n    Table table2;\n    function setValue(address _addr, uint _value) public {\n        table1.values[_addr] = _value;\n        table1.valueCount += _value;\n    }\n    function cloneTable() public {\n        table2.valueCount = table1.valueCount;\n    }\n    function getValueCount() public view returns (uint) {\n        return table2.valueCount;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Registry {\n        mapping(address => uint) records;\n        uint recordTotal;\n    }\n    Registry registry1;\n    Registry registry2;\n    function addRecord(address _addr, uint _record) public {\n        registry1.records[_addr] = _record;\n        registry1.recordTotal += _record;\n    }\n    function copyRegistry() public {\n        registry2.recordTotal = registry1.recordTotal;\n    }\n    function getRecordTotal() public view returns (uint) {\n        return registry2.recordTotal;\n    }\n    function func1() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Database {\n        mapping(address => uint) entries;\n        uint entrySum;\n    }\n    Database db1;\n    Database db2;\n    function addEntry(address _addr, uint _entry) public {\n        db1.entries[_addr] = _entry;\n        db1.entrySum += _entry;\n    }\n    function replicateDatabase() public {\n        db2.entrySum = db1.entrySum;\n    }\n    function getEntrySum() public view returns (uint) {\n        return db2.entrySum;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Storage {\n        mapping(address => uint) tokens;\n        uint tokenTotal;\n    }\n    Storage storage1;\n    Storage storage2;\n    function addToken(address _addr, uint _token) public {\n        storage1.tokens[_addr] = _token;\n        storage1.tokenTotal += _token;\n    }\n    function copyStorage() public {\n        storage2.tokenTotal = storage1.tokenTotal;\n    }\n    function getTokenTotal() public view returns (uint) {\n        return storage2.tokenTotal;\n    }\n    function dummy() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Archive {\n        mapping(address => uint) files;\n        uint fileCount;\n    }\n    Archive archive1;\n    Archive archive2;\n    function addFile(address _addr, uint _file) public {\n        archive1.files[_addr] = _file;\n        archive1.fileCount += _file;\n    }\n    function cloneArchive() public {\n        archive2.fileCount = archive1.fileCount;\n    }\n    function getFileCount() public view returns (uint) {\n        return archive2.fileCount;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Network {\n        mapping(address => uint) nodes;\n        uint nodeCount;\n    }\n    Network network1;\n    Network network2;\n    function addNode(address _addr, uint _node) public {\n        network1.nodes[_addr] = _node;\n        network1.nodeCount += _node;\n    }\n    function duplicateNetwork() public {\n        network2.nodeCount = network1.nodeCount;\n    }\n    function getNodeCount() public view returns (uint) {\n        return network2.nodeCount;\n    }\n    function dummyFunc() public pure returns (string memory) {\n        return \"Node\";\n    }\n    function anotherDummyFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Cache {\n        mapping(address => uint) items;\n        uint itemTotal;\n    }\n    Cache cache1;\n    Cache cache2;\n    function addItem(address _addr, uint _item) public {\n        cache1.items[_addr] = _item;\n        cache1.itemTotal += _item;\n    }\n    function replicateCache() public {\n        cache2.itemTotal = cache1.itemTotal;\n    }\n    function getItemTotal() public view returns (uint) {\n        return cache2.itemTotal;\n    }\n}"
      }
    }
  },
  {
    "Changes22": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Multiple events with the same name and parameter types in the same\ninheritance hierarchy are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function submitReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n}\n\ncontract DerivedContract11 is BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function fileReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n\n    function nonRelatedFunction() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Non-related\"));\n    }\n\n    function anotherNonRelatedFunction() public pure returns (uint256) {\n        return 789;\n    }\n}",
          "error message": ":1:251: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract11 is BaseContract11 {     event ReportEvent(uint256 indexed reportId);      function fileReport(uint256 _ ...\n                                        ^------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0; contract BaseContract11 {     event ReportEvent(uint256 indexed reportId);      function submitReport(uint256 ...\n                                        ^------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function function12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n}\n\ncontract DerivedContract12 is BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function derivedFunction12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n\n    function helperFunction12() public pure returns (uint256) {\n        return 120;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract12 is BaseContract12 {     event Event12(uint256 indexed id12);      function derivedFunction12(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract12 {     event Event12(uint256 indexed id12);      function function12(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function function13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n}\n\ncontract DerivedContract13 is BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function derivedFunction13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n\n    function additionalFunction13() public pure returns (bool) {\n        return true;\n    }\n\n    function anotherFunction13() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract13 is BaseContract13 {     event Event13(uint256 indexed id13);      function derivedFunction13(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract13 {     event Event13(uint256 indexed id13);      function function13(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function function14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n}\n\ncontract DerivedContract14 is BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function derivedFunction14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n\n    function unrelatedFunction14() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Unrelated\"));\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract14 is BaseContract14 {     event Event14(uint256 indexed id14);      function derivedFunction14(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract14 {     event Event14(uint256 indexed id14);      function function14(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function function15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n}\n\ncontract DerivedContract15 is BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function derivedFunction15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n\n    function extraFunction15() public pure returns (uint256) {\n        return 150;\n    }\n\n    function anotherExtraFunction15() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract15 is BaseContract15 {     event Event15(uint256 indexed id15);      function derivedFunction15(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract15 {     event Event15(uint256 indexed id15);      function function15(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function function16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}\n\ncontract DerivedContract16 is BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function derivedFunction16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract16 is BaseContract16 {     event Event16(uint256 indexed id16);      function derivedFunction16(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract16 {     event Event16(uint256 indexed id16);      function function16(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function function17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n\n    function unrelatedFunction17() public pure returns (int256) {\n        return -17;\n    }\n}\n\ncontract DerivedContract17 is BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function derivedFunction17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n}",
          "error message": ":1:323: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract17 is BaseContract17 {     event Event17(uint256 indexed id17);      function derivedFunction17(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract17 {     event Event17(uint256 indexed id17);      function function17(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function function18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n}\n\ncontract DerivedContract18 is BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function derivedFunction18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n\n    function anotherUnrelatedFunction18() public pure returns (address) {\n        return address(this);\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract18 is BaseContract18 {     event Event18(uint256 indexed id18);      function derivedFunction18(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract18 {     event Event18(uint256 indexed id18);      function function18(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function function19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n}\n\ncontract DerivedContract19 is BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function derivedFunction19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n\n    function nonRelatedFunction19() public pure returns (uint256) {\n        return 190;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract19 is BaseContract19 {     event Event19(uint256 indexed id19);      function derivedFunction19(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract19 {     event Event19(uint256 indexed id19);      function function19(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function function20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n\n    function unrelatedFunction20() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}\n\ncontract DerivedContract20 is BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function derivedFunction20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n}",
          "error message": ":1:338: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract20 is BaseContract20 {     event Event20(uint256 indexed id20);      function derivedFunction20(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract20 {     event Event20(uint256 indexed id20);      function function20(uint256 _ ...\n                                        ^----------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function submitReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n}\n\ncontract DerivedContract11 is BaseContract11 {\n    function fileReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n\n    function nonRelatedFunction() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Non-related\"));\n    }\n\n    function anotherNonRelatedFunction() public pure returns (uint256) {\n        return 789;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function function12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n}\n\ncontract DerivedContract12 is BaseContract12 {\n    function derivedFunction12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n\n    function helperFunction12() public pure returns (uint256) {\n        return 120;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function function13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n}\n\ncontract DerivedContract13 is BaseContract13 {\n    function derivedFunction13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n\n    function additionalFunction13() public pure returns (bool) {\n        return true;\n    }\n\n    function anotherFunction13() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function function14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n}\n\ncontract DerivedContract14 is BaseContract14 {\n    function derivedFunction14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n\n    function unrelatedFunction14() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Unrelated\"));\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function function15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n}\n\ncontract DerivedContract15 is BaseContract15 {\n    function derivedFunction15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n\n    function extraFunction15() public pure returns (uint256) {\n        return 150;\n    }\n\n    function anotherExtraFunction15() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function function16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}\n\ncontract DerivedContract16 is BaseContract16 {\n    function derivedFunction16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function function17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n\n    function unrelatedFunction17() public pure returns (int256) {\n        return -17;\n    }\n}\n\ncontract DerivedContract17 is BaseContract17 {\n    function derivedFunction17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function function18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n}\n\ncontract DerivedContract18 is BaseContract18 {\n    function derivedFunction18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n\n    function anotherUnrelatedFunction18() public pure returns (address) {\n        return address(this);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function function19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n}\n\ncontract DerivedContract19 is BaseContract19 {\n    function derivedFunction19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n\n    function nonRelatedFunction19() public pure returns (uint256) {\n        return 190;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function function20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n\n    function unrelatedFunction20() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}\n\ncontract DerivedContract20 is BaseContract20 {\n    function derivedFunction20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n}"
      }
    }
  },
  {
    "Changes23": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "<code>using A for B</code> only affects the contract it is mentioned in.\nPreviously, the effect was inherited. Now, you have to repeat the <code>using</code>\nstatement in all derived contracts that make use of the feature.Repeat the <code>using A for B</code> statements in all derived contracts if needed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Operations {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Operations: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract A {\n    using Operations for uint;\n\n    uint public aValue;\n\n    function setAValue(uint _value) public {\n        aValue = _value;\n    }\n\n    function subtractAValue(uint _value) public {\n        aValue = aValue.subtract(_value);\n    }\n}\n\ncontract B is A {\n    uint public bValue;\n\n    function setBValue(uint _value) public {\n        bValue = _value;\n    }\n\n    function subtractBValue(uint _value) public {\n        bValue = bValue.subtract(_value);\n    }\n}",
          "error message": ":1:642: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ...  _value) public {         bValue = bValue.subtract(_value);     } }\n                                        ^-------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Calculate {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"Calculate: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract X {\n    using Calculate for uint;\n\n    uint public xValue;\n\n    function setXValue(uint _value) public {\n        xValue = _value;\n    }\n\n    function multiplyXValue(uint _value) public {\n        xValue = xValue.multiply(_value);\n    }\n}\n\ncontract Y is X {\n    uint public yValue;\n\n    function setYValue(uint _value) public {\n        yValue = _value;\n    }\n\n    function multiplyYValue(uint _value) public {\n        yValue = yValue.multiply(_value);\n    }\n}",
          "error message": ":1:666: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ...  _value) public {         yValue = yValue.multiply(_value);     } }\n                                        ^-------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary CalcLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"CalcLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract Master {\n    using CalcLib for uint;\n\n    uint public masterValue;\n\n    function setMasterValue(uint _value) public {\n        masterValue = _value;\n    }\n\n    function addMasterValue(uint _value) public {\n        masterValue = masterValue.add(_value);\n    }\n}\n\ncontract Slave is Master {\n    uint public slaveValue;\n\n    function setSlaveValue(uint _value) public {\n        slaveValue = _value;\n    }\n\n    function addSlaveValue(uint _value) public {\n        slaveValue = slaveValue.add(_value);\n    }\n}",
          "error message": ":1:694: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         slaveValue = slaveValue.add(_value);     } }\n                                        ^------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary NumberLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"NumberLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Origin {\n    using NumberLib for uint;\n\n    uint public originValue;\n\n    function setOriginValue(uint _value) public {\n        originValue = _value;\n    }\n\n    function subtractOriginValue(uint _value) public {\n        originValue = originValue.subtract(_value);\n    }\n}\n\ncontract Copy is Origin {\n    uint public copyValue;\n\n    function setCopyValue(uint _value) public {\n        copyValue = _value;\n    }\n\n    function subtractCopyValue(uint _value) public {\n        copyValue = copyValue.subtract(_value);\n    }\n}",
          "error message": ":1:697: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         copyValue = copyValue.subtract(_value);     } }\n                                        ^----------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary MyLibrary {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"MyLibrary: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Prime {\n    using MyLibrary for uint;\n\n    uint public primeValue;\n\n    function setPrimeValue(uint _value) public {\n        primeValue = _value;\n    }\n\n    function multiplyPrimeValue(uint _value) public {\n        primeValue = primeValue.multiply(_value);\n    }\n}\n\ncontract Secondary is Prime {\n    uint public secondaryValue;\n\n    function setSecondaryValue(uint _value) public {\n        secondaryValue = _value;\n    }\n\n    function multiplySecondaryValue(uint _value) public {\n        secondaryValue = secondaryValue.multiply(_value);\n    }\n}",
          "error message": ":1:746: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ...  public {         secondaryValue = secondaryValue.multiply(_value);     } }\n                                        ^---------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary UtilsLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"UtilsLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Initial {\n    using UtilsLib for uint;\n\n    uint public initialValue;\n\n    function setInitialValue(uint _value) public {\n        initialValue = _value;\n    }\n\n    function divideInitialValue(uint _value) public {\n        initialValue = initialValue.divide(_value);\n    }\n}\n\ncontract Final is Initial {\n    uint public finalValue;\n\n    function setFinalValue(uint _value) public {\n        finalValue = _value;\n    }\n\n    function divideFinalValue(uint _value) public {\n        finalValue = finalValue.divide(_value);\n    }\n}",
          "error message": ":1:695: TypeError: Member \"divide\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         finalValue = finalValue.divide(_value);     } }\n                                        ^---------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary ExtraLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ExtraLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract First {\n    using ExtraLib for uint;\n\n    uint public firstValue;\n\n    function setFirstValue(uint _value) public {\n        firstValue = _value;\n    }\n\n    function addFirstValue(uint _value) public {\n        firstValue = firstValue.add(_value);\n    }\n}\n\ncontract Second is First {\n    uint public secondValue;\n\n    function setSecondValue(uint _value) public {\n        secondValue = _value;\n    }\n\n    function addSecondValue(uint _value) public {\n        secondValue = secondValue.add(_value);\n    }\n}",
          "error message": ":1:695: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         secondValue = secondValue.add(_value);     } }\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary OperationLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"OperationLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Root {\n    using OperationLib for uint;\n\n    uint public rootValue;\n\n    function setRootValue(uint _value) public {\n        rootValue = _value;\n    }\n\n    function subtractRootValue(uint _value) public {\n        rootValue = rootValue.subtract(_value);\n    }\n}\n\ncontract Branch is Root {\n    uint public branchValue;\n\n    function setBranchValue(uint _value) public {\n        branchValue = _value;\n    }\n\n    function subtractBranchValue(uint _value) public {\n        branchValue = branchValue.subtract(_value);\n    }\n}",
          "error message": ":1:702: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         branchValue = branchValue.subtract(_value);     } }\n                                        ^------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary CalculationLib {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"CalculationLib: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Main {\n    using CalculationLib for uint;\n\n    uint public mainValue;\n\n    function setMainValue(uint _value) public {\n        mainValue = _value;\n    }\n\n    function multiplyMainValue(uint _value) public {\n        mainValue = mainValue.multiply(_value);\n    }\n}\n\ncontract Side is Main {\n    uint public sideValue;\n\n    function setSideValue(uint _value) public {\n        sideValue = _value;\n    }\n\n    function multiplySideValue(uint _value) public {\n        sideValue = sideValue.multiply(_value);\n    }\n}",
          "error message": ":1:723: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         sideValue = sideValue.multiply(_value);     } }\n                                        ^----------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary HelperLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"HelperLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Alpha {\n    using HelperLib for uint;\n\n    uint public alphaValue;\n\n    function setAlphaValue(uint _value) public {\n        alphaValue = _value;\n    }\n\n    function divideAlphaValue(uint _value) public {\n        alphaValue = alphaValue.divide(_value);\n    }\n}\n\ncontract Beta is Alpha {\n    uint public betaValue;\n\n    function setBetaValue(uint _value) public {\n        betaValue = _value;\n    }\n\n    function divideBetaValue(uint _value) public {\n        betaValue = betaValue.divide(_value);\n    }\n}",
          "error message": ":1:676: TypeError: Member \"divide\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         betaValue = betaValue.divide(_value);     } }\n                                        ^--------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary Operations {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Operations: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract A {\n    using Operations for uint;\n    uint public aValue;\n    function setAValue(uint _value) public {\n        aValue = _value;\n    }\n    function subtractAValue(uint _value) public {\n        aValue = aValue.subtract(_value);\n    }\n}\n\ncontract B is A {\n    using Operations for uint;\n    uint public bValue;\n    function setBValue(uint _value) public {\n        bValue = _value;\n    }\n    function subtractBValue(uint _value) public {\n        bValue = bValue.subtract(_value);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary Calculate {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"Calculate: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract X {\n    using Calculate for uint;\n    uint public xValue;\n    function setXValue(uint _value) public {\n        xValue = _value;\n    }\n    function multiplyXValue(uint _value) public {\n        xValue = xValue.multiply(_value);\n    }\n}\n\ncontract Y is X {\n    using Calculate for uint;\n    uint public yValue;\n    function setYValue(uint _value) public {\n        yValue = _value;\n    }\n    function multiplyYValue(uint _value) public {\n        yValue = yValue.multiply(_value);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary CalcLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"CalcLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract Master {\n    using CalcLib for uint;\n    uint public masterValue;\n    function setMasterValue(uint _value) public {\n        masterValue = _value;\n    }\n    function addMasterValue(uint _value) public {\n        masterValue = masterValue.add(_value);\n    }\n}\n\ncontract Slave is Master {\n    using CalcLib for uint;\n    uint public slaveValue;\n    function setSlaveValue(uint _value) public {\n        slaveValue = _value;\n    }\n    function addSlaveValue(uint _value) public {\n        slaveValue = slaveValue.add(_value);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary NumberLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"NumberLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Origin {\n    using NumberLib for uint;\n    uint public originValue;\n    function setOriginValue(uint _value) public {\n        originValue = _value;\n    }\n    function subtractOriginValue(uint _value) public {\n        originValue = originValue.subtract(_value);\n    }\n}\n\ncontract Copy is Origin {\n    using NumberLib for uint;\n    uint public copyValue;\n    function setCopyValue(uint _value) public {\n        copyValue = _value;\n    }\n    function subtractCopyValue(uint _value) public {\n        copyValue = copyValue.subtract(_value);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary MyLibrary {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"MyLibrary: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Prime {\n    using MyLibrary for uint;\n    uint public primeValue;\n    function setPrimeValue(uint _value) public {\n        primeValue = _value;\n    }\n    function multiplyPrimeValue(uint _value) public {\n        primeValue = primeValue.multiply(_value);\n    }\n}\n\ncontract Secondary is Prime {\n    using MyLibrary for uint;\n    uint public secondaryValue;\n    function setSecondaryValue(uint _value) public {\n        secondaryValue = _value;\n    }\n    function multiplySecondaryValue(uint _value) public {\n        secondaryValue = secondaryValue.multiply(_value);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary UtilsLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"UtilsLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Initial {\n    using UtilsLib for uint;\n    uint public initialValue;\n    function setInitialValue(uint _value) public {\n        initialValue = _value;\n    }\n    function divideInitialValue(uint _value) public {\n        initialValue = initialValue.divide(_value);\n    }\n}\n\ncontract Final is Initial {\n    using UtilsLib for uint;\n    uint public finalValue;\n    function setFinalValue(uint _value) public {\n        finalValue = _value;\n    }\n    function divideFinalValue(uint _value) public {\n        finalValue = finalValue.divide(_value);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary ExtraLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ExtraLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract First {\n    using ExtraLib for uint;\n    uint public firstValue;\n    function setFirstValue(uint _value) public {\n        firstValue = _value;\n    }\n    function addFirstValue(uint _value) public {\n        firstValue = firstValue.add(_value);\n    }\n}\n\ncontract Second is First {\n    using ExtraLib for uint;\n    uint public secondValue;\n    function setSecondValue(uint _value) public {\n        secondValue = _value;\n    }\n    function addSecondValue(uint _value) public {\n        secondValue = secondValue.add(_value);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary OperationLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"OperationLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Root {\n    using OperationLib for uint;\n    uint public rootValue;\n    function setRootValue(uint _value) public {\n        rootValue = _value;\n    }\n    function subtractRootValue(uint _value) public {\n        rootValue = rootValue.subtract(_value);\n    }\n}\n\ncontract Branch is Root {\n    using OperationLib for uint;\n    uint public branchValue;\n    function setBranchValue(uint _value) public {\n        branchValue = _value;\n    }\n    function subtractBranchValue(uint _value) public {\n        branchValue = branchValue.subtract(_value);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary CalculationLib {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"CalculationLib: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Main {\n    using CalculationLib for uint;\n    uint public mainValue;\n    function setMainValue(uint _value) public {\n        mainValue = _value;\n    }\n    function multiplyMainValue(uint _value) public {\n        mainValue = mainValue.multiply(_value);\n    }\n}\n\ncontract Side is Main {\n    using CalculationLib for uint;\n    uint public sideValue;\n    function setSideValue(uint _value) public {\n        sideValue = _value;\n    }\n    function multiplySideValue(uint _value) public {\n        sideValue = sideValue.multiply(_value);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary HelperLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"HelperLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Alpha {\n    using HelperLib for uint;\n    uint public alphaValue;\n    function setAlphaValue(uint _value) public {\n        alphaValue = _value;\n    }\n    function divideAlphaValue(uint _value) public {\n        alphaValue = alphaValue.divide(_value);\n    }\n}\n\ncontract Beta is Alpha {\n    using HelperLib for uint;\n    uint public betaValue;\n    function setBetaValue(uint _value) public {\n        betaValue = _value;\n    }\n    function divideBetaValue(uint _value) public {\n        betaValue = betaValue.divide(_value);\n    }\n}"
      }
    }
  },
  {
    "Changes24": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Shifts by signed types are disallowed.\nPreviously, shifts by negative amounts were allowed, but reverted at runtime.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    int public output;\n\n    function shiftLeft(int x, int y) public {\n        output = x << y;\n    }\n}",
          "error message": ":1:133: TypeError: Operator << not compatible with types int256 and int256\npragma solidity^0.7.0;  contract Example11 {     int public output;      function shiftLeft(int x, int y) public {         output = x << y;     } }\n                                                                                                                                    ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    int public shiftResult;\n\n    function performRightShift(int a, int b) public {\n        shiftResult = a >> b;\n    }\n\n    function dummyFunction2() public pure returns (int) {\n        return 50;\n    }\n}",
          "error message": ":1:151: TypeError: Operator >> not compatible with types int256 and int256\n ...  b) public {         shiftResult = a >> b;     }      function dummyFunction ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    int public shifted;\n\n    function leftShift(int x, int y) public {\n        shifted = x << y;\n    }\n}",
          "error message": ":1:135: TypeError: Operator << not compatible with types int256 and int256\npragma solidity^0.7.0;  contract Example13 {     int public shifted;      function leftShift(int x, int y) public {         shifted = x << y;     } }\n                                                                                                                                      ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    int public resultShift;\n\n    function rightShift(int number, int shiftBy) public {\n        resultShift = number >> shiftBy;\n    }\n\n    function additionalFunction1() public pure returns (int) {\n        return 99;\n    }\n}",
          "error message": ":1:155: TypeError: Operator >> not compatible with types int256 and int256\n ... By) public {         resultShift = number >> shiftBy;     }      function additionalFun ...\n                                        ^---------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    int public finalShift;\n\n    function shiftLeftBy(int input, int shiftAmount) public {\n        finalShift = input << shiftAmount;\n    }\n\n    function anotherDummyFunction() public pure returns (int) {\n        return 15;\n    }\n\n    function extraFunction() public pure returns (int) {\n        return 200;\n    }\n}",
          "error message": ":1:157: TypeError: Operator << not compatible with types int256 and int256\n ... unt) public {         finalShift = input << shiftAmount;     }      function anotherDummyF ...\n                                        ^------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    int public shiftedValue;\n\n    function shiftOperation(int base, int offset) public {\n        shiftedValue = base << offset;\n    }\n}",
          "error message": ":1:158: TypeError: Operator << not compatible with types int256 and int256\n ... t) public {         shiftedValue = base << offset;     } }\n                                        ^------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    int public result;\n\n    function performShift(int x, int y) public {\n        result = x << y;\n    }\n\n    function auxiliaryFunction() public pure returns (int) {\n        return 3;\n    }\n}",
          "error message": ":1:136: TypeError: Operator << not compatible with types int256 and int256\n ... , int y) public {         result = x << y;     }      function auxiliaryFunc ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    int public shiftOutcome;\n\n    function leftShift(int a, int b) public {\n        shiftOutcome = a << b;\n    }\n}",
          "error message": ":1:145: TypeError: Operator << not compatible with types int256 and int256\n ... b) public {         shiftOutcome = a << b;     } }\n                                        ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    int public data;\n\n    function shiftLeftBy(int number, int shiftBy) public {\n        data = number << shiftBy;\n    }\n\n    function unusedFunction() public pure returns (int) {\n        return -5;\n    }\n}",
          "error message": ":1:142: TypeError: Operator << not compatible with types int256 and int256\n ... t shiftBy) public {         data = number << shiftBy;     }      function unusedFunctio ...\n                                        ^---------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    int public shiftedResult;\n\n    function rightShiftOperation(int num, int shiftAmount) public {\n        shiftedResult = num >> shiftAmount;\n    }\n\n    function extraFunction1() public pure returns (int) {\n        return 101;\n    }\n}",
          "error message": ":1:169: TypeError: Operator >> not compatible with types int256 and int256\n ... ) public {         shiftedResult = num >> shiftAmount;     }      function extraFunction ...\n                                        ^----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    int public output;\n\n    function shiftLeft(int x, uint y) public {\n        output = x << y;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    int public shiftResult;\n\n    function performRightShift(int a, uint b) public {\n        shiftResult = a >> b;\n    }\n\n    function dummyFunction2() public pure returns (int) {\n        return 50;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    int public shifted;\n\n    function leftShift(int x, uint y) public {\n        shifted = x << y;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    int public resultShift;\n\n    function rightShift(int number, uint shiftBy) public {\n        resultShift = number >> shiftBy;\n    }\n\n    function additionalFunction1() public pure returns (int) {\n        return 99;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    int public finalShift;\n\n    function shiftLeftBy(int input, uint shiftAmount) public {\n        finalShift = input << shiftAmount;\n    }\n\n    function anotherDummyFunction() public pure returns (int) {\n        return 15;\n    }\n\n    function extraFunction() public pure returns (int) {\n        return 200;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    int public shiftedValue;\n\n    function shiftOperation(int base, uint offset) public {\n        shiftedValue = base << offset;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    int public result;\n\n    function performShift(int x, uint y) public {\n        result = x << y;\n    }\n\n    function auxiliaryFunction() public pure returns (int) {\n        return 3;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    int public shiftOutcome;\n\n    function leftShift(int a, uint b) public {\n        shiftOutcome = a << b;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    int public data;\n\n    function shiftLeftBy(int number, uint shiftBy) public {\n        data = number << shiftBy;\n    }\n\n    function unusedFunction() public pure returns (int) {\n        return -5;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    int public shiftedResult;\n\n    function rightShiftOperation(int num, uint shiftAmount) public {\n        shiftedResult = num >> shiftAmount;\n    }\n\n    function extraFunction1() public pure returns (int) {\n        return 101;\n    }\n}"
      }
    }
  },
  {
    "Changes25": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The <code>finney</code> and <code>szabo</code> denominations are removed.\nThey are rarely used and do not make the actual amount readily visible. Instead, explicit\nvalues like <code>1e20</code> or the very common <code>gwei</code> can be used.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public feeInFinney = 3 finney;\n\n    function payFee() public payable {\n        require(msg.value >= feeInFinney, \"Fee is 3 finney\");\n    }\n\n    function getFee() public view returns (uint) {\n        return feeInFinney;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": ":1:78: ParserError: Expected ';' but got identifier\n ...  {     uint public feeInFinney = 3 finney;      function payFee() public pay ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public donationInSzabo = 25 szabo;\n\n    function donate() public payable {\n        require(msg.value >= donationInSzabo, \"Minimum donation is 25 szabo\");\n    }\n\n    function getDonation() public view returns (uint) {\n        return donationInSzabo;\n    }\n\n    function anotherFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:83: ParserError: Expected ';' but got identifier\n ...   uint public donationInSzabo = 25 szabo;      function donate() public pay ...\n                                        ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public valueInFinney = 5 finney;\n\n    function setValue(uint newValue) public {\n        valueInFinney = newValue * 1 finney;\n    }\n\n    function getValue() public view returns (uint) {\n        return valueInFinney;\n    }\n\n    function randomFunc() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
          "error message": ":1:80: ParserError: Expected ';' but got identifier\n ...      uint public valueInFinney = 5 finney;      function setValue(uint newVa ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public minSzabo = 30 szabo;\n\n    function deposit() public payable {\n        require(msg.value >= minSzabo, \"Must deposit at least 30 szabo\");\n    }\n\n    function getMin() public view returns (uint) {\n        return minSzabo;\n    }\n}",
          "error message": ":1:76: ParserError: Expected ';' but got identifier\n ... 14 {     uint public minSzabo = 30 szabo;      function deposit() public pa ...\n                                        ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public maxFinney = 50 finney;\n\n    function setMax(uint newMax) public {\n        maxFinney = newMax * 1 finney;\n    }\n\n    function getMax() public view returns (uint) {\n        return maxFinney;\n    }\n}",
          "error message": ":1:77: ParserError: Expected ';' but got identifier\n ... 5 {     uint public maxFinney = 50 finney;      function setMax(uint newMax) ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public requiredSzabo = 75 szabo;\n\n    function sendFunds() public payable {\n        require(msg.value >= requiredSzabo, \"Need at least 75 szabo\");\n    }\n\n    function getRequired() public view returns (uint) {\n        return requiredSzabo;\n    }\n\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:81: ParserError: Expected ';' but got identifier\n ...     uint public requiredSzabo = 75 szabo;      function sendFunds() public  ...\n                                        ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public feeFinney = 4 finney;\n\n    function pay() public payable {\n        require(msg.value >= feeFinney, \"Fee is 4 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return feeFinney;\n    }\n\n    function additionalFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": ":1:76: ParserError: Expected ';' but got identifier\n ... 17 {     uint public feeFinney = 4 finney;      function pay() public payabl ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public amountSzabo = 40 szabo;\n\n    function contribute() public payable {\n        require(msg.value >= amountSzabo, \"Contribution must be at least 40 szabo\");\n    }\n\n    function getAmount() public view returns (uint) {\n        return amountSzabo;\n    }\n}",
          "error message": ":1:79: ParserError: Expected ';' but got identifier\n ... {     uint public amountSzabo = 40 szabo;      function contribute() public ...\n                                        ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public rateFinney = 6 finney;\n\n    function invest() public payable {\n        require(msg.value >= rateFinney, \"Investment rate is 6 finney\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rateFinney;\n    }\n\n    function someFunction() public pure returns (string memory) {\n        return \"some\";\n    }\n}",
          "error message": ":1:77: ParserError: Expected ';' but got identifier\n ... 9 {     uint public rateFinney = 6 finney;      function invest() public pay ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public thresholdSzabo = 100 szabo;\n\n    function setThreshold(uint newThreshold) public {\n        thresholdSzabo = newThreshold * 1 szabo;\n    }\n\n    function getThreshold() public view returns (uint) {\n        return thresholdSzabo;\n    }\n}",
          "error message": ":1:83: ParserError: Expected ';' but got identifier\n ...   uint public thresholdSzabo = 100 szabo;      function setThreshold(uint n ...\n                                        ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public feeInWei = 3e15;\n\n    function payFee() public payable {\n        require(msg.value >= feeInWei, \"Fee is 3 finney equivalent in wei\");\n    }\n\n    function getFee() public view returns (uint) {\n        return feeInWei;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public donationInWei = 25e12;\n\n    function donate() public payable {\n        require(msg.value >= donationInWei, \"Minimum donation is 25 szabo equivalent in wei\");\n    }\n\n    function getDonation() public view returns (uint) {\n        return donationInWei;\n    }\n\n    function anotherFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public valueInWei = 5e15;\n\n    function setValue(uint newValue) public {\n        valueInWei = newValue * 1e15;\n    }\n\n    function getValue() public view returns (uint) {\n        return valueInWei;\n    }\n\n    function randomFunc() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public minWei = 30e12;\n\n    function deposit() public payable {\n        require(msg.value >= minWei, \"Must deposit at least 30 szabo equivalent in wei\");\n    }\n\n    function getMin() public view returns (uint) {\n        return minWei;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public maxWei = 50e15;\n\n    function setMax(uint newMax) public {\n        maxWei = newMax * 1e15;\n    }\n\n    function getMax() public view returns (uint) {\n        return maxWei;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public requiredWei = 75e12;\n\n    function sendFunds() public payable {\n        require(msg.value >= requiredWei, \"Need at least 75 szabo equivalent in wei\");\n    }\n\n    function getRequired() public view returns (uint) {\n        return requiredWei;\n    }\n\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public feeWei = 4e15;\n\n    function pay() public payable {\n        require(msg.value >= feeWei, \"Fee is 4 finney equivalent in wei\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return feeWei;\n    }\n\n    function additionalFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public amountWei = 40e12;\n\n    function contribute() public payable {\n        require(msg.value >= amountWei, \"Contribution must be at least 40 szabo equivalent in wei\");\n    }\n\n    function getAmount() public view returns (uint) {\n        return amountWei;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public rateWei = 6e15;\n\n    function invest() public payable {\n        require(msg.value >= rateWei, \"Investment rate is 6 finney equivalent in wei\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rateWei;\n    }\n\n    function someFunction() public pure returns (string memory) {\n        return \"some\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public thresholdWei = 100e12;\n\n    function setThreshold(uint newThreshold) public {\n        thresholdWei = newThreshold * 1e12;\n    }\n\n    function getThreshold() public view returns (uint) {\n        return thresholdWei;\n    }\n}"
      }
    }
  },
  {
    "Changes26": {
      "Version Migration": "0.5->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract TestContract1 {\n    byte public data1;\n    byte public extraData;\n\n    function setData1(byte _data1) public {\n        data1 = _data1;\n        extraData = _data1;\n        for (uint i = 0; i < 10; i++) {\n            extraData = _data1;\n        }\n    }\n    \n    function calculateSum(uint a, uint b) public pure returns (uint) {\n        uint sum = a + b;\n        sum = a + b;\n        return sum;\n    }\n}\n",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleContract2 {\n    byte public info;\n\n    function updateInfo(byte _info) public {\n        info = _info;\n        for (uint i = 0; i < 5; i++) {\n            info = _info;\n        }\n    }\n    \n    function additionalFunction() public pure returns (uint) {\n        uint result = 42;\n        for (uint i = 0; i < 3; i++) {\n            result += i;\n        }\n        return result;\n    }\n    \n    function compute(uint x, uint y) public pure returns (uint) {\n        uint z = x * y;\n        return z;\n    }\n}\n",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract AnotherContract3 {\n    byte public value;\n    uint public multiplier;\n    \n    function storeValue(byte _value) public {\n        value = _value;\n        multiplier = 2;\n        uint i = 0;\n        while (i < 10) {\n            multiplier = 3;\n            i++;\n        }\n    }\n    \n    function swapValues(uint a, uint b) public pure returns (uint, uint) {\n        uint temp = a;\n        a = b;\n        b = temp;\n        return (a, b);\n    }\n    \n    function complexCalculation(uint a, uint b) public pure returns (uint) {\n        uint result = a * b;\n        result += a;\n        return result;\n    }\n}\n",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract SampleContract4 {\n    byte public data;\n    uint public count;\n\n    function modifyData(byte _data) public {\n        data = _data;\n        count = 0;\n        for (uint i = 0; i < 5; i++) {\n            count++;\n        }\n    }\n    \n    function calculateProduct(uint a, uint b) public pure returns (uint) {\n        uint product = a * b;\n        product *= 2;\n        return product;\n    }\n    \n    function unusedFunction() public pure returns (bool) {\n        return true;\n    }\n    \n    function helper() public pure returns (uint) {\n        return 1;\n    }\n}\n",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Contract5 {\n    byte public info;\n    byte public backupInfo;\n\n    function updateInfo(byte _newInfo) public {\n        info = _newInfo;\n        backupInfo = _newInfo;\n        for (uint i = 0; i < 4; i++) {\n            info = _newInfo;\n        }\n    }\n    \n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n    \n    function extraLogic(uint a, uint b) public pure returns (uint) {\n        uint sum = a + b;\n        return sum;\n    }\n}\n",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example6 {\n    byte public value;\n    byte public secondaryValue;\n\n    function setValue(byte _value) public {\n        value = _value;\n        secondaryValue = _value;\n        for (uint i = 0; i < 6; i++) {\n            value = _value;\n        }\n    }\n    \n    function randomFunction() public pure returns (int) {\n        int number = -1;\n        for (int i = 0; i < 3; i++) {\n            number--;\n        }\n        return number;\n    }\n}\n",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Demo7 {\n    byte public data;\n    byte public tempData;\n\n    function changeData(byte _newData) public {\n        data = _newData;\n        tempData = _newData;\n        uint i = 0;\n        while (i < 5) {\n            data = _newData;\n            i++;\n        }\n    }\n    \n    function tempFunction() public pure returns (address) {\n        return address(0);\n    }\n    \n    function calculate(uint x, uint y) public pure returns (uint) {\n        uint result = x + y;\n        result += 10;\n        return result;\n    }\n}\n",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Contract8 {\n    byte public info;\n    uint public factor;\n\n    function setInfo(byte _info) public {\n        info = _info;\n        factor = 1;\n        for (uint i = 0; i < 7; i++) {\n            factor++;\n        }\n    }\n    \n    function auxiliaryFunction() public pure returns (bool) {\n        return false;\n    }\n    \n    function calculate(uint a, uint b) public pure returns (uint) {\n        uint result = a + b;\n        return result;\n    }\n}\n",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example9 {\n    byte public value;\n    byte public additionalValue;\n\n    function updateValue(byte _value) public {\n        value = _value;\n        additionalValue = _value;\n        uint i = 0;\n        while (i < 8) {\n            value = _value;\n            i++;\n        }\n    }\n    \n    function dummyFunction() public pure returns (uint) {\n        uint dummy = 123;\n        for (uint i = 0; i < 2; i++) {\n            dummy += i;\n        }\n        return dummy;\n    }\n    \n    function sum(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}\n",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract SampleContract10 {\n    byte public data;\n    byte public backupData;\n\n    function setData(byte _data) public {\n        data = _data;\n        backupData = _data;\n        for (uint i = 0; i < 9; i++) {\n            data = _data;\n        }\n    }\n    \n    function placeholderFunction() public pure returns (string memory) {\n        return \"Placeholder\";\n    }\n    \n    function multiply(uint a, uint b) public pure returns (uint) {\n        uint result = a * b;\n        result *= 2;\n        return result;\n    }\n}\n\n\n"
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract TestContract1 {\n    bytes1 public data1;\n    bytes1 public extraData;\n\n    function setData1(bytes1 _data1) public {\n        data1 = _data1;\n        extraData = _data1;\n        for (uint i = 0; i < 10; i++) {\n            extraData = _data1;\n        }\n    }\n    \n    function calculateSum(uint a, uint b) public pure returns (uint) {\n        uint sum = a + b;\n        sum = a + b;\n        return sum;\n    }\n}\n",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleContract2 {\n    bytes1 public info;\n\n    function updateInfo(bytes1 _info) public {\n        info = _info;\n        for (uint i = 0; i < 5; i++) {\n            info = _info;\n        }\n    }\n    \n    function additionalFunction() public pure returns (uint) {\n        uint result = 42;\n        for (uint i = 0; i < 3; i++) {\n            result += i;\n        }\n        return result;\n    }\n    \n    function compute(uint x, uint y) public pure returns (uint) {\n        uint z = x * y;\n        return z;\n    }\n}\n",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract AnotherContract3 {\n    bytes1 public value;\n    uint public multiplier;\n    \n    function storeValue(bytes1 _value) public {\n        value = _value;\n        multiplier = 2;\n        uint i = 0;\n        while (i < 10) {\n            multiplier = 3;\n            i++;\n        }\n    }\n    \n    function swapValues(uint a, uint b) public pure returns (uint, uint) {\n        uint temp = a;\n        a = b;\n        b = temp;\n        return (a, b);\n    }\n    \n    function complexCalculation(uint a, uint b) public pure returns (uint) {\n        uint result = a * b;\n        result += a;\n        return result;\n    }\n}\n",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract SampleContract4 {\n    bytes1 public data;\n    uint public count;\n\n    function modifyData(bytes1 _data) public {\n        data = _data;\n        count = 0;\n        for (uint i = 0; i < 5; i++) {\n            count++;\n        }\n    }\n    \n    function calculateProduct(uint a, uint b) public pure returns (uint) {\n        uint product = a * b;\n        product *= 2;\n        return product;\n    }\n    \n    function unusedFunction() public pure returns (bool) {\n        return true;\n    }\n    \n    function helper() public pure returns (uint) {\n        return 1;\n    }\n}\n",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Contract5 {\n    bytes1 public info;\n    bytes1 public backupInfo;\n\n    function updateInfo(bytes1 _newInfo) public {\n        info = _newInfo;\n        backupInfo = _newInfo;\n        for (uint i = 0; i < 4; i++) {\n            info = _newInfo;\n        }\n    }\n    \n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n    \n    function extraLogic(uint a, uint b) public pure returns (uint) {\n        uint sum = a + b;\n        return sum;\n    }\n}\n",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example6 {\n    bytes1 public value;\n    bytes1 public secondaryValue;\n\n    function setValue(bytes1 _value) public {\n        value = _value;\n        secondaryValue = _value;\n        for (uint i = 0; i < 6; i++) {\n            value = _value;\n        }\n    }\n    \n    function randomFunction() public pure returns (int) {\n        int number = -1;\n        for (int i = 0; i < 3; i++) {\n            number--;\n        }\n        return number;\n    }\n}\n",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Demo7 {\n    bytes1 public data;\n    bytes1 public tempData;\n\n    function changeData(bytes1 _newData) public {\n        data = _newData;\n        tempData = _newData;\n        uint i = 0;\n        while (i < 5) {\n            data = _newData;\n            i++;\n        }\n    }\n    \n    function tempFunction() public pure returns (address) {\n        return address(0);\n    }\n    \n    function calculate(uint x, uint y) public pure returns (uint) {\n        uint result = x + y;\n        result += 10;\n        return result;\n    }\n}\n",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Contract8 {\n    bytes1 public info;\n    uint public factor;\n\n    function setInfo(bytes1 _info) public {\n        info = _info;\n        factor = 1;\n        for (uint i = 0; i < 7; i++) {\n            factor++;\n        }\n    }\n    \n    function auxiliaryFunction() public pure returns (bool) {\n        return false;\n    }\n    \n    function calculate(uint a, uint b) public pure returns (uint) {\n        uint result = a + b;\n        return result;\n    }\n}\n",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example9 {\n    bytes1 public value;\n    bytes1 public additionalValue;\n\n    function updateValue(bytes1 _value) public {\n        value = _value;\n        additionalValue = _value;\n        uint i = 0;\n        while (i < 8) {\n            value = _value;\n            i++;\n        }\n    }\n    \n    function dummyFunction() public pure returns (uint) {\n        uint dummy = 123;\n        for (uint i = 0; i < 2; i++) {\n            dummy += i;\n        }\n        return dummy;\n    }\n    \n    function sum(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}\n",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract SampleContract10 {\n    bytes1 public data;\n    bytes1 public backupData;\n\n    function setData(bytes1 _data) public {\n        data = _data;\n        backupData = _data;\n        for (uint i = 0; i < 9; i++) {\n            data = _data;\n        }\n    }\n    \n    function placeholderFunction() public pure returns (string memory) {\n        return \"Placeholder\";\n    }\n    \n    function multiply(uint a, uint b) public pure returns (uint) {\n        uint result = a * b;\n        result *= 2;\n        return result;\n    }\n}\n\n\n"
      }
    }
  },
  {
    "Changes27": {
      "Version Migration": "->0.5",
      "Knowledge": "The functions <code>.call()</code>, <code>.delegatecall()</code>, <code>staticcall()</code>,\n<code>keccak256()</code>, <code>sha256()</code> and <code>ripemd160()</code> now accept only a single\n<code>bytes</code> argument. Moreover, the argument is not padded. This was changed to\nmake more explicit and clear how the arguments are concatenated. Change every\n<code>.call()</code> (and family) to a <code>.call(\"\")</code> and every <code>.call(signature, a,\nb, c)</code> to use <code>.call(abi.encodeWithSignature(signature, a, b, c))</code> (the\nlast one only works for value types).  Change every <code>keccak256(a, b, c)</code> to\n<code>keccak256(abi.encodePacked(a, b, c))</code>. Even though it is not a breaking\nchange, it is suggested that developers change\n<code>x.call(bytes4(keccak256(\"f(uint256)\")), a, b)</code> to\n<code>x.call(abi.encodeWithSignature(\"f(uint256)\", a, b))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractEleven {\n    function triggerCall(address target, uint256 param) public {\n        target.call(bytes4(keccak256(\"activate(uint256)\")), param);\n    }\n    function displayMessage() public pure returns (string memory) {\n        return \"Welcome to Contract Eleven!\";\n    }\n}",
          "error message": ":1:123: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... t, uint256 param) public {         target.call(bytes4(keccak256(\"activate(uint256)\")), param);     }     function displayMessage ...\n                                        ^--------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractTwelve {\n    function calculateHash(uint256 num) public pure returns (bytes32) {\n        return keccak256(num);\n    }\n    function getBoolean() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:147: TypeError: Invalid type for argument in function call. Invalid implicit conversion from uint256 to bytes memory requested. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... ytes32) {         return keccak256(num);     }     function getBoolean()  ...\n                                        ^-^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractThirteen {\n    function invokeStaticCall(address addr, uint256 data) public {\n        addr.staticcall(bytes4(keccak256(\"readData(uint256)\")), data);\n    }\n    function getNumber() public pure returns (int) {\n        return 5;\n    }\n}",
          "error message": ":1:127: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... dr, uint256 data) public {         addr.staticcall(bytes4(keccak256(\"readData(uint256)\")), data);     }     function getNumber() pu ...\n                                        ^-----------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractFourteen {\n    function hashMultipleValues(uint256 a, uint256 b, uint256 c) public pure returns (bytes32) {\n        return ripemd160(a, b, c);\n    }\n    function extraNumeric() public pure returns (uint256) {\n        return 2024;\n    }\n}",
          "error message": ":1:164: TypeError: Wrong argument count for function call: 3 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return ripemd160(a, b, c);     }     function extraNumeric() ...\n                                        ^----------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractFifteen {\n    function makeDelegateCall(address delegate, uint256 value) public {\n        delegate.delegatecall(bytes4(keccak256(\"setValue(uint256)\")), value);\n    }\n    function extraBoolean() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:131: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... e, uint256 value) public {         delegate.delegatecall(bytes4(keccak256(\"setValue(uint256)\")), value);     }     function extraBoolean() ...\n                                        ^------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractSixteen {\n    function applySha256(uint256 x, uint256 y) public pure returns (bytes32) {\n        return sha256(x, y);\n    }\n    function checkValidity() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:145: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return sha256(x, y);     }     function checkValidity( ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractSeventeen {\n    function computeRipemd(uint256 num1, uint256 num2) public pure returns (bytes20) {\n        return ripemd160(num1, num2);\n    }\n    function utilityFunction() public pure returns (uint256) {\n        return 987;\n    }\n}",
          "error message": ":1:155: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes20) {         return ripemd160(num1, num2);     }     function utilityFunctio ...\n                                        ^-------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractEighteen {\n    function doCall(address callee, uint256 arg) public {\n        callee.call(bytes4(keccak256(\"setArg(uint256)\")), arg);\n    }\n    function getRandomNumber() public pure returns (uint256) {\n        return 123456789;\n    }\n}",
          "error message": ":1:118: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... lee, uint256 arg) public {         callee.call(bytes4(keccak256(\"setArg(uint256)\")), arg);     }     function getRandomNumbe ...\n                                        ^----------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractNineteen {\n    function sendHashRequest(uint256 val1, uint256 val2) public pure returns (bytes32) {\n        return keccak256(val1, val2);\n    }\n    function simpleAddition(uint256 a, uint256 b) public pure returns (uint256) {\n        return a + b;\n    }\n}",
          "error message": ":1:156: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return keccak256(val1, val2);     }     function simpleAddition ...\n                                        ^-------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractTwenty {\n    function performHash(uint256 one, uint256 two) public pure returns (bytes32) {\n        return sha256(one, two);\n    }\n    function provideInteger() public pure returns (int256) {\n        return -100;\n    }\n}",
          "error message": ":1:148: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return sha256(one, two);     }     function provideInteger ...\n                                        ^--------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ContractEleven {\n    function triggerCall(address target, uint256 param) public {\n        target.call(abi.encodeWithSignature(\"activate(uint256)\", param));\n    }\n    function displayMessage() public pure returns (string memory) {\n        return \"Welcome to Contract Eleven!\";\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ContractTwelve {\n    function calculateHash(uint256 num) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(num));\n    }\n    function getBoolean() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ContractThirteen {\n    function invokeStaticCall(address addr, uint256 data) public {\n        addr.staticcall(abi.encodeWithSignature(\"readData(uint256)\", data));\n    }\n    function getNumber() public pure returns (int) {\n        return 5;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ContractFourteen {\n    function hashMultipleValues(uint256 a, uint256 b, uint256 c) public pure returns (bytes32) {\n        return ripemd160(abi.encodePacked(a, b, c));\n    }\n    function extraNumeric() public pure returns (uint256) {\n        return 2024;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ContractFifteen {\n    function makeDelegateCall(address delegate, uint256 value) public {\n        delegate.delegatecall(abi.encodeWithSignature(\"setValue(uint256)\", value));\n    }\n    function extraBoolean() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ContractSixteen {\n    function applySha256(uint256 x, uint256 y) public pure returns (bytes32) {\n        return sha256(abi.encodePacked(x, y));\n    }\n    function checkValidity() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ContractSeventeen {\n    function computeRipemd(uint256 num1, uint256 num2) public pure returns (bytes20) {\n        return ripemd160(abi.encodePacked(num1, num2));\n    }\n    function utilityFunction() public pure returns (uint256) {\n        return 987;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ContractEighteen {\n    function doCall(address callee, uint256 arg) public {\n        callee.call(abi.encodeWithSignature(\"setArg(uint256)\", arg));\n    }\n    function getRandomNumber() public pure returns (uint256) {\n        return 123456789;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ContractNineteen {\n    function sendHashRequest(uint256 val1, uint256 val2) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(val1, val2));\n    }\n    function simpleAddition(uint256 a, uint256 b) public pure returns (uint256) {\n        return a + b;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ContractTwenty {\n    function performHash(uint256 one, uint256 two) public pure returns (bytes32) {\n        return sha256(abi.encodePacked(one, two));\n    }\n    function provideInteger() public pure returns (int256) {\n        return -100;\n    }\n}"
      }
    }
  },
  {
    "Changes28": {
      "Version Migration": "->0.5",
      "Knowledge": "Functions <code>.call()</code>, <code>.delegatecall()</code> and <code>.staticcall()</code> now return\n<code>(bool, bytes memory)</code> to provide access to the return data.  Change\n<code>bool success = otherContract.call(\"f\")</code> to <code>(bool success, bytes memory\ndata) = otherContract.call(\"f\")</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract AssetTracker {\n    address registryContract;\n    function trackAsset() public {\n        bool tracked = registryContract.call(abi.encodeWithSignature(\"track()\"));\n    }\n    function extraDetails() public pure returns (string memory) {\n        return \"Additional Details\";\n    }\n}",
          "error message": ":1:121: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... tion trackAsset() public {         bool tracked = registryContract.call(abi.encodeWithSignature(\"track()\"));     }     function extraDetails() ...\n                                        ^----------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract HealthRecordSystem {\n    address healthContract;\n    function updateRecord() public {\n        bool updated = healthContract.call(abi.encodeWithSignature(\"update()\"));\n    }\n    function unrelatedFunction6() private {\n    }\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:127: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... on updateRecord() public {         bool updated = healthContract.call(abi.encodeWithSignature(\"update()\"));     }     function unrelatedFunct ...\n                                        ^---------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract CryptoExchange {\n    address exchangeContract;\n    function performTrade() public {\n        bool traded = exchangeContract.call(abi.encodeWithSignature(\"trade()\"));\n    }\n    function randomValue(uint256 value) public pure returns (uint256) {\n        return value * 42;\n    }\n}",
          "error message": ":1:125: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... on performTrade() public {         bool traded = exchangeContract.call(abi.encodeWithSignature(\"trade()\"));     }     function randomValue(ui ...\n                                        ^---------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract VotingSystem {\n    address votingContract;\n    function castVote() public {\n        bool voteCasted = votingContract.call(abi.encodeWithSignature(\"vote()\"));\n    }\n    function logEvent(string memory event) public pure returns (string memory) {\n        return event;\n    }\n}",
          "error message": ":1:233: ParserError: Expected ',' but got 'event'\n ...    function logEvent(string memory event) public pure returns (string memor ...\n                                        ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ContentManagement {\n    address contentContract;\n    function publishContent() public {\n        bool published = contentContract.call(abi.encodeWithSignature(\"publish()\"));\n    }\n    function unrelatedFunction7() public {\n    }\n}",
          "error message": ":1:129: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ...  publishContent() public {         bool published = contentContract.call(abi.encodeWithSignature(\"publish()\"));     }     function unrelatedFunct ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract LoyaltyProgram {\n    address loyaltyContract;\n    function redeemPoints() public {\n        bool redeemed = loyaltyContract.call(abi.encodeWithSignature(\"redeem()\"));\n    }\n    function randomTask1() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": ":1:124: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... on redeemPoints() public {         bool redeemed = loyaltyContract.call(abi.encodeWithSignature(\"redeem()\"));     }     function randomTask1()  ...\n                                        ^-----------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract TaskManager {\n    address taskContract;\n    function manageTask() public {\n        bool managed = taskContract.call(abi.encodeWithSignature(\"manage()\"));\n    }\n    function unrelatedFunction8() public {\n    }\n    function additionalHelper() public pure returns (uint) {\n        return 2024;\n    }\n}",
          "error message": ":1:116: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... tion manageTask() public {         bool managed = taskContract.call(abi.encodeWithSignature(\"manage()\"));     }     function unrelatedFunct ...\n                                        ^-------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract AlertSystem {\n    address alertContract;\n    function triggerAlert() public {\n        bool alerted = alertContract.call(abi.encodeWithSignature(\"alert()\"));\n    }\n    function randomModifier() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:119: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... on triggerAlert() public {         bool alerted = alertContract.call(abi.encodeWithSignature(\"alert()\"));     }     function randomModifier ...\n                                        ^-------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract EventOrganizer {\n    address eventContract;\n    function organizeEvent() public {\n        bool organized = eventContract.call(abi.encodeWithSignature(\"organize()\"));\n    }\n    function extraData(int data) public pure returns (int) {\n        return data * 2;\n    }\n}",
          "error message": ":1:123: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... n organizeEvent() public {         bool organized = eventContract.call(abi.encodeWithSignature(\"organize()\"));     }     function extraData(int  ...\n                                        ^------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ProjectDeployer {\n    address projectContract;\n    function deployProject() public {\n        bool deployed = projectContract.call(abi.encodeWithSignature(\"deploy()\"));\n    }\n    function unrelatedFunction9() public {\n    }\n    function randomUtilization() public pure returns (string memory) {\n        return \"Utilized\";\n    }\n}",
          "error message": ":1:126: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... n deployProject() public {         bool deployed = projectContract.call(abi.encodeWithSignature(\"deploy()\"));     }     function unrelatedFunct ...\n                                        ^-----------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract AssetTracker {\n    address registryContract;\n    function trackAsset() public {\n        (bool tracked, ) = registryContract.call(abi.encodeWithSignature(\"track()\"));\n    }\n    function extraDetails() public pure returns (string memory) {\n        return \"Additional Details\";\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract HealthRecordSystem {\n    address healthContract;\n    function updateRecord() public {\n        (bool updated, ) = healthContract.call(abi.encodeWithSignature(\"update()\"));\n    }\n    function unrelatedFunction6() private {\n    }\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract CryptoExchange {\n    address exchangeContract;\n    function performTrade() public {\n        (bool traded, ) = exchangeContract.call(abi.encodeWithSignature(\"trade()\"));\n    }\n    function randomValue(uint256 value) public pure returns (uint256) {\n        return value * 42;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract VotingSystem {\n    address votingContract;\n    function castVote() public {\n        (bool voteCasted, ) = votingContract.call(abi.encodeWithSignature(\"vote()\"));\n    }\n    function logEvent(string memory event) public pure returns (string memory) {\n        return event;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ContentManagement {\n    address contentContract;\n    function publishContent() public {\n        (bool published, ) = contentContract.call(abi.encodeWithSignature(\"publish()\"));\n    }\n    function unrelatedFunction7() public {\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract LoyaltyProgram {\n    address loyaltyContract;\n    function redeemPoints() public {\n        (bool redeemed, ) = loyaltyContract.call(abi.encodeWithSignature(\"redeem()\"));\n    }\n    function randomTask1() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract TaskManager {\n    address taskContract;\n    function manageTask() public {\n        (bool managed, ) = taskContract.call(abi.encodeWithSignature(\"manage()\"));\n    }\n    function unrelatedFunction8() public {\n    }\n    function additionalHelper() public pure returns (uint) {\n        return 2024;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract AlertSystem {\n    address alertContract;\n    function triggerAlert() public {\n        (bool alerted, ) = alertContract.call(abi.encodeWithSignature(\"alert()\"));\n    }\n    function randomModifier() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract EventOrganizer {\n    address eventContract;\n    function organizeEvent() public {\n        (bool organized, ) = eventContract.call(abi.encodeWithSignature(\"organize()\"));\n    }\n    function extraData(int data) public pure returns (int) {\n        return data * 2;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ProjectDeployer {\n    address projectContract;\n    function deployProject() public {\n        (bool deployed, ) = projectContract.call(abi.encodeWithSignature(\"deploy()\"));\n    }\n    function unrelatedFunction9() public {\n    }\n    function randomUtilization() public pure returns (string memory) {\n        return \"Utilized\";\n    }\n}"
      }
    }
  },
  {
    "Changes29": {
      "Version Migration": "->0.5",
      "Knowledge": "Solidity now implements C99-style scoping rules for function local\nvariables, that is, variables can only be used after they have been\ndeclared and only in the same or nested scopes. Variables declared in the\ninitialization block of a <code>for</code> loop are valid at any point inside the\nloop.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleEleven {\n    function totalValue() public pure returns (uint) {\n        uint total = 11;\n        { uint l = total; }\n        return l;\n    }\n    function helperOne() public pure returns (bool) { return false; }\n}",
          "error message": ":1:172: DeclarationError: Undeclared identifier.\n ... { uint l = total; }         return l;     }     function helperOne() pu ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleTwelve {\n    function deriveProduct() public pure returns (uint) {\n        uint product = 12;\n        { uint m = product; }\n        return m;\n    }\n    function helperTwo() public pure {}\n    function irrelevant() public pure returns (int) { return 100; }\n}",
          "error message": ":1:179: DeclarationError: Undeclared identifier.\n ... uint m = product; }         return m;     }     function helperTwo() pu ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleThirteen {\n    function countItems() public pure returns (uint) {\n        uint count = 13;\n        { uint n = count; }\n        return n;\n    }\n    function randomAction() public pure {}\n    function extraMethod() public pure returns (uint) { return 55; }\n}",
          "error message": ":1:174: DeclarationError: Undeclared identifier.\n ... { uint n = count; }         return n;     }     function randomAction() ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleFourteen {\n    function sumDigits() public pure returns (uint) {\n        uint sum = 14;\n        { uint o = sum; }\n        return o;\n    }\n    function computeAgain() public pure returns (int) { return -14; }\n}",
          "error message": ":1:169: DeclarationError: Undeclared identifier.\n ...   { uint o = sum; }         return o;     }     function computeAgain() ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleFifteen {\n    function getDataCount() public pure returns (uint) {\n        uint data = 15;\n        { uint p = data; }\n        return p;\n    }\n    function anotherHelper() public pure {}\n    function logSomething() public pure {}\n}",
          "error message": ":1:173: DeclarationError: Undeclared identifier.\n ...  { uint p = data; }         return p;     }     function anotherHelper( ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleSixteen {\n    function evaluateCondition() public pure returns (uint) {\n        uint condition = 16;\n        { uint q = condition; }\n        return q;\n    }\n    function extraEval() public pure returns (string memory) { return \"Extra Eval\"; }\n}",
          "error message": ":1:188: DeclarationError: Undeclared identifier.\n ... nt q = condition; }         return q;     }     function extraEval() pu ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleSeventeen {\n    function findElement() public pure returns (uint) {\n        uint element = 17;\n        { uint r = element; }\n        return r;\n    }\n    function unusedHelper() public pure {}\n    function extraHelper() public pure {}\n    function voidMethod() public {}\n}",
          "error message": ":1:180: DeclarationError: Undeclared identifier.\n ... uint r = element; }         return r;     }     function unusedHelper() ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleEighteen {\n    function generateNumber() public pure returns (uint) {\n        uint number = 18;\n        { uint s = number; }\n        return s;\n    }\n    function processSomething() public pure {}\n}",
          "error message": ":1:180: DeclarationError: Undeclared identifier.\n ...  uint s = number; }         return s;     }     function processSomethi ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleNineteen {\n    function calculateArea() public pure returns (uint) {\n        uint area = 19;\n        { uint t = area; }\n        return t;\n    }\n    function debugArea() public pure returns (uint) { return 190; }\n}",
          "error message": ":1:175: DeclarationError: Undeclared identifier.\n ...  { uint t = area; }         return t;     }     function debugArea() pu ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleTwenty {\n    function determineLength() public pure returns (uint) {\n        uint length = 20;\n        { uint u = length; }\n        return u;\n    }\n    function randomFunctionality() public pure {}\n    function anotherFunction() public pure returns (string memory) { return \"Lengthy\"; }\n}",
          "error message": ":1:179: DeclarationError: Undeclared identifier.\n ...  uint u = length; }         return u;     }     function randomFunction ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ExampleEleven {\n    function totalValue() public pure returns (uint) {\n        uint total = 11;\n        uint l = total;\n        return l;\n    }\n    function helperOne() public pure returns (bool) { return false; }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ExampleTwelve {\n    function deriveProduct() public pure returns (uint) {\n        uint product = 12;\n        uint m = product;\n        return m;\n    }\n    function helperTwo() public pure {}\n    function irrelevant() public pure returns (int) { return 100; }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ExampleThirteen {\n    function countItems() public pure returns (uint) {\n        uint count = 13;\n        uint n = count;\n        return n;\n    }\n    function randomAction() public pure {}\n    function extraMethod() public pure returns (uint) { return 55; }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ExampleFourteen {\n    function sumDigits() public pure returns (uint) {\n        uint sum = 14;\n        uint o = sum;\n        return o;\n    }\n    function computeAgain() public pure returns (int) { return -14; }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ExampleFifteen {\n    function getDataCount() public pure returns (uint) {\n        uint data = 15;\n        uint p = data;\n        return p;\n    }\n    function anotherHelper() public pure {}\n    function logSomething() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ExampleSixteen {\n    function evaluateCondition() public pure returns (uint) {\n        uint condition = 16;\n        uint q = condition;\n        return q;\n    }\n    function extraEval() public pure returns (string memory) { return \"Extra Eval\"; }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ExampleSeventeen {\n    function findElement() public pure returns (uint) {\n        uint element = 17;\n        uint r = element;\n        return r;\n    }\n    function unusedHelper() public pure {}\n    function extraHelper() public pure {}\n    function voidMethod() public {}\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ExampleEighteen {\n    function generateNumber() public pure returns (uint) {\n        uint number = 18;\n        uint s = number;\n        return s;\n    }\n    function processSomething() public pure {}\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ExampleNineteen {\n    function calculateArea() public pure returns (uint) {\n        uint area = 19;\n        uint t = area;\n        return t;\n    }\n    function debugArea() public pure returns (uint) { return 190; }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ExampleTwenty {\n    function determineLength() public pure returns (uint) {\n        uint length = 20;\n        uint u = length;\n        return u;\n    }\n    function randomFunctionality() public pure {}\n    function anotherFunction() public pure returns (string memory) { return \"Lengthy\"; }\n}"
      }
    }
  },
  {
    "Changes30": {
      "Version Migration": "->0.5",
      "Knowledge": "Explicit function visibility is now mandatory.  Add <code>public</code> to every\nfunction and constructor, and <code>external</code> to every fallback or interface\nfunction that does not specify its visibility already.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractOne {\n    function addValues(uint x, uint y) returns(uint) {\n        return x + y;\n    }\n}",
          "error message": ":1:51: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ContractOne {     function addValues(uint x, uint y) returns(uint) {         return x + y;     } }\n                                                  ^----------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractTwo {\n    function subtract(int a, int b) returns(int) {\n        return a - b;\n    }\n    function noop() public pure {}\n}",
          "error message": ":1:51: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... ^0.5.0; contract ContractTwo {     function subtract(int a, int b) returns(int) {         return a - b;     }     function noop() public pure {} ...\n                                        ^------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractThree {\n    function multiplyValues(uint value, uint multiplier) returns(uint) {\n        return value * multiplier;\n    }\n    function dummyFunction() public pure returns(string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:53: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... .5.0; contract ContractThree {     function multiplyValues(uint value, uint multiplier) returns(uint) {         return value * multiplier;     }     function dummyFunction() publi ...\n                                        ^-----------------------------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractFour {\n    function divideNumbers(uint num1, uint num2) returns(uint) {\n        return num1 / num2;\n    }\n}",
          "error message": ":1:52: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ContractFour {     function divideNumbers(uint num1, uint num2) returns(uint) {         return num1 / num2;     } }\n                                                   ^--------------------------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractFive {\n    function getBoolean() returns(bool result) {\n        return true;\n    }\n    function extra() public pure {}\n    function extraTwo() public pure {}\n}",
          "error message": ":1:52: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... 0.5.0; contract ContractFive {     function getBoolean() returns(bool result) {         return true;     }     function extra() public pure { ...\n                                        ^---------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractSix {\n    function checkEven(uint num) returns(bool) {\n        return num % 2 == 0;\n    }\n}",
          "error message": ":1:51: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ContractSix {     function checkEven(uint num) returns(bool) {         return num % 2 == 0;     } }\n                                                  ^-----------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractSeven {\n    function setString(string memory newStr) returns(string memory) {\n        return newStr;\n    }\n    function anotherFunction() private pure {}\n}",
          "error message": ":1:53: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... .5.0; contract ContractSeven {     function setString(string memory newStr) returns(string memory) {         return newStr;     }     function anotherFunction() pri ...\n                                        ^--------------------------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractEight {\n    function processValue(uint input) returns(uint) {\n        return input * 100;\n    }\n}",
          "error message": ":1:53: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ContractEight {     function processValue(uint input) returns(uint) {         return input * 100;     } }\n                                                    ^---------------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractNine {\n    function toggleSwitch(bool currentState) returns(bool) {\n        return !currentState;\n    }\n    function helper() public pure returns(bool) {\n        return true;\n    }\n}",
          "error message": ":1:52: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... 0.5.0; contract ContractNine {     function toggleSwitch(bool currentState) returns(bool) {         return !currentState;     }     function helper() public pure  ...\n                                        ^------------------------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractTen {\n    function calculateSum(int value1, int value2) returns(int) {\n        return value1 + value2;\n    }\n}",
          "error message": ":1:51: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ContractTen {     function calculateSum(int value1, int value2) returns(int) {         return value1 + value2;     } }\n                                                  ^------------------------------------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ContractOne {\n    function addValues(uint x, uint y) public returns(uint) {\n        return x + y;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ContractTwo {\n    function subtract(int a, int b) public returns(int) {\n        return a - b;\n    }\n    function noop() public pure {}\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ContractThree {\n    function multiplyValues(uint value, uint multiplier) public returns(uint) {\n        return value * multiplier;\n    }\n    function dummyFunction() public pure returns(string memory) {\n        return \"Hello\";\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ContractFour {\n    function divideNumbers(uint num1, uint num2) public returns(uint) {\n        return num1 / num2;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ContractFive {\n    function getBoolean() public returns(bool result) {\n        return true;\n    }\n    function extra() public pure {}\n    function extraTwo() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ContractSix {\n    function checkEven(uint num) public returns(bool) {\n        return num % 2 == 0;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ContractSeven {\n    function setString(string memory newStr) public returns(string memory) {\n        return newStr;\n    }\n    function anotherFunction() private pure {}\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ContractEight {\n    function processValue(uint input) public returns(uint) {\n        return input * 100;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ContractNine {\n    function toggleSwitch(bool currentState) public returns(bool) {\n        return !currentState;\n    }\n    function helper() public pure returns(bool) {\n        return true;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ContractTen {\n    function calculateSum(int value1, int value2) public returns(int) {\n        return value1 + value2;\n    }\n}"
      }
    }
  },
  {
    "Changes31": {
      "Version Migration": "->0.5",
      "Knowledge": "Explicit conversions between unrelated contract types are now disallowed. You can only\nconvert from a contract type to one of its base or ancestor types. If you are sure that\na contract is compatible with the contract type you want to convert to, although it does not\ninherit from it, you can work around this by converting to <code>address</code> first.\nExample: if <code>A</code> and <code>B</code> are contract types, <code>B</code> does not inherit from <code>A</code> and\n<code>b</code> is a contract of type <code>B</code>, you can still convert <code>b</code> to type <code>A</code> using <code>A(address(b))</code>.\nNote that you still need to watch out for matching payable fallback functions, as explained below.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract Circle {\n    function spin() public pure returns (string memory) { return \"Circle Spin\"; }\n}\ncontract Square {\n    function draw() public pure returns (string memory) { return \"Square Draw\"; }\n}\ncontract Shape {\n    Square sq = new Square();\n    function shapeShift() public view returns (string memory) {\n        Circle cir = Circle(sq);\n        return cir.spin();\n    }\n}",
          "error message": ":1:360: TypeError: Explicit type conversion not allowed from \"contract Square\" to \"contract Circle\".\n ... ing memory) {         Circle cir = Circle(sq);         return cir.spin();     }  ...\n                                        ^--------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract Rocket {\n    function launch() public pure returns (string memory) { return \"Rocket Launch\"; }\n}\ncontract Satellite {\n    function orbit() public pure returns (string memory) { return \"Satellite Orbit\"; }\n}\ncontract Space {\n    Satellite sat = new Satellite();\n    function spaceTravel() public view returns (string memory) {\n        Rocket roc = Rocket(sat);\n        return roc.launch();\n    }\n}",
          "error message": ":1:380: TypeError: Explicit type conversion not allowed from \"contract Satellite\" to \"contract Rocket\".\n ... ing memory) {         Rocket roc = Rocket(sat);         return roc.launch();      ...\n                                        ^---------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract Flashlight {\n    function illuminate() public pure returns (string memory) { return \"Light On\"; }\n}\ncontract Battery {\n    function charge() public pure returns (string memory) { return \"Battery Charge\"; }\n}\ncontract Electronics {\n    Battery bat = new Battery();\n    function powerUp() public view returns (string memory) {\n        Flashlight fl = Flashlight(bat);\n        return fl.illuminate();\n    }\n}",
          "error message": ":1:382: TypeError: Explicit type conversion not allowed from \"contract Battery\" to \"contract Flashlight\".\n ...  memory) {         Flashlight fl = Flashlight(bat);         return fl.illuminate();   ...\n                                        ^-------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Pen {\n    function write() public pure returns (string memory) { return \"Pen Write\"; }\n}\ncontract Pencil {\n    function sketch() public pure returns (string memory) { return \"Pencil Sketch\"; }\n}\ncontract Stationery {\n    Pencil pen = new Pencil();\n    function drawArt() public view returns (string memory) {\n        Pen p = Pen(pen);\n        return p.write();\n    }\n    function extraTool() public pure {}\n}",
          "error message": ":1:358: TypeError: Explicit type conversion not allowed from \"contract Pencil\" to \"contract Pen\".\n ...  (string memory) {         Pen p = Pen(pen);         return p.write();     }   ...\n                                        ^------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract Coffee {\n    function brew() public pure returns (string memory) { return \"Coffee Brew\"; }\n}\ncontract Tea {\n    function steep() public pure returns (string memory) { return \"Tea Steep\"; }\n}\ncontract Beverage {\n    Tea t = new Tea();\n    function prepareDrink() public view returns (string memory) {\n        Coffee c = Coffee(t);\n        return c.brew();\n    }\n}",
          "error message": ":1:352: TypeError: Explicit type conversion not allowed from \"contract Tea\" to \"contract Coffee\".\n ... tring memory) {         Coffee c = Coffee(t);         return c.brew();     } }\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Planet {\n    function rotate() public pure returns (string memory) { return \"Planet Rotate\"; }\n}\ncontract Star {\n    function shine() public pure returns (string memory) { return \"Star Shine\"; }\n}\ncontract Cosmos {\n    Star s = new Star();\n    function viewSky() public view returns (string memory) {\n        Planet p = Planet(s);\n        return p.rotate();\n    }\n}",
          "error message": ":1:353: TypeError: Explicit type conversion not allowed from \"contract Star\" to \"contract Planet\".\n ... tring memory) {         Planet p = Planet(s);         return p.rotate();     }  ...\n                                        ^-------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract Guitar {\n    function strum() public pure returns (string memory) { return \"Guitar Strum\"; }\n}\ncontract Violin {\n    function play() public pure returns (string memory) { return \"Violin Play\"; }\n}\ncontract Music {\n    Violin v = new Violin();\n    function concert() public view returns (string memory) {\n        Guitar g = Guitar(v);\n        return g.strum();\n    }\n}",
          "error message": ":1:356: TypeError: Explicit type conversion not allowed from \"contract Violin\" to \"contract Guitar\".\n ... tring memory) {         Guitar g = Guitar(v);         return g.strum();     } }\n                                        ^-------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract Cloud {\n    function rain() public pure returns (string memory) { return \"Cloud Rain\"; }\n}\ncontract Wind {\n    function blow() public pure returns (string memory) { return \"Wind Blow\"; }\n}\ncontract Weather {\n    Wind w = new Wind();\n    function weatherReport() public view returns (string memory) {\n        Cloud c = Cloud(w);\n        return c.rain();\n    }\n    function extraData() public pure {}\n}",
          "error message": ":1:351: TypeError: Explicit type conversion not allowed from \"contract Wind\" to \"contract Cloud\".\n ... string memory) {         Cloud c = Cloud(w);         return c.rain();     }    ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract Shirt {\n    function wear() public pure returns (string memory) { return \"Shirt Wear\"; }\n}\ncontract Hat {\n    function putOn() public pure returns (string memory) { return \"Hat Put On\"; }\n}\ncontract Clothing {\n    Hat h = new Hat();\n    function dressUp() public view returns (string memory) {\n        Shirt s = Shirt(h);\n        return s.wear();\n    }\n}",
          "error message": ":1:345: TypeError: Explicit type conversion not allowed from \"contract Hat\" to \"contract Shirt\".\n ... string memory) {         Shirt s = Shirt(h);         return s.wear();     } }\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract Cheese {\n    function slice() public pure returns (string memory) { return \"Cheese Slice\"; }\n}\ncontract Bread {\n    function bake() public pure returns (string memory) { return \"Bread Bake\"; }\n}\ncontract Food {\n    Bread b = new Bread();\n    function makeSandwich() public view returns (string memory) {\n        Cheese c = Cheese(b);\n        return c.slice();\n    }\n}",
          "error message": ":1:356: TypeError: Explicit type conversion not allowed from \"contract Bread\" to \"contract Cheese\".\n ... tring memory) {         Cheese c = Cheese(b);         return c.slice();     } }\n                                        ^-------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract Circle {\n    function spin() public pure returns (string memory) { return \"Circle Spin\"; }\n}\ncontract Square {\n    function draw() public pure returns (string memory) { return \"Square Draw\"; }\n}\ncontract Shape {\n    Square sq = new Square();\n    function shapeShift() public view returns (string memory) {\n        Circle cir = Circle(address(sq));\n        return cir.spin();\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract Rocket {\n    function launch() public pure returns (string memory) { return \"Rocket Launch\"; }\n}\ncontract Satellite {\n    function orbit() public pure returns (string memory) { return \"Satellite Orbit\"; }\n}\ncontract Space {\n    Satellite sat = new Satellite();\n    function spaceTravel() public view returns (string memory) {\n        Rocket roc = Rocket(address(sat));\n        return roc.launch();\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract Flashlight {\n    function illuminate() public pure returns (string memory) { return \"Light On\"; }\n}\ncontract Battery {\n    function charge() public pure returns (string memory) { return \"Battery Charge\"; }\n}\ncontract Electronics {\n    Battery bat = new Battery();\n    function powerUp() public view returns (string memory) {\n        Flashlight fl = Flashlight(address(bat));\n        return fl.illuminate();\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Pen {\n    function write() public pure returns (string memory) { return \"Pen Write\"; }\n}\ncontract Pencil {\n    function sketch() public pure returns (string memory) { return \"Pencil Sketch\"; }\n}\ncontract Stationery {\n    Pencil pen = new Pencil();\n    function drawArt() public view returns (string memory) {\n        Pen p = Pen(address(pen));\n        return p.write();\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract Coffee {\n    function brew() public pure returns (string memory) { return \"Coffee Brew\"; }\n}\ncontract Tea {\n    function steep() public pure returns (string memory) { return \"Tea Steep\"; }\n}\ncontract Beverage {\n    Tea t = new Tea();\n    function prepareDrink() public view returns (string memory) {\n        Coffee c = Coffee(address(t));\n        return c.brew();\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Planet {\n    function rotate() public pure returns (string memory) { return \"Planet Rotate\"; }\n}\ncontract Star {\n    function shine() public pure returns (string memory) { return \"Star Shine\"; }\n}\ncontract Cosmos {\n    Star s = new Star();\n    function viewSky() public view returns (string memory) {\n        Planet p = Planet(address(s));\n        return p.rotate();\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract Guitar {\n    function strum() public pure returns (string memory) { return \"Guitar Strum\"; }\n}\ncontract Violin {\n    function play() public pure returns (string memory) { return \"Violin Play\"; }\n}\ncontract Music {\n    Violin v = new Violin();\n    function concert() public view returns (string memory) {\n        Guitar g = Guitar(address(v));\n        return g.strum();\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract Cloud {\n    function rain() public pure returns (string memory) { return \"Cloud Rain\"; }\n}\ncontract Wind {\n    function blow() public pure returns (string memory) { return \"Wind Blow\"; }\n}\ncontract Weather {\n    Wind w = new Wind();\n    function weatherReport() public view returns (string memory) {\n        Cloud c = Cloud(address(w));\n        return c.rain();\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract Shirt {\n    function wear() public pure returns (string memory) { return \"Shirt Wear\"; }\n}\ncontract Hat {\n    function putOn() public pure returns (string memory) { return \"Hat Put On\"; }\n}\ncontract Clothing {\n    Hat h = new Hat();\n    function dressUp() public view returns (string memory) {\n        Shirt s = Shirt(address(h));\n        return s.wear();\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract Cheese {\n    function slice() public pure returns (string memory) { return \"Cheese Slice\"; }\n}\ncontract Bread {\n    function bake() public pure returns (string memory) { return \"Bread Bake\"; }\n}\ncontract Food {\n    Bread b = new Bread();\n    function makeSandwich() public view returns (string memory) {\n        Cheese c = Cheese(address(b));\n        return c.slice();\n    }\n}"
      }
    }
  },
  {
    "Changes32": {
      "Version Migration": "->0.5",
      "Knowledge": "The <code>address</code> type  was split into <code>address</code> and <code>address payable</code>,\nwhere only <code>address payable</code> provides the <code>transfer</code> function.  An\n<code>address payable</code> can be directly converted to an <code>address</code>, but the\nother way around is not allowed. Converting <code>address</code> to <code>address\npayable</code> is possible via conversion through <code>uint160</code>. If <code>c</code> is a\ncontract, <code>address(c)</code> results in <code>address payable</code> only if <code>c</code> has a\npayable fallback function. If you use the <a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/common-patterns.html#withdrawal-pattern\"><span class=\"std std-ref\">withdraw pattern</a>,\nyou most likely do not have to change your code because <code>transfer</code>\nis only used on <code>msg.sender</code> instead of stored addresses and <code>msg.sender</code>\nis an <code>address payable</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract WalletHandler {\n    address walletOwner;\n    constructor() public { walletOwner = msg.sender; }\n    function executeWithdrawal(uint amount) public { walletOwner.transfer(amount); }\n    function logThis() public { }\n    function randomFunction() public pure {}\n}",
          "error message": ":1:182: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... teWithdrawal(uint amount) public { walletOwner.transfer(amount); }     function logThis()  ...\n                                        ^------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract FundsController {\n    address fundManager;\n    constructor() public { fundManager = msg.sender; }\n    function triggerPayment(uint value) public { fundManager.transfer(value); }\n    function extraMethod() public { }\n    function additionalMethod() public pure returns (bool) { return true; }\n}",
          "error message": ":1:180: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... riggerPayment(uint value) public { fundManager.transfer(value); }     function extraMethod ...\n                                        ^------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract FinancialOperations {\n    address treasurer;\n    constructor() public { treasurer = msg.sender; }\n    function disburseAmount(uint256 amount) public { treasurer.transfer(amount); }\n    function logEvent() public pure returns (string memory) { return \"Logged\"; }\n}",
          "error message": ":1:184: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... rseAmount(uint256 amount) public { treasurer.transfer(amount); }     function logEvent() ...\n                                        ^----------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract PaymentAdmin {\n    address payable adminAccount;\n    constructor() public { adminAccount = msg.sender; }\n    function sendOutPayment(uint total) public { adminAccount.transfer(total); }\n    function logTransaction() public { }\n    function noteActivity() public pure {}\n}",
          "error message": ""
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract BudgetManager {\n    address financialOfficer;\n    constructor() public { financialOfficer = msg.sender; }\n    function releaseFunds(uint funds) public { financialOfficer.transfer(funds); }\n    function additionalTask() public pure returns (int) { return 1; }\n}",
          "error message": ":1:186: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ...  releaseFunds(uint funds) public { financialOfficer.transfer(funds); }     function additionalT ...\n                                        ^-----------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Treasury {\n    address secretary;\n    constructor() public { secretary = msg.sender; }\n    function issueFunds(uint256 amount) public { secretary.transfer(amount); }\n    function keepRecords() public { }\n}",
          "error message": ":1:169: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... ssueFunds(uint256 amount) public { secretary.transfer(amount); }     function keepRecord ...\n                                        ^----------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract PaymentDispatcher {\n    address account;\n    constructor() public { account = msg.sender; }\n    function dispatchFunds(uint value) public { account.transfer(value); }\n    function recordDetails() public { }\n    function extraHelper() public pure returns (bool) { return false; }\n}",
          "error message": ":1:173: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... dispatchFunds(uint value) public { account.transfer(value); }     function recordDetai ...\n                                        ^--------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract CapitalManager {\n    address capitalHolder;\n    constructor() public { capitalHolder = msg.sender; }\n    function manageWithdrawal(uint amount) public { capitalHolder.transfer(amount); }\n    function trackTransaction() public { }\n}",
          "error message": ":1:186: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... geWithdrawal(uint amount) public { capitalHolder.transfer(amount); }     function trackTrans ...\n                                        ^--------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract RevenueCollector {\n    address revenueOfficer;\n    constructor() public { revenueOfficer = msg.sender; }\n    function collectRevenue(uint value) public { revenueOfficer.transfer(value); }\n    function logOperation() public { }\n    function helperFunction() public pure {}\n}",
          "error message": ":1:187: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... ollectRevenue(uint value) public { revenueOfficer.transfer(value); }     function logOperatio ...\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract CashFlowController {\n    address controller;\n    constructor() public { controller = msg.sender; }\n    function processFlow(uint cashAmount) public { controller.transfer(cashAmount); }\n    function logFlow() public { }\n    function auxiliary() public pure {}\n}",
          "error message": ":1:183: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... cessFlow(uint cashAmount) public { controller.transfer(cashAmount); }     function logFlo ...\n                                        ^-----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract WalletHandler {\n    address payable walletOwner;\n    constructor() public { walletOwner = msg.sender; }\n    function executeWithdrawal(uint amount) public { walletOwner.transfer(amount); }\n    function logThis() public { }\n    function randomFunction() public pure {}\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract FundsController {\n    address payable fundManager;\n    constructor() public { fundManager = msg.sender; }\n    function triggerPayment(uint value) public { fundManager.transfer(value); }\n    function extraMethod() public { }\n    function additionalMethod() public pure returns (bool) { return true; }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract FinancialOperations {\n    address payable treasurer;\n    constructor() public { treasurer = msg.sender; }\n    function disburseAmount(uint256 amount) public { treasurer.transfer(amount); }\n    function logEvent() public pure returns (string memory) { return \"Logged\"; }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract PaymentAdmin {\n    address payable adminAccount;\n    constructor() public { adminAccount = msg.sender; }\n    function sendOutPayment(uint total) public { adminAccount.transfer(total); }\n    function logTransaction() public { }\n    function noteActivity() public pure {}\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract BudgetManager {\n    address payable financialOfficer;\n    constructor() public { financialOfficer = msg.sender; }\n    function releaseFunds(uint funds) public { financialOfficer.transfer(funds); }\n    function additionalTask() public pure returns (int) { return 1; }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Treasury {\n    address payable secretary;\n    constructor() public { secretary = msg.sender; }\n    function issueFunds(uint256 amount) public { secretary.transfer(amount); }\n    function keepRecords() public { }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract PaymentDispatcher {\n    address payable account;\n    constructor() public { account = msg.sender; }\n    function dispatchFunds(uint value) public { account.transfer(value); }\n    function recordDetails() public { }\n    function extraHelper() public pure returns (bool) { return false; }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract CapitalManager {\n    address payable capitalHolder;\n    constructor() public { capitalHolder = msg.sender; }\n    function manageWithdrawal(uint amount) public { capitalHolder.transfer(amount); }\n    function trackTransaction() public { }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract RevenueCollector {\n    address payable revenueOfficer;\n    constructor() public { revenueOfficer = msg.sender; }\n    function collectRevenue(uint value) public { revenueOfficer.transfer(value); }\n    function logOperation() public { }\n    function helperFunction() public pure {}\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract CashFlowController {\n    address payable controller;\n    constructor() public { controller = msg.sender; }\n    function processFlow(uint cashAmount) public { controller.transfer(cashAmount); }\n    function logFlow() public { }\n    function auxiliary() public pure {}\n}"
      }
    }
  },
  {
    "Changes33": {
      "Version Migration": "->0.5",
      "Knowledge": "Conversions between <code>bytesX</code> and <code>uintY</code> of different size are now\ndisallowed due to <code>bytesX</code> padding on the right and <code>uintY</code> padding on\nthe left which may cause unexpected conversion results.  The size must now be\nadjusted within the type before the conversion.  For example, you can convert\na <code>bytes4</code> (4 bytes) to a <code>uint64</code> (8 bytes) by first converting the\n<code>bytes4</code> variable to <code>bytes8</code> and then to <code>uint64</code>. You get the\nopposite padding when converting through <code>uint32</code>. Before v0.5.0 any\nconversion between <code>bytesX</code> and <code>uintY</code> would go through <code>uint8X</code>. For\nexample <code>uint8(bytes3(0x291807))</code> would be converted to <code>uint8(uint24(bytes3(0x291807)))</code>\n(the result is <code>0x07</code>).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionOne {\n    function convertOne() public pure returns (uint) {\n        bytes3 b = 0x123456;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:154: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x123456;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionTwo {\n    function convertTwo() public pure returns (uint) {\n        bytes3 b = 0xabcdef;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function dummy() public pure {}\n}",
          "error message": ":1:154: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xabcdef;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionThree {\n    function convertThree() public pure returns (uint) {\n        bytes3 b = 0xfedcba;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function dummy() public pure {}\n    function dummyTwo() public pure {}\n}",
          "error message": ":1:158: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xfedcba;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionFour {\n    function convertFour() public pure returns (uint) {\n        bytes3 b = 0x456789;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:156: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x456789;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionFive {\n    function quickConvert() public pure returns (uint) {\n        bytes3 b = 0x998877;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function nonRelated() public pure {}\n}",
          "error message": ":1:157: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x998877;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionSix {\n    function dataChange() public pure returns (uint) {\n        bytes3 b = 0xa1b2c3;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:154: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xa1b2c3;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionSeven {\n    function shiftBytes() public pure returns (uint) {\n        bytes3 b = 0x1a2b3c;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:156: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x1a2b3c;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionEight {\n    function byteToUint() public pure returns (uint) {\n        bytes3 b = 0xabcdef;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function extraFunc() public pure {}\n}",
          "error message": ":1:156: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xabcdef;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionNine {\n    function transformData() public pure returns (uint) {\n        bytes3 b = 0x123abc;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function extraOne() public pure {}\n    function extraTwo() public pure {}\n}",
          "error message": ":1:158: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x123abc;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionTen {\n    function finalConvert() public pure returns (uint) {\n        bytes3 b = 0xabc123;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:156: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xabc123;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ConversionOne {\n    function convertOne() public pure returns (uint) {\n        bytes3 b = 0x123456;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ConversionTwo {\n    function convertTwo() public pure returns (uint) {\n        bytes3 b = 0xabcdef;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function dummy() public pure {}\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ConversionThree {\n    function convertThree() public pure returns (uint) {\n        bytes3 b = 0xfedcba;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function dummy() public pure {}\n    function dummyTwo() public pure {}\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ConversionFour {\n    function convertFour() public pure returns (uint) {\n        bytes3 b = 0x456789;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ConversionFive {\n    function quickConvert() public pure returns (uint) {\n        bytes3 b = 0x998877;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function nonRelated() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ConversionSix {\n    function dataChange() public pure returns (uint) {\n        bytes3 b = 0xa1b2c3;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ConversionSeven {\n    function shiftBytes() public pure returns (uint) {\n        bytes3 b = 0x1a2b3c;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ConversionEight {\n    function byteToUint() public pure returns (uint) {\n        bytes3 b = 0xabcdef;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function extraFunc() public pure {}\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ConversionNine {\n    function transformData() public pure returns (uint) {\n        bytes3 b = 0x123abc;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function extraOne() public pure {}\n    function extraTwo() public pure {}\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ConversionTen {\n    function finalConvert() public pure returns (uint) {\n        bytes3 b = 0xabc123;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}"
      }
    }
  },
  {
    "Changes34": {
      "Version Migration": "->0.5",
      "Knowledge": "Using <code>msg.value</code> in non-payable functions (or introducing it via a\nmodifier) is disallowed as a security feature. Turn the function into\n<code>payable</code> or create a new internal function for the program logic that\nuses <code>msg.value</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract DepositTracker {\n    uint public totalDeposits;\n    function addDeposit() public {\n        totalDeposits += msg.value;\n    }\n    function getDeposit() public view returns (uint) {\n        return totalDeposits;\n    }\n}",
          "error message": ":1:141: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ...  public {         totalDeposits += msg.value;     }     function getDeposit() p ...\n                                        ^-------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract AssetManager {\n    uint public assetTotal;\n    function accumulateAssets() public {\n        assetTotal += msg.value;\n    }\n}",
          "error message": ":1:139: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... s() public {         assetTotal += msg.value;     } }\n                                        ^-------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract InvestmentPool {\n    uint public investmentSum;\n    function poolInvestment() public {\n        investmentSum += msg.value;\n    }\n    function retrieveInvestment() public view returns (uint) {\n        return investmentSum;\n    }\n}",
          "error message": ":1:145: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ...  public {         investmentSum += msg.value;     }     function retrieveInvest ...\n                                        ^-------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract CharityFund {\n    uint public charityAmount;\n    function receiveCharity() public {\n        charityAmount += msg.value;\n    }\n}",
          "error message": ":1:142: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ...  public {         charityAmount += msg.value;     } }\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract FinanceTracker {\n    uint public financeTotal;\n    function addFinance() public {\n        financeTotal += msg.value;\n    }\n    function randomFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:139: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... ) public {         financeTotal += msg.value;     }     function randomFunction ...\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract BudgetControl {\n    uint public budgetTotal;\n    function increaseBudget() public {\n        budgetTotal += msg.value;\n    }\n}",
          "error message": ":1:140: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... () public {         budgetTotal += msg.value;     } }\n                                        ^-------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract CashFlow {\n    uint public cashFlowTotal;\n    function addCashFlow() public {\n        cashFlowTotal += msg.value;\n    }\n}",
          "error message": ":1:136: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ...  public {         cashFlowTotal += msg.value;     } }\n                                        ^-------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract RevenueStream {\n    uint public revenue;\n    function increaseRevenue() public {\n        revenue += msg.value;\n    }\n    function anotherExtraFunction() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:133: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... enue() public {         revenue += msg.value;     }     function anotherExtraFu ...\n                                        ^-------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract CashCollection {\n    uint public collectionTotal;\n    function collectCash() public {\n        collectionTotal += msg.value;\n    }\n}",
          "error message": ":1:146: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... ublic {         collectionTotal += msg.value;     } }\n                                        ^-------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract FundCollector {\n    uint public collectedFunds;\n    function collectFunds() public {\n        collectedFunds += msg.value;\n    }\n}",
          "error message": ":1:144: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... public {         collectedFunds += msg.value;     } }\n                                        ^-------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract DepositTracker {\n    uint public totalDeposits;\n    function addDeposit() public payable {\n        totalDeposits += msg.value;\n    }\n    function getDeposit() public view returns (uint) {\n        return totalDeposits;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract AssetManager {\n    uint public assetTotal;\n    function accumulateAssets() public payable {\n        assetTotal += msg.value;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract InvestmentPool {\n    uint public investmentSum;\n    function poolInvestment() public payable {\n        investmentSum += msg.value;\n    }\n    function retrieveInvestment() public view returns (uint) {\n        return investmentSum;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract CharityFund {\n    uint public charityAmount;\n    function receiveCharity() public payable {\n        charityAmount += msg.value;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract FinanceTracker {\n    uint public financeTotal;\n    function addFinance() public payable {\n        financeTotal += msg.value;\n    }\n    function randomFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract BudgetControl {\n    uint public budgetTotal;\n    function increaseBudget() public payable {\n        budgetTotal += msg.value;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract CashFlow {\n    uint public cashFlowTotal;\n    function addCashFlow() public payable {\n        cashFlowTotal += msg.value;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract RevenueStream {\n    uint public revenue;\n    function increaseRevenue() public payable {\n        revenue += msg.value;\n    }\n    function anotherExtraFunction() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract CashCollection {\n    uint public collectionTotal;\n    function collectCash() public payable {\n        collectionTotal += msg.value;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract FundCollector {\n    uint public collectedFunds;\n    function collectFunds() public payable {\n        collectedFunds += msg.value;\n    }\n}"
      }
    }
  },
  {
    "Changes35": {
      "Version Migration": "->0.5",
      "Knowledge": "Constructors must now be defined using the <code>constructor</code> keyword.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract Garden {\n    uint public plantCount;\n    function Garden(uint initialPlants) public {\n        plantCount = initialPlants;\n    }\n    function plantTree() public {\n        plantCount += 1;\n    }\n}",
          "error message": ":1:74: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ...  {     uint public plantCount;     function Garden(uint initialPlants) public {         plantCount = initialPlants;     }     function plantTree() public {  ...\n                                        ^------------------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract Classroom {\n    uint public studentNumber;\n    function Classroom(uint initialStudents) public {\n        studentNumber = initialStudents;\n    }\n    function enrollStudent() public {\n        studentNumber += 1;\n    }\n    function dropStudent() public {\n        if (studentNumber > 0) {\n            studentNumber -= 1;\n        }\n    }\n}",
          "error message": ":1:80: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ...     uint public studentNumber;     function Classroom(uint initialStudents) public {         studentNumber = initialStudents;     }     function enrollStudent() publi ...\n                                        ^----------------------------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract BankAccount {\n    uint public balance;\n    function BankAccount(uint initialBalance) public {\n        balance = initialBalance;\n    }\n    function deposit(uint amount) public {\n        balance += amount;\n    }\n}",
          "error message": ":1:76: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... unt {     uint public balance;     function BankAccount(uint initialBalance) public {         balance = initialBalance;     }     function deposit(uint amount)  ...\n                                        ^----------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Clock {\n    uint public currentTime;\n    function Clock(uint startTime) public {\n        currentTime = startTime;\n    }\n    function setTime(uint newTime) public {\n        currentTime = newTime;\n    }\n}",
          "error message": ":1:74: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... {     uint public currentTime;     function Clock(uint startTime) public {         currentTime = startTime;     }     function setTime(uint newTime) ...\n                                        ^----------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract MusicPlayer {\n    uint public volume;\n    function MusicPlayer(uint initialVolume) public {\n        volume = initialVolume;\n    }\n    function increaseVolume() public {\n        volume += 10;\n    }\n    function decreaseVolume() public {\n        if (volume > 10) {\n            volume -= 10;\n        }\n    }\n}",
          "error message": ":1:75: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... ayer {     uint public volume;     function MusicPlayer(uint initialVolume) public {         volume = initialVolume;     }     function increaseVolume() publ ...\n                                        ^-------------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Painting {\n    uint public colorCount;\n    function Painting(uint initialColors) public {\n        colorCount = initialColors;\n    }\n    function addColor() public {\n        colorCount += 1;\n    }\n}",
          "error message": ":1:76: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ...  {     uint public colorCount;     function Painting(uint initialColors) public {         colorCount = initialColors;     }     function addColor() public {   ...\n                                        ^--------------------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract Wallet {\n    uint public coinCount;\n    function Wallet(uint initialCoins) public {\n        coinCount = initialCoins;\n    }\n    function addCoins(uint amount) public {\n        coinCount += amount;\n    }\n}",
          "error message": ":1:73: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... t {     uint public coinCount;     function Wallet(uint initialCoins) public {         coinCount = initialCoins;     }     function addCoins(uint amount) ...\n                                        ^---------------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract Chair {\n    uint public legCount;\n    function Chair(uint initialLegs) public {\n        legCount = initialLegs;\n    }\n    function addLeg() public {\n        legCount += 1;\n    }\n}",
          "error message": ":1:71: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... ir {     uint public legCount;     function Chair(uint initialLegs) public {         legCount = initialLegs;     }     function addLeg() public {     ...\n                                        ^-----------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract Basket {\n    uint public itemCount;\n    function Basket(uint initialItems) public {\n        itemCount = initialItems;\n    }\n    function addItem() public {\n        itemCount += 1;\n    }\n}",
          "error message": ":1:73: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... t {     uint public itemCount;     function Basket(uint initialItems) public {         itemCount = initialItems;     }     function addItem() public {    ...\n                                        ^---------------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract Refrigerator {\n    uint public temperature;\n    function Refrigerator(uint initialTemperature) public {\n        temperature = initialTemperature;\n    }\n    function coolDown() public {\n        temperature -= 5;\n    }\n}",
          "error message": ":1:81: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... {     uint public temperature;     function Refrigerator(uint initialTemperature) public {         temperature = initialTemperature;     }     function coolDown() public {   ...\n                                        ^-----------------------------------------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract Garden {\n    uint public plantCount;\n    constructor(uint initialPlants) public {\n        plantCount = initialPlants;\n    }\n    function plantTree() public {\n        plantCount += 1;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract Classroom {\n    uint public studentNumber;\n    constructor(uint initialStudents) public {\n        studentNumber = initialStudents;\n    }\n    function enrollStudent() public {\n        studentNumber += 1;\n    }\n    function dropStudent() public {\n        if (studentNumber > 0) {\n            studentNumber -= 1;\n        }\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract BankAccount {\n    uint public balance;\n    constructor(uint initialBalance) public {\n        balance = initialBalance;\n    }\n    function deposit(uint amount) public {\n        balance += amount;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Clock {\n    uint public currentTime;\n    constructor(uint startTime) public {\n        currentTime = startTime;\n    }\n    function setTime(uint newTime) public {\n        currentTime = newTime;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract MusicPlayer {\n    uint public volume;\n    constructor(uint initialVolume) public {\n        volume = initialVolume;\n    }\n    function increaseVolume() public {\n        volume += 10;\n    }\n    function decreaseVolume() public {\n        if (volume > 10) {\n            volume -= 10;\n        }\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Painting {\n    uint public colorCount;\n    constructor(uint initialColors) public {\n        colorCount = initialColors;\n    }\n    function addColor() public {\n        colorCount += 1;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract Wallet {\n    uint public coinCount;\n    constructor(uint initialCoins) public {\n        coinCount = initialCoins;\n    }\n    function addCoins(uint amount) public {\n        coinCount += amount;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract Chair {\n    uint public legCount;\n    constructor(uint initialLegs) public {\n        legCount = initialLegs;\n    }\n    function addLeg() public {\n        legCount += 1;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract Basket {\n    uint public itemCount;\n    constructor(uint initialItems) public {\n        itemCount = initialItems;\n    }\n    function addItem() public {\n        itemCount += 1;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract Refrigerator {\n    uint public temperature;\n    constructor(uint initialTemperature) public {\n        temperature = initialTemperature;\n    }\n    function coolDown() public {\n        temperature -= 5;\n    }\n}"
      }
    }
  },
  {
    "Changes36": {
      "Version Migration": "->0.5",
      "Knowledge": "Calling base constructors without parentheses is now disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract BaseOne {\n    uint data;\n    constructor(uint x) { data = x; }\n}\ncontract ChildOne is BaseOne(5) {}",
          "error message": ":1:62: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract BaseOne {     uint data;     constructor(uint x) { data = x; } } contract ChildOne is BaseOne(5) {}\n                                                             ^-------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract Storage {\n    uint amount;\n    constructor(uint x) { amount = x; }\n}\ncontract Keeper is Storage(100) {}",
          "error message": ":1:64: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract Storage {     uint amount;     constructor(uint x) { amount = x; } } contract Keeper is Storage(100) {}\n                                                               ^---------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract Record {\n    uint counter;\n    constructor(uint num) { counter = num; }\n}\ncontract Log is Record(42) {\n    function add() public { counter++; }\n}",
          "error message": ":1:64: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... act Record {     uint counter;     constructor(uint num) { counter = num; } } contract Log is Record(42) {     ...\n                                        ^--------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Item {\n    uint stock;\n    constructor(uint initialStock) { stock = initialStock; }\n}\ncontract Inventory is Item(150) {\n    function decrement() public { stock--; }\n    function increment() public { stock++; }\n}",
          "error message": ":1:60: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... ontract Item {     uint stock;     constructor(uint initialStock) { stock = initialStock; } } contract Inventory is Item(150)  ...\n                                        ^------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract Balance {\n    uint balance;\n    constructor(uint initBal) { balance = initBal; }\n}\ncontract Account is Balance(2000) {}",
          "error message": ":1:65: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... ct Balance {     uint balance;     constructor(uint initBal) { balance = initBal; } } contract Account is Balance(2000 ...\n                                        ^----------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Asset {\n    uint value;\n    constructor(uint initValue) { value = initValue; }\n}\ncontract Property is Asset(3000) {\n    function assess() public { value += 500; }\n}",
          "error message": ":1:61: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... ntract Asset {     uint value;     constructor(uint initValue) { value = initValue; } } contract Property is Asset(3000) ...\n                                        ^------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract Box {\n    uint size;\n    constructor(uint sz) { size = sz; }\n}\ncontract Container is Box(500) {\n    function expand() public { size *= 2; }\n    function reduce() public { size /= 2; }\n}",
          "error message": ":1:58: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ...  contract Box {     uint size;     constructor(uint sz) { size = sz; } } contract Container is Box(500) { ...\n                                        ^---------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract Coin {\n    uint public count;\n    constructor(uint initCount) { count = initCount; }\n}\ncontract Purse is Coin(25) {}",
          "error message": ":1:67: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract Coin {     uint public count;     constructor(uint initCount) { count = initCount; } } contract Purse is Coin(25) {}\n                                                                  ^------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract BaseTen {\n    uint num;\n    constructor(uint number) { num = number; }\n}\ncontract DerivedTen is BaseTen(10) {}",
          "error message": ":1:61: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract BaseTen {     uint num;     constructor(uint number) { num = number; } } contract DerivedTen is BaseTen(10) {}\n                                                            ^----------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract Mark {\n    uint score;\n    constructor(uint initScore) { score = initScore; }\n}\ncontract Grade is Mark(88) {}",
          "error message": ":1:60: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract Mark {     uint score;     constructor(uint initScore) { score = initScore; } } contract Grade is Mark(88) {}\n                                                           ^------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract BaseOne {\n    uint data;\n    constructor(uint x) public { data = x; }\n}\ncontract ChildOne is BaseOne {\n    constructor(uint init) BaseOne(init) public {}\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract Storage {\n    uint amount;\n    constructor(uint x) public { amount = x; }\n}\ncontract Keeper is Storage {\n    constructor(uint init) Storage(init) public {}\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract Record {\n    uint counter;\n    constructor(uint num) public { counter = num; }\n}\ncontract Log is Record {\n    constructor(uint init) Record(init) public {}\n    function add() public { counter++; }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Item {\n    uint stock;\n    constructor(uint initialStock) public { stock = initialStock; }\n}\ncontract Inventory is Item {\n    constructor(uint init) Item(init) public {}\n    function decrement() public { stock--; }\n    function increment() public { stock++; }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract Balance {\n    uint balance;\n    constructor(uint initBal) public { balance = initBal; }\n}\ncontract Account is Balance {\n    constructor(uint init) Balance(init) public {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Asset {\n    uint value;\n    constructor(uint initValue) public { value = initValue; }\n}\ncontract Property is Asset {\n    constructor(uint init) Asset(init) public {}\n    function assess() public { value += 500; }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract Box {\n    uint size;\n    constructor(uint sz) public { size = sz; }\n}\ncontract Container is Box {\n    constructor(uint init) Box(init) public {}\n    function expand() public { size *= 2; }\n    function reduce() public { size /= 2; }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract Coin {\n    uint public count;\n    constructor(uint initCount) public { count = initCount; }\n}\ncontract Purse is Coin {\n    constructor(uint init) Coin(init) public {}\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract BaseTen {\n    uint num;\n    constructor(uint number) public { num = number; }\n}\ncontract DerivedTen is BaseTen {\n    constructor(uint init) BaseTen(init) public {}\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract Mark {\n    uint score;\n    constructor(uint initScore) public { score = initScore; }\n}\ncontract Grade is Mark {\n    constructor(uint init) Mark(init) public {}\n}"
      }
    }
  },
  {
    "Changes37": {
      "Version Migration": "->0.5",
      "Knowledge": "<code>suicide</code> is now disallowed (in favor of <code>selfdestruct</code>).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Vault {\n    address payable vaultOwner;\n\n    constructor() public {\n        vaultOwner = msg.sender;\n    }\n\n    function eliminate() public {\n        require(msg.sender == vaultOwner);\n        suicide(vaultOwner);\n    }\n\n    function extraFunc() public {}\n}",
          "error message": ":1:227: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... msg.sender == vaultOwner);         suicide(vaultOwner);     }      function extraFunc() p ...\n                                        ^-----------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\n\ncontract AccountManager {\n    address payable admin;\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    function closeAccount() public {\n        if (msg.sender == admin) {\n            suicide(admin);\n        }\n    }\n\n    function logAccess() public {}\n    function record() public {}\n}",
          "error message": ":1:225: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... msg.sender == admin) {             suicide(admin);         }     }      function log ...\n                                        ^------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\n\ncontract TreasureChest {\n    address payable treasureKeeper;\n\n    constructor() public {\n        treasureKeeper = msg.sender;\n    }\n\n    function sealChest() public {\n        require(msg.sender == treasureKeeper);\n        suicide(treasureKeeper);\n    }\n}",
          "error message": ":1:247: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... sender == treasureKeeper);         suicide(treasureKeeper);     } }\n                                        ^---------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Business {\n    address payable businessOwner;\n\n    constructor() public {\n        businessOwner = msg.sender;\n    }\n\n    function concludeBusiness() public {\n        if (msg.sender == businessOwner) {\n            suicide(businessOwner);\n        }\n    }\n}",
          "error message": ":1:247: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... er == businessOwner) {             suicide(businessOwner);         }     } }\n                                        ^--------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\n\ncontract PersonalWallet {\n    address payable walletOwner;\n\n    constructor() public {\n        walletOwner = msg.sender;\n    }\n\n    function deactivateWallet() public {\n        require(msg.sender == walletOwner);\n        suicide(walletOwner);\n    }\n\n    function reset() public {}\n}",
          "error message": ":1:246: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... sg.sender == walletOwner);         suicide(walletOwner);     }      function reset() publi ...\n                                        ^------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\n\ncontract DataStorage {\n    address payable dataAdmin;\n\n    constructor() public {\n        dataAdmin = msg.sender;\n    }\n\n    function terminateStorage() public {\n        if (msg.sender == dataAdmin) {\n            suicide(dataAdmin);\n        }\n    }\n\n    function store(uint data) public {}\n}",
          "error message": ":1:238: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... sender == dataAdmin) {             suicide(dataAdmin);         }     }      function sto ...\n                                        ^----------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Archive {\n    address payable archivist;\n\n    constructor() public {\n        archivist = msg.sender;\n    }\n\n    function destroyArchive() public {\n        require(msg.sender == archivist);\n        suicide(archivist);\n    }\n}",
          "error message": ":1:231: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... (msg.sender == archivist);         suicide(archivist);     } }\n                                        ^----------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\n\ncontract InvestmentFund {\n    address payable fundManager;\n\n    constructor() public {\n        fundManager = msg.sender;\n    }\n\n    function liquidateFund() public {\n        if (msg.sender == fundManager) {\n            suicide(fundManager);\n        }\n    }\n\n    function auditTrail() public {}\n}",
          "error message": ":1:244: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... nder == fundManager) {             suicide(fundManager);         }     }      function aud ...\n                                        ^------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ServiceContract {\n    address payable serviceOwner;\n\n    constructor() public {\n        serviceOwner = msg.sender;\n    }\n\n    function endService() public {\n        require(msg.sender == serviceOwner);\n        suicide(serviceOwner);\n    }\n\n    function maintenance() public {}\n}",
          "error message": ":1:244: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... g.sender == serviceOwner);         suicide(serviceOwner);     }      function maintenance() ...\n                                        ^-------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\n\ncontract TechCompany {\n    address payable techDirector;\n\n    constructor() public {\n        techDirector = msg.sender;\n    }\n\n    function dissolveCompany() public {\n        if (msg.sender == techDirector) {\n            suicide(techDirector);\n        }\n    }\n\n    function logOperation() public {}\n    function updateRecord() public {}\n}",
          "error message": ":1:246: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... der == techDirector) {             suicide(techDirector);         }     }      function log ...\n                                        ^-------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\n\ncontract Vault {\n    address payable vaultOwner;\n\n    constructor() public {\n        vaultOwner = msg.sender;\n    }\n\n    function eliminate() public {\n        require(msg.sender == vaultOwner);\n        selfdestruct(vaultOwner);\n    }\n\n    function extraFunc() public {}\n}",
        "Example2": "pragma solidity ^0.5.0;\n\ncontract AccountManager {\n    address payable admin;\n\n    constructor() public {\n        admin = msg.sender;\n    }\n\n    function closeAccount() public {\n        if (msg.sender == admin) {\n            selfdestruct(admin);\n        }\n    }\n\n    function logAccess() public {}\n    function record() public {}\n}",
        "Example3": "pragma solidity ^0.5.0;\n\ncontract TreasureChest {\n    address payable treasureKeeper;\n\n    constructor() public {\n        treasureKeeper = msg.sender;\n    }\n\n    function sealChest() public {\n        require(msg.sender == treasureKeeper);\n        selfdestruct(treasureKeeper);\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\n\ncontract Business {\n    address payable businessOwner;\n\n    constructor() public {\n        businessOwner = msg.sender;\n    }\n\n    function concludeBusiness() public {\n        if (msg.sender == businessOwner) {\n            selfdestruct(businessOwner);\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\n\ncontract PersonalWallet {\n    address payable walletOwner;\n\n    constructor() public {\n        walletOwner = msg.sender;\n    }\n\n    function deactivateWallet() public {\n        require(msg.sender == walletOwner);\n        selfdestruct(walletOwner);\n    }\n\n    function reset() public {}\n}",
        "Example6": "pragma solidity ^0.5.0;\n\ncontract DataStorage {\n    address payable dataAdmin;\n\n    constructor() public {\n        dataAdmin = msg.sender;\n    }\n\n    function terminateStorage() public {\n        if (msg.sender == dataAdmin) {\n            selfdestruct(dataAdmin);\n        }\n    }\n\n    function store(uint data) public {}\n}",
        "Example7": "pragma solidity ^0.5.0;\n\ncontract Archive {\n    address payable archivist;\n\n    constructor() public {\n        archivist = msg.sender;\n    }\n\n    function destroyArchive() public {\n        require(msg.sender == archivist);\n        selfdestruct(archivist);\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\n\ncontract InvestmentFund {\n    address payable fundManager;\n\n    constructor() public {\n        fundManager = msg.sender;\n    }\n\n    function liquidateFund() public {\n        if (msg.sender == fundManager) {\n            selfdestruct(fundManager);\n        }\n    }\n\n    function auditTrail() public {}\n}",
        "Example9": "pragma solidity ^0.5.0;\n\ncontract ServiceContract {\n    address payable serviceOwner;\n\n    constructor() public {\n        serviceOwner = msg.sender;\n    }\n\n    function endService() public {\n        require(msg.sender == serviceOwner);\n        selfdestruct(serviceOwner);\n    }\n\n    function maintenance() public {}\n}",
        "Example10": "pragma solidity ^0.5.0;\n\ncontract TechCompany {\n    address payable techDirector;\n\n    constructor() public {\n        techDirector = msg.sender;\n    }\n\n    function dissolveCompany() public {\n        if (msg.sender == techDirector) {\n            selfdestruct(techDirector);\n        }\n    }\n\n    function logOperation() public {}\n    function updateRecord() public {}\n}"
      }
    }
  },
  {
    "Changes38": {
      "Version Migration": "->0.5",
      "Knowledge": "<code>sha3</code> is now disallowed (in favor of <code>keccak256</code>).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleK {\n    function hashOutput(bytes32 source) public pure returns (bytes32) {\n        return sha3(source);\n    }\n}",
          "error message": ":1:134: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(source);     } }\n                                        ^----------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleL {\n    function resolveHash(bytes32 seed) public pure returns (bytes32) {\n        return sha3(seed);\n    }\n    function additionalFunctionL() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": ":1:133: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(seed);     }     function additionalFunc ...\n                                        ^--------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleM {\n    function fetchHash(bytes32 input) public pure returns (bytes32) {\n        return sha3(input);\n    }\n    function helperFunctionM1() public pure returns (uint) {\n        return 50;\n    }\n}",
          "error message": ":1:132: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(input);     }     function helperFunction ...\n                                        ^---------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleN {\n    function generateKey(bytes32 data) public pure returns (bytes32) {\n        return sha3(data);\n    }\n    function helperFunctionN() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:133: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(data);     }     function helperFunction ...\n                                        ^--------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleO {\n    function hashBytes(bytes32 info) public pure returns (bytes32) {\n        return sha3(info);\n    }\n}",
          "error message": ":1:131: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\npragma solidity^0.5.0; contract HashModuleO {     function hashBytes(bytes32 info) public pure returns (bytes32) {         return sha3(info);     } }\n                                                                                                                                  ^--------^\n                                                                                                                              ^--^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleP {\n    function hashCompute(bytes32 datum) public pure returns (bytes32) {\n        return sha3(datum);\n    }\n}",
          "error message": ":1:134: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(datum);     } }\n                                        ^---------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleQ {\n    function deriveHashValue(bytes32 parameter) public pure returns (bytes32) {\n        return sha3(parameter);\n    }\n}",
          "error message": ":1:142: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(parameter);     } }\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleR {\n    function hashFunction(bytes32 value) public pure returns (bytes32) {\n        return sha3(value);\n    }\n    function auxiliaryFunctionR() public pure returns (uint) {\n        return 101;\n    }\n}",
          "error message": ":1:135: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(value);     }     function auxiliaryFunct ...\n                                        ^---------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleS {\n    function getHashResult(bytes32 attribute) public pure returns (bytes32) {\n        return sha3(attribute);\n    }\n}",
          "error message": ":1:140: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(attribute);     } }\n                                        ^-------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract HashModuleT {\n    function calculateHashValue(bytes32 input) public pure returns (bytes32) {\n        return sha3(input);\n    }\n    function extraFunctionT1() public pure returns (uint) {\n        return 77;\n    }\n    function extraFunctionT2() public pure returns (uint) {\n        return 88;\n    }\n}",
          "error message": ":1:141: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(input);     }     function extraFunctionT ...\n                                        ^---------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract HashModuleK {\n    function hashOutput(bytes32 source) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(source));\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract HashModuleL {\n    function resolveHash(bytes32 seed) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(seed));\n    }\n    function additionalFunctionL() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract HashModuleM {\n    function fetchHash(bytes32 input) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(input));\n    }\n    function helperFunctionM1() public pure returns (uint) {\n        return 50;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract HashModuleN {\n    function generateKey(bytes32 data) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(data));\n    }\n    function helperFunctionN() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract HashModuleO {\n    function hashBytes(bytes32 info) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(info));\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract HashModuleP {\n    function hashCompute(bytes32 datum) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(datum));\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract HashModuleQ {\n    function deriveHashValue(bytes32 parameter) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(parameter));\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract HashModuleR {\n    function hashFunction(bytes32 value) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(value));\n    }\n    function auxiliaryFunctionR() public pure returns (uint) {\n        return 101;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract HashModuleS {\n    function getHashResult(bytes32 attribute) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(attribute));\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract HashModuleT {\n    function calculateHashValue(bytes32 input) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(input));\n    }\n    function extraFunctionT1() public pure returns (uint) {\n        return 77;\n    }\n    function extraFunctionT2() public pure returns (uint) {\n        return 88;\n    }\n}"
      }
    }
  },
  {
    "Changes39": {
      "Version Migration": "->0.5",
      "Knowledge": "<code>throw</code> is now disallowed (in favor of <code>revert</code>, <code>require</code> and\n<code>assert</code>).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractOne {\n    function triggerFault() public pure {\n        throw;\n    }\n    function helperFunction() public pure {}\n}",
          "error message": ":1:102: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... iggerFault() public pure {         throw;     }     function helperFunction ...\n                                        ^---^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractTwo {\n    function provokeError() public pure {\n        throw;\n    }\n}",
          "error message": ":1:102: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract FaultContractTwo {     function provokeError() public pure {         throw;     } }\n                                                                                                     ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractThree {\n    function initiateThrow() public pure {\n        throw;\n    }\n    function extraA() public pure {}\n}",
          "error message": ":1:105: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... tiateThrow() public pure {         throw;     }     function extraA() publi ...\n                                        ^---^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractFour {\n    function throwNow() public pure {\n        throw;\n    }\n}",
          "error message": ":1:99: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract FaultContractFour {     function throwNow() public pure {         throw;     } }\n                                                                                                  ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractFive {\n    function throwErrorAgain() public pure {\n        throw;\n    }\n    function anotherHelper() public pure {}\n    function yetAnother() public pure {}\n}",
          "error message": ":1:106: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... ErrorAgain() public pure {         throw;     }     function anotherHelper( ...\n                                        ^---^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractSix {\n    function generateError() public pure {\n        throw;\n    }\n}",
          "error message": ":1:103: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract FaultContractSix {     function generateError() public pure {         throw;     } }\n                                                                                                      ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractSeven {\n    function triggerException() public pure {\n        throw;\n    }\n    function someExtraFunction() public pure {}\n}",
          "error message": ":1:108: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... rException() public pure {         throw;     }     function someExtraFunct ...\n                                        ^---^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractEight {\n    function forceError() public pure {\n        throw;\n    }\n}",
          "error message": ":1:102: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract FaultContractEight {     function forceError() public pure {         throw;     } }\n                                                                                                     ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractNine {\n    function throwException() public pure {\n        throw;\n    }\n    function optionalFunction() public pure {}\n}",
          "error message": ":1:105: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... wException() public pure {         throw;     }     function optionalFuncti ...\n                                        ^---^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract FaultContractTen {\n    function initiateException() public pure {\n        throw;\n    }\n    function extraFunctionOne() public pure {}\n    function extraFunctionTwo() public pure {}\n}",
          "error message": ":1:107: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... eException() public pure {         throw;     }     function extraFunctionO ...\n                                        ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract FaultContractOne {\n    function triggerFault() public pure {\n        revert();\n    }\n    function helperFunction() public pure {}\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract FaultContractTwo {\n    function provokeError() public pure {\n        revert();\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract FaultContractThree {\n    function initiateThrow() public pure {\n        revert();\n    }\n    function extraA() public pure {}\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract FaultContractFour {\n    function throwNow() public pure {\n        revert();\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract FaultContractFive {\n    function throwErrorAgain() public pure {\n        revert();\n    }\n    function anotherHelper() public pure {}\n    function yetAnother() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract FaultContractSix {\n    function generateError() public pure {\n        revert();\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract FaultContractSeven {\n    function triggerException() public pure {\n        revert();\n    }\n    function someExtraFunction() public pure {}\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract FaultContractEight {\n    function forceError() public pure {\n        revert();\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract FaultContractNine {\n    function throwException() public pure {\n        revert();\n    }\n    function optionalFunction() public pure {}\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract FaultContractTen {\n    function initiateException() public pure {\n        revert();\n    }\n    function extraFunctionOne() public pure {}\n    function extraFunctionTwo() public pure {}\n}"
      }
    }
  },
  {
    "Changes40": {
      "Version Migration": "->0.5",
      "Knowledge": "The unit denomination <code>years</code> is now disallowed due to complications and\nconfusions about leap years.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ClubMembership {\n    address public member;\n    uint public membershipExpires;\n\n    constructor() public {\n        member = msg.sender;\n        membershipExpires = now + 3 years;\n    }\n\n    function renewMembership() public {\n        require(now >= membershipExpires, \"Membership not expired yet!\");\n    }\n}",
          "error message": ":1:203: TypeError: Using \"years\" as a unit denomination is deprecated.\n ...          membershipExpires = now + 3 years;     }      function renewMembersh ...\n                                        ^-----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract GraduationGift {\n    address payable public graduate;\n    uint public giftReleaseTime;\n\n    constructor() public {\n        graduate = msg.sender;\n        giftReleaseTime = now + 4 years;\n    }\n\n    function retrieveGift() public {\n        require(now >= giftReleaseTime, \"Graduation not yet reached!\");\n        graduate.transfer(address(this).balance);\n    }\n}",
          "error message": ":1:211: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... r;         giftReleaseTime = now + 4 years;     }      function retrieveGift( ...\n                                        ^-----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ArtistPatronage {\n    address public artist;\n    uint public contractEnd;\n\n    constructor() public {\n        artist = msg.sender;\n        contractEnd = now + 1 years;\n    }\n\n    function endPatronage() public {\n        require(now >= contractEnd, \"Contract still active!\");\n    }\n}",
          "error message": ":1:192: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... ender;         contractEnd = now + 1 years;     }      function endPatronage( ...\n                                        ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract SportsContract {\n    address public athlete;\n    uint public contractDuration;\n\n    constructor() public {\n        athlete = msg.sender;\n        contractDuration = now + 5 years;\n    }\n\n    function terminateContract() public {\n        require(now >= contractDuration, \"Contract not yet terminated!\");\n    }\n}",
          "error message": ":1:203: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... ;         contractDuration = now + 5 years;     }      function terminateCont ...\n                                        ^-----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract TechnologyLease {\n    address payable public lessee;\n    uint public leasePeriod;\n\n    constructor() public {\n        lessee = msg.sender;\n        leasePeriod = now + 2 years;\n    }\n\n    function completeLease() public {\n        require(now >= leasePeriod, \"Lease period still ongoing!\");\n    }\n}",
          "error message": ":1:200: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... ender;         leasePeriod = now + 2 years;     }      function completeLease ...\n                                        ^-----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ChildTrustFund {\n    address payable public trustee;\n    uint public fundMaturity;\n\n    constructor() public {\n        trustee = msg.sender;\n        fundMaturity = now + 18 years;\n    }\n\n    function withdrawFund() public {\n        require(now >= fundMaturity, \"Trust fund not matured yet!\");\n        trustee.transfer(address(this).balance);\n    }\n}",
          "error message": ":1:203: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... nder;         fundMaturity = now + 18 years;     }      function withdrawFund( ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ResearchGrant {\n    address public researcher;\n    uint public grantEnd;\n\n    constructor() public {\n        researcher = msg.sender;\n        grantEnd = now + 3 years;\n    }\n\n    function endGrant() public {\n        require(now >= grantEnd, \"Grant still active!\");\n    }\n}",
          "error message": ":1:192: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... g.sender;         grantEnd = now + 3 years;     }      function endGrant() pu ...\n                                        ^-----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract BusinessLoan {\n    address payable public borrower;\n    uint public loanEnd;\n\n    constructor() public {\n        borrower = msg.sender;\n        loanEnd = now + 10 years;\n    }\n\n    function settleLoan() public {\n        require(now >= loanEnd, \"Loan not due yet!\");\n        borrower.transfer(address(this).balance);\n    }\n}",
          "error message": ":1:193: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... sg.sender;         loanEnd = now + 10 years;     }      function settleLoan()  ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract HistoricalPreservation {\n    address public conservator;\n    uint public preservationTerm;\n\n    constructor() public {\n        conservator = msg.sender;\n        preservationTerm = now + 15 years;\n    }\n\n}",
          "error message": ":1:219: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... ;         preservationTerm = now + 15 years;     }  }\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract FreelancerContract {\n    address public freelancer;\n    uint public projectCompletion;\n\n    constructor() public {\n        freelancer = msg.sender;\n        projectCompletion = now + 1 years;\n    }\n\n    function completeProject() public {\n        require(now >= projectCompletion, \"Project still ongoing!\");\n    }\n}",
          "error message": ":1:215: TypeError: Using \"years\" as a unit denomination is deprecated.\n ...          projectCompletion = now + 1 years;     }      function completeProje ...\n                                        ^-----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ClubMembership {\n    address public member;\n    uint public membershipExpires;\n\n    constructor() public {\n        member = msg.sender;\n        membershipExpires = now + 3 * 365 days;\n    }\n\n    function renewMembership() public {\n        require(now >= membershipExpires, \"Membership not expired yet!\");\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract GraduationGift {\n    address payable public graduate;\n    uint public giftReleaseTime;\n\n    constructor() public {\n        graduate = msg.sender;\n        giftReleaseTime = now + 4 * 365 days;\n    }\n\n    function retrieveGift() public {\n        require(now >= giftReleaseTime, \"Graduation not yet reached!\");\n        graduate.transfer(address(this).balance);\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ArtistPatronage {\n    address public artist;\n    uint public contractEnd;\n\n    constructor() public {\n        artist = msg.sender;\n        contractEnd = now + 1 * 365 days;\n    }\n\n    function endPatronage() public {\n        require(now >= contractEnd, \"Contract still active!\");\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract SportsContract {\n    address public athlete;\n    uint public contractDuration;\n\n    constructor() public {\n        athlete = msg.sender;\n        contractDuration = now + 5 * 365 days;\n    }\n\n    function terminateContract() public {\n        require(now >= contractDuration, \"Contract not yet terminated!\");\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract TechnologyLease {\n    address payable public lessee;\n    uint public leasePeriod;\n\n    constructor() public {\n        lessee = msg.sender;\n        leasePeriod = now + 2 * 365 days;\n    }\n\n    function completeLease() public {\n        require(now >= leasePeriod, \"Lease period still ongoing!\");\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ChildTrustFund {\n    address payable public trustee;\n    uint public fundMaturity;\n\n    constructor() public {\n        trustee = msg.sender;\n        fundMaturity = now + 18 * 365 days;\n    }\n\n    function withdrawFund() public {\n        require(now >= fundMaturity, \"Trust fund not matured yet!\");\n        trustee.transfer(address(this).balance);\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ResearchGrant {\n    address public researcher;\n    uint public grantEnd;\n\n    constructor() public {\n        researcher = msg.sender;\n        grantEnd = now + 3 * 365 days;\n    }\n\n    function endGrant() public {\n        require(now >= grantEnd, \"Grant still active!\");\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract BusinessLoan {\n    address payable public borrower;\n    uint public loanEnd;\n\n    constructor() public {\n        borrower = msg.sender;\n        loanEnd = now + 10 * 365 days;\n    }\n\n    function settleLoan() public {\n        require(now >= loanEnd, \"Loan not due yet!\");\n        borrower.transfer(address(this).balance);\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract HistoricalPreservation {\n    address public conservator;\n    uint public preservationTerm;\n\n    constructor() public {\n        conservator = msg.sender;\n        preservationTerm = now + 15 * 365 days;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract FreelancerContract {\n    address public freelancer;\n    uint public projectCompletion;\n\n    constructor() public {\n        freelancer = msg.sender;\n        projectCompletion = now + 1 * 365 days;\n    }\n\n    function completeProject() public {\n        require(now >= projectCompletion, \"Project still ongoing!\");\n    }\n}"
      }
    }
  },
  {
    "Changes41": {
      "Version Migration": "->0.5",
      "Knowledge": "Trailing dots that are not followed by a number are now disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorEleven {\n    function computeEdge() public pure returns (uint) {\n        uint edge = 60.;\n        return edge;\n    }\n    function additional() public pure returns (uint) { return 9; }\n}",
          "error message": ":1:133: ParserError: Expected identifier but got ';'\n ... ns (uint) {         uint edge = 60.;         return edge;     }     fun ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorTwelve {\n    function deriveParameter() public pure returns (uint) {\n        uint parameter = 35.;\n        return parameter;\n    }\n    function extra() public pure returns (uint) { return 10; }\n    function more() public pure returns (uint) { return 11; }\n}",
          "error message": ":1:142: ParserError: Expected identifier but got ';'\n ... int) {         uint parameter = 35.;         return parameter;     }    ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorThirteen {\n    function generateOutput() public pure returns (uint) {\n        uint output = 145.;\n        return output;\n    }\n}",
          "error message": ":1:141: ParserError: Expected identifier but got ';'\n ... (uint) {         uint output = 145.;         return output;     } }\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorFourteen {\n    function findLimit() public pure returns (uint) {\n        uint limit = 250.;\n        return limit;\n    }\n    function unusedFunction() public pure returns (uint) { return 12; }\n}",
          "error message": ":1:135: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint limit = 250.;         return limit;     }     fu ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorFifteen {\n    function assessCapacity() public pure returns (uint) {\n        uint capacity = 300.;\n        return capacity;\n    }\n}",
          "error message": ":1:142: ParserError: Expected identifier but got ';'\n ... int) {         uint capacity = 300.;         return capacity;     } }\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorSixteen {\n    function getThreshold() public pure returns (uint) {\n        uint threshold = 85.;\n        return threshold;\n    }\n    function anotherExtra() public pure returns (uint) { return 13; }\n}",
          "error message": ":1:140: ParserError: Expected identifier but got ';'\n ... int) {         uint threshold = 85.;         return threshold;     }    ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorSeventeen {\n    function calculateRatio() public pure returns (uint) {\n        uint ratio = 175.;\n        return ratio;\n    }\n}",
          "error message": ":1:141: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint ratio = 175.;         return ratio;     } }\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorEighteen {\n    function determineFactor() public pure returns (uint) {\n        uint factor = 95.;\n        return factor;\n    }\n    function anotherIrrelevant() public pure returns (uint) { return 14; }\n    function alsoUseless() public pure returns (uint) { return 15; }\n}",
          "error message": ":1:141: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint factor = 95.;         return factor;     }     f ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorNineteen {\n    function measureScale() public pure returns (uint) {\n        uint scale = 40.;\n        return scale;\n    }\n}",
          "error message": ":1:137: ParserError: Expected identifier but got ';'\n ... s (uint) {         uint scale = 40.;         return scale;     } }\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorTwenty {\n    function evaluateIndex() public pure returns (uint) {\n        uint index = 190.;\n        return index;\n    }\n    function notRelated() public pure returns (uint) { return 16; }\n}",
          "error message": ":1:137: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint index = 190.;         return index;     }     fu ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract DecimalErrorEleven {\n    function computeEdge() public pure returns (uint) {\n        uint edge = 60;\n        return edge;\n    }\n    function additional() public pure returns (uint) { return 9; }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract DecimalErrorTwelve {\n    function deriveParameter() public pure returns (uint) {\n        uint parameter = 35;\n        return parameter;\n    }\n    function extra() public pure returns (uint) { return 10; }\n    function more() public pure returns (uint) { return 11; }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract DecimalErrorThirteen {\n    function generateOutput() public pure returns (uint) {\n        uint output = 145;\n        return output;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract DecimalErrorFourteen {\n    function findLimit() public pure returns (uint) {\n        uint limit = 250;\n        return limit;\n    }\n    function unusedFunction() public pure returns (uint) { return 12; }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract DecimalErrorFifteen {\n    function assessCapacity() public pure returns (uint) {\n        uint capacity = 300;\n        return capacity;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract DecimalErrorSixteen {\n    function getThreshold() public pure returns (uint) {\n        uint threshold = 85;\n        return threshold;\n    }\n    function anotherExtra() public pure returns (uint) { return 13; }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract DecimalErrorSeventeen {\n    function calculateRatio() public pure returns (uint) {\n        uint ratio = 175;\n        return ratio;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract DecimalErrorEighteen {\n    function determineFactor() public pure returns (uint) {\n        uint factor = 95;\n        return factor;\n    }\n    function anotherIrrelevant() public pure returns (uint) { return 14; }\n    function alsoUseless() public pure returns (uint) { return 15; }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract DecimalErrorNineteen {\n    function measureScale() public pure returns (uint) {\n        uint scale = 40;\n        return scale;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract DecimalErrorTwenty {\n    function evaluateIndex() public pure returns (uint) {\n        uint index = 190;\n        return index;\n    }\n    function notRelated() public pure returns (uint) { return 16; }\n}"
      }
    }
  },
  {
    "Changes42": {
      "Version Migration": "->0.5",
      "Knowledge": "Combining hex numbers with unit denominations (e.g. <code>0x1e wei</code>) is now\ndisallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractEleven {\n    function getValueHex() public pure returns (uint) {\n        uint payload = 0x1c wei;\n        return payload;\n    }\n    function extraOne() public pure {}\n}",
          "error message": ":1:135: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... ns (uint) {         uint payload = 0x1c wei;         return payload;     }     ...\n                                        ^------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractTwelve {\n    function calculateTotal() public pure returns (uint) {\n        uint balance = 0x3e wei;\n        return balance;\n    }\n    function extraTwo() public pure {}\n    function extraThree() public pure {}\n}",
          "error message": ":1:138: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... ns (uint) {         uint balance = 0x3e wei;         return balance;     }     ...\n                                        ^------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractThirteen {\n    function fetchAmount() public pure returns (uint) {\n        uint level = 0x7a wei;\n        return level;\n    }\n}",
          "error message": ":1:135: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... urns (uint) {         uint level = 0x7a wei;         return level;     } }\n                                        ^------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractFourteen {\n    function deriveHex() public pure returns (uint) {\n        uint num = 0x2f wei;\n        return num;\n    }\n    function randomFunction() public pure {}\n}",
          "error message": ":1:131: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... eturns (uint) {         uint num = 0x2f wei;         return num;     }     fun ...\n                                        ^------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractFifteen {\n    function getQuantity() public pure returns (uint) {\n        uint amount = 0x5b wei;\n        return amount;\n    }\n    function irrelevantFunction() public pure {}\n}",
          "error message": ":1:135: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... rns (uint) {         uint amount = 0x5b wei;         return amount;     }      ...\n                                        ^------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractSixteen {\n    function measureHex() public pure returns (uint) {\n        uint data = 0x2d wei;\n        return data;\n    }\n    function additionalOne() public pure {}\n    function additionalTwo() public pure {}\n}",
          "error message": ":1:132: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... turns (uint) {         uint data = 0x2d wei;         return data;     }     fu ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractSeventeen {\n    function processValue() public pure returns (uint) {\n        uint content = 0x6c wei;\n        return content;\n    }\n}",
          "error message": ":1:139: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... ns (uint) {         uint content = 0x6c wei;         return content;     } }\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractEighteen {\n    function retrieveData() public pure returns (uint) {\n        uint figure = 0x3c wei;\n        return figure;\n    }\n    function extraDummy() public pure {}\n}",
          "error message": ":1:137: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... rns (uint) {         uint figure = 0x3c wei;         return figure;     }      ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractNineteen {\n    function generateOutput() public pure returns (uint) {\n        uint outcome = 0x12 wei;\n        return outcome;\n    }\n    function randomAct() public pure {}\n}",
          "error message": ":1:140: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... ns (uint) {         uint outcome = 0x12 wei;         return outcome;     }     ...\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractTwenty {\n    function computeFigure() public pure returns (uint) {\n        uint quantity = 0x88 wei;\n        return quantity;\n    }\n    function anotherExtra() public pure {}\n}",
          "error message": ":1:138: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... s (uint) {         uint quantity = 0x88 wei;         return quantity;     }    ...\n                                        ^------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\n\ncontract ErrorContractEleven {\n    function getValueHex() public pure returns (uint) {\n        uint payload = 0x1c;\n        return payload;\n    }\n    function extraOne() public pure {}\n}",
        "Example2": "pragma solidity ^0.5.0;\n\ncontract ErrorContractTwelve {\n    function calculateTotal() public pure returns (uint) {\n        uint balance = 0x3e;\n        return balance;\n    }\n    function extraTwo() public pure {}\n    function extraThree() public pure {}\n}",
        "Example3": "pragma solidity ^0.5.0;\n\ncontract ErrorContractThirteen {\n    function fetchAmount() public pure returns (uint) {\n        uint level = 0x7a;\n        return level;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\n\ncontract ErrorContractFourteen {\n    function deriveHex() public pure returns (uint) {\n        uint num = 0x2f;\n        return num;\n    }\n    function randomFunction() public pure {}\n}",
        "Example5": "pragma solidity ^0.5.0;\n\ncontract ErrorContractFifteen {\n    function getQuantity() public pure returns (uint) {\n        uint amount = 0x5b;\n        return amount;\n    }\n    function irrelevantFunction() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\n\ncontract ErrorContractSixteen {\n    function measureHex() public pure returns (uint) {\n        uint data = 0x2d;\n        return data;\n    }\n    function additionalOne() public pure {}\n    function additionalTwo() public pure {}\n}",
        "Example7": "pragma solidity ^0.5.0;\n\ncontract ErrorContractSeventeen {\n    function processValue() public pure returns (uint) {\n        uint content = 0x6c;\n        return content;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\n\ncontract ErrorContractEighteen {\n    function retrieveData() public pure returns (uint) {\n        uint figure = 0x3c;\n        return figure;\n    }\n    function extraDummy() public pure {}\n}",
        "Example9": "pragma solidity ^0.5.0;\n\ncontract ErrorContractNineteen {\n    function generateOutput() public pure returns (uint) {\n        uint outcome = 0x12;\n        return outcome;\n    }\n    function randomAct() public pure {}\n}",
        "Example10": "pragma solidity ^0.5.0;\n\ncontract ErrorContractTwenty {\n    function computeFigure() public pure returns (uint) {\n        uint quantity = 0x88;\n        return quantity;\n    }\n    function anotherExtra() public pure {}\n}"
      }
    }
  },
  {
    "Changes43": {
      "Version Migration": "->0.5",
      "Knowledge": "The prefix <code>0X</code> for hex numbers is disallowed, only <code>0x</code> is possible.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataOne {\n    function pullHex() public pure returns (uint) {\n        return 0XcaFe00;\n    }\n    function extraMethod() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:113: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0XcaFe00;     }     function extraMe ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataTwo {\n    function getHexData() public pure returns (uint) {\n        return 0XbA5Eba11;\n    }\n    function helper() public pure returns (uint) {\n        return 55;\n    }\n}",
          "error message": ":1:116: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0XbA5Eba11;     }     function helpe ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataThree {\n    function fetchHex() public pure returns (uint) {\n        return 0XdeadBeef;\n    }\n}",
          "error message": ":1:116: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexDataThree {     function fetchHex() public pure returns (uint) {         return 0XdeadBeef;     } }\n                                                                                                                   ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataFour {\n    function retrieveHex() public pure returns (uint) {\n        return 0XfaceB00c;\n    }\n    function unused() public pure returns (string memory) {\n        return \"Unused\";\n    }\n    function dummy() public pure returns (int) {\n        return -999;\n    }\n}",
          "error message": ":1:118: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0XfaceB00c;     }     function unuse ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataFive {\n    function getUniqueHex() public pure returns (uint) {\n        return 0X123Abc;\n    }\n}",
          "error message": ":1:119: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexDataFive {     function getUniqueHex() public pure returns (uint) {         return 0X123Abc;     } }\n                                                                                                                      ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataSix {\n    function generateHex() public pure returns (uint) {\n        return 0XfeedC0de;\n    }\n    function extraFunc() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": ":1:117: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0XfeedC0de;     }     function extra ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataSeven {\n    function showHex() public pure returns (uint) {\n        return 0XbeaD123;\n    }\n    function additional() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
          "error message": ":1:115: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0XbeaD123;     }     function additi ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataEight {\n    function extractHex() public pure returns (uint) {\n        return 0XbaDf00d;\n    }\n}",
          "error message": ":1:118: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexDataEight {     function extractHex() public pure returns (uint) {         return 0XbaDf00d;     } }\n                                                                                                                     ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataNine {\n    function printHex() public pure returns (uint) {\n        return 0Xc001d00d;\n    }\n    function anotherExtra() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:115: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0Xc001d00d;     }     function anoth ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract HexDataTen {\n    function calculateHex() public pure returns (uint) {\n        return 0XfaCe100;\n    }\n}",
          "error message": ":1:118: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexDataTen {     function calculateHex() public pure returns (uint) {         return 0XfaCe100;     } }\n                                                                                                                     ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract HexDataOne {\n    function pullHex() public pure returns (uint) {\n        return 0xcaFe00;\n    }\n    function extraMethod() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract HexDataTwo {\n    function getHexData() public pure returns (uint) {\n        return 0xbA5Eba11;\n    }\n    function helper() public pure returns (uint) {\n        return 55;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract HexDataThree {\n    function fetchHex() public pure returns (uint) {\n        return 0xdeadBeef;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract HexDataFour {\n    function retrieveHex() public pure returns (uint) {\n        return 0xfaceB00c;\n    }\n    function unused() public pure returns (string memory) {\n        return \"Unused\";\n    }\n    function dummy() public pure returns (int) {\n        return -999;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract HexDataFive {\n    function getUniqueHex() public pure returns (uint) {\n        return 0x123Abc;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract HexDataSix {\n    function generateHex() public pure returns (uint) {\n        return 0xfeedC0de;\n    }\n    function extraFunc() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract HexDataSeven {\n    function showHex() public pure returns (uint) {\n        return 0xbeaD123;\n    }\n    function additional() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract HexDataEight {\n    function extractHex() public pure returns (uint) {\n        return 0xbaDf00d;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract HexDataNine {\n    function printHex() public pure returns (uint) {\n        return 0xc001d00d;\n    }\n    function anotherExtra() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract HexDataTen {\n    function calculateHex() public pure returns (uint) {\n        return 0xfaCe100;\n    }\n}"
      }
    }
  },
  {
    "Changes44": {
      "Version Migration": "->0.5",
      "Knowledge": "Using <code>constant</code> as function state mutability modifier is now disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract Lambda {\n    uint256 public constant serial = 120;\n    function fetchSerial() public constant returns (uint256) {\n        return serial;\n    }\n    function additionalInfo() public pure returns (string memory) {\n        return \"More info\";\n    }\n}",
          "error message": ":1:118: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ...      function fetchSerial() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract Mu {\n    uint256 public constant quantity = 300;\n    function getQuantity() public constant returns (uint256) {\n        return quantity;\n    }\n}",
          "error message": ":1:116: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ...      function getQuantity() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract Nu {\n    uint256 public constant detail = 450;\n    function fetchDetail() public constant returns (uint256) {\n        return detail;\n    }\n    function somethingElse() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:114: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ...      function fetchDetail() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Xi {\n    uint256 public constant factor = 700;\n    function getFactor() public constant returns (uint256) {\n        return factor;\n    }\n    function extraMethod() public pure returns (uint256) {\n        return 1000;\n    }\n}",
          "error message": ":1:112: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 0;     function getFactor() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract Omicron {\n    uint256 public constant code = 25;\n    function getCode() public constant returns (uint256) {\n        return code;\n    }\n}",
          "error message": ":1:112: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ...  25;     function getCode() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Pi {\n    uint256 public constant weight = 55;\n    function getWeight() public constant returns (uint256) {\n        return weight;\n    }\n    function helper() public pure returns (string memory) {\n        return \"Helper\";\n    }\n}",
          "error message": ":1:111: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 5;     function getWeight() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract Rho {\n    uint256 public constant speed = 95;\n    function getSpeed() public constant returns (uint256) {\n        return speed;\n    }\n    function dummy() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:110: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 95;     function getSpeed() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract Sigma {\n    uint256 public constant depth = 40;\n    function getDepth() public constant returns (uint256) {\n        return depth;\n    }\n}",
          "error message": ":1:112: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 40;     function getDepth() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract Tau {\n    uint256 public constant temperature = 300;\n    function getTemperature() public constant returns (uint256) {\n        return temperature;\n    }\n    function randomFunction() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": ":1:123: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ...   function getTemperature() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract Upsilon {\n    uint256 public constant pressure = 150;\n    function getPressure() public constant returns (uint256) {\n        return pressure;\n    }\n    function extraFeature() public pure returns (uint256) {\n        return 200;\n    }\n}",
          "error message": ":1:121: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ...      function getPressure() public constant returns (uint256) {         return ...\n                                        ^------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract Lambda {\n    uint256 public constant serial = 120;\n    function fetchSerial() public view returns (uint256) {\n        return serial;\n    }\n    function additionalInfo() public pure returns (string memory) {\n        return \"More info\";\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract Mu {\n    uint256 public constant quantity = 300;\n    function getQuantity() public view returns (uint256) {\n        return quantity;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract Nu {\n    uint256 public constant detail = 450;\n    function fetchDetail() public view returns (uint256) {\n        return detail;\n    }\n    function somethingElse() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Xi {\n    uint256 public constant factor = 700;\n    function getFactor() public view returns (uint256) {\n        return factor;\n    }\n    function extraMethod() public pure returns (uint256) {\n        return 1000;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract Omicron {\n    uint256 public constant code = 25;\n    function getCode() public view returns (uint256) {\n        return code;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Pi {\n    uint256 public constant weight = 55;\n    function getWeight() public view returns (uint256) {\n        return weight;\n    }\n    function helper() public pure returns (string memory) {\n        return \"Helper\";\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract Rho {\n    uint256 public constant speed = 95;\n    function getSpeed() public view returns (uint256) {\n        return speed;\n    }\n    function dummy() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract Sigma {\n    uint256 public constant depth = 40;\n    function getDepth() public view returns (uint256) {\n        return depth;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract Tau {\n    uint256 public constant temperature = 300;\n    function getTemperature() public view returns (uint256) {\n        return temperature;\n    }\n    function randomFunction() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract Upsilon {\n    uint256 public constant pressure = 150;\n    function getPressure() public view returns (uint256) {\n        return pressure;\n    }\n    function extraFeature() public pure returns (uint256) {\n        return 200;\n    }\n}"
      }
    }
  },
  {
    "Changes45": {
      "Version Migration": "->0.5",
      "Knowledge": "Empty return statements for functions with one or more return values are now\ndisallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ValueChecker {\n    function checkValue() public pure returns (bool) {\n        return;\n    }\n    function auxiliary() public pure returns (int) {\n        return 5;\n    }\n}",
          "error message": ":1:111: TypeError: Return arguments required.\n ... blic pure returns (bool) {         return;     }     function auxiliary() pub ...\n                                        ^-----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract AssetTracker {\n    function trackAsset() public pure returns (uint) {\n        return;\n    }\n}",
          "error message": ":1:111: TypeError: Return arguments required.\npragma solidity^0.5.0; contract AssetTracker {     function trackAsset() public pure returns (uint) {         return;     } }\n                                                                                                              ^-----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract HealthMonitor {\n    function monitorHealth() public pure returns (bytes32) {\n        return;\n    }\n    function logActivity() public pure {}\n}",
          "error message": ":1:118: TypeError: Return arguments required.\n ... c pure returns (bytes32) {         return;     }     function logActivity() p ...\n                                        ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ItemValidator {\n    function validateItem() public pure returns (string memory) {\n        return;\n    }\n    function setup() public pure {}\n}",
          "error message": ":1:123: TypeError: Return arguments required.\n ...  returns (string memory) {         return;     }     function setup() public  ...\n                                        ^-----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract MemberRegistrar {\n    function registerMember() public pure returns (address) {\n        return;\n    }\n    function deregister() public pure {}\n}",
          "error message": ":1:121: TypeError: Return arguments required.\n ... c pure returns (address) {         return;     }     function deregister() pu ...\n                                        ^-----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract TransactionLogger {\n    function logTransaction() public pure returns (bytes memory) {\n        return;\n    }\n    function startLog() public pure {}\n    function endLog() public pure {}\n}",
          "error message": ":1:128: TypeError: Return arguments required.\n ... e returns (bytes memory) {         return;     }     function startLog() publ ...\n                                        ^-----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract FeeCalculator {\n    function calculateFee() public pure returns (uint) {\n        return;\n    }\n}",
          "error message": ":1:114: TypeError: Return arguments required.\npragma solidity^0.5.0; contract FeeCalculator {     function calculateFee() public pure returns (uint) {         return;     } }\n                                                                                                                 ^-----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract StockChecker {\n    function checkStock() public pure returns (int) {\n        return;\n    }\n    function updateStock(int newStock) public pure {}\n}",
          "error message": ":1:110: TypeError: Return arguments required.\n ... ublic pure returns (int) {         return;     }     function updateStock(int ...\n                                        ^-----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract UserIdentifier {\n    function identifyUser() public pure returns (bytes32) {\n        return;\n    }\n}",
          "error message": ":1:118: TypeError: Return arguments required.\npragma solidity^0.5.0; contract UserIdentifier {     function identifyUser() public pure returns (bytes32) {         return;     } }\n                                                                                                                     ^-----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract PaymentValidator {\n    function validatePayment() public pure returns (bool) {\n        return;\n    }\n    function confirm() public pure {}\n}",
          "error message": ":1:120: TypeError: Return arguments required.\n ... blic pure returns (bool) {         return;     }     function confirm() publi ...\n                                        ^-----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ValueChecker {\n    function checkValue() public pure returns (bool) {\n        return true;\n    }\n    function auxiliary() public pure returns (int) {\n        return 5;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract AssetTracker {\n    function trackAsset() public pure returns (uint) {\n        return 1;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract HealthMonitor {\n    function monitorHealth() public pure returns (bytes32) {\n        return \"healthy\";\n    }\n    function logActivity() public pure {}\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ItemValidator {\n    function validateItem() public pure returns (string memory) {\n        return \"valid\";\n    }\n    function setup() public pure {}\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract MemberRegistrar {\n    function registerMember() public pure returns (address) {\n        return address(0);\n    }\n    function deregister() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract TransactionLogger {\n    function logTransaction() public pure returns (bytes memory) {\n        return \"log\";\n    }\n    function startLog() public pure {}\n    function endLog() public pure {}\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract FeeCalculator {\n    function calculateFee() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract StockChecker {\n    function checkStock() public pure returns (int) {\n        return 50;\n    }\n    function updateStock(int newStock) public pure {}\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract UserIdentifier {\n    function identifyUser() public pure returns (bytes32) {\n        return \"user\";\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract PaymentValidator {\n    function validatePayment() public pure returns (bool) {\n        return true;\n    }\n    function confirm() public pure {}\n}"
      }
    }
  },
  {
    "Changes46": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "In external function and contract creation calls, Ether and gas is now specified using a new syntax:\n<code>x.f{gas: 10000, value: 2 ether}(arg1, arg2)</code>.\nThe old syntax \u2013 <code>x.f.gas(10000).value(2 ether)(arg1, arg2)</code> \u2013 will cause an error.Change <code>x.f.value(...)()</code> to <code>x.f{value: ...}()</code>. Similarly <code>(new C).value(...)()</code> to <code>new C{value: ...}()</code> and <code>x.f.gas(...).value(...)()</code> to <code>x.f{gas: ..., value: ...}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract FundAllocator {\n    address payable public account;\n    constructor(address payable _account) public {\n        account = _account;\n    }\n    function allocate() public payable {\n        (bool allocated, ) = account.call.gas(3100).value(msg.value)(\"\");\n        require(allocated, \"Allocation failed\");\n    }\n    function helperFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... ble {         (bool allocated, ) = account.call.gas(3100).value(msg.value)(\"\");        ...\n                                        ^--------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract WealthManager {\n    address payable public manager;\n    constructor(address payable _manager) public {\n        manager = _manager;\n    }\n    function manageWealth() public payable {\n        (bool managed, ) = manager.call.gas(4200).value(msg.value)(\"\");\n        require(managed, \"Management failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... yable {         (bool managed, ) = manager.call.gas(4200).value(msg.value)(\"\");        ...\n                                        ^--------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract AssetDistributor {\n    address payable public distributor;\n    constructor(address payable _distributor) public {\n        distributor = _distributor;\n    }\n    function distributeAssets() public payable {\n        (bool distributed, ) = distributor.call.gas(5300).value(msg.value)(\"\");\n        require(distributed, \"Distribution failed\");\n    }\n    function extraMethod() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... e {         (bool distributed, ) = distributor.call.gas(5300).value(msg.value)(\"\");        ...\n                                        ^------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract MoneyHandler {\n    address payable public handler;\n    constructor(address payable _handler) public {\n        handler = _handler;\n    }\n    function handleFunds() public payable {\n        (bool handled, ) = handler.call.gas(6400).value(msg.value)(\"\");\n        require(handled, \"Handling failed\");\n    }\n    function calculateSomething() public pure returns (uint) {\n        return 12345;\n    }\n    function dummy() public pure {}\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... yable {         (bool handled, ) = handler.call.gas(6400).value(msg.value)(\"\");        ...\n                                        ^--------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract CashFlowController {\n    address payable public controller;\n    constructor(address payable _controller) public {\n        controller = _controller;\n    }\n    function controlCashFlow() public payable {\n        (bool controlled, ) = controller.call.gas(3500).value(msg.value)(\"\");\n        require(controlled, \"Control failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... le {         (bool controlled, ) = controller.call.gas(3500).value(msg.value)(\"\");        ...\n                                        ^-----------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract RevenueCollector {\n    address payable public collector;\n    constructor(address payable _collector) public {\n        collector = _collector;\n    }\n    function collectRevenue() public payable {\n        (bool collected, ) = collector.call.gas(4600).value(msg.value)(\"\");\n        require(collected, \"Collection failed\");\n    }\n    function nonEssentialFunction() public pure returns (string memory) {\n        return \"Non-Essential\";\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... ble {         (bool collected, ) = collector.call.gas(4600).value(msg.value)(\"\");        ...\n                                        ^----------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract PaymentFacilitator {\n    address payable public facilitator;\n    constructor(address payable _facilitator) public {\n        facilitator = _facilitator;\n    }\n    function facilitatePayment() public payable {\n        (bool facilitated, ) = facilitator.call.gas(5700).value(msg.value)(\"\");\n        require(facilitated, \"Payment facilitation failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... e {         (bool facilitated, ) = facilitator.call.gas(5700).value(msg.value)(\"\");        ...\n                                        ^------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract CapitalFlowManager {\n    address payable public manager;\n    constructor(address payable _manager) public {\n        manager = _manager;\n    }\n    function manageCapitalFlow() public payable {\n        (bool managed, ) = manager.call.gas(3800).value(msg.value)(\"\");\n        require(managed, \"Capital flow management failed\");\n    }\n    function unused() public pure {}\n    function anotherDummy() public pure {}\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... yable {         (bool managed, ) = manager.call.gas(3800).value(msg.value)(\"\");        ...\n                                        ^--------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract CashMover {\n    address payable public mover;\n    constructor(address payable _mover) public {\n        mover = _mover;\n    }\n    function moveCash() public payable {\n        (bool moved, ) = mover.call.gas(4900).value(msg.value)(\"\");\n        require(moved, \"Cash move failed\");\n    }\n    function extra() public pure returns (uint) {\n        return 88;\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... payable {         (bool moved, ) = mover.call.gas(4900).value(msg.value)(\"\");        ...\n                                        ^------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract ResourceController {\n    address payable public controller;\n    constructor(address payable _controller) public {\n        controller = _controller;\n    }\n    function controlResources() public payable {\n        (bool controlled, ) = controller.call.gas(6000).value(msg.value)(\"\");\n        require(controlled, \"Resource control failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... le {         (bool controlled, ) = controller.call.gas(6000).value(msg.value)(\"\");        ...\n                                        ^-----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract FundAllocator {\n    address payable public account;\n    constructor(address payable _account) public {\n        account = _account;\n    }\n    function allocate() public payable {\n        (bool allocated, ) = account.call{gas: 3100, value: msg.value}(\"\");\n        require(allocated, \"Allocation failed\");\n    }\n    function helperFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract WealthManager {\n    address payable public manager;\n    constructor(address payable _manager) public {\n        manager = _manager;\n    }\n    function manageWealth() public payable {\n        (bool managed, ) = manager.call{gas: 4200, value: msg.value}(\"\");\n        require(managed, \"Management failed\");\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract AssetDistributor {\n    address payable public distributor;\n    constructor(address payable _distributor) public {\n        distributor = _distributor;\n    }\n    function distributeAssets() public payable {\n        (bool distributed, ) = distributor.call{gas: 5300, value: msg.value}(\"\");\n        require(distributed, \"Distribution failed\");\n    }\n    function extraMethod() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract MoneyHandler {\n    address payable public handler;\n    constructor(address payable _handler) public {\n        handler = _handler;\n    }\n    function handleFunds() public payable {\n        (bool handled, ) = handler.call{gas: 6400, value: msg.value}(\"\");\n        require(handled, \"Handling failed\");\n    }\n    function calculateSomething() public pure returns (uint) {\n        return 12345;\n    }\n    function dummy() public pure {}\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract CashFlowController {\n    address payable public controller;\n    constructor(address payable _controller) public {\n        controller = _controller;\n    }\n    function controlCashFlow() public payable {\n        (bool controlled, ) = controller.call{gas: 3500, value: msg.value}(\"\");\n        require(controlled, \"Control failed\");\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract RevenueCollector {\n    address payable public collector;\n    constructor(address payable _collector) public {\n        collector = _collector;\n    }\n    function collectRevenue() public payable {\n        (bool collected, ) = collector.call{gas: 4600, value: msg.value}(\"\");\n        require(collected, \"Collection failed\");\n    }\n    function nonEssentialFunction() public pure returns (string memory) {\n        return \"Non-Essential\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract PaymentFacilitator {\n    address payable public facilitator;\n    constructor(address payable _facilitator) public {\n        facilitator = _facilitator;\n    }\n    function facilitatePayment() public payable {\n        (bool facilitated, ) = facilitator.call{gas: 5700, value: msg.value}(\"\");\n        require(facilitated, \"Payment facilitation failed\");\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract CapitalFlowManager {\n    address payable public manager;\n    constructor(address payable _manager) public {\n        manager = _manager;\n    }\n    function manageCapitalFlow() public payable {\n        (bool managed, ) = manager.call{gas: 3800, value: msg.value}(\"\");\n        require(managed, \"Capital flow management failed\");\n    }\n    function unused() public pure {}\n    function anotherDummy() public pure {}\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract CashMover {\n    address payable public mover;\n    constructor(address payable _mover) public {\n        mover = _mover;\n    }\n    function moveCash() public payable {\n        (bool moved, ) = mover.call{gas: 4900, value: msg.value}(\"\");\n        require(moved, \"Cash move failed\");\n    }\n    function extra() public pure returns (uint) {\n        return 88;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract ResourceController {\n    address payable public controller;\n    constructor(address payable _controller) public {\n        controller = _controller;\n    }\n    function controlResources() public payable {\n        (bool controlled, ) = controller.call{gas: 6000, value: msg.value}(\"\");\n        require(controlled, \"Resource control failed\");\n    }\n}"
      }
    }
  },
  {
    "Changes47": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The global variable <code>now</code> is deprecated, <code>block.timestamp</code> should be used instead.\nThe single identifier <code>now</code> is too generic for a global variable and could give the impression\nthat it changes during transaction processing, whereas <code>block.timestamp</code> correctly\nreflects the fact that it is just a property of the block.Change <code>now</code> to <code>block.timestamp</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeCapture {\n    function captureCurrent() public view returns (uint) {\n        return now;\n    }\n    function extraHelper() public pure returns (int) {\n        return 2024;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function extraHelper()  ...\n                                        ^-^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract EventScheduler {\n    function getEventTime() public view returns (uint) {\n        return now;\n    }\n    function additionalMethod() public pure returns (uint) {\n        return 1000;\n    }\n    function extraDataMethod() public pure returns (string memory) {\n        return \"ExtraInfo\";\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function additionalMeth ...\n                                        ^-^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract BlockWatcher {\n    function watchBlockTime() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract BlockWatcher {     function watchBlockTime() public view returns (uint) {         return now;     } }\n                                                                                                                         ^-^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract CurrentTime {\n    function queryCurrentTime() public view returns (uint) {\n        return now;\n    }\n    function unusedMethod() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function unusedMethod() ...\n                                        ^-^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract SystemClock {\n    function getSystemClock() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract SystemClock {     function getSystemClock() public view returns (uint) {         return now;     } }\n                                                                                                                        ^-^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeQuery {\n    function queryTime() public view returns (uint) {\n        return now;\n    }\n    function helperFunction() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function helperFunction ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract Clock {\n    function currentClock() public view returns (uint) {\n        return now;\n    }\n    function simpleFunction() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function simpleFunction ...\n                                        ^-^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeLog {\n    function logTime() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract TimeLog {     function logTime() public view returns (uint) {         return now;     } }\n                                                                                                             ^-^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract InstantTime {\n    function getInstantTime() public view returns (uint) {\n        return now;\n    }\n    function randomOutput() public pure returns (uint) {\n        return 2023;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function randomOutput() ...\n                                        ^-^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract TemporalCheck {\n    function checkTimeNow() public view returns (uint) {\n        return now;\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function randomFunction ...\n                                        ^-^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract TimeCapture {\n    function captureCurrent() public view returns (uint) {\n        return block.timestamp;\n    }\n    function extraHelper() public pure returns (int) {\n        return 2024;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract EventScheduler {\n    function getEventTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function additionalMethod() public pure returns (uint) {\n        return 1000;\n    }\n    function extraDataMethod() public pure returns (string memory) {\n        return \"ExtraInfo\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract BlockWatcher {\n    function watchBlockTime() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract CurrentTime {\n    function queryCurrentTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function unusedMethod() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract SystemClock {\n    function getSystemClock() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract TimeQuery {\n    function queryTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function helperFunction() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract Clock {\n    function currentClock() public view returns (uint) {\n        return block.timestamp;\n    }\n    function simpleFunction() public pure returns (int) {\n        return 42;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract TimeLog {\n    function logTime() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract InstantTime {\n    function getInstantTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function randomOutput() public pure returns (uint) {\n        return 2023;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract TemporalCheck {\n    function checkTimeNow() public view returns (uint) {\n        return block.timestamp;\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"random\";\n    }\n}"
      }
    }
  },
  {
    "Changes48": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The token <code>gwei</code> is a keyword now (used to specify, e.g. <code>2 gwei</code> as a number)\nand cannot be used as an identifier.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract Example11 {\n    uint public gwei;\n    uint public volume;\n\n    constructor(uint initialVolume) {\n        gwei = 101;\n        volume = initialVolume;\n    }\n\n    function adjustVolume(uint newVolume) public {\n        volume = newVolume;\n    }\n\n    function getVolume() public view returns (uint) {\n        return volume;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example11 {     uint public gwei;     uint public volume;      cons ...\n                                        ^--^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract Example12 {\n    uint public gwei;\n    uint public capacity;\n\n    constructor(uint initialCapacity) {\n        gwei = 202;\n        capacity = initialCapacity;\n    }\n\n    function setCapacity(uint newCapacity) public {\n        capacity = newCapacity;\n    }\n\n    function getCapacity() public view returns (uint) {\n        return capacity;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example12 {     uint public gwei;     uint public capacity;      co ...\n                                        ^--^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract Example13 {\n    uint public gwei;\n    uint public load;\n\n    constructor(uint initialLoad) {\n        gwei = 303;\n        load = initialLoad;\n    }\n\n    function modifyLoad(uint newLoad) public {\n        load = newLoad;\n    }\n\n    function getLoad() public view returns (uint) {\n        return load;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example13 {     uint public gwei;     uint public load;      constr ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract Example14 {\n    uint public gwei;\n    uint public speed;\n\n    constructor(uint initialSpeed) {\n        gwei = 404;\n        speed = initialSpeed;\n    }\n\n    function updateSpeed(uint newSpeed) public {\n        speed = newSpeed;\n    }\n\n    function getSpeed() public view returns (uint) {\n        return speed;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example14 {     uint public gwei;     uint public speed;      const ...\n                                        ^--^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract Example15 {\n    uint public gwei;\n    uint public energy;\n\n    constructor(uint initialEnergy) {\n        gwei = 505;\n        energy = initialEnergy;\n    }\n\n    function adjustEnergy(uint newEnergy) public {\n        energy = newEnergy;\n    }\n\n    function getEnergy() public view returns (uint) {\n        return energy;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example15 {     uint public gwei;     uint public energy;      cons ...\n                                        ^--^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract Example16 {\n    uint public gwei;\n    uint public intensity;\n\n    constructor(uint initialIntensity) {\n        gwei = 606;\n        intensity = initialIntensity;\n    }\n\n    function setIntensity(uint newIntensity) public {\n        intensity = newIntensity;\n    }\n\n    function getIntensity() public view returns (uint) {\n        return intensity;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example16 {     uint public gwei;     uint public intensity;      c ...\n                                        ^--^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract Example17 {\n    uint public gwei;\n    uint public density;\n\n    constructor(uint initialDensity) {\n        gwei = 707;\n        density = initialDensity;\n    }\n\n    function modifyDensity(uint newDensity) public {\n        density = newDensity;\n    }\n\n    function getDensity() public view returns (uint) {\n        return density;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example17 {     uint public gwei;     uint public density;      con ...\n                                        ^--^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract Example18 {\n    uint public gwei;\n    uint public mass;\n\n    constructor(uint initialMass) {\n        gwei = 808;\n        mass = initialMass;\n    }\n\n    function updateMass(uint newMass) public {\n        mass = newMass;\n    }\n\n    function getMass() public view returns (uint) {\n        return mass;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example18 {     uint public gwei;     uint public mass;      constr ...\n                                        ^--^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract Example19 {\n    uint public gwei;\n    uint public force;\n\n    constructor(uint initialForce) {\n        gwei = 909;\n        force = initialForce;\n    }\n\n    function setForce(uint newForce) public {\n        force = newForce;\n    }\n\n    function getForce() public view returns (uint) {\n        return force;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example19 {     uint public gwei;     uint public force;      const ...\n                                        ^--^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract Example20 {\n    uint public gwei;\n    uint public pressure;\n\n    constructor(uint initialPressure) {\n        gwei = 1001;\n        pressure = initialPressure;\n    }\n\n    function adjustPressure(uint newPressure) public {\n        pressure = newPressure;\n    }\n\n    function getPressure() public view returns (uint) {\n        return pressure;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example20 {     uint public gwei;     uint public pressure;      co ...\n                                        ^--^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract Example11 {\n    uint public unitPrice;\n    uint public volume;\n\n    constructor(uint initialVolume) {\n        unitPrice = 101;\n        volume = initialVolume;\n    }\n\n    function adjustVolume(uint newVolume) public {\n        volume = newVolume;\n    }\n\n    function getVolume() public view returns (uint) {\n        return volume;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract Example12 {\n    uint public unitPrice;\n    uint public capacity;\n\n    constructor(uint initialCapacity) {\n        unitPrice = 202;\n        capacity = initialCapacity;\n    }\n\n    function setCapacity(uint newCapacity) public {\n        capacity = newCapacity;\n    }\n\n    function getCapacity() public view returns (uint) {\n        return capacity;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract Example13 {\n    uint public unitPrice;\n    uint public load;\n\n    constructor(uint initialLoad) {\n        unitPrice = 303;\n        load = initialLoad;\n    }\n\n    function modifyLoad(uint newLoad) public {\n        load = newLoad;\n    }\n\n    function getLoad() public view returns (uint) {\n        return load;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract Example14 {\n    uint public unitPrice;\n    uint public speed;\n\n    constructor(uint initialSpeed) {\n        unitPrice = 404;\n        speed = initialSpeed;\n    }\n\n    function updateSpeed(uint newSpeed) public {\n        speed = newSpeed;\n    }\n\n    function getSpeed() public view returns (uint) {\n        return speed;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract Example15 {\n    uint public unitPrice;\n    uint public energy;\n\n    constructor(uint initialEnergy) {\n        unitPrice = 505;\n        energy = initialEnergy;\n    }\n\n    function adjustEnergy(uint newEnergy) public {\n        energy = newEnergy;\n    }\n\n    function getEnergy() public view returns (uint) {\n        return energy;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract Example16 {\n    uint public unitPrice;\n    uint public intensity;\n\n    constructor(uint initialIntensity) {\n        unitPrice = 606;\n        intensity = initialIntensity;\n    }\n\n    function setIntensity(uint newIntensity) public {\n        intensity = newIntensity;\n    }\n\n    function getIntensity() public view returns (uint) {\n        return intensity;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract Example17 {\n    uint public unitPrice;\n    uint public density;\n\n    constructor(uint initialDensity) {\n        unitPrice = 707;\n        density = initialDensity;\n    }\n\n    function modifyDensity(uint newDensity) public {\n        density = newDensity;\n    }\n\n    function getDensity() public view returns (uint) {\n        return density;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract Example18 {\n    uint public unitPrice;\n    uint public mass;\n\n    constructor(uint initialMass) {\n        unitPrice = 808;\n        mass = initialMass;\n    }\n\n    function updateMass(uint newMass) public {\n        mass = newMass;\n    }\n\n    function getMass() public view returns (uint) {\n        return mass;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract Example19 {\n    uint public unitPrice;\n    uint public force;\n\n    constructor(uint initialForce) {\n        unitPrice = 909;\n        force = initialForce;\n    }\n\n    function setForce(uint newForce) public {\n        force = newForce;\n    }\n\n    function getForce() public view returns (uint) {\n        return force;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract Example20 {\n    uint public unitPrice;\n    uint public pressure;\n\n    constructor(uint initialPressure) {\n        unitPrice = 1001;\n        pressure = initialPressure;\n    }\n\n    function adjustPressure(uint newPressure) public {\n        pressure = newPressure;\n    }\n\n    function getPressure() public view returns (uint) {\n        return pressure;\n    }\n}"
      }
    }
  },
  {
    "Changes49": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Disallow <code>.</code> in user-defined function and variable names in inline assembly.\nIt is still valid if you use Solidity in Yul-only mode.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleOne {\n    function computeAmount() public pure returns (uint) {\n        uint x;\n        assembly {\n            let temp.amount := 150\n            x := add(temp.amount, 50)\n        }\n        return x;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let temp.amount := 150             x := add(temp.a ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleTwo {\n    function calculateTotal() public pure returns (uint) {\n        uint y;\n        assembly {\n            let total.value := 80\n            y := add(total.value, 20)\n        }\n        return y;\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 1000;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let total.value := 80             y := add(total.v ...\n                                        ^---------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleThree {\n    function getResult() public pure returns (uint) {\n        uint z;\n        assembly {\n            let result.value := 90\n            z := add(result.value, 10)\n        }\n        return z;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let result.value := 90             z := add(result. ...\n                                        ^----------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleFour {\n    function generateNumber() public pure returns (uint) {\n        uint a;\n        assembly {\n            let number.amount := 200\n            a := add(number.amount, 100)\n        }\n        return a;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let number.amount := 200             a := add(number ...\n                                        ^-----------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleFive {\n    function retrieveValue() public pure returns (uint) {\n        uint b;\n        assembly {\n            let value.info := 65\n            b := add(value.info, 35)\n        }\n        return b;\n    }\n    function extraFuncOne() public pure returns (uint) {\n        return 250;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let value.info := 65             b := add(value.i ...\n                                        ^--------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleSix {\n    function gatherDetails() public pure returns (uint) {\n        uint c;\n        assembly {\n            let details.info := 110\n            c := add(details.info, 90)\n        }\n        return c;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let details.info := 110             c := add(detail ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleSeven {\n    function deriveResult() public pure returns (uint) {\n        uint d;\n        assembly {\n            let result.data := 120\n            d := add(result.data, 30)\n        }\n        return d;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let result.data := 120             d := add(result ...\n                                        ^---------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleEight {\n    function extractInfo() public pure returns (uint) {\n        uint e;\n        assembly {\n            let info.part := 140\n            e := add(info.part, 60)\n        }\n        return e;\n    }\n    function extraFuncTwo() public pure returns (uint) {\n        return 360;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let info.part := 140             e := add(info.p ...\n                                        ^-------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleNine {\n    function obtainValue() public pure returns (uint) {\n        uint f;\n        assembly {\n            let value.amount := 170\n            f := add(value.amount, 30)\n        }\n        return f;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let value.amount := 170             f := add(value. ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleTen {\n    function fetchDetail() public pure returns (uint) {\n        uint g;\n        assembly {\n            let detail.info := 95\n            g := add(detail.info, 5)\n        }\n        return g;\n    }\n    function additionalFunction() public pure returns (uint) {\n        return 450;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let detail.info := 95             g := add(detail. ...\n                                        ^---------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract AssemblyExampleOne {\n    function computeAmount() public pure returns (uint) {\n        uint x;\n        assembly {\n            let tempAmount := 150\n            x := add(tempAmount, 50)\n        }\n        return x;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract AssemblyExampleTwo {\n    function calculateTotal() public pure returns (uint) {\n        uint y;\n        assembly {\n            let totalValue := 80\n            y := add(totalValue, 20)\n        }\n        return y;\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 1000;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract AssemblyExampleThree {\n    function getResult() public pure returns (uint) {\n        uint z;\n        assembly {\n            let resultValue := 90\n            z := add(resultValue, 10)\n        }\n        return z;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract AssemblyExampleFour {\n    function generateNumber() public pure returns (uint) {\n        uint a;\n        assembly {\n            let numberAmount := 200\n            a := add(numberAmount, 100)\n        }\n        return a;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract AssemblyExampleFive {\n    function retrieveValue() public pure returns (uint) {\n        uint b;\n        assembly {\n            let valueInfo := 65\n            b := add(valueInfo, 35)\n        }\n        return b;\n    }\n    function extraFuncOne() public pure returns (uint) {\n        return 250;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract AssemblyExampleSix {\n    function gatherDetails() public pure returns (uint) {\n        uint c;\n        assembly {\n            let detailsInfo := 110\n            c := add(detailsInfo, 90)\n        }\n        return c;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract AssemblyExampleSeven {\n    function deriveResult() public pure returns (uint) {\n        uint d;\n        assembly {\n            let resultData := 120\n            d := add(resultData, 30)\n        }\n        return d;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract AssemblyExampleEight {\n    function extractInfo() public pure returns (uint) {\n        uint e;\n        assembly {\n            let infoPart := 140\n            e := add(infoPart, 60)\n        }\n        return e;\n    }\n    function extraFuncTwo() public pure returns (uint) {\n        return 360;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract AssemblyExampleNine {\n    function obtainValue() public pure returns (uint) {\n        uint f;\n        assembly {\n            let valueAmount := 170\n            f := add(valueAmount, 30)\n        }\n        return f;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract AssemblyExampleTen {\n    function fetchDetail() public pure returns (uint) {\n        uint g;\n        assembly {\n            let detailInfo := 95\n            g := add(detailInfo, 5)\n        }\n        return g;\n    }\n    function additionalFunction() public pure returns (uint) {\n        return 450;\n    }\n}"
      }
    }
  },
  {
    "Changes50": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Slot and offset of storage pointer variable <code>x</code> are accessed via <code>x.slot</code>\nand <code>x.offset</code> instead of <code>x_slot</code> and <code>x_offset</code>.Change <code>_slot</code> and <code>_offset</code> suffixes in inline assembly to <code>.slot</code> and <code>.offset</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Profile {\n        uint256 age;\n    }\n\n    Profile private profile;\n\n    function setAge(uint256 _age) public {\n        profile.age = _age;\n    }\n\n    function getAge() public view returns (uint256) {\n        return profile.age;\n    }\n\n    function storageSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 profileSlot;\n        uint256 profileOffset;\n        \n        assembly {\n            profileSlot := profile_slot\n            profileOffset := profile_offset\n        }\n        \n        return (profileSlot, profileOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             profileSlot := profile_slot             profileOffset := profi ...\n                                        ^----------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Record {\n        uint256 value;\n    }\n\n    Record private record;\n\n    function setValue(uint256 _value) public {\n        record.value = _value;\n    }\n\n    function getValue() public view returns (uint256) {\n        return record.value;\n    }\n\n    function findSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 recordSlot;\n        uint256 recordOffset;\n        \n        assembly {\n            recordSlot := record_slot\n            recordOffset := record_offset\n        }\n        \n        return (recordSlot, recordOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             recordSlot := record_slot             recordOffset := record ...\n                                        ^---------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Item {\n        uint256 price;\n    }\n\n    Item private item;\n\n    function setPrice(uint256 _price) public {\n        item.price = _price;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return item.price;\n    }\n\n    function retrieveStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 itemSlot;\n        uint256 itemOffset;\n        \n        assembly {\n            itemSlot := item_slot\n            itemOffset := item_offset\n        }\n        \n        return (itemSlot, itemOffset);\n    }\n\n    function dummyFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             itemSlot := item_slot             itemOffset := item_off ...\n                                        ^-------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Entry {\n        uint256 amount;\n    }\n\n    Entry private entry;\n\n    function setAmount(uint256 _amount) public {\n        entry.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return entry.amount;\n    }\n\n    function accessStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 entrySlot;\n        uint256 entryOffset;\n        \n        assembly {\n            entrySlot := entry_slot\n            entryOffset := entry_offset\n        }\n        \n        return (entrySlot, entryOffset);\n    }\n\n    function dummyFunction2() public pure returns (uint256) {\n        return 100;\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             entrySlot := entry_slot             entryOffset := entry_o ...\n                                        ^--------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Detail {\n        uint256 score;\n    }\n\n    Detail private detail;\n\n    function setScore(uint256 _score) public {\n        detail.score = _score;\n    }\n\n    function getScore() public view returns (uint256) {\n        return detail.score;\n    }\n\n    function storageDetails() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 detailSlot;\n        uint256 detailOffset;\n        \n        assembly {\n            detailSlot := detail_slot\n            detailOffset := detail_offset\n        }\n        \n        return (detailSlot, detailOffset);\n    }\n\n    function dummyFunction3() public pure returns (string memory) {\n        return \"Solidity\";\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             detailSlot := detail_slot             detailOffset := detail ...\n                                        ^---------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Property {\n        uint256 size;\n    }\n\n    Property private property;\n\n    function setSize(uint256 _size) public {\n        property.size = _size;\n    }\n\n    function getSize() public view returns (uint256) {\n        return property.size;\n    }\n\n    function retrieveSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 propertySlot;\n        uint256 propertyOffset;\n        \n        assembly {\n            propertySlot := property_slot\n            propertyOffset := property_offset\n        }\n        \n        return (propertySlot, propertyOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... mbly {             propertySlot := property_slot             propertyOffset := prop ...\n                                        ^-----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Token {\n        uint256 balance;\n    }\n\n    Token private token;\n\n    function setBalance(uint256 _balance) public {\n        token.balance = _balance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return token.balance;\n    }\n\n    function getStoragePointers() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 tokenSlot;\n        uint256 tokenOffset;\n        \n        assembly {\n            tokenSlot := token_slot\n            tokenOffset := token_offset\n        }\n        \n        return (tokenSlot, tokenOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             tokenSlot := token_slot             tokenOffset := token_o ...\n                                        ^--------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Value {\n        uint256 amount;\n    }\n\n    Value private value;\n\n    function setAmount(uint256 _amount) public {\n        value.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return value.amount;\n    }\n\n    function fetchSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 valueSlot;\n        uint256 valueOffset;\n        \n        assembly {\n            valueSlot := value_slot\n            valueOffset := value_offset\n        }\n        \n        return (valueSlot, valueOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             valueSlot := value_slot             valueOffset := value_o ...\n                                        ^--------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Account {\n        uint256 balance;\n    }\n\n    Account private account;\n\n    function setBalance(uint256 _balance) public {\n        account.balance = _balance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return account.balance;\n    }\n\n    function retrieveSlotInfo() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 accountSlot;\n        uint256 accountOffset;\n        \n        assembly {\n            accountSlot := account_slot\n            accountOffset := account_offset\n        }\n        \n        return (accountSlot, accountOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             accountSlot := account_slot             accountOffset := accou ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Holder {\n        uint256 quantity;\n    }\n\n    Holder private holder;\n\n    function setQuantity(uint256 _quantity) public {\n        holder.quantity = _quantity;\n    }\n\n    function getQuantity() public view returns (uint256) {\n        return holder.quantity;\n    }\n\n    function storageLocation() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 holderSlot;\n        uint256 holderOffset;\n        \n        assembly {\n            holderSlot := holder_slot\n            holderOffset := holder_offset\n        }\n        \n        return (holderSlot, holderOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             holderSlot := holder_slot             holderOffset := holder ...\n                                        ^---------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Profile {\n        uint256 age;\n    }\n\n    Profile private profile;\n\n    function setAge(uint256 _age) public {\n        profile.age = _age;\n    }\n\n    function getAge() public view returns (uint256) {\n        return profile.age;\n    }\n\n    function storageSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 profileSlot;\n        uint256 profileOffset;\n        \n        assembly {\n            profileSlot := profile.slot\n            profileOffset := profile.offset\n        }\n        \n        return (profileSlot, profileOffset);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Record {\n        uint256 value;\n    }\n\n    Record private record;\n\n    function setValue(uint256 _value) public {\n        record.value = _value;\n    }\n\n    function getValue() public view returns (uint256) {\n        return record.value;\n    }\n\n    function findSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 recordSlot;\n        uint256 recordOffset;\n        \n        assembly {\n            recordSlot := record.slot\n            recordOffset := record.offset\n        }\n        \n        return (recordSlot, recordOffset);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Item {\n        uint256 price;\n    }\n\n    Item private item;\n\n    function setPrice(uint256 _price) public {\n        item.price = _price;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return item.price;\n    }\n\n    function retrieveStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 itemSlot;\n        uint256 itemOffset;\n        \n        assembly {\n            itemSlot := item.slot\n            itemOffset := item.offset\n        }\n        \n        return (itemSlot, itemOffset);\n    }\n\n    function dummyFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Entry {\n        uint256 amount;\n    }\n\n    Entry private entry;\n\n    function setAmount(uint256 _amount) public {\n        entry.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return entry.amount;\n    }\n\n    function accessStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 entrySlot;\n        uint256 entryOffset;\n        \n        assembly {\n            entrySlot := entry.slot\n            entryOffset := entry.offset\n        }\n        \n        return (entrySlot, entryOffset);\n    }\n\n    function dummyFunction2() public pure returns (uint256) {\n        return 100;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Detail {\n        uint256 score;\n    }\n\n    Detail private detail;\n\n    function setScore(uint256 _score) public {\n        detail.score = _score;\n    }\n\n    function getScore() public view returns (uint256) {\n        return detail.score;\n    }\n\n    function storageDetails() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 detailSlot;\n        uint256 detailOffset;\n        \n        assembly {\n            detailSlot := detail.slot\n            detailOffset := detail.offset\n        }\n        \n        return (detailSlot, detailOffset);\n    }\n\n    function dummyFunction3() public pure returns (string memory) {\n        return \"Solidity\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Property {\n        uint256 size;\n    }\n\n    Property private property;\n\n    function setSize(uint256 _size) public {\n        property.size = _size;\n    }\n\n    function getSize() public view returns (uint256) {\n        return property.size;\n    }\n\n    function retrieveSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 propertySlot;\n        uint256 propertyOffset;\n        \n        assembly {\n            propertySlot := property.slot\n            propertyOffset := property.offset\n        }\n        \n        return (propertySlot, propertyOffset);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Token {\n        uint256 balance;\n    }\n\n    Token private token;\n\n    function setBalance(uint256 _balance) public {\n        token.balance = _balance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return token.balance;\n    }\n\n    function getStoragePointers() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 tokenSlot;\n        uint256 tokenOffset;\n        \n        assembly {\n            tokenSlot := token.slot\n            tokenOffset := token.offset\n        }\n        \n        return (tokenSlot, tokenOffset);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Value {\n        uint256 amount;\n    }\n\n    Value private value;\n\n    function setAmount(uint256 _amount) public {\n        value.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return value.amount;\n    }\n\n    function fetchSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 valueSlot;\n        uint256 valueOffset;\n        \n        assembly {\n            valueSlot := value.slot\n            valueOffset := value.offset\n        }\n        \n        return (valueSlot, valueOffset);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Account {\n        uint256 balance;\n    }\n\n    Account private account;\n\n    function setBalance(uint256 _balance) public {\n        account.balance = _balance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return account.balance;\n    }\n\n    function retrieveSlotInfo() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 accountSlot;\n        uint256 accountOffset;\n        \n        assembly {\n            accountSlot := account.slot\n            accountOffset := account.offset\n        }\n        \n        return (accountSlot, accountOffset);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Holder {\n        uint256 quantity;\n    }\n\n    Holder private holder;\n\n    function setQuantity(uint256 _quantity) public {\n        holder.quantity = _quantity;\n    }\n\n    function getQuantity() public view returns (uint256) {\n        return holder.quantity;\n    }\n\n    function storageLocation() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 holderSlot;\n        uint256 holderOffset;\n        \n        assembly {\n            holderSlot := holder.slot\n            holderOffset := holder.offset\n        }\n        \n        return (holderSlot, holderOffset);\n    }\n}"
      }
    }
  },
  {
    "Changes51": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "If a struct or array contains a mapping, it can only be used in storage.\nPreviously, mapping members were silently skipped in memory, which\nis confusing and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Detail {\n        uint amount;\n        mapping(address => uint) credits;\n    }\n\n    Detail[] public details;\n\n    function addDetail(uint _amount) public {\n        Detail memory newDetail;\n        newDetail.amount = _amount;\n        details.push(newDetail);\n    }\n\n    function setCredit(uint index, address user, uint credit) public {\n        details[index].credits[user] = credit;\n    }\n\n    function getCredit(uint index, address user) public view returns (uint) {\n        return details[index].credits[user];\n    }\n}",
          "error message": "Error: Type struct Example11.Detail is only valid in storage because it contains a (nested) mapping.\n ... ail(uint _amount) public {         Detail memory newDetail;         newDetail.amount = _amoun ...\n                                        ^---------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Account {\n        uint balance;\n        mapping(address => uint) allowances;\n    }\n\n    Account[] public accounts;\n\n    function addAccount(uint _balance) public {\n        Account memory newAccount;\n        newAccount.balance = _balance;\n        accounts.push(newAccount);\n    }\n\n    function updateAllowance(uint index, address user, uint allowance) public {\n        accounts[index].allowances[user] = allowance;\n    }\n\n    function viewAllowance(uint index, address user) public view returns (uint) {\n        return accounts[index].allowances[user];\n    }\n\n    function dummyFunction7() public pure returns (string memory) {\n        return \"Dummy function 7\";\n    }\n}",
          "error message": "Error: Type struct Example12.Account is only valid in storage because it contains a (nested) mapping.\n ... nt(uint _balance) public {         Account memory newAccount;         newAccount.balance = _bal ...\n                                        ^-----------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Member {\n        uint id;\n        mapping(address => uint) votes;\n    }\n\n    Member[] public members;\n\n    function registerMember(uint _id) public {\n        Member memory newMember;\n        newMember.id = _id;\n        members.push(newMember);\n    }\n\n    function castVote(uint index, address user, uint vote) public {\n        members[index].votes[user] = vote;\n    }\n\n    function getVote(uint index, address user) public view returns (uint) {\n        return members[index].votes[user];\n    }\n}",
          "error message": "Error: Type struct Example13.Member is only valid in storage because it contains a (nested) mapping.\n ... rMember(uint _id) public {         Member memory newMember;         newMember.id = _id;       ...\n                                        ^---------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Client {\n        uint clientId;\n        mapping(address => uint) balances;\n    }\n\n    Client[] public clients;\n\n    function addClient(uint _clientId) public {\n        Client memory newClient;\n        newClient.clientId = _clientId;\n        clients.push(newClient);\n    }\n\n    function updateBalance(uint index, address user, uint balance) public {\n        clients[index].balances[user] = balance;\n    }\n\n    function getBalance(uint index, address user) public view returns (uint) {\n        return clients[index].balances[user];\n    }\n\n    function dummyFunction8() public pure returns (uint) {\n        return 50;\n    }\n}",
          "error message": "Error: Type struct Example14.Client is only valid in storage because it contains a (nested) mapping.\n ... t(uint _clientId) public {         Client memory newClient;         newClient.clientId = _cli ...\n                                        ^---------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Transaction {\n        uint id;\n        mapping(address => uint) amounts;\n    }\n\n    Transaction[] public transactions;\n\n    function addTransaction(uint _id) public {\n        Transaction memory newTransaction;\n        newTransaction.id = _id;\n        transactions.push(newTransaction);\n    }\n\n    function updateAmount(uint index, address user, uint amount) public {\n        transactions[index].amounts[user] = amount;\n    }\n\n    function getAmount(uint index, address user) public view returns (uint) {\n        return transactions[index].amounts[user];\n    }\n}",
          "error message": "Error: Type struct Example15.Transaction is only valid in storage because it contains a (nested) mapping.\n ... saction(uint _id) public {         Transaction memory newTransaction;         newTransaction.id = _id;  ...\n                                        ^-------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Package {\n        uint packageId;\n        mapping(address => uint) weights;\n    }\n\n    Package[] public packages;\n\n    function addPackage(uint _packageId) public {\n        Package memory newPackage;\n        newPackage.packageId = _packageId;\n        packages.push(newPackage);\n    }\n\n    function setWeight(uint index, address user, uint weight) public {\n        packages[index].weights[user] = weight;\n    }\n\n    function getWeight(uint index, address user) public view returns (uint) {\n        return packages[index].weights[user];\n    }\n}",
          "error message": "Error: Type struct Example16.Package is only valid in storage because it contains a (nested) mapping.\n ... (uint _packageId) public {         Package memory newPackage;         newPackage.packageId = _p ...\n                                        ^-----------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Asset {\n        uint assetId;\n        mapping(address => uint) values;\n    }\n\n    Asset[] public assets;\n\n    function registerAsset(uint _assetId) public {\n        Asset memory newAsset;\n        newAsset.assetId = _assetId;\n        assets.push(newAsset);\n    }\n\n    function setValue(uint index, address user, uint value) public {\n        assets[index].values[user] = value;\n    }\n\n    function getValue(uint index, address user) public view returns (uint) {\n        return assets[index].values[user];\n    }\n\n    function dummyFunction9() public pure returns (bool) {\n        return false;\n    }\n\n    function dummyFunction10() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": "Error: Type struct Example17.Asset is only valid in storage because it contains a (nested) mapping.\n ... et(uint _assetId) public {         Asset memory newAsset;         newAsset.assetId = _asset ...\n                                        ^-------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct ContractDetail {\n        uint contractId;\n        mapping(address => uint) penalties;\n    }\n\n    ContractDetail[] public contractDetails;\n\n    function addContractDetail(uint _contractId) public {\n        ContractDetail memory newContractDetail;\n        newContractDetail.contractId = _contractId;\n        contractDetails.push(newContractDetail);\n    }\n\n    function setPenalty(uint index, address user, uint penalty) public {\n        contractDetails[index].penalties[user] = penalty;\n    }\n\n    function getPenalty(uint index, address user) public view returns (uint) {\n        return contractDetails[index].penalties[user];\n    }\n}",
          "error message": "Error: Type struct Example18.ContractDetail is only valid in storage because it contains a (nested) mapping.\n ... uint _contractId) public {         ContractDetail memory newContractDetail;         newContractDetail.contrac ...\n                                        ^-------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Task {\n        uint taskId;\n        mapping(address => uint) hours;\n    }\n\n    Task[] public tasks;\n\n    function addTask(uint _taskId) public {\n        Task memory newTask;\n        newTask.taskId = _taskId;\n        tasks.push(newTask);\n    }\n\n    function setHours(uint index, address user, uint hour) public {\n        tasks[index].hours[user] = hour;\n    }\n\n    function getHours(uint index, address user) public view returns (uint) {\n        return tasks[index].hours[user];\n    }\n\n    function dummyFunction11() public pure returns (string memory) {\n        return \"Dummy function 11\";\n    }\n}",
          "error message": "Error: Expected identifier but got 'hours'\n ... ;         mapping(address => uint) hours;     }      Task[] public tasks;   ...\n                                        ^---^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Product {\n        uint productId;\n        mapping(address => uint) quantities;\n    }\n\n    Product[] public products;\n\n    function addProduct(uint _productId) public {\n        Product memory newProduct;\n        newProduct.productId = _productId;\n        products.push(newProduct);\n    }\n\n    function setQuantity(uint index, address user, uint quantity) public {\n        products[index].quantities[user] = quantity;\n    }\n\n    function getQuantity(uint index, address user) public view returns (uint) {\n        return products[index].quantities[user];\n    }\n\n    function dummyFunction12() public pure returns (uint) {\n        return 20;\n    }\n}",
          "error message": "Error: Type struct Example20.Product is only valid in storage because it contains a (nested) mapping.\n ... (uint _productId) public {         Product memory newProduct;         newProduct.productId = _p ...\n                                        ^-----------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Detail {\n        uint amount;\n        mapping(address => uint) credits;\n    }\n\n    Detail[] public details;\n\n    function addDetail(uint _amount) public {\n        details.push();\n        Detail storage newDetail = details[details.length - 1];\n        newDetail.amount = _amount;\n    }\n\n    function setCredit(uint index, address user, uint credit) public {\n        details[index].credits[user] = credit;\n    }\n\n    function getCredit(uint index, address user) public view returns (uint) {\n        return details[index].credits[user];\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Account {\n        uint balance;\n        mapping(address => uint) allowances;\n    }\n\n    Account[] public accounts;\n\n    function addAccount(uint _balance) public {\n        accounts.push();\n        Account storage newAccount = accounts[accounts.length - 1];\n        newAccount.balance = _balance;\n    }\n\n    function updateAllowance(uint index, address user, uint allowance) public {\n        accounts[index].allowances[user] = allowance;\n    }\n\n    function viewAllowance(uint index, address user) public view returns (uint) {\n        return accounts[index].allowances[user];\n    }\n\n    function dummyFunction7() public pure returns (string memory) {\n        return \"Dummy function 7\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Member {\n        uint id;\n        mapping(address => uint) votes;\n    }\n\n    Member[] public members;\n\n    function registerMember(uint _id) public {\n        members.push();\n        Member storage newMember = members[members.length - 1];\n        newMember.id = _id;\n    }\n\n    function castVote(uint index, address user, uint vote) public {\n        members[index].votes[user] = vote;\n    }\n\n    function getVote(uint index, address user) public view returns (uint) {\n        return members[index].votes[user];\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Client {\n        uint clientId;\n        mapping(address => uint) balances;\n    }\n\n    Client[] public clients;\n\n    function addClient(uint _clientId) public {\n        clients.push();\n        Client storage newClient = clients[clients.length - 1];\n        newClient.clientId = _clientId;\n    }\n\n    function updateBalance(uint index, address user, uint balance) public {\n        clients[index].balances[user] = balance;\n    }\n\n    function getBalance(uint index, address user) public view returns (uint) {\n        return clients[index].balances[user];\n    }\n\n    function dummyFunction8() public pure returns (uint) {\n        return 50;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Transaction {\n        uint id;\n        mapping(address => uint) amounts;\n    }\n\n    Transaction[] public transactions;\n\n    function addTransaction(uint _id) public {\n        transactions.push();\n        Transaction storage newTransaction = transactions[transactions.length - 1];\n        newTransaction.id = _id;\n    }\n\n    function updateAmount(uint index, address user, uint amount) public {\n        transactions[index].amounts[user] = amount;\n    }\n\n    function getAmount(uint index, address user) public view returns (uint) {\n        return transactions[index].amounts[user];\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Package {\n        uint packageId;\n        mapping(address => uint) weights;\n    }\n\n    Package[] public packages;\n\n    function addPackage(uint _packageId) public {\n        packages.push();\n        Package storage newPackage = packages[packages.length - 1];\n        newPackage.packageId = _packageId;\n    }\n\n    function setWeight(uint index, address user, uint weight) public {\n        packages[index].weights[user] = weight;\n    }\n\n    function getWeight(uint index, address user) public view returns (uint) {\n        return packages[index].weights[user];\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Asset {\n        uint assetId;\n        mapping(address => uint) values;\n    }\n\n    Asset[] public assets;\n\n    function registerAsset(uint _assetId) public {\n        assets.push();\n        Asset storage newAsset = assets[assets.length - 1];\n        newAsset.assetId = _assetId;\n    }\n\n    function setValue(uint index, address user, uint value) public {\n        assets[index].values[user] = value;\n    }\n\n    function getValue(uint index, address user) public view returns (uint) {\n        return assets[index].values[user];\n    }\n\n    function dummyFunction9() public pure returns (bool) {\n        return false;\n    }\n\n    function dummyFunction10() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct ContractDetail {\n        uint contractId;\n        mapping(address => uint) penalties;\n    }\n\n    ContractDetail[] public contractDetails;\n\n    function addContractDetail(uint _contractId) public {\n        contractDetails.push();\n        ContractDetail storage newContractDetail = contractDetails[contractDetails.length - 1];\n        newContractDetail.contractId = _contractId;\n    }\n\n    function setPenalty(uint index, address user, uint penalty) public {\n        contractDetails[index].penalties[user] = penalty;\n    }\n\n    function getPenalty(uint index, address user) public view returns (uint) {\n        return contractDetails[index].penalties[user];\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Task {\n        uint taskId;\n        mapping(address => uint) hours;\n    }\n\n    Task[] public tasks;\n\n    function addTask(uint _taskId) public {\n        tasks.push();\n        Task storage newTask = tasks[tasks.length - 1];\n        newTask.taskId = _taskId;\n    }\n\n    function setHours(uint index, address user, uint hour) public {\n        tasks[index].hours[user] = hour;\n    }\n\n    function getHours(uint index, address user) public view returns (uint) {\n        return tasks[index].hours[user];\n    }\n\n    function dummyFunction11() public pure returns (string memory) {\n        return \"Dummy function 11\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Product {\n        uint productId;\n        mapping(address => uint) quantities;\n    }\n\n    Product[] public products;\n\n    function addProduct(uint _productId) public {\n        products.push();\n        Product storage newProduct = products[products.length - 1];\n        newProduct.productId = _productId;\n    }\n\n    function setQuantity(uint index, address user, uint quantity) public {\n        products[index].quantities[user] = quantity;\n    }\n\n    function getQuantity(uint index, address user) public view returns (uint) {\n        return products[index].quantities[user];\n    }\n\n    function dummyFunction12() public pure returns (uint) {\n        return 20;\n    }\n}"
      }
    }
  },
  {
    "Changes52": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Assignments to structs or arrays in storage does not work if they contain\nmappings.\nPreviously, mappings were silently skipped during the copy operation, which\nis misleading and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Stats {\n        mapping(address => uint) scores;\n        uint total;\n    }\n\n    Stats[] public statsList;\n\n    function addStats() public {\n        Stats storage newStats = statsList.push();\n        newStats.total = 1000;\n        statsList[11] = newStats;\n    }\n\n    function updateScores(uint idx, address user, uint value) public {\n        Stats storage stats = statsList[idx];\n        stats.scores[user] = value;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...     newStats.total = 1000;         statsList[11] = newStats;     }      function up ...\n                                        ^-----------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Config {\n        mapping(address => uint) parameters;\n        uint limit;\n    }\n\n    Config[] public configList;\n\n    function addConfig() public {\n        Config storage newConfig = configList.push();\n        newConfig.limit = 1100;\n        configList[12] = newConfig;\n    }\n\n    function modifyParameters(uint idx, address user, uint val) public {\n        Config storage config = configList[idx];\n        config.parameters[user] = val;\n    }\n    \n    function dummyFunction5() public pure returns (string memory) {\n        return \"Test\";\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...    newConfig.limit = 1100;         configList[12] = newConfig;     }      function m ...\n                                        ^------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Transaction {\n        mapping(address => uint) amounts;\n        uint balance;\n    }\n\n    Transaction[] public transactionList;\n\n    function addTransaction() public {\n        Transaction storage newTransaction = transactionList.push();\n        newTransaction.balance = 1200;\n        transactionList[13] = newTransaction;\n    }\n\n    function updateAmounts(uint idx, address user, uint amount) public {\n        Transaction storage transaction = transactionList[idx];\n        transaction.amounts[user] = amount;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ... ransaction.balance = 1200;         transactionList[13] = newTransaction;     }      funct ...\n                                        ^-----------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct User {\n        mapping(address => uint) details;\n        uint id;\n    }\n\n    User[] public userList;\n\n    function addUser() public {\n        User storage newUser = userList.push();\n        newUser.id = 1300;\n        userList[14] = newUser;\n    }\n\n    function changeDetails(uint idx, address user, uint value) public {\n        User storage usr = userList[idx];\n        usr.details[user] = value;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...         newUser.id = 1300;         userList[14] = newUser;     }      function cha ...\n                                        ^----------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Metadata {\n        mapping(address => uint) values;\n        uint count;\n    }\n\n    Metadata[] public metadataList;\n\n    function addMetadata() public {\n        Metadata storage newMetadata = metadataList.push();\n        newMetadata.count = 1400;\n        metadataList[15] = newMetadata;\n    }\n\n    function updateValues(uint idx, address user, uint val) public {\n        Metadata storage metadata = metadataList[idx];\n        metadata.values[user] = val;\n    }\n    \n    function dummyFunction6() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...  newMetadata.count = 1400;         metadataList[15] = newMetadata;     }      function ...\n                                        ^--------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Data {\n        mapping(address => uint) records;\n        uint amount;\n    }\n\n    Data[] public dataList;\n\n    function addData() public {\n        Data storage newData = dataList.push();\n        newData.amount = 1500;\n        dataList[16] = newData;\n    }\n\n    function updateRecords(uint idx, address user, uint value) public {\n        Data storage data = dataList[idx];\n        data.records[user] = value;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...     newData.amount = 1500;         dataList[16] = newData;     }      function upd ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint total;\n    }\n\n    Log[] public logList;\n\n    function addLog() public {\n        Log storage newLog = logList.push();\n        newLog.total = 1600;\n        logList[17] = newLog;\n    }\n\n    function modifyEntries(uint idx, address user, uint val) public {\n        Log storage log = logList[idx];\n        log.entries[user] = val;\n    }\n    \n    function dummyFunction7() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...       newLog.total = 1600;         logList[17] = newLog;     }      function modi ...\n                                        ^---------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Registry {\n        mapping(address => uint) items;\n        uint count;\n    }\n\n    Registry[] public registryList;\n\n    function addRegistry() public {\n        Registry storage newRegistry = registryList.push();\n        newRegistry.count = 1700;\n        registryList[18] = newRegistry;\n    }\n\n    function updateItems(uint idx, address user, uint amount) public {\n        Registry storage registry = registryList[idx];\n        registry.items[user] = amount;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...  newRegistry.count = 1700;         registryList[18] = newRegistry;     }      function ...\n                                        ^--------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Container {\n        mapping(address => uint) contents;\n        uint volume;\n    }\n\n    Container[] public containerList;\n\n    function addContainer() public {\n        Container storage newContainer = containerList.push();\n        newContainer.volume = 1800;\n        containerList[19] = newContainer;\n    }\n\n    function modifyContents(uint idx, address user, uint value) public {\n        Container storage container = containerList[idx];\n        container.contents[user] = value;\n    }\n    \n    function dummyFunction8() public pure returns (address) {\n        return address(0);\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ... ewContainer.volume = 1800;         containerList[19] = newContainer;     }      functio ...\n                                        ^---------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Box {\n        mapping(address => uint) items;\n        uint size;\n    }\n\n    Box[] public boxList;\n\n    function addBox() public {\n        Box storage newBox = boxList.push();\n        newBox.size = 1900;\n        boxList[20] = newBox;\n    }\n\n    function updateItems(uint idx, address user, uint amount) public {\n        Box storage box = boxList[idx];\n        box.items[user] = amount;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...        newBox.size = 1900;         boxList[20] = newBox;     }      function upda ...\n                                        ^---------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Stats {\n        mapping(address => uint) scores;\n        uint total;\n    }\n\n    Stats[] public statsList;\n\n    function addStats() public {\n        Stats storage newStats = statsList.push();\n        newStats.total = 1000;\n    }\n\n    function updateScores(uint idx, address user, uint value) public {\n        Stats storage stats = statsList[idx];\n        stats.scores[user] = value;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Config {\n        mapping(address => uint) parameters;\n        uint limit;\n    }\n\n    Config[] public configList;\n\n    function addConfig() public {\n        Config storage newConfig = configList.push();\n        newConfig.limit = 1100;\n    }\n\n    function modifyParameters(uint idx, address user, uint val) public {\n        Config storage config = configList[idx];\n        config.parameters[user] = val;\n    }\n    \n    function dummyFunction5() public pure returns (string memory) {\n        return \"Test\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Transaction {\n        mapping(address => uint) amounts;\n        uint balance;\n    }\n\n    Transaction[] public transactionList;\n\n    function addTransaction() public {\n        Transaction storage newTransaction = transactionList.push();\n        newTransaction.balance = 1200;\n    }\n\n    function updateAmounts(uint idx, address user, uint amount) public {\n        Transaction storage transaction = transactionList[idx];\n        transaction.amounts[user] = amount;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct User {\n        mapping(address => uint) details;\n        uint id;\n    }\n\n    User[] public userList;\n\n    function addUser() public {\n        User storage newUser = userList.push();\n        newUser.id = 1300;\n    }\n\n    function changeDetails(uint idx, address user, uint value) public {\n        User storage usr = userList[idx];\n        usr.details[user] = value;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Metadata {\n        mapping(address => uint) values;\n        uint count;\n    }\n\n    Metadata[] public metadataList;\n\n    function addMetadata() public {\n        Metadata storage newMetadata = metadataList.push();\n        newMetadata.count = 1400;\n    }\n\n    function updateValues(uint idx, address user, uint val) public {\n        Metadata storage metadata = metadataList[idx];\n        metadata.values[user] = val;\n    }\n    \n    function dummyFunction6() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Data {\n        mapping(address => uint) records;\n        uint amount;\n    }\n\n    Data[] public dataList;\n\n    function addData() public {\n        Data storage newData = dataList.push();\n        newData.amount = 1500;\n    }\n\n    function updateRecords(uint idx, address user, uint value) public {\n        Data storage data = dataList[idx];\n        data.records[user] = value;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint total;\n    }\n\n    Log[] public logList;\n\n    function addLog() public {\n        Log storage newLog = logList.push();\n        newLog.total = 1600;\n    }\n\n    function modifyEntries(uint idx, address user, uint val) public {\n        Log storage log = logList[idx];\n        log.entries[user] = val;\n    }\n    \n    function dummyFunction7() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Registry {\n        mapping(address => uint) items;\n        uint count;\n    }\n\n    Registry[] public registryList;\n\n    function addRegistry() public {\n        Registry storage newRegistry = registryList.push();\n        newRegistry.count = 1700;\n    }\n\n    function updateItems(uint idx, address user, uint amount) public {\n        Registry storage registry = registryList[idx];\n        registry.items[user] = amount;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Container {\n        mapping(address => uint) contents;\n        uint volume;\n    }\n\n    Container[] public containerList;\n\n    function addContainer() public {\n        Container storage newContainer = containerList.push();\n        newContainer.volume = 1800;\n    }\n\n    function modifyContents(uint idx, address user, uint value) public {\n        Container storage container = containerList[idx];\n        container.contents[user] = value;\n    }\n    \n    function dummyFunction8() public pure returns (address) {\n        return address(0);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Box {\n        mapping(address => uint) items;\n        uint size;\n    }\n\n    Box[] public boxList;\n\n    function addBox() public {\n        Box storage newBox = boxList.push();\n        newBox.size = 1900;\n    }\n\n    function updateItems(uint idx, address user, uint amount) public {\n        Box storage box = boxList[idx];\n        box.items[user] = amount;\n    }\n}"
      }
    }
  },
  {
    "Changes53": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Visibility (<code>public</code> / <code>internal</code>) is not needed for constructors anymore:\nTo prevent a contract from being created, it can be marked <code>abstract</code>.\nThis makes the visibility concept for constructors obsolete.Remove the <code>public</code> keyword from every constructor.Remove the <code>internal</code> keyword from every constructor and add <code>abstract</code> to the contract (if not already present).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract AlphaContract1 {\n    address public supervisor;\n\n    constructor() internal {\n        supervisor = msg.sender;\n    }\n\n    function getSupervisor() public view returns (address) {\n        return supervisor;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...    address public supervisor;      constructor() internal {         supervisor = msg.sender;     }      function getSupervisor() publ ...\n                                        ^-------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BetaContract2 {\n    address public coordinator;\n\n    constructor() internal {\n        coordinator = msg.sender;\n    }\n\n    function getCoordinator() public view returns (address) {\n        return coordinator;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...   address public coordinator;      constructor() internal {         coordinator = msg.sender;     }      function getCoordinator() pub ...\n                                        ^--------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract GammaContract3 {\n    address public chiefOfficer;\n\n    constructor() internal {\n        chiefOfficer = msg.sender;\n    }\n\n    function getChiefOfficer() public view returns (address) {\n        return chiefOfficer;\n    }\n\n    function isChiefOfficer(address _address) public view returns (bool) {\n        return _address == chiefOfficer;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...  address public chiefOfficer;      constructor() internal {         chiefOfficer = msg.sender;     }      function getChiefOfficer() pu ...\n                                        ^---------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract DeltaContract4 {\n    address public leader;\n\n    constructor() internal {\n        leader = msg.sender;\n    }\n\n    function getLeader() public view returns (address) {\n        return leader;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...  {     address public leader;      constructor() internal {         leader = msg.sender;     }      function getLeader() public v ...\n                                        ^---------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract EpsilonContract5 {\n    address public director;\n\n    constructor() internal {\n        director = msg.sender;\n    }\n\n    function getDirector() public view returns (address) {\n        return director;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...      address public director;      constructor() internal {         director = msg.sender;     }      function getDirector() public ...\n                                        ^-----------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ZetaContract6 {\n    address public guardian;\n\n    constructor() internal {\n        guardian = msg.sender;\n    }\n\n    function getGuardian() public view returns (address) {\n        return guardian;\n    }\n\n    function isGuardian(address _address) public view returns (bool) {\n        return _address == guardian;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...      address public guardian;      constructor() internal {         guardian = msg.sender;     }      function getGuardian() public ...\n                                        ^-----------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract EtaContract7 {\n    address public head;\n\n    constructor() internal {\n        head = msg.sender;\n    }\n\n    function getHead() public view returns (address) {\n        return head;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... t7 {     address public head;      constructor() internal {         head = msg.sender;     }      function getHead() public vie ...\n                                        ^-------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ThetaContract8 {\n    address public principal;\n\n    constructor() internal {\n        principal = msg.sender;\n    }\n\n    function getPrincipal() public view returns (address) {\n        return principal;\n    }\n\n    function getWelcomeMessage() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...     address public principal;      constructor() internal {         principal = msg.sender;     }      function getPrincipal() publi ...\n                                        ^------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract IotaContract9 {\n    address public boss;\n\n    constructor() internal {\n        boss = msg.sender;\n    }\n\n    function getBoss() public view returns (address) {\n        return boss;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... t9 {     address public boss;      constructor() internal {         boss = msg.sender;     }      function getBoss() public vie ...\n                                        ^-------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract KappaContract10 {\n    address public controller;\n\n    constructor() internal {\n        controller = msg.sender;\n    }\n\n    function getController() public view returns (address) {\n        return controller;\n    }\n\n    function getStatus() public pure returns (string memory) {\n        return \"Active\";\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...    address public controller;      constructor() internal {         controller = msg.sender;     }      function getController() publ ...\n                                        ^-------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nabstract contract AlphaContract1 {\n    address public supervisor;\n\n    constructor() {\n        supervisor = msg.sender;\n    }\n\n    function getSupervisor() public view returns (address) {\n        return supervisor;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nabstract contract BetaContract2 {\n    address public coordinator;\n\n    constructor() {\n        coordinator = msg.sender;\n    }\n\n    function getCoordinator() public view returns (address) {\n        return coordinator;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nabstract contract GammaContract3 {\n    address public chiefOfficer;\n\n    constructor() {\n        chiefOfficer = msg.sender;\n    }\n\n    function getChiefOfficer() public view returns (address) {\n        return chiefOfficer;\n    }\n\n    function isChiefOfficer(address _address) public view returns (bool) {\n        return _address == chiefOfficer;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nabstract contract DeltaContract4 {\n    address public leader;\n\n    constructor() {\n        leader = msg.sender;\n    }\n\n    function getLeader() public view returns (address) {\n        return leader;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nabstract contract EpsilonContract5 {\n    address public director;\n\n    constructor() {\n        director = msg.sender;\n    }\n\n    function getDirector() public view returns (address) {\n        return director;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nabstract contract ZetaContract6 {\n    address public guardian;\n\n    constructor() {\n        guardian = msg.sender;\n    }\n\n    function getGuardian() public view returns (address) {\n        return guardian;\n    }\n\n    function isGuardian(address _address) public view returns (bool) {\n        return _address == guardian;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nabstract contract EtaContract7 {\n    address public head;\n\n    constructor() {\n        head = msg.sender;\n    }\n\n    function getHead() public view returns (address) {\n        return head;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nabstract contract ThetaContract8 {\n    address public principal;\n\n    constructor() {\n        principal = msg.sender;\n    }\n\n    function getPrincipal() public view returns (address) {\n        return principal;\n    }\n\n    function getWelcomeMessage() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nabstract contract IotaContract9 {\n    address public boss;\n\n    constructor() {\n        boss = msg.sender;\n    }\n\n    function getBoss() public view returns (address) {\n        return boss;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nabstract contract KappaContract10 {\n    address public controller;\n\n    constructor() {\n        controller = msg.sender;\n    }\n\n    function getController() public view returns (address) {\n        return controller;\n    }\n\n    function getStatus() public pure returns (string memory) {\n        return \"Active\";\n    }\n}"
      }
    }
  },
  {
    "Changes54": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Type Checker: Disallow <code>virtual</code> for library functions:\nSince libraries cannot be inherited from, library functions should not be virtual.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib11 {\n    function factorial(uint256 n) public pure virtual returns (uint256) {\n        if (n == 0) {\n            return 1;\n        } else {\n            return n * factorial(n - 1);\n        }\n    }\n}\n\ncontract Example11 {\n    using Lib11 for uint256;\n\n    function calculateFactorial(uint256 n) public pure returns (uint256) {\n        return n.factorial();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib11 {     function factorial(uint256 n) publi ... * factorial(n - 1);         }     } }  contract Example11 {     using  ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib12 {\n    function max(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n\ncontract Example12 {\n    using Lib12 for uint256;\n\n    function findMax(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.max(b);\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib12 {     function max(uint256 a, uint256 b) public pure virtual returns (uint256) {         return a >= b ? a : b;     } }  contract Example12 {     using  ...\n                                        ^-------------------------------------------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib13 {\n    function min(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        return a <= b ? a : b;\n    }\n}\n\ncontract Example13 {\n    using Lib13 for uint256;\n\n    function findMin(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.min(b);\n    }\n\n    function dummyFunction() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib13 {     function min(uint256 a, uint256 b) public pure virtual returns (uint256) {         return a <= b ? a : b;     } }  contract Example13 {     using  ...\n                                        ^-------------------------------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib14 {\n    function abs(int256 a) public pure virtual returns (int256) {\n        return a >= 0 ? a : -a;\n    }\n}\n\ncontract Example14 {\n    using Lib14 for int256;\n\n    function getAbsolute(int256 a) public pure returns (int256) {\n        return a.abs();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib14 {     function abs(int256 a) public pure virtual returns (int256) {         return a >= 0 ? a : -a;     } }  contract Example14 {     using  ...\n                                        ^-------------------------------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib15 {\n    function isPositive(int256 a) public pure virtual returns (bool) {\n        return a > 0;\n    }\n}\n\ncontract Example15 {\n    using Lib15 for int256;\n\n    function checkPositive(int256 a) public pure returns (bool) {\n        return a.isPositive();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib15 {     function isPositive(int256 a) public pure virtual returns (bool) {         return a > 0;     } }  contract Example15 {     using  ...\n                                        ^--------------------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib16 {\n    function gcd(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        while (b != 0) {\n            uint256 temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n\ncontract Example16 {\n    using Lib16 for uint256;\n\n    function calculateGCD(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.gcd(b);\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib16 {     function gcd(uint256 a, uint256 b)  ... ;         }         return a;     } }  contract Example16 {     using  ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib17 {\n    function lcm(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        return (a * b);\n    }\n}\n\ncontract Example17 {\n    using Lib17 for uint256;\n\n    function calculateLCM(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.lcm(b);\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib17 {     function lcm(uint256 a, uint256 b) public pure virtual returns (uint256) {         return (a * b);     } }  contract Example17 {     using  ...\n                                        ^------------------------------------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib18 {\n    function isPrime(uint256 num) public pure virtual returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint256 i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\ncontract Example18 {\n    using Lib18 for uint256;\n\n    function checkPrime(uint256 num) public pure returns (bool) {\n        return num.isPrime();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib18 {     function isPrime(uint256 num) publi ...        }         return true;     } }  contract Example18 {     using  ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib19 {\n    function fibonacci(uint256 n) public pure virtual returns (uint256) {\n        if (n == 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        } else {\n            return fibonacci(n - 1) + fibonacci(n - 2);\n        }\n    }\n}\n\ncontract Example19 {\n    using Lib19 for uint256;\n\n    function calculateFibonacci(uint256 n) public pure returns (uint256) {\n        return n.fibonacci();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib19 {     function fibonacci(uint256 n) publi ... + fibonacci(n - 2);         }     } }  contract Example19 {     using  ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib20 {\n    function isOdd(uint256 a) public pure virtual returns (bool) {\n        return a % 2 != 0;\n    }\n}\n\ncontract Example20 {\n    using Lib20 for uint256;\n\n    function checkOdd(uint256 a) public pure returns (bool) {\n        return a.isOdd();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib20 {     function isOdd(uint256 a) public pure virtual returns (bool) {         return a % 2 != 0;     } }  contract Example20 {     using  ...\n                                        ^---------------------------------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary Lib11 {\n    function factorial(uint256 n) public pure returns (uint256) {\n        if (n == 0) {\n            return 1;\n        } else {\n            return n * factorial(n - 1);\n        }\n    }\n}\n\ncontract Example11 {\n    using Lib11 for uint256;\n\n    function calculateFactorial(uint256 n) public pure returns (uint256) {\n        return n.factorial();\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary Lib12 {\n    function max(uint256 a, uint256 b) public pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n\ncontract Example12 {\n    using Lib12 for uint256;\n\n    function findMax(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.max(b);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary Lib13 {\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n}\n\ncontract Example13 {\n    using Lib13 for uint256;\n\n    function findMin(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.min(b);\n    }\n\n    function dummyFunction() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary Lib14 {\n    function abs(int256 a) public pure returns (int256) {\n        return a >= 0 ? a : -a;\n    }\n}\n\ncontract Example14 {\n    using Lib14 for int256;\n\n    function getAbsolute(int256 a) public pure returns (int256) {\n        return a.abs();\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary Lib15 {\n    function isPositive(int256 a) public pure returns (bool) {\n        return a > 0;\n    }\n}\n\ncontract Example15 {\n    using Lib15 for int256;\n\n    function checkPositive(int256 a) public pure returns (bool) {\n        return a.isPositive();\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary Lib16 {\n    function gcd(uint256 a, uint256 b) public pure returns (uint256) {\n        while (b != 0) {\n            uint256 temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n\ncontract Example16 {\n    using Lib16 for uint256;\n\n    function calculateGCD(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.gcd(b);\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary Lib17 {\n    function lcm(uint256 a, uint256 b) public pure returns (uint256) {\n        return (a * b);\n    }\n}\n\ncontract Example17 {\n    using Lib17 for uint256;\n\n    function calculateLCM(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.lcm(b);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary Lib18 {\n    function isPrime(uint256 num) public pure returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint256 i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\ncontract Example18 {\n    using Lib18 for uint256;\n\n    function checkPrime(uint256 num) public pure returns (bool) {\n        return num.isPrime();\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary Lib19 {\n    function fibonacci(uint256 n) public pure returns (uint256) {\n        if (n == 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        } else {\n            return fibonacci(n - 1) + fibonacci(n - 2);\n        }\n    }\n}\n\ncontract Example19 {\n    using Lib19 for uint256;\n\n    function calculateFibonacci(uint256 n) public pure returns (uint256) {\n        return n.fibonacci();\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary Lib20 {\n    function isOdd(uint256 a) public pure returns (bool) {\n        return a % 2 != 0;\n    }\n}\n\ncontract Example20 {\n    using Lib20 for uint256;\n\n    function checkOdd(uint256 a) public pure returns (bool) {\n        return a.isOdd();\n    }\n}"
      }
    }
  },
  {
    "Changes55": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Multiple events with the same name and parameter types in the same\ninheritance hierarchy are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Alpha {\n    event LogEvent(uint256 indexed id, string message);\n\n    function fireEvent(uint256 _id, string memory _message) public {\n        emit LogEvent(_id, _message);\n    }\n}\n\ncontract BetaA is Alpha {\n    event LogEvent(uint256 indexed id, string message);\n\n    function fireEventA(uint256 _id, string memory _message) public {\n        emit LogEvent(_id, _message);\n    }\n}\n\ncontract BetaB is Alpha {\n    event LogEvent(uint256 indexed id, string message);\n\n    function fireEventB(uint256 _id, string memory _message) public {\n        emit LogEvent(_id, _message);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... } }  contract BetaA is Alpha {     event LogEvent(uint256 indexed id, string message);      function fireEventA(uint256 _ ..."
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Creator {\n    event Notification(uint256 indexed code, string description);\n\n    function notify(uint256 _code, string memory _description) public {\n        emit Notification(_code, _description);\n    }\n}\n\ncontract Actor1 is Creator {\n    event Notification(uint256 indexed code, string description);\n\n    function notify1(uint256 _code, string memory _description) public {\n        emit Notification(_code, _description);\n    }\n}\n\ncontract Actor2 is Creator {\n    event Notification(uint256 indexed code, string description);\n\n    function notify2(uint256 _code, string memory _description) public {\n        emit Notification(_code, _description);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...   contract Actor1 is Creator {     event Notification(uint256 indexed code, string description);      function notify1(uint256 _cod ..."
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseEntity {\n    event Status(uint256 indexed index, string detail);\n\n    function setStatus(uint256 _index, string memory _detail) public {\n        emit Status(_index, _detail);\n    }\n}\n\ncontract Entity1 is BaseEntity {\n    event Status(uint256 indexed index, string detail);\n\n    function setStatus1(uint256 _index, string memory _detail) public {\n        emit Status(_index, _detail);\n    }\n}\n\ncontract Entity2 is BaseEntity {\n    event Status(uint256 indexed index, string detail);\n\n    function setStatus2(uint256 _index, string memory _detail) public {\n        emit Status(_index, _detail);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... ntract Entity1 is BaseEntity {     event Status(uint256 indexed index, string detail);      function setStatus1(uint256 _ ..."
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ParentContract {\n    event Record(uint256 indexed id, string info);\n\n    function addRecord(uint256 _id, string memory _info) public {\n        emit Record(_id, _info);\n    }\n}\n\ncontract ChildContractA is ParentContract {\n    event Record(uint256 indexed id, string info);\n\n    function addRecordA(uint256 _id, string memory _info) public {\n        emit Record(_id, _info);\n    }\n}\n\ncontract ChildContractB is ParentContract {\n    event Record(uint256 indexed id, string info);\n\n    function addRecordB(uint256 _id, string memory _info) public {\n        emit Record(_id, _info);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... dContractA is ParentContract {     event Record(uint256 indexed id, string info);      function addRecordA(uint256 _ ..."
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Master {\n    event Entry(uint256 indexed key, string data);\n\n    function logEntry(uint256 _key, string memory _data) public {\n        emit Entry(_key, _data);\n    }\n}\n\ncontract UnitA is Master {\n    event Entry(uint256 indexed key, string data);\n\n    function logEntryA(uint256 _key, string memory _data) public {\n        emit Entry(_key, _data);\n    }\n}\n\ncontract UnitB is Master {\n    event Entry(uint256 indexed key, string data);\n\n    function logEntryB(uint256 _key, string memory _data) public {\n        emit Entry(_key, _data);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...  }  contract UnitA is Master {     event Entry(uint256 indexed key, string data);      function logEntryA(uint256 _k ..."
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Source {\n    event Alert(uint256 indexed id, string notification);\n\n    function triggerAlert(uint256 _id, string memory _notification) public {\n        emit Alert(_id, _notification);\n    }\n}\n\ncontract BranchA is Source {\n    event Alert(uint256 indexed id, string notification);\n\n    function triggerAlertA(uint256 _id, string memory _notification) public {\n        emit Alert(_id, _notification);\n    }\n}\n\ncontract BranchB is Source {\n    event Alert(uint256 indexed id, string notification);\n\n    function triggerAlertB(uint256 _id, string memory _notification) public {\n        emit Alert(_id, _notification);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...   contract BranchA is Source {     event Alert(uint256 indexed id, string notification);      function triggerAlertA(uint25 ..."
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Top {\n    event Notification(uint256 indexed code, string message);\n\n    function sendNotification(uint256 _code, string memory _message) public {\n        emit Notification(_code, _message);\n    }\n}\n\ncontract Bottom1 is Top {\n    event Notification(uint256 indexed code, string message);\n\n    function sendNotification1(uint256 _code, string memory _message) public {\n        emit Notification(_code, _message);\n    }\n}\n\ncontract Bottom2 is Top {\n    event Notification(uint256 indexed code, string message);\n\n    function sendNotification2(uint256 _code, string memory _message) public {\n        emit Notification(_code, _message);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... } }  contract Bottom1 is Top {     event Notification(uint256 indexed code, string message);      function sendNotification1(ui ..."
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract RootContract {\n    event Signal(uint256 indexed id, string text);\n\n    function emitSignal(uint256 _id, string memory _text) public {\n        emit Signal(_id, _text);\n    }\n}\n\ncontract Node1 is RootContract {\n    event Signal(uint256 indexed id, string text);\n\n    function emitSignal1(uint256 _id, string memory _text) public {\n        emit Signal(_id, _text);\n    }\n}\n\ncontract Node2 is RootContract {\n    event Signal(uint256 indexed id, string text);\n\n    function emitSignal2(uint256 _id, string memory _text) public {\n        emit Signal(_id, _text);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... ntract Node1 is RootContract {     event Signal(uint256 indexed id, string text);      function emitSignal1(uint256  ..."
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract CoreContract {\n    event Log(uint256 indexed id, string info);\n\n    function generateLog(uint256 _id, string memory _info) public {\n        emit Log(_id, _info);\n    }\n}\n\ncontract SegmentA is CoreContract {\n    event Log(uint256 indexed id, string info);\n\n    function generateLogA(uint256 _id, string memory _info) public {\n        emit Log(_id, _info);\n    }\n}\n\ncontract SegmentB is CoreContract {\n    event Log(uint256 indexed id, string info);\n\n    function generateLogB(uint256 _id, string memory _info) public {\n        emit Log(_id, _info);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... act SegmentA is CoreContract {     event Log(uint256 indexed id, string info);      function generateLogA(uint256 ..."
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract OriginContract {\n    event LogData(uint256 indexed key, string detail);\n\n    function recordLogData(uint256 _key, string memory _detail) public {\n        emit LogData(_key, _detail);\n    }\n}\n\ncontract PartA is OriginContract {\n    event LogData(uint256 indexed key, string detail);\n\n    function recordLogDataA(uint256 _key, string memory _detail) public {\n        emit LogData(_key, _detail);\n    }\n}\n\ncontract PartB is OriginContract {\n    event LogData(uint256 indexed key, string detail);\n\n    function recordLogDataB(uint256 _key, string memory _detail) public {\n        emit LogData(_key, _detail);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... ract PartA is OriginContract {     event LogData(uint256 indexed key, string detail);      function recordLogDataA(uint2 ..."
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Alpha {\n    event LogEvent(uint256 indexed id, string message);\n\n    function fireEvent(uint256 _id, string memory _message) public {\n        emit LogEvent(_id, _message);\n    }\n}\n\ncontract BetaA is Alpha {\n    event LogEventA(uint256 indexed id, string message);\n\n    function fireEventA(uint256 _id, string memory _message) public {\n        emit LogEventA(_id, _message);\n    }\n}\n\ncontract BetaB is Alpha {\n    event LogEventB(uint256 indexed id, string message);\n\n    function fireEventB(uint256 _id, string memory _message) public {\n        emit LogEventB(_id, _message);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Creator {\n    event Notification(uint256 indexed code, string description);\n\n    function notify(uint256 _code, string memory _description) public {\n        emit Notification(_code, _description);\n    }\n}\n\ncontract Actor1 is Creator {\n    event Notification1(uint256 indexed code, string description);\n\n    function notify1(uint256 _code, string memory _description) public {\n        emit Notification1(_code, _description);\n    }\n}\n\ncontract Actor2 is Creator {\n    event Notification2(uint256 indexed code, string description);\n\n    function notify2(uint256 _code, string memory _description) public {\n        emit Notification2(_code, _description);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract BaseEntity {\n    event Status(uint256 indexed index, string detail);\n\n    function setStatus(uint256 _index, string memory _detail) public {\n        emit Status(_index, _detail);\n    }\n}\n\ncontract Entity1 is BaseEntity {\n    event Status1(uint256 indexed index, string detail);\n\n    function setStatus1(uint256 _index, string memory _detail) public {\n        emit Status1(_index, _detail);\n    }\n}\n\ncontract Entity2 is BaseEntity {\n    event Status2(uint256 indexed index, string detail);\n\n    function setStatus2(uint256 _index, string memory _detail) public {\n        emit Status2(_index, _detail);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ParentContract {\n    event Record(uint256 indexed id, string info);\n\n    function addRecord(uint256 _id, string memory _info) public {\n        emit Record(_id, _info);\n    }\n}\n\ncontract ChildContractA is ParentContract {\n    event RecordA(uint256 indexed id, string info);\n\n    function addRecordA(uint256 _id, string memory _info) public {\n        emit RecordA(_id, _info);\n    }\n}\n\ncontract ChildContractB is ParentContract {\n    event RecordB(uint256 indexed id, string info);\n\n    function addRecordB(uint256 _id, string memory _info) public {\n        emit RecordB(_id, _info);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Master {\n    event Entry(uint256 indexed key, string data);\n\n    function logEntry(uint256 _key, string memory _data) public {\n        emit Entry(_key, _data);\n    }\n}\n\ncontract UnitA is Master {\n    event EntryA(uint256 indexed key, string data);\n\n    function logEntryA(uint256 _key, string memory _data) public {\n        emit EntryA(_key, _data);\n    }\n}\n\ncontract UnitB is Master {\n    event EntryB(uint256 indexed key, string data);\n\n    function logEntryB(uint256 _key, string memory _data) public {\n        emit EntryB(_key, _data);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Source {\n    event Alert(uint256 indexed id, string notification);\n\n    function triggerAlert(uint256 _id, string memory _notification) public {\n        emit Alert(_id, _notification);\n    }\n}\n\ncontract BranchA is Source {\n    event AlertA(uint256 indexed id, string notification);\n\n    function triggerAlertA(uint256 _id, string memory _notification) public {\n        emit AlertA(_id, _notification);\n    }\n}\n\ncontract BranchB is Source {\n    event AlertB(uint256 indexed id, string notification);\n\n    function triggerAlertB(uint256 _id, string memory _notification) public {\n        emit AlertB(_id, _notification);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Top {\n    event Notification(uint256 indexed code, string message);\n\n    function sendNotification(uint256 _code, string memory _message) public {\n        emit Notification(_code, _message);\n    }\n}\n\ncontract Bottom1 is Top {\n    event Notification1(uint256 indexed code, string message);\n\n    function sendNotification1(uint256 _code, string memory _message) public {\n        emit Notification1(_code, _message);\n    }\n}\n\ncontract Bottom2 is Top {\n    event Notification2(uint256 indexed code, string message);\n\n    function sendNotification2(uint256 _code, string memory _message) public {\n        emit Notification2(_code, _message);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract RootContract {\n    event Signal(uint256 indexed id, string text);\n\n    function emitSignal(uint256 _id, string memory _text) public {\n        emit Signal(_id, _text);\n    }\n}\n\ncontract Node1 is RootContract {\n    event Signal1(uint256 indexed id, string text);\n\n    function emitSignal1(uint256 _id, string memory _text) public {\n        emit Signal1(_id, _text);\n    }\n}\n\ncontract Node2 is RootContract {\n    event Signal2(uint256 indexed id, string text);\n\n    function emitSignal2(uint256 _id, string memory _text) public {\n        emit Signal2(_id, _text);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract CoreContract {\n    event Log(uint256 indexed id, string info);\n\n    function generateLog(uint256 _id, string memory _info) public {\n        emit Log(_id, _info);\n    }\n}\n\ncontract SegmentA is CoreContract {\n    event LogA(uint256 indexed id, string info);\n\n    function generateLogA(uint256 _id, string memory _info) public {\n        emit LogA(_id, _info);\n    }\n}\n\ncontract SegmentB is CoreContract {\n    event LogB(uint256 indexed id, string info);\n\n    function generateLogB(uint256 _id, string memory _info) public {\n        emit LogB(_id, _info);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract OriginContract {\n    event LogData(uint256 indexed key, string detail);\n\n    function recordLogData(uint256 _key, string memory _detail) public {\n        emit LogData(_key, _detail);\n    }\n}\n\ncontract PartA is OriginContract {\n    event LogDataA(uint256 indexed key, string detail);\n\n    function recordLogDataA(uint256 _key, string memory _detail) public {\n        emit LogDataA(_key, _detail);\n    }\n}\n\ncontract PartB is OriginContract {\n    event LogDataB(uint256 indexed key, string detail);\n\n    function recordLogDataB(uint256 _key, string memory _detail) public {\n        emit LogDataB(_key, _detail);\n    }\n}"
      }
    }
  },
  {
    "Changes56": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "<code>using A for B</code> only affects the contract it is mentioned in.\nPreviously, the effect was inherited. Now, you have to repeat the <code>using</code>\nstatement in all derived contracts that make use of the feature.Repeat the <code>using A for B</code> statements in all derived contracts if needed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary BasicMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"BasicMath: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Root {\n    using BasicMath for uint256;\n    \n    uint256 public rootValue;\n    \n    function multiply(uint256 _value) public {\n        rootValue = _value.mul(3);\n    }\n}\n\ncontract Branch is Root {\n    function expand(uint256 _value) public {\n        rootValue = _value.mul(6);\n    }\n}",
          "error message": "Error: Member \"mul\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         rootValue = _value.mul(6);     } }\n                                        ^--------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary DivOperations {\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DivOperations: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Divider {\n    using DivOperations for uint256;\n    \n    uint256 public dividerValue;\n    \n    function divide(uint256 _value) public {\n        dividerValue = _value.div(4);\n    }\n}\n\ncontract Splitter is Divider {\n    function split(uint256 _value) public {\n        dividerValue = _value.div(5);\n    }\n}",
          "error message": "Error: Member \"div\" not found or not visible after argument-dependent lookup in uint256.\n ... e) public {         dividerValue = _value.div(5);     } }\n                                        ^--------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Modulus {\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Modulus: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract BaseMod {\n    using Modulus for uint256;\n    \n    uint256 public baseModValue;\n    \n    function modulo(uint256 _value) public {\n        baseModValue = _value.mod(4);\n    }\n}\n\ncontract DerivedMod is BaseMod {\n    function remainder(uint256 _value) public {\n        baseModValue = _value.mod(6);\n    }\n}",
          "error message": "Error: Member \"mod\" not found or not visible after argument-dependent lookup in uint256.\n ... e) public {         baseModValue = _value.mod(6);     } }\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Exponentiation {\n    function pow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 result = 1;\n        for (uint256 i = 0; i < exp; i++) {\n            result = result * base;\n        }\n        return result;\n    }\n}\n\ncontract Power {\n    using Exponentiation for uint256;\n    \n    uint256 public powerValue;\n    \n    function exponent(uint256 _base, uint256 _exp) public {\n        powerValue = _base.pow(_exp);\n    }\n}\n\ncontract Exponent is Power {\n    function raise(uint256 _base, uint256 _exp) public {\n        powerValue = _base.pow(_exp + 2);\n    }\n}",
          "error message": "Error: Member \"pow\" not found or not visible after argument-dependent lookup in uint256.\n ... exp) public {         powerValue = _base.pow(_exp + 2);     } }\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Percentage {\n    function addPercentage(uint256 a, uint256 percent) internal pure returns (uint256) {\n        return a + (a * percent / 100);\n    }\n}\n\ncontract Amount {\n    using Percentage for uint256;\n    \n    uint256 public amountValue;\n    \n    function addPercent(uint256 _value, uint256 _percent) public {\n        amountValue = _value.addPercentage(_percent);\n    }\n}\n\ncontract Fraction is Amount {\n    function increase(uint256 _value, uint256 _percent) public {\n        amountValue = _value.addPercentage(_percent + 3);\n    }\n}",
          "error message": "Error: Member \"addPercentage\" not found or not visible after argument-dependent lookup in uint256.\n ... nt) public {         amountValue = _value.addPercentage(_percent + 3);     } }\n                                        ^------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Averages {\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b) / 2;\n    }\n}\n\ncontract AverageCalculator {\n    using Averages for uint256;\n    \n    uint256 public averageValue;\n    \n    function calculateAverage(uint256 _a, uint256 _b) public {\n        averageValue = _a.average(_b);\n    }\n}\n\ncontract MeanCalculator is AverageCalculator {\n    function calculateMean(uint256 _a, uint256 _b) public {\n        averageValue = _a.average(_b + 2);\n    }\n}",
          "error message": "Error: Member \"average\" not found or not visible after argument-dependent lookup in uint256.\n ... b) public {         averageValue = _a.average(_b + 2);     } }\n                                        ^--------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Incrementer {\n    function increment(uint256 a) internal pure returns (uint256) {\n        return a + 1;\n    }\n}\n\ncontract Incremental {\n    using Incrementer for uint256;\n    \n    uint256 public incrementalValue;\n    \n    function addOne(uint256 _value) public {\n        incrementalValue = _value.increment();\n    }\n}\n\ncontract Increment is Incremental {\n    function addTwo(uint256 _value) public {\n        incrementalValue = _value.increment() + 1;\n    }\n}",
          "error message": "Error: Member \"increment\" not found or not visible after argument-dependent lookup in uint256.\n ... ublic {         incrementalValue = _value.increment() + 1;     } }\n                                        ^--------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Doubling {\n    function double(uint256 a) internal pure returns (uint256) {\n        return a * 2;\n    }\n}\n\ncontract Double {\n    using Doubling for uint256;\n    \n    uint256 public doubleValue;\n    \n    function doubleAmount(uint256 _value) public {\n        doubleValue = _value.double();\n    }\n}\n\ncontract DoublePlus is Double {\n    function doubleAndAdd(uint256 _value) public {\n        doubleValue = _value.double() + 2;\n    }\n}",
          "error message": "Error: Member \"double\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         doubleValue = _value.double() + 2;     } }\n                                        ^-----------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Squarer {\n    function square(uint256 a) internal pure returns (uint256) {\n        return a * a;\n    }\n}\n\ncontract SquareCalculator {\n    using Squarer for uint256;\n    \n    uint256 public squareValue;\n    \n    function calculateSquare(uint256 _value) public {\n        squareValue = _value.square();\n    }\n}\n\ncontract SquarerPlus is SquareCalculator {\n    function calculateSquarePlus(uint256 _value) public {\n        squareValue = _value.square() + 5;\n    }\n}",
          "error message": "Error: Member \"square\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         squareValue = _value.square() + 5;     } }\n                                        ^-----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Enhancer {\n    function enhance(uint256 a) internal pure returns (uint256) {\n        return a + 100;\n    }\n}\n\ncontract BasicEnhancer {\n    using Enhancer for uint256;\n    \n    uint256 public enhancedValue;\n    \n    function enhanceValue(uint256 _value) public {\n        enhancedValue = _value.enhance();\n    }\n}\n\ncontract AdvancedEnhancer is BasicEnhancer {\n    function doubleEnhance(uint256 _value) public {\n        enhancedValue = _value.enhance() * 2;\n    }\n}",
          "error message": "Error: Member \"enhance\" not found or not visible after argument-dependent lookup in uint256.\n ... ) public {         enhancedValue = _value.enhance() * 2;     } }\n                                        ^------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary BasicMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"BasicMath: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Root {\n    using BasicMath for uint256;\n    \n    uint256 public rootValue;\n    \n    function multiply(uint256 _value) public {\n        rootValue = _value.mul(3);\n    }\n}\n\ncontract Branch is Root {\n    using BasicMath for uint256;\n\n    function expand(uint256 _value) public {\n        rootValue = _value.mul(6);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary DivOperations {\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DivOperations: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Divider {\n    using DivOperations for uint256;\n    \n    uint256 public dividerValue;\n    \n    function divide(uint256 _value) public {\n        dividerValue = _value.div(4);\n    }\n}\n\ncontract Splitter is Divider {\n    using DivOperations for uint256;\n\n    function split(uint256 _value) public {\n        dividerValue = _value.div(5);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary Modulus {\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Modulus: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract BaseMod {\n    using Modulus for uint256;\n    \n    uint256 public baseModValue;\n    \n    function modulo(uint256 _value) public {\n        baseModValue = _value.mod(4);\n    }\n}\n\ncontract DerivedMod is BaseMod {\n    using Modulus for uint256;\n\n    function remainder(uint256 _value) public {\n        baseModValue = _value.mod(6);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary Exponentiation {\n    function pow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 result = 1;\n        for (uint256 i = 0; i < exp; i++) {\n            result = result * base;\n        }\n        return result;\n    }\n}\n\ncontract Power {\n    using Exponentiation for uint256;\n    \n    uint256 public powerValue;\n    \n    function exponent(uint256 _base, uint256 _exp) public {\n        powerValue = _base.pow(_exp);\n    }\n}\n\ncontract Exponent is Power {\n    using Exponentiation for uint256;\n\n    function raise(uint256 _base, uint256 _exp) public {\n        powerValue = _base.pow(_exp + 2);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary Percentage {\n    function addPercentage(uint256 a, uint256 percent) internal pure returns (uint256) {\n        return a + (a * percent / 100);\n    }\n}\n\ncontract Amount {\n    using Percentage for uint256;\n    \n    uint256 public amountValue;\n    \n    function addPercent(uint256 _value, uint256 _percent) public {\n        amountValue = _value.addPercentage(_percent);\n    }\n}\n\ncontract Fraction is Amount {\n    using Percentage for uint256;\n\n    function increase(uint256 _value, uint256 _percent) public {\n        amountValue = _value.addPercentage(_percent + 3);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary Averages {\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b) / 2;\n    }\n}\n\ncontract AverageCalculator {\n    using Averages for uint256;\n    \n    uint256 public averageValue;\n    \n    function calculateAverage(uint256 _a, uint256 _b) public {\n        averageValue = _a.average(_b);\n    }\n}\n\ncontract MeanCalculator is AverageCalculator {\n    using Averages for uint256;\n\n    function calculateMean(uint256 _a, uint256 _b) public {\n        averageValue = _a.average(_b + 2);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary Incrementer {\n    function increment(uint256 a) internal pure returns (uint256) {\n        return a + 1;\n    }\n}\n\ncontract Incremental {\n    using Incrementer for uint256;\n    \n    uint256 public incrementalValue;\n    \n    function addOne(uint256 _value) public {\n        incrementalValue = _value.increment();\n    }\n}\n\ncontract Increment is Incremental {\n    using Incrementer for uint256;\n\n    function addTwo(uint256 _value) public {\n        incrementalValue = _value.increment() + 1;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary Doubling {\n    function double(uint256 a) internal pure returns (uint256) {\n        return a * 2;\n    }\n}\n\ncontract Double {\n    using Doubling for uint256;\n    \n    uint256 public doubleValue;\n    \n    function doubleAmount(uint256 _value) public {\n        doubleValue = _value.double();\n    }\n}\n\ncontract DoublePlus is Double {\n    using Doubling for uint256;\n\n    function doubleAndAdd(uint256 _value) public {\n        doubleValue = _value.double() + 2;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary Squarer {\n    function square(uint256 a) internal pure returns (uint256) {\n        return a * a;\n    }\n}\n\ncontract SquareCalculator {\n    using Squarer for uint256;\n    \n    uint256 public squareValue;\n    \n    function calculateSquare(uint256 _value) public {\n        squareValue = _value.square();\n    }\n}\n\ncontract SquarerPlus is SquareCalculator {\n    using Squarer for uint256;\n\n    function calculateSquarePlus(uint256 _value) public {\n        squareValue = _value.square() + 5;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary Enhancer {\n    function enhance(uint256 a) internal pure returns (uint256) {\n        return a + 100;\n    }\n}\n\ncontract BasicEnhancer {\n    using Enhancer for uint256;\n    \n    uint256 public enhancedValue;\n    \n    function enhanceValue(uint256 _value) public {\n        enhancedValue = _value.enhance();\n    }\n}\n\ncontract AdvancedEnhancer is BasicEnhancer {\n    using Enhancer for uint256;\n\n    function doubleEnhance(uint256 _value) public {\n        enhancedValue = _value.enhance() * 2;\n    }\n}"
      }
    }
  },
  {
    "Changes57": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Shifts by signed types are disallowed.\nPreviously, shifts by negative amounts were allowed, but reverted at runtime.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftExample2 {\n    function shiftLeftExample(int8 a, int8 b) public pure returns (int8) {\n        return a << b;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return a << b;     } }\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitShiftOperations {\n    function performBitShift(int8 x, int8 y) public pure returns (int8) {\n        return x << y;\n    }\n\n    function extraMethod1() public pure returns (uint256) {\n        return 1234;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return x << y;     }      function extraMethod1( ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftBits {\n    function shiftBitsLeft(int8 c, int8 d) public pure returns (int8) {\n        return c << d;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\npragma solidity^0.7.0;  contract ShiftBits {     function shiftBitsLeft(int8 c, int8 d) public pure returns (int8) {         return c << d;     } }\n                                                                                                                                    ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitwiseOperations {\n    function bitwiseShift(int8 e, int8 f) public pure returns (int8) {\n        return e << f;\n    }\n\n    function additionalFunction1() public pure returns (address) {\n        return address(0x123);\n    }\n\n    function additionalFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return e << f;     }      function additionalFun ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftOperation {\n    function shiftLeftOperation(int8 g, int8 h) public pure returns (int8) {\n        return g << h;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return g << h;     } }\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract LeftShiftOperations {\n    function performLeftShift(int8 m, int8 n) public pure returns (int8) {\n        return m << n;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return m << n;     } }\n                                        ^----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftLeftTest {\n    function testShift(int8 p, int8 q) public pure returns (int8) {\n        return p << q;\n    }\n\n    function dummyMethod() public pure returns (uint) {\n        return 9999;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return p << q;     }      function dummyMethod() ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftingBits {\n    function shiftLeftBits(int8 s, int8 t) public pure returns (int8) {\n        return s << t;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\npragma solidity^0.7.0;  contract ShiftingBits {     function shiftLeftBits(int8 s, int8 t) public pure returns (int8) {         return s << t;     } }\n                                                                                                                                       ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract LeftShiftBitwise {\n    function shiftBitsLeft(int8 u, int8 v) public pure returns (int8) {\n        return u << v;\n    }\n\n    function extraMethod2() public pure returns (uint256) {\n        return 5678;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return u << v;     }      function extraMethod2( ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitShiftHandler {\n    function handleBitShift(int8 w, int8 x) public pure returns (int8) {\n        return w << x;\n    }\n\n    function additionalMethod() public pure returns (address) {\n        return address(0xABC);\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return w << x;     }      function additionalMet ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ShiftExample2 {\n    function shiftLeftExample(uint8 a, uint8 b) public pure returns (uint8) {\n        return a << b;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract BitShiftOperations {\n    function performBitShift(uint8 x, uint8 y) public pure returns (uint8) {\n        return x << y;\n    }\n\n    function extraMethod1() public pure returns (uint256) {\n        return 1234;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ShiftBits {\n    function shiftBitsLeft(uint8 c, uint8 d) public pure returns (uint8) {\n        return c << d;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract BitwiseOperations {\n    function bitwiseShift(uint8 e, uint8 f) public pure returns (uint8) {\n        return e << f;\n    }\n\n    function additionalFunction1() public pure returns (address) {\n        return address(0x123);\n    }\n\n    function additionalFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ShiftOperation {\n    function shiftLeftOperation(uint8 g, uint8 h) public pure returns (uint8) {\n        return g << h;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract LeftShiftOperations {\n    function performLeftShift(uint8 m, uint8 n) public pure returns (uint8) {\n        return m << n;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ShiftLeftTest {\n    function testShift(uint8 p, uint8 q) public pure returns (uint8) {\n        return p << q;\n    }\n\n    function dummyMethod() public pure returns (uint) {\n        return 9999;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ShiftingBits {\n    function shiftLeftBits(uint8 s, uint8 t) public pure returns (uint8) {\n        return s << t;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract LeftShiftBitwise {\n    function shiftBitsLeft(uint8 u, uint8 v) public pure returns (uint8) {\n        return u << v;\n    }\n\n    function extraMethod2() public pure returns (uint256) {\n        return 5678;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract BitShiftHandler {\n    function handleBitShift(uint8 w, uint8 x) public pure returns (uint8) {\n        return w << x;\n    }\n\n    function additionalMethod() public pure returns (address) {\n        return address(0xABC);\n    }\n}"
      }
    }
  },
  {
    "Changes58": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The <code>finney</code> and <code>szabo</code> denominations are removed.\nThey are rarely used and do not make the actual amount readily visible. Instead, explicit\nvalues like <code>1e20</code> or the very common <code>gwei</code> can be used.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public amountInFinney = 2 finney;\n\n    function checkAmount() public view returns (uint) {\n        return amountInFinney;\n    }\n\n    function pay() public payable {\n        require(msg.value >= amountInFinney, \"Insufficient payment\");\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...     uint public amountInFinney = 2 finney;      function checkAmount() publi ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public valueInSzabo = 10 szabo;\n\n    function deposit() public payable {\n        require(msg.value >= valueInSzabo, \"Deposit must be at least 10 szabo\");\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...      uint public valueInSzabo = 10 szabo;      function deposit() public pa ...\n                                        ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public threshold = 5 finney;\n\n    function setThreshold(uint _newThreshold) public {\n        threshold = _newThreshold * 1 finney;\n    }\n\n    function isAboveThreshold(uint amount) public view returns (bool) {\n        return amount >= threshold;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... e3 {     uint public threshold = 5 finney;      function setThreshold(uint _ ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public smallAmount = 3 szabo;\n\n    function sendEther() public payable {\n        require(msg.value == smallAmount, \"Must send exactly 3 szabo\");\n    }\n\n    function currentAmount() public view returns (uint) {\n        return smallAmount;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...  {     uint public smallAmount = 3 szabo;      function sendEther() public  ...\n                                        ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public requiredAmount = 7 finney;\n\n    function receivePayment() public payable {\n        require(msg.value == requiredAmount, \"Must send 7 finney\");\n    }\n\n    function checkRequired() public view returns (uint) {\n        return requiredAmount;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...     uint public requiredAmount = 7 finney;      function receivePayment() pu ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public minimumSzabo = 50 szabo;\n\n    function contribute() public payable {\n        require(msg.value >= minimumSzabo, \"Contribution must be at least 50 szabo\");\n    }\n\n    function getMinimum() public view returns (uint) {\n        return minimumSzabo;\n    }\n\n    function dummyFunc() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...      uint public minimumSzabo = 50 szabo;      function contribute() public ...\n                                        ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public fee = 1 finney;\n\n    function payFee() public payable {\n        require(msg.value >= fee, \"Fee is 1 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return fee;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... Example7 {     uint public fee = 1 finney;      function payFee() public pay ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public donation = 20 szabo;\n\n    function donate() public payable {\n        require(msg.value == donation, \"Donate exactly 20 szabo\");\n    }\n\n    function getDonationAmount() public view returns (uint) {\n        return donation;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... e8 {     uint public donation = 20 szabo;      function donate() public pay ...\n                                        ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public cost = 15 finney;\n\n    function purchase() public payable {\n        require(msg.value >= cost, \"Cost is 15 finney\");\n    }\n\n    function getCost() public view returns (uint) {\n        return cost;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... ample9 {     uint public cost = 15 finney;      function purchase() public p ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public rate = 5 szabo;\n\n    function invest() public payable {\n        require(msg.value >= rate, \"Investment rate is 5 szabo\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rate;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... ample10 {     uint public rate = 5 szabo;      function invest() public pay ...\n                                        ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public amountInFinney = 2 * 1e15;\n\n    function checkAmount() public view returns (uint) {\n        return amountInFinney;\n    }\n\n    function pay() public payable {\n        require(msg.value >= amountInFinney, \"Insufficient payment\");\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public valueInSzabo = 10 * 1e12;\n\n    function deposit() public payable {\n        require(msg.value >= valueInSzabo, \"Deposit must be at least 10 szabo\");\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public threshold = 5 * 1e15;\n\n    function setThreshold(uint _newThreshold) public {\n        threshold = _newThreshold * 1e15;\n    }\n\n    function isAboveThreshold(uint amount) public view returns (bool) {\n        return amount >= threshold;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public smallAmount = 3 * 1e12;\n\n    function sendEther() public payable {\n        require(msg.value == smallAmount, \"Must send exactly 3 szabo\");\n    }\n\n    function currentAmount() public view returns (uint) {\n        return smallAmount;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public requiredAmount = 7 * 1e15;\n\n    function receivePayment() public payable {\n        require(msg.value == requiredAmount, \"Must send 7 finney\");\n    }\n\n    function checkRequired() public view returns (uint) {\n        return requiredAmount;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public minimumSzabo = 50 * 1e12;\n\n    function contribute() public payable {\n        require(msg.value >= minimumSzabo, \"Contribution must be at least 50 szabo\");\n    }\n\n    function getMinimum() public view returns (uint) {\n        return minimumSzabo;\n    }\n\n    function dummyFunc() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public fee = 1 * 1e15;\n\n    function payFee() public payable {\n        require(msg.value >= fee, \"Fee is 1 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return fee;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public donation = 20 * 1e12;\n\n    function donate() public payable {\n        require(msg.value == donation, \"Donate exactly 20 szabo\");\n    }\n\n    function getDonationAmount() public view returns (uint) {\n        return donation;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public cost = 15 * 1e15;\n\n    function purchase() public payable {\n        require(msg.value >= cost, \"Cost is 15 finney\");\n    }\n\n    function getCost() public view returns (uint) {\n        return cost;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public rate = 5 * 1e12;\n\n    function invest() public payable {\n        require(msg.value >= rate, \"Investment rate is 5 szabo\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rate;\n    }\n}"
      }
    }
  },
  {
    "Changes59": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractK {\n    byte itemK;\n    function resetItemK(byte newValue) public {\n        itemK = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/2.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractK {     byte itemK;     function resetItemK(byte newValue) public {         itemK = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractL {\n    byte itemL;\n    function loadItemL(byte newValue) public {\n        itemL = newValue;\n    }\n    function helperFunctionL() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/3.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractL {     byte itemL;     function loadItemL(byte ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractM {\n    byte itemM;\n    function pushItemM(byte newValue) public {\n        itemM = newValue;\n    }\n    function irrelevantM1() public pure returns (uint) {\n        return 42;\n    }\n    function irrelevantM2() public pure returns (uint) {\n        return 24;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/4.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractM {     byte itemM;     function pushItemM(byte ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractN {\n    byte itemN;\n    function storeItemN(byte newValue) public {\n        itemN = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/5.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractN {     byte itemN;     function storeItemN(byte newValue) public {         itemN = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractO {\n    byte itemO;\n    function editItemO(byte newValue) public {\n        itemO = newValue;\n    }\n    function dummyO() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/6.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractO {     byte itemO;     function editItemO(byte ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractP {\n    byte itemP;\n    function insertItemP(byte newValue) public {\n        itemP = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/7.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractP {     byte itemP;     function insertItemP(byte newValue) public {         itemP = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractQ {\n    byte itemQ;\n    function setItemQ(byte newValue) public {\n        itemQ = newValue;\n    }\n    function randomFunctionQ() public pure returns (int) {\n        return -123;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/8.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractQ {     byte itemQ;     function setItemQ(byte  ...\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractR {\n    byte itemR;\n    function alterItemR(byte newValue) public {\n        itemR = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/9.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractR {     byte itemR;     function alterItemR(byte newValue) public {         itemR = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractS {\n    byte itemS;\n    function modifyItemS(byte newValue) public {\n        itemS = newValue;\n    }\n    function extraFunctionS() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/10.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractS {     byte itemS;     function modifyItemS(by ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractT {\n    byte itemT;\n    function applyItemT(byte newValue) public {\n        itemT = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/11.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractT {     byte itemT;     function applyItemT(byte newValue) public {         itemT = newValue;     } }\n  |                                                 ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractK {\n    bytes1 itemK;\n    function resetItemK(bytes1 newValue) public {\n        itemK = newValue;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractL {\n    bytes1 itemL;\n    function loadItemL(bytes1 newValue) public {\n        itemL = newValue;\n    }\n    function helperFunctionL() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractM {\n    bytes1 itemM;\n    function pushItemM(bytes1 newValue) public {\n        itemM = newValue;\n    }\n    function irrelevantM1() public pure returns (uint) {\n        return 42;\n    }\n    function irrelevantM2() public pure returns (uint) {\n        return 24;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractN {\n    bytes1 itemN;\n    function storeItemN(bytes1 newValue) public {\n        itemN = newValue;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractO {\n    bytes1 itemO;\n    function editItemO(bytes1 newValue) public {\n        itemO = newValue;\n    }\n    function dummyO() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractP {\n    bytes1 itemP;\n    function insertItemP(bytes1 newValue) public {\n        itemP = newValue;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractQ {\n    bytes1 itemQ;\n    function setItemQ(bytes1 newValue) public {\n        itemQ = newValue;\n    }\n    function randomFunctionQ() public pure returns (int) {\n        return -123;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractR {\n    bytes1 itemR;\n    function alterItemR(bytes1 newValue) public {\n        itemR = newValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractS {\n    bytes1 itemS;\n    function modifyItemS(bytes1 newValue) public {\n        itemS = newValue;\n    }\n    function extraFunctionS() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractT {\n    bytes1 itemT;\n    function applyItemT(bytes1 newValue) public {\n        itemT = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes60": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions from negative literals and literals larger than <code>type(uint160).max</code> to\n<code>address</code> are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractEleven {\n    function negativeConversion() public pure returns (address) {\n        int data = -11;\n        return address(uint160(data));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/12.sol:1:164:\n  |\n1 |  ... data = -11;         return address(uint160(data));     } }\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwelve {\n    function convertMinus() public pure returns (address) {\n        int smallNeg = -12;\n        return address(uint160(smallNeg));\n    }\n    function unused() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/13.sol:1:162:\n  |\n1 |  ... lNeg = -12;         return address(uint160(smallNeg));     }     function unused() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirteen {\n    function makeNegativeAddress() public pure returns (address) {\n        int numNeg = -13;\n        return address(uint160(numNeg));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/14.sol:1:169:\n  |\n1 |  ... mNeg = -13;         return address(uint160(numNeg));     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractFourteen {\n    function processNegative() public pure returns (address) {\n        int bigNegative = -14;\n        return address(uint160(bigNegative));\n    }\n    function extraData() public pure returns (uint) {\n        return 2024;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/15.sol:1:170:\n  |\n1 |  ... tive = -14;         return address(uint160(bigNegative));     }     function extraData() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractFifteen {\n    function transformNeg() public pure returns (address) {\n        int moreNegative = -15;\n        return address(uint160(moreNegative));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/16.sol:1:167:\n  |\n1 |  ... tive = -15;         return address(uint160(moreNegative));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractSixteen {\n    function modifyNeg() public pure returns (address) {\n        int negIntVal = -16;\n        return address(uint160(negIntVal));\n    }\n    function randomFunc() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/17.sol:1:161:\n  |\n1 |  ... tVal = -16;         return address(uint160(negIntVal));     }     function randomFunc()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractSeventeen {\n    function invertToAddress() public pure returns (address) {\n        int negativeOne = -17;\n        return address(uint160(negativeOne));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/18.sol:1:171:\n  |\n1 |  ... eOne = -17;         return address(uint160(negativeOne));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractEighteen {\n    function switchNeg() public pure returns (address) {\n        int lesserNeg = -18;\n        return address(uint160(lesserNeg));\n    }\n    function helperFunc() public pure returns (uint) {\n        return 18;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/19.sol:1:162:\n  |\n1 |  ... rNeg = -18;         return address(uint160(lesserNeg));     }     function helperFunc()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractNineteen {\n    function addressFromNeg() public pure returns (address) {\n        int negativeCount = -19;\n        return address(uint160(negativeCount));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/20.sol:1:171:\n  |\n1 |  ... ount = -19;         return address(uint160(negativeCount));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwenty {\n    function flipNegative() public pure returns (address) {\n        int anotherNeg = -20;\n        return address(uint160(anotherNeg));\n    }\n    function additionalMethod() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/21.sol:1:164:\n  |\n1 |  ... rNeg = -20;         return address(uint160(anotherNeg));     }     function additionalMet ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractEleven {\n    function negativeConversion() public pure returns (uint) {\n        int data = -11;\n        return uint(data);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractTwelve {\n    function convertMinus() public pure returns (uint) {\n        int smallNeg = -12;\n        return uint(smallNeg);\n    }\n    function unused() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractThirteen {\n    function makeNegativeAddress() public pure returns (uint) {\n        int numNeg = -13;\n        return uint(numNeg);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractFourteen {\n    function processNegative() public pure returns (uint) {\n        int bigNegative = -14;\n        return uint(bigNegative);\n    }\n    function extraData() public pure returns (uint) {\n        return 2024;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractFifteen {\n    function transformNeg() public pure returns (uint) {\n        int moreNegative = -15;\n        return uint(moreNegative);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractSixteen {\n    function modifyNeg() public pure returns (uint) {\n        int negIntVal = -16;\n        return uint(negIntVal);\n    }\n    function randomFunc() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractSeventeen {\n    function invertToAddress() public pure returns (uint) {\n        int negativeOne = -17;\n        return uint(negativeOne);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractEighteen {\n    function switchNeg() public pure returns (uint) {\n        int lesserNeg = -18;\n        return uint(lesserNeg);\n    }\n    function helperFunc() public pure returns (uint) {\n        return 18;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractNineteen {\n    function addressFromNeg() public pure returns (uint) {\n        int negativeCount = -19;\n        return uint(negativeCount);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractTwenty {\n    function flipNegative() public pure returns (uint) {\n        int anotherNeg = -20;\n        return uint(anotherNeg);\n    }\n    function additionalMethod() public pure returns (int) {\n        return 42;\n    }\n}"
      }
    }
  },
  {
    "Changes61": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and an integer type <code>T</code> are only allowed if the literal\nlies between <code>type(T).min</code> and <code>type(T).max</code>. In particular, replace usages of <code>uint(-1)</code>\nwith <code>type(uint).max</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleEleven {\n    function computeCeiling() public pure returns (uint) {\n        uint ceiling = uint(-1);\n        return ceiling;\n    }\n    function helperOne() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/22.sol:1:132:\n  |\n1 |  ... ns (uint) {         uint ceiling = uint(-1);         return ceiling;     }     ...\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwelve {\n    function determineMax() public pure returns (uint) {\n        uint maximum = uint(-1);\n        return maximum;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/23.sol:1:130:\n  |\n1 |  ... ns (uint) {         uint maximum = uint(-1);         return maximum;     } }\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirteen {\n    function extractMaximum() public pure returns (uint) {\n        uint maxExtract = uint(-1);\n        return maxExtract;\n    }\n    function dummyFunc() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/24.sol:1:137:\n  |\n1 |  ... (uint) {         uint maxExtract = uint(-1);         return maxExtract;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleFourteen {\n    function reachBoundary() public pure returns (uint) {\n        uint boundaryReach = uint(-1);\n        return boundaryReach;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/25.sol:1:139:\n  |\n1 |  ... nt) {         uint boundaryReach = uint(-1);         return boundaryReach;     ...\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleFifteen {\n    function pullCeilingValue() public pure returns (uint) {\n        uint ceilingValue = uint(-1);\n        return ceilingValue;\n    }\n    function dummyOutput() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/26.sol:1:140:\n  |\n1 |  ... int) {         uint ceilingValue = uint(-1);         return ceilingValue;      ...\n  |                                         ^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleSixteen {\n    function generateMax() public pure returns (uint) {\n        uint generatedMax = uint(-1);\n        return generatedMax;\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Unrelated string\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/27.sol:1:135:\n  |\n1 |  ... int) {         uint generatedMax = uint(-1);         return generatedMax;      ...\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleSeventeen {\n    function secureLimit() public pure returns (uint) {\n        uint secureValue = uint(-1);\n        return secureValue;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/28.sol:1:136:\n  |\n1 |  ... uint) {         uint secureValue = uint(-1);         return secureValue;     } ...\n  |                                         ^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleEighteen {\n    function defineUpperBound() public pure returns (uint) {\n        uint upperBound = uint(-1);\n        return upperBound;\n    }\n    function extraFunc() public pure returns (int) {\n        return -100;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/29.sol:1:139:\n  |\n1 |  ... (uint) {         uint upperBound = uint(-1);         return upperBound;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleNineteen {\n    function pinpointMax() public pure returns (uint) {\n        uint pinpoint = uint(-1);\n        return pinpoint;\n    }\n    function unrelatedOne() public pure returns (uint) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/30.sol:1:132:\n  |\n1 |  ... s (uint) {         uint pinpoint = uint(-1);         return pinpoint;     }    ...\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwenty {\n    function identifyBoundary() public pure returns (uint) {\n        uint boundaryIdentify = uint(-1);\n        return boundaryIdentify;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/31.sol:1:143:\n  |\n1 |  ...  {         uint boundaryIdentify = uint(-1);         return boundaryIdentify;  ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ExampleEleven {\n    function computeCeiling() public pure returns (uint) {\n        uint ceiling = type(uint).max;\n        return ceiling;\n    }\n    function helperOne() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleTwelve {\n    function determineMax() public pure returns (uint) {\n        uint maximum = type(uint).max;\n        return maximum;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ExampleThirteen {\n    function extractMaximum() public pure returns (uint) {\n        uint maxExtract = type(uint).max;\n        return maxExtract;\n    }\n    function dummyFunc() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ExampleFourteen {\n    function reachBoundary() public pure returns (uint) {\n        uint boundaryReach = type(uint).max;\n        return boundaryReach;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ExampleFifteen {\n    function pullCeilingValue() public pure returns (uint) {\n        uint ceilingValue = type(uint).max;\n        return ceilingValue;\n    }\n    function dummyOutput() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ExampleSixteen {\n    function generateMax() public pure returns (uint) {\n        uint generatedMax = type(uint).max;\n        return generatedMax;\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Unrelated string\";\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ExampleSeventeen {\n    function secureLimit() public pure returns (uint) {\n        uint secureValue = type(uint).max;\n        return secureValue;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ExampleEighteen {\n    function defineUpperBound() public pure returns (uint) {\n        uint upperBound = type(uint).max;\n        return upperBound;\n    }\n    function extraFunc() public pure returns (int) {\n        return -100;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ExampleNineteen {\n    function pinpointMax() public pure returns (uint) {\n        uint pinpoint = type(uint).max;\n        return pinpoint;\n    }\n    function unrelatedOne() public pure returns (uint) {\n        return 999;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ExampleTwenty {\n    function identifyBoundary() public pure returns (uint) {\n        uint boundaryIdentify = type(uint).max;\n        return boundaryIdentify;\n    }\n}"
      }
    }
  },
  {
    "Changes62": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and enums are only allowed if the literal can\nrepresent a value in the enum.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example12 {\n    enum Action { Play, Pause, Stop }\n    Action public playerAction;\n    function setAction() public {\n        playerAction = Action(3);\n    }\n    function miscFunction() public pure returns (uint) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example12.Action\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/32.sol:1:173:\n  |\n1 |  ... () public {         playerAction = Action(3);     }     function miscFunction() ...\n  |                                         ^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example13 {\n    enum Direction { North, South, East, West }\n    Direction public compass;\n    function setDirection() public {\n        compass = Direction(4);\n    }\n    function anotherMiscFunction() public pure returns (string memory) {\n        return \"Direction function\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example13.Direction\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/33.sol:1:179:\n  |\n1 |  ... ction() public {         compass = Direction(4);     }     function anotherMiscFun ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example14 {\n    enum Gear { Park, Reverse, Neutral, Drive }\n    Gear public carGear;\n    function shiftGear() public {\n        carGear = Gear(5);\n    }\n    function utilityOne() public pure returns (bool) {\n        return false;\n    }\n    function utilityTwo() public pure returns (int) {\n        return -100;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example14.Gear\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/34.sol:1:171:\n  |\n1 |  ... tGear() public {         carGear = Gear(5);     }     function utilityOne() p ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example15 {\n    enum Mood { Happy, Sad, Excited, Anxious }\n    Mood public currentMood;\n    function updateMood() public {\n        currentMood = Mood(6);\n    }\n    function simpleFunction() public pure returns (bytes memory) {\n        return \"test\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 6\" to \"enum Example15.Mood\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/35.sol:1:179:\n  |\n1 |  ... d() public {         currentMood = Mood(6);     }     function simpleFunction ...\n  |                                         ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example16 {\n    enum Size { Small, Medium, Large }\n    Size public boxSize;\n    function setSize() public {\n        boxSize = Size(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example16.Size\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/36.sol:1:160:\n  |\n1 |  ... tSize() public {         boxSize = Size(3);     } }\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example17 {\n    enum Age { Young, Middle, Old }\n    Age public personAge;\n    function setAge() public {\n        personAge = Age(4);\n    }\n    function extraDetails() public pure returns (string memory) {\n        return \"Age details\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example17.Age\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/37.sol:1:159:\n  |\n1 |  ... Age() public {         personAge = Age(4);     }     function extraDetails() ...\n  |                                         ^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example18 {\n    enum Frequency { Rarely, Sometimes, Often, Always }\n    Frequency public usageFrequency;\n    function setFrequency() public {\n        usageFrequency = Frequency(8);\n    }\n    function helperFunction() public pure returns (uint) {\n        return 321;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 8\" to \"enum Example18.Frequency\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/38.sol:1:201:\n  |\n1 |  ...  public {         usageFrequency = Frequency(8);     }     function helperFunction ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example19 {\n    enum Season { Spring, Summer, Autumn, Winter }\n    Season public currentSeason;\n    function changeSeason() public {\n        currentSeason = Season(5);\n    }\n    function randomHelper() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example19.Season\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/39.sol:1:191:\n  |\n1 |  ... ) public {         currentSeason = Season(5);     }     function randomHelper() ...\n  |                                         ^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example20 {\n    enum Speed { Slow, Moderate, Fast }\n    Speed public vehicleSpeed;\n    function setSpeed() public {\n        vehicleSpeed = Speed(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example20.Speed\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/40.sol:1:173:\n  |\n1 |  ... () public {         vehicleSpeed = Speed(3);     } }\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example21 {\n    enum Response { Yes, No, Maybe }\n    Response public answer;\n    function setResponse() public {\n        answer = Response(4);\n    }\n    function anotherFunction() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example21.Response\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/41.sol:1:164:\n  |\n1 |  ... sponse() public {         answer = Response(4);     }     function anotherFunctio ...\n  |                                         ^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example12 {\n    enum Action { Play, Pause, Stop }\n    Action public playerAction;\n    function setAction(Action _action) public {\n        playerAction = _action;\n    }\n    function miscFunction() public pure returns (uint) {\n        return 999;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example13 {\n    enum Direction { North, South, East, West }\n    Direction public compass;\n    function setDirection(Direction _direction) public {\n        compass = _direction;\n    }\n    function anotherMiscFunction() public pure returns (string memory) {\n        return \"Direction function\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example14 {\n    enum Gear { Park, Reverse, Neutral, Drive }\n    Gear public carGear;\n    function shiftGear(Gear _gear) public {\n        carGear = _gear;\n    }\n    function utilityOne() public pure returns (bool) {\n        return false;\n    }\n    function utilityTwo() public pure returns (int) {\n        return -100;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example15 {\n    enum Mood { Happy, Sad, Excited, Anxious }\n    Mood public currentMood;\n    function updateMood(Mood _mood) public {\n        currentMood = _mood;\n    }\n    function simpleFunction() public pure returns (bytes memory) {\n        return \"test\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example16 {\n    enum Size { Small, Medium, Large }\n    Size public boxSize;\n    function setSize(Size _size) public {\n        boxSize = _size;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example17 {\n    enum Age { Young, Middle, Old }\n    Age public personAge;\n    function setAge(Age _age) public {\n        personAge = _age;\n    }\n    function extraDetails() public pure returns (string memory) {\n        return \"Age details\";\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example18 {\n    enum Frequency { Rarely, Sometimes, Often, Always }\n    Frequency public usageFrequency;\n    function setFrequency(Frequency _frequency) public {\n        usageFrequency = _frequency;\n    }\n    function helperFunction() public pure returns (uint) {\n        return 321;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example19 {\n    enum Season { Spring, Summer, Autumn, Winter }\n    Season public currentSeason;\n    function changeSeason(Season _season) public {\n        currentSeason = _season;\n    }\n    function randomHelper() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example20 {\n    enum Speed { Slow, Moderate, Fast }\n    Speed public vehicleSpeed;\n    function setSpeed(Speed _speed) public {\n        vehicleSpeed = _speed;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example21 {\n    enum Response { Yes, No, Maybe }\n    Response public answer;\n    function setResponse(Response _response) public {\n        answer = _response;\n    }\n    function anotherFunction() public pure returns (int) {\n        return 42;\n    }\n}"
      }
    }
  },
  {
    "Changes63": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and <code>address</code> type (e.g. <code>address(literal)</code>) have the\ntype <code>address</code> instead of <code>address payable</code>. One can get a payable address type by using an\nexplicit conversion, i.e., <code>payable(literal)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example12 {\n    function sendTokens(address recipient, uint256 amount) public {\n        address payable dest = address(0xAAA);\n        dest.transfer(amount);\n    }\n\n    function computeInterest(uint principal, uint rate, uint time) public pure returns (uint) {\n        return principal * rate * time / 100;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/42.sol:1:122:\n  |\n1 |  ... , uint256 amount) public {         address payable dest = address(0xAAA);         dest.transfer(amount);    ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example13 {\n    function distributeRewards(address addr, uint rewards) public {\n        address payable account = address(0xBBB);\n        account.transfer(rewards);\n    }\n\n    function getSum(uint[] memory data) public pure returns (uint) {\n        uint sum = 0;\n        for (uint i = 0; i < data.length; i++) {\n            sum += data[i];\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/43.sol:1:122:\n  |\n1 |  ... dr, uint rewards) public {         address payable account = address(0xBBB);         account.transfer(rewards) ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example14 {\n    function makePayment(address to, uint256 sum) public {\n        address payable payAddress = address(0xCCC);\n        payAddress.transfer(sum);\n    }\n\n    function doubleValue(uint value) public pure returns (uint) {\n        return value * 2;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/44.sol:1:113:\n  |\n1 |  ...  to, uint256 sum) public {         address payable payAddress = address(0xCCC);         payAddress.transfer(sum); ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example15 {\n    function dispatchFunds(address entity, uint quantity) public {\n        address payable wallet = address(0xDDD);\n        wallet.transfer(quantity);\n    }\n\n    function countParticipants(uint[] memory participants) public pure returns (uint) {\n        return participants.length;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/45.sol:1:121:\n  |\n1 |  ... y, uint quantity) public {         address payable wallet = address(0xDDD);         wallet.transfer(quantity) ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example16 {\n    function grantAccess(address user, uint funds) public {\n        address payable account = address(0xEEE);\n        account.transfer(funds);\n    }\n\n    function incrementCount(uint count) public pure returns (uint) {\n        return count + 1;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/46.sol:1:114:\n  |\n1 |  ... user, uint funds) public {         address payable account = address(0xEEE);         account.transfer(funds);  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example17 {\n    function releaseFunds(address receiver, uint payment) public {\n        address payable payee = address(0xFFF);\n        payee.transfer(payment);\n    }\n\n    function calculateDiscount(uint price, uint discountRate) public pure returns (uint) {\n        return price * discountRate / 100;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/47.sol:1:121:\n  |\n1 |  ... er, uint payment) public {         address payable payee = address(0xFFF);         payee.transfer(payment);  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example18 {\n    function transferAssets(address client, uint cash) public {\n        address payable holder = address(0x111);\n        holder.transfer(cash);\n    }\n\n    function getBalance() public pure returns (uint) {\n        return 1500;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/48.sol:1:118:\n  |\n1 |  ... lient, uint cash) public {         address payable holder = address(0x111);         holder.transfer(cash);    ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example19 {\n    function moveCapital(address user, uint amount) public {\n        address payable recipient = address(0x222);\n        recipient.transfer(amount);\n    }\n\n    function min(uint a, uint b) public pure returns (uint) {\n        return a < b ? a : b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/49.sol:1:115:\n  |\n1 |  ... ser, uint amount) public {         address payable recipient = address(0x222);         recipient.transfer(amount ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example20 {\n    function allocateGrant(address recipient, uint funds) public {\n        address payable agency = address(0x333);\n        agency.transfer(funds);\n    }\n\n    function max(uint a, uint b) public pure returns (uint) {\n        return a > b ? a : b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/50.sol:1:121:\n  |\n1 |  ... ient, uint funds) public {         address payable agency = address(0x333);         agency.transfer(funds);   ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example21 {\n    function remitSalaries(address employee, uint salary) public {\n        address payable worker = address(0x444);\n        worker.transfer(salary);\n    }\n\n    function squareNumber(uint num) public pure returns (uint) {\n        return num * num;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/51.sol:1:121:\n  |\n1 |  ... yee, uint salary) public {         address payable worker = address(0x444);         worker.transfer(salary);  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example12 {\n    function sendTokens(address recipient, uint256 amount) public {\n        address payable dest = payable(address(0xAAA));\n        dest.transfer(amount);\n    }\n\n    function computeInterest(uint principal, uint rate, uint time) public pure returns (uint) {\n        return principal * rate * time / 100;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example13 {\n    function distributeRewards(address addr, uint rewards) public {\n        address payable account = payable(address(0xBBB));\n        account.transfer(rewards);\n    }\n\n    function getSum(uint[] memory data) public pure returns (uint) {\n        uint sum = 0;\n        for (uint i = 0; i < data.length; i++) {\n            sum += data[i];\n        }\n        return sum;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example14 {\n    function makePayment(address to, uint256 sum) public {\n        address payable payAddress = payable(address(0xCCC));\n        payAddress.transfer(sum);\n    }\n\n    function doubleValue(uint value) public pure returns (uint) {\n        return value * 2;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example15 {\n    function dispatchFunds(address entity, uint quantity) public {\n        address payable wallet = payable(address(0xDDD));\n        wallet.transfer(quantity);\n    }\n\n    function countParticipants(uint[] memory participants) public pure returns (uint) {\n        return participants.length;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example16 {\n    function grantAccess(address user, uint funds) public {\n        address payable account = payable(address(0xEEE));\n        account.transfer(funds);\n    }\n\n    function incrementCount(uint count) public pure returns (uint) {\n        return count + 1;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example17 {\n    function releaseFunds(address receiver, uint payment) public {\n        address payable payee = payable(address(0xFFF));\n        payee.transfer(payment);\n    }\n\n    function calculateDiscount(uint price, uint discountRate) public pure returns (uint) {\n        return price * discountRate / 100;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example18 {\n    function transferAssets(address client, uint cash) public {\n        address payable holder = payable(address(0x111));\n        holder.transfer(cash);\n    }\n\n    function getBalance() public pure returns (uint) {\n        return 1500;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example19 {\n    function moveCapital(address user, uint amount) public {\n        address payable recipient = payable(address(0x222));\n        recipient.transfer(amount);\n    }\n\n    function min(uint a, uint b) public pure returns (uint) {\n        return a < b ? a : b;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example20 {\n    function allocateGrant(address recipient, uint funds) public {\n        address payable agency = payable(address(0x333));\n        agency.transfer(funds);\n    }\n\n    function max(uint a, uint b) public pure returns (uint) {\n        return a > b ? a : b;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example21 {\n    function remitSalaries(address employee, uint salary) public {\n        address payable worker = payable(address(0x444));\n        worker.transfer(salary);\n    }\n\n    function squareNumber(uint num) public pure returns (uint) {\n        return num * num;\n    }\n}"
      }
    }
  },
  {
    "Changes64": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/types.html#address-literals\"><span class=\"std std-ref\">Address literals</a> have the type <code>address</code> instead of <code>address\npayable</code>. They can be converted to <code>address payable</code> by using an explicit conversion, e.g.\n<code>payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract TransactionManager {\n    address payable public transactionAddress;\n    constructor() {\n        transactionAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/52.sol:1:150:\n  |\n1 |  ... r() {         transactionAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetTracker {\n    address payable public assetOwner;\n    constructor() {\n        assetOwner = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/53.sol:1:128:\n  |\n1 |  ... nstructor() {         assetOwner = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueStream {\n    address payable public revenueAddress;\n    constructor() {\n        revenueAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function helperFunction() public pure returns (string memory) { return \"Helper\"; }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/54.sol:1:137:\n  |\n1 |  ... uctor() {         revenueAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function helperFunction ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantDistributor {\n    address payable public grantee;\n    constructor() {\n        grantee = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function utilityFunction() internal {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/55.sol:1:126:\n  |\n1 |  ...  constructor() {         grantee = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function utilityFunctio ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract LoyaltyProgram {\n    address payable public participant;\n    constructor() {\n        participant = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function somethingUseless() private {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/56.sol:1:132:\n  |\n1 |  ... structor() {         participant = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function somethingUsele ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ScholarshipFund {\n    address payable public fundManager;\n    constructor() {\n        fundManager = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function extraFunction() external pure {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/57.sol:1:133:\n  |\n1 |  ... structor() {         fundManager = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract MembershipClub {\n    address payable public memberAccount;\n    constructor() {\n        memberAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function randomFunction() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/58.sol:1:136:\n  |\n1 |  ... ructor() {         memberAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function randomFunction ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract VendorContract {\n    address payable public vendor;\n    constructor() {\n        vendor = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function unnecessaryFunction() public pure {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/59.sol:1:122:\n  |\n1 |  ...   constructor() {         vendor = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function unnecessaryFun ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract TalentManagement {\n    address payable public talentAccount;\n    constructor() {\n        talentAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/60.sol:1:138:\n  |\n1 |  ... ructor() {         talentAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract AdvertisingCampaign {\n    address payable public advertiser;\n    constructor() {\n        advertiser = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function additionalMethod() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/61.sol:1:135:\n  |\n1 |  ... nstructor() {         advertiser = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function additionalMeth ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract TransactionManager {\n    address payable public transactionAddress;\n    constructor() {\n        transactionAddress = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract AssetTracker {\n    address payable public assetOwner;\n    constructor() {\n        assetOwner = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract RevenueStream {\n    address payable public revenueAddress;\n    constructor() {\n        revenueAddress = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function helperFunction() public pure returns (string memory) { return \"Helper\"; }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract GrantDistributor {\n    address payable public grantee;\n    constructor() {\n        grantee = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function utilityFunction() internal {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract LoyaltyProgram {\n    address payable public participant;\n    constructor() {\n        participant = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function somethingUseless() private {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ScholarshipFund {\n    address payable public fundManager;\n    constructor() {\n        fundManager = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function extraFunction() external pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract MembershipClub {\n    address payable public memberAccount;\n    constructor() {\n        memberAccount = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function randomFunction() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract VendorContract {\n    address payable public vendor;\n    constructor() {\n        vendor = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function unnecessaryFunction() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract TalentManagement {\n    address payable public talentAccount;\n    constructor() {\n        talentAccount = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract AdvertisingCampaign {\n    address payable public advertiser;\n    constructor() {\n        advertiser = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function additionalMethod() public {}\n}"
      }
    }
  },
  {
    "Changes65": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>address(uint)</code> and <code>uint(address)</code>: converting both type-category and width. Replace this by\n<code>address(uint160(uint))</code> and <code>uint(uint160(address))</code> respectively.Add intermediate explicit type conversions if required.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Encode {\n    function encodeUintToAddress(uint h) public pure returns (address) {\n        return address(h);\n    }\n    function helperFunction() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/62.sol:1:130:\n  |\n1 |  ... returns (address) {         return address(h);     }     function helperFunction ...\n  |                                         ^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Cast {\n    function castAddressToUint(address i) public pure returns (uint) {\n        return uint(i);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/63.sol:1:126:\n  |\n1 | pragma solidity^0.8.0; contract Cast {     function castAddressToUint(address i) public pure returns (uint) {         return uint(i);     } }\n  |                                                                                                                              ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Translate {\n    function translateUintToAddress(uint j) public pure returns (address) {\n        return address(j);\n    }\n    function anotherHelper() public pure returns (int) {\n        return 42;\n    }\n    function anotherOne() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/64.sol:1:136:\n  |\n1 |  ... returns (address) {         return address(j);     }     function anotherHelper( ...\n  |                                         ^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Reformat {\n    function reformatAddressToUint(address k) public pure returns (uint) {\n        return uint(k);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/65.sol:1:134:\n  |\n1 | pragma solidity^0.8.0; contract Reformat {     function reformatAddressToUint(address k) public pure returns (uint) {         return uint(k);     } }\n  |                                                                                                                                      ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Replicate {\n    function replicateUintToAddress(uint l) public pure returns (address) {\n        return address(l);\n    }\n    function irrelevant() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/66.sol:1:136:\n  |\n1 |  ... returns (address) {         return address(l);     }     function irrelevant() p ...\n  |                                         ^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ConvertX {\n    function convertXAddressToUint(address m) public pure returns (uint) {\n        return uint(m);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/67.sol:1:134:\n  |\n1 | pragma solidity^0.8.0; contract ConvertX {     function convertXAddressToUint(address m) public pure returns (uint) {         return uint(m);     } }\n  |                                                                                                                                      ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Morph {\n    function morphUintToAddress(uint n) public pure returns (address) {\n        return address(n);\n    }\n    function unused() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/68.sol:1:128:\n  |\n1 |  ... returns (address) {         return address(n);     }     function unused() publi ...\n  |                                         ^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Transition {\n    function transitionAddressToUint(address o) public pure returns (uint) {\n        return uint(o);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/69.sol:1:138:\n  |\n1 |  ... re returns (uint) {         return uint(o);     } }\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ShiftX {\n    function shiftXUintToAddress(uint p) public pure returns (address) {\n        return address(p);\n    }\n    function extraOne() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/70.sol:1:130:\n  |\n1 |  ... returns (address) {         return address(p);     }     function extraOne() pub ...\n  |                                         ^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Permute {\n    function permuteAddressToUint(address q) public pure returns (uint) {\n        return uint(q);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/71.sol:1:132:\n  |\n1 | pragma solidity^0.8.0; contract Permute {     function permuteAddressToUint(address q) public pure returns (uint) {         return uint(q);     } }\n  |                                                                                                                                    ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Encode {\n    function encodeUintToAddress(uint h) public pure returns (address) {\n        return address(uint160(h));\n    }\n    function helperFunction() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Cast {\n    function castAddressToUint(address i) public pure returns (uint) {\n        return uint(uint160(i));\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Translate {\n    function translateUintToAddress(uint j) public pure returns (address) {\n        return address(uint160(j));\n    }\n    function anotherHelper() public pure returns (int) {\n        return 42;\n    }\n    function anotherOne() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Reformat {\n    function reformatAddressToUint(address k) public pure returns (uint) {\n        return uint(uint160(k));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Replicate {\n    function replicateUintToAddress(uint l) public pure returns (address) {\n        return address(uint160(l));\n    }\n    function irrelevant() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ConvertX {\n    function convertXAddressToUint(address m) public pure returns (uint) {\n        return uint(uint160(m));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Morph {\n    function morphUintToAddress(uint n) public pure returns (address) {\n        return address(uint160(n));\n    }\n    function unused() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Transition {\n    function transitionAddressToUint(address o) public pure returns (uint) {\n        return uint(uint160(o));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ShiftX {\n    function shiftXUintToAddress(uint p) public pure returns (address) {\n        return address(uint160(p));\n    }\n    function extraOne() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Permute {\n    function permuteAddressToUint(address q) public pure returns (uint) {\n        return uint(uint160(q));\n    }\n}"
      }
    }
  },
  {
    "Changes66": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>payable(uint160)</code>, <code>payable(bytes20)</code> and <code>payable(integer-literal)</code>: converting both\ntype-category and state-mutability. Replace this by <code>payable(address(uint160))</code>,\n<code>payable(address(bytes20))</code> and <code>payable(address(integer-literal))</code> respectively. Note that\n<code>payable(0)</code> is valid and is an exception to the rule.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetManager {\n    function modifyAsset(uint160 assetId) public pure returns (address payable) {\n        return payable(assetId);\n    }\n    function countItems() public pure returns (uint) {\n        return 150;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/72.sol:1:145:\n  |\n1 |  ... (address payable) {         return payable(assetId);     }     function countItems() p ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract TokenDistributor {\n    function distributeToken(uint160 tokenId) public pure returns (address payable) {\n        return payable(tokenId);\n    }\n    function extraCheck() public pure returns (bool) {\n        return false;\n    }\n    function getVersion() public pure returns (string memory) {\n        return \"1.0\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/73.sol:1:153:\n  |\n1 |  ... (address payable) {         return payable(tokenId);     }     function extraCheck() p ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract BudgetController {\n    function controlBudget(uint160 budget) public pure returns (address payable) {\n        return payable(budget);\n    }\n    function isActiveUser() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/74.sol:1:150:\n  |\n1 |  ... (address payable) {         return payable(budget);     }     function isActiveUser() ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract CashFlowManager {\n    function manageCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(cashFlow);\n    }\n    function getBalance() public pure returns (uint256) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/75.sol:1:152:\n  |\n1 |  ... (address payable) {         return payable(cashFlow);     }     function getBalance() p ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ExpenseTracker {\n    function trackExpense(uint160 expense) public pure returns (address payable) {\n        return payable(expense);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/76.sol:1:148:\n  |\n1 |  ... (address payable) {         return payable(expense);     } }\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    function processPayment(uint160 paymentAmount) public pure returns (address payable) {\n        return payable(paymentAmount);\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/77.sol:1:158:\n  |\n1 |  ... (address payable) {         return payable(paymentAmount);     }     function extraData() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract FundManager {\n    function manageFund(uint160 fundAmount) public pure returns (address payable) {\n        return payable(fundAmount);\n    }\n    function logEvent() public pure returns (string memory) {\n        return \"Event logged\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/78.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(fundAmount);     }     function logEvent() pub ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueHandler {\n    function handleRevenue(uint160 revenue) public pure returns (address payable) {\n        return payable(revenue);\n    }\n    function checkStatus() public pure returns (bool) {\n        return true;\n    }\n    function extraFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/79.sol:1:149:\n  |\n1 |  ... (address payable) {         return payable(revenue);     }     function checkStatus()  ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceHandler {\n    function handleResource(uint160 resourceAmount) public pure returns (address payable) {\n        return payable(resourceAmount);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/80.sol:1:158:\n  |\n1 |  ... (address payable) {         return payable(resourceAmount);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentRedirector {\n    function redirectPayment(uint160 payment) public pure returns (address payable) {\n        return payable(payment);\n    }\n    function checkValidity() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/81.sol:1:154:\n  |\n1 |  ... (address payable) {         return payable(payment);     }     function checkValidity( ...\n  |                                         ^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract AssetManager {\n    function modifyAsset(uint160 assetId) public pure returns (address payable) {\n        return payable(address(assetId));\n    }\n    function countItems() public pure returns (uint) {\n        return 150;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract TokenDistributor {\n    function distributeToken(uint160 tokenId) public pure returns (address payable) {\n        return payable(address(tokenId));\n    }\n    function extraCheck() public pure returns (bool) {\n        return false;\n    }\n    function getVersion() public pure returns (string memory) {\n        return \"1.0\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract BudgetController {\n    function controlBudget(uint160 budget) public pure returns (address payable) {\n        return payable(address(budget));\n    }\n    function isActiveUser() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract CashFlowManager {\n    function manageCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(address(cashFlow));\n    }\n    function getBalance() public pure returns (uint256) {\n        return 999;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ExpenseTracker {\n    function trackExpense(uint160 expense) public pure returns (address payable) {\n        return payable(address(expense));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    function processPayment(uint160 paymentAmount) public pure returns (address payable) {\n        return payable(address(paymentAmount));\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract FundManager {\n    function manageFund(uint160 fundAmount) public pure returns (address payable) {\n        return payable(address(fundAmount));\n    }\n    function logEvent() public pure returns (string memory) {\n        return \"Event logged\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract RevenueHandler {\n    function handleRevenue(uint160 revenue) public pure returns (address payable) {\n        return payable(address(revenue));\n    }\n    function checkStatus() public pure returns (bool) {\n        return true;\n    }\n    function extraFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ResourceHandler {\n    function handleResource(uint160 resourceAmount) public pure returns (address payable) {\n        return payable(address(resourceAmount));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract PaymentRedirector {\n    function redirectPayment(uint160 payment) public pure returns (address payable) {\n        return payable(address(payment));\n    }\n    function checkValidity() public pure returns (bool) {\n        return false;\n    }\n}"
      }
    }
  },
  {
    "Changes67": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>int80(bytes10)</code> and <code>bytes10(int80)</code>: converting both type-category and sign. Replace this by\n<code>int80(uint80(bytes10))</code> and <code>bytes10(uint80(int80)</code> respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterAlpha {\n    function alphaConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function randomValue() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/82.sol:1:136:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function randomValue()  ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract DataProcessor {\n    function processData(int80 data) public pure returns (bytes10) {\n        return bytes10(data);\n    }\n    function generateValue() public pure returns (uint) {\n        return 300;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/83.sol:1:133:\n  |\n1 |  ... returns (bytes10) {         return bytes10(data);     }     function generateValue( ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract TypeChanger {\n    function changeType(bytes10 arg) public pure returns (int80) {\n        return int80(arg);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/84.sol:1:129:\n  |\n1 | pragma solidity^0.8.0; contract TypeChanger {     function changeType(bytes10 arg) public pure returns (int80) {         return int80(arg);     } }\n  |                                                                                                                                 ^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract QuickTransform {\n    function fastConvert(int80 arg) public pure returns (bytes10) {\n        return bytes10(arg);\n    }\n    function helperFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/85.sol:1:133:\n  |\n1 |  ... returns (bytes10) {         return bytes10(arg);     }     function helperFunction ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ByteToInteger {\n    function byteToInt(bytes10 byteArg) public pure returns (int80) {\n        return int80(byteArg);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/86.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(byteArg);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IntegerToByte {\n    function intToByte(int80 intArg) public pure returns (bytes10) {\n        return bytes10(intArg);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/87.sol:1:133:\n  |\n1 |  ... returns (bytes10) {         return bytes10(intArg);     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ConvertSimple {\n    function convertBytes(bytes10 simpleArg) public pure returns (int80) {\n        return int80(simpleArg);\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/88.sol:1:139:\n  |\n1 |  ... e returns (int80) {         return int80(simpleArg);     }     function extraMethod()  ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract BasicConverter {\n    function simpleByteToInt(bytes10 simpleByte) public pure returns (int80) {\n        return int80(simpleByte);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/89.sol:1:144:\n  |\n1 |  ... e returns (int80) {         return int80(simpleByte);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Encoder {\n    function encodeInput(bytes10 encodedData) public pure returns (int80) {\n        return int80(encodedData);\n    }\n    function dummyFunction() public pure returns (int) {\n        return 555;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/90.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(encodedData);     }     function dummyFunction( ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Decoder {\n    function decodeOutput(int80 decodedData) public pure returns (bytes10) {\n        return bytes10(decodedData);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/91.sol:1:135:\n  |\n1 |  ... returns (bytes10) {         return bytes10(decodedData);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ConverterAlpha {\n    function alphaConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function randomValue() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract DataProcessor {\n    function processData(int80 data) public pure returns (bytes10) {\n        return bytes10(uint80(data));\n    }\n    function generateValue() public pure returns (uint) {\n        return 300;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract TypeChanger {\n    function changeType(bytes10 arg) public pure returns (int80) {\n        return int80(uint80(arg));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract QuickTransform {\n    function fastConvert(int80 arg) public pure returns (bytes10) {\n        return bytes10(uint80(arg));\n    }\n    function helperFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ByteToInteger {\n    function byteToInt(bytes10 byteArg) public pure returns (int80) {\n        return int80(uint80(byteArg));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IntegerToByte {\n    function intToByte(int80 intArg) public pure returns (bytes10) {\n        return bytes10(uint80(intArg));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ConvertSimple {\n    function convertBytes(bytes10 simpleArg) public pure returns (int80) {\n        return int80(uint80(simpleArg));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract BasicConverter {\n    function simpleByteToInt(bytes10 simpleByte) public pure returns (int80) {\n        return int80(uint80(simpleByte));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Encoder {\n    function encodeInput(bytes10 encodedData) public pure returns (int80) {\n        return int80(uint80(encodedData));\n    }\n    function dummyFunction() public pure returns (int) {\n        return 555;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Decoder {\n    function decodeOutput(int80 decodedData) public pure returns (bytes10) {\n        return bytes10(uint80(decodedData));\n    }\n}"
      }
    }
  },
  {
    "Changes68": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>Contract(uint)</code>: converting both type-category and width. Replace this by\n<code>Contract(address(uint160(uint)))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractA {\n    function adjust(uint input) public pure returns (address) {\n        address addr = address(input);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/92.sol:1:132:\n  |\n1 |  ... (address) {         address addr = address(input);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractB {\n    function generate(uint num) public pure returns (address) {\n        address output = address(num);\n        return output;\n    }\n    function unrelatedFunction1() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/93.sol:1:134:\n  |\n1 |  ... ddress) {         address output = address(num);         return output;     }      ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractC {\n    function deliver(uint data) public pure returns (address) {\n        address result = address(data);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/94.sol:1:134:\n  |\n1 |  ... ddress) {         address result = address(data);         return result;     } }\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractD {\n    function resolve(uint input) public pure returns (address) {\n        address addressVar = address(input);\n        return addressVar;\n    }\n    function unrelatedFunction2() public pure {}\n    function unrelatedFunction3() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/95.sol:1:139:\n  |\n1 |  ... ss) {         address addressVar = address(input);         return addressVar;     }  ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractE {\n    function derive(uint value) public pure returns (address) {\n        address addr = address(value);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/96.sol:1:132:\n  |\n1 |  ... (address) {         address addr = address(value);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractF {\n    function translate(uint amount) public pure returns (address) {\n        address addr = address(amount);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/97.sol:1:136:\n  |\n1 |  ... (address) {         address addr = address(amount);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractG {\n    function modify(uint num) public pure returns (address) {\n        address output = address(num);\n        return output;\n    }\n    function unrelatedFunction4() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/98.sol:1:132:\n  |\n1 |  ... ddress) {         address output = address(num);         return output;     }      ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractH {\n    function convert(uint quantity) public pure returns (address) {\n        address converted = address(quantity);\n        return converted;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/99.sol:1:141:\n  |\n1 |  ... ess) {         address converted = address(quantity);         return converted;     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractI {\n    function transform(uint number) public pure returns (address) {\n        address transformed = address(number);\n        return transformed;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/100.sol:1:143:\n  |\n1 |  ... s) {         address transformed = address(number);         return transformed;     } ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractJ {\n    function alter(uint parameter) public pure returns (address) {\n        address changed = address(parameter);\n        return changed;\n    }\n    function unrelatedFunction5() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/101.sol:1:138:\n  |\n1 |  ... dress) {         address changed = address(parameter);         return changed;     }     ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractA {\n    function adjust(uint input) public pure returns (address) {\n        address addr = address(uint160(input));\n        return addr;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractB {\n    function generate(uint num) public pure returns (address) {\n        address output = address(uint160(num));\n        return output;\n    }\n    function unrelatedFunction1() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractC {\n    function deliver(uint data) public pure returns (address) {\n        address result = address(uint160(data));\n        return result;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractD {\n    function resolve(uint input) public pure returns (address) {\n        address addressVar = address(uint160(input));\n        return addressVar;\n    }\n    function unrelatedFunction2() public pure {}\n    function unrelatedFunction3() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractE {\n    function derive(uint value) public pure returns (address) {\n        address addr = address(uint160(value));\n        return addr;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractF {\n    function translate(uint amount) public pure returns (address) {\n        address addr = address(uint160(amount));\n        return addr;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractG {\n    function modify(uint num) public pure returns (address) {\n        address output = address(uint160(num));\n        return output;\n    }\n    function unrelatedFunction4() public pure {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractH {\n    function convert(uint quantity) public pure returns (address) {\n        address converted = address(uint160(quantity));\n        return converted;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractI {\n    function transform(uint number) public pure returns (address) {\n        address transformed = address(uint160(number));\n        return transformed;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractJ {\n    function alter(uint parameter) public pure returns (address) {\n        address changed = address(uint160(parameter));\n        return changed;\n    }\n    function unrelatedFunction5() public pure {}\n}"
      }
    }
  },
  {
    "Changes69": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Function call options can only be given once, i.e. <code>c.f{gas: 10000}{value: 1}()</code> is invalid and has to be changed to <code>c.f{gas: 10000, value: 1}()</code>.Combine <code>c.f{gas: 10000}{value: 1}()</code> to <code>c.f{gas: 10000, value: 1}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ExpenseTracker {\n    address payable public accountant;\n    function recordExpense() public {\n        accountant.call{gas: 3000}{value: 3 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/102.sol:1:135:\n  |\n1 |  ... n recordExpense() public {         accountant.call{gas: 3000}{value: 3 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract CharityFund {\n    address payable public donor;\n    function donate() public {\n        donor.call{gas: 4000}{value: 2 ether}(\"\");\n    }\n    function reportDonation() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/103.sol:1:120:\n  |\n1 |  ... function donate() public {         donor.call{gas: 4000}{value: 2 ether}(\"\");     }     function reportDona ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract PurchaseOrder {\n    address payable public supplier;\n    function orderItems() public {\n        supplier.call{gas: 2000}{value: 5 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/104.sol:1:129:\n  |\n1 |  ... tion orderItems() public {         supplier.call{gas: 2000}{value: 5 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract CashFlowManagement {\n    address payable public cashier;\n    function manageCashFlow() public {\n        cashier.call{gas: 5000}{value: 1 ether}(\"\");\n    }\n    function liquidityStatus() public pure returns (string memory) {\n        return \"Stable\";\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/105.sol:1:137:\n  |\n1 |  ...  manageCashFlow() public {         cashier.call{gas: 5000}{value: 1 ether}(\"\");     }     function liquidityS ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract FundingCampaign {\n    address payable public campaignTreasurer;\n    function startCampaign() public {\n        campaignTreasurer.call{gas: 4500}{value: 4 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/106.sol:1:143:\n  |\n1 |  ... n startCampaign() public {         campaignTreasurer.call{gas: 4500}{value: 4 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueService {\n    address payable public taxCollector;\n    function collectTax() public {\n        taxCollector.call{gas: 6000}{value: 2 ether}(\"\");\n    }\n    function revenueReport() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/107.sol:1:134:\n  |\n1 |  ... tion collectTax() public {         taxCollector.call{gas: 6000}{value: 2 ether}(\"\");     }     function revenueRep ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract SalaryDisbursement {\n    address payable public payroll;\n    function disburseSalary() public {\n        payroll.call{gas: 3500}{value: 3 ether}(\"\");\n    }\n    function updatePayroll() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/108.sol:1:137:\n  |\n1 |  ...  disburseSalary() public {         payroll.call{gas: 3500}{value: 3 ether}(\"\");     }     function updatePayr ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract EventOrganizer {\n    address payable public organizer;\n    function organizeEvent() public {\n        organizer.call{gas: 2500}{value: 1 ether}(\"\");\n    }\n    function eventSummary() public pure returns (string memory) {\n        return \"Event Successful\";\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/109.sol:1:134:\n  |\n1 |  ... n organizeEvent() public {         organizer.call{gas: 2500}{value: 1 ether}(\"\");     }     function eventSumma ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract InvestmentPool {\n    address payable public investor;\n    function poolFunds() public {\n        investor.call{gas: 7000}{value: 2 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/110.sol:1:129:\n  |\n1 |  ... ction poolFunds() public {         investor.call{gas: 7000}{value: 2 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract BudgetControl {\n    address payable public controller;\n    function controlBudget() public {\n        controller.call{gas: 8000}{value: 1 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/111.sol:1:134:\n  |\n1 |  ... n controlBudget() public {         controller.call{gas: 8000}{value: 1 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ExpenseTracker {\n    address payable public accountant;\n    function recordExpense() public {\n        accountant.call{gas: 3000, value: 3 ether}(\"\");\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract CharityFund {\n    address payable public donor;\n    function donate() public {\n        donor.call{gas: 4000, value: 2 ether}(\"\");\n    }\n    function reportDonation() public {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract PurchaseOrder {\n    address payable public supplier;\n    function orderItems() public {\n        supplier.call{gas: 2000, value: 5 ether}(\"\");\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract CashFlowManagement {\n    address payable public cashier;\n    function manageCashFlow() public {\n        cashier.call{gas: 5000, value: 1 ether}(\"\");\n    }\n    function liquidityStatus() public pure returns (string memory) {\n        return \"Stable\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract FundingCampaign {\n    address payable public campaignTreasurer;\n    function startCampaign() public {\n        campaignTreasurer.call{gas: 4500, value: 4 ether}(\"\");\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract RevenueService {\n    address payable public taxCollector;\n    function collectTax() public {\n        taxCollector.call{gas: 6000, value: 2 ether}(\"\");\n    }\n    function revenueReport() public {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract SalaryDisbursement {\n    address payable public payroll;\n    function disburseSalary() public {\n        payroll.call{gas: 3500, value: 3 ether}(\"\");\n    }\n    function updatePayroll() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract EventOrganizer {\n    address payable public organizer;\n    function organizeEvent() public {\n        organizer.call{gas: 2500, value: 1 ether}(\"\");\n    }\n    function eventSummary() public pure returns (string memory) {\n        return \"Event Successful\";\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract InvestmentPool {\n    address payable public investor;\n    function poolFunds() public {\n        investor.call{gas: 7000, value: 2 ether}(\"\");\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract BudgetControl {\n    address payable public controller;\n    function controlBudget() public {\n        controller.call{gas: 8000, value: 1 ether}(\"\");\n    }\n}"
      }
    }
  },
  {
    "Changes70": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The global functions <code>log0</code>, <code>log1</code>, <code>log2</code>, <code>log3</code> and <code>log4</code> have been removed.Use inline assembly as a replacement for <code>log0</code>, \u2026, <code>log4</code>.13.These are low-level functions that were largely unused. Their behavior can be accessed from inline assembly.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract AlertLogger {\n    function alertData(uint256 alertInfo) public {\n        bytes memory alertBytes = abi.encodePacked(alertInfo);\n        assembly {\n            log0(alertBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/112.sol:1:192:\n  |\n1 |  ... o);         assembly {             log0(alertBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract EventTracker {\n    function trackEvent(int256 eventValue) public {\n        bytes memory eventData = abi.encodePacked(eventValue);\n        assembly {\n            log3(eventData, eventValue, eventValue, eventValue)\n        }\n    }\n    function extraMethod() public pure returns (uint) { return 5; }\n}",
          "error message": "Error: Function expects 5 arguments but got 4.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/113.sol:1:194:\n  |\n1 |  ... e);         assembly {             log3(eventData, eventValue, eventValue, ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentLogger {\n    function logPayment(bytes32 paymentData) public {\n        assembly {\n            log4(paymentData, paymentData, paymentData, paymentData, paymentData)\n        }\n    }\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/114.sol:1:134:\n  |\n1 |  ... c {         assembly {             log4(paymentData, paymentData, paymentD ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract UsageLogger {\n    function logUsage(uint256 usage) public {\n        bytes memory usageBytes = abi.encodePacked(usage);\n        assembly {\n            log2(usageBytes, usage, usage)\n        }\n    }\n    function helperMethod() public pure {}\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/115.sol:1:183:\n  |\n1 |  ... e);         assembly {             log2(usageBytes, usage, usage)          ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract DetailTracker {\n    function trackDetail(uint256 detailAmount) public {\n        bytes memory detailBytes = abi.encodePacked(detailAmount);\n        assembly {\n            log1(detailBytes, detailAmount)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/116.sol:1:203:\n  |\n1 |  ... t);         assembly {             log1(detailBytes, detailAmount)         ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ProcessLogger {\n    function logProcess(uint256 processId) public {\n        bytes memory processBytes = abi.encodePacked(processId);\n        assembly {\n            log2(processBytes, processId, processId)\n        }\n    }\n    function unusedMethod() public pure {}\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/117.sol:1:197:\n  |\n1 |  ... d);         assembly {             log2(processBytes, processId, processId ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract FeedbackLogger {\n    function logFeedback(string memory feedback) public {\n        bytes memory feedbackBytes = bytes(feedback);\n        assembly {\n            log0(feedbackBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/118.sol:1:193:\n  |\n1 |  ... k);         assembly {             log0(feedbackBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract UpdateLogger {\n    function logUpdate(uint256 updateId) public {\n        bytes memory updateBytes = abi.encodePacked(updateId);\n        assembly {\n            log4(updateBytes, updateId, updateId, updateId, updateId)\n        }\n    }\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/119.sol:1:192:\n  |\n1 |  ... d);         assembly {             log4(updateBytes, updateId, updateId, u ...\n  |                                         ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueRecorder {\n    function recordValue(uint256 value) public {\n        bytes memory valueBytes = abi.encodePacked(value);\n        assembly {\n            log1(valueBytes, value)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/120.sol:1:188:\n  |\n1 |  ... e);         assembly {             log1(valueBytes, value)         }     } ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract NotificationLogger {\n    function logNotification(string memory notification) public {\n        bytes memory notificationBytes = bytes(notification);\n        assembly {\n            log2(notificationBytes, notificationBytes, notificationBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/121.sol:1:213:\n  |\n1 |  ... n);         assembly {             log2(notificationBytes, notificationByt ...\n  |                                         ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract AlertLogger {\n    event Alert(uint256 alertInfo);\n    function alertData(uint256 alertInfo) public {\n        emit Alert(alertInfo);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract EventTracker {\n    event TrackEvent(int256 eventValue);\n    function trackEvent(int256 eventValue) public {\n        emit TrackEvent(eventValue);\n    }\n    function extraMethod() public pure returns (uint) { return 5; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract PaymentLogger {\n    event Payment(bytes32 paymentData);\n    function logPayment(bytes32 paymentData) public {\n        emit Payment(paymentData);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract UsageLogger {\n    event Usage(uint256 usage);\n    function logUsage(uint256 usage) public {\n        emit Usage(usage);\n    }\n    function helperMethod() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract DetailTracker {\n    event Detail(uint256 detailAmount);\n    function trackDetail(uint256 detailAmount) public {\n        emit Detail(detailAmount);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ProcessLogger {\n    event Process(uint256 processId);\n    function logProcess(uint256 processId) public {\n        emit Process(processId);\n    }\n    function unusedMethod() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract FeedbackLogger {\n    event Feedback(string feedback);\n    function logFeedback(string memory feedback) public {\n        emit Feedback(feedback);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract UpdateLogger {\n    event Update(uint256 updateId);\n    function logUpdate(uint256 updateId) public {\n        emit Update(updateId);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ValueRecorder {\n    event Value(uint256 value);\n    function recordValue(uint256 value) public {\n        emit Value(value);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract NotificationLogger {\n    event Notification(string notification);\n    function logNotification(string memory notification) public {\n        emit Notification(notification);\n    }\n}"
      }
    }
  },
  {
    "Changes71": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Declarations with the name <code>this</code>, <code>super</code> and <code>_</code> are disallowed, with the exception of\npublic functions and events. The exception is to make it possible to declare interfaces of contracts\nimplemented in languages other than Solidity that do permit such function names.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractA {\n    uint256 public super;\n\n    function modifySuper(uint256 _value) public {\n        super = _value;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/122.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractA {     uint256 public super;      function modifySuper(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractB {\n    uint256 public this;\n\n    function updateThis(uint256 _value) public {\n        this = _value;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/123.sol:1:50:\n  |\n1 | pragma solidity^0.8.0;  contract ContractB {     uint256 public this;      function updateThis(uint256 _value) public {         this = _value;     } }\n  |                                                  ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractC {\n    bool public _;\n\n    function toggle_() public {\n        _ = !_;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/124.sol:1:50:\n  |\n1 | pragma solidity^0.8.0;  contract ContractC {     bool public _;      function toggle_() public {         _ = !_;     } }\n  |                                                  ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractD {\n    int256 public super;\n\n    function adjustSuper(int256 _value) public {\n        super = _value;\n    }\n\n    function extraMethod() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/125.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractD {     int256 public super;      function adjustSuper(int256  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractE {\n    string public this;\n\n    function setThis(string calldata _value) public {\n        this = _value;\n    }\n\n    function dummy() public pure returns (uint) {\n        return 1;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/126.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractE {     string public this;      function setThis(string call ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractF {\n    address public _;\n\n    function setAddress(address _address) public {\n        _ = _address;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/127.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractF {     address public _;      function setAddress(address  ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractG {\n    bytes32 public super;\n\n    function putSuper(bytes32 _value) public {\n        super = _value;\n    }\n\n    function anotherFunction() public pure returns (bytes32) {\n        return \"Sample\";\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/128.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractG {     bytes32 public super;      function putSuper(bytes32 _v ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractH {\n    uint256 public this;\n\n    function refreshThis(uint256 _value) public {\n        this = _value;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/129.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractH {     uint256 public this;      function refreshThis(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractI {\n    int public _;\n\n    function increment_() public {\n        _ += 1;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/130.sol:1:50:\n  |\n1 | pragma solidity^0.8.0;  contract ContractI {     int public _;      function increment_() public {         _ += 1;     } }\n  |                                                  ^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractJ {\n    bool public this;\n\n    function switchThis() public {\n        this = !this;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/131.sol:1:50:\n  |\n1 | pragma solidity^0.8.0;  contract ContractJ {     bool public this;      function switchThis() public {         this = !this;     } }\n  |                                                  ^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractA {\n    uint256 public value;\n\n    function modifyValue(uint256 _value) public {\n        value = _value;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractB {\n    uint256 public variable;\n\n    function updateVariable(uint256 _value) public {\n        variable = _value;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractC {\n    bool public state;\n\n    function toggleState() public {\n        state = !state;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractD {\n    int256 public value;\n\n    function adjustValue(int256 _value) public {\n        value = _value;\n    }\n\n    function extraMethod() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractE {\n    string public variable;\n\n    function setVariable(string calldata _value) public {\n        variable = _value;\n    }\n\n    function dummy() public pure returns (uint) {\n        return 1;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractF {\n    address public addressVariable;\n\n    function setAddressVariable(address _address) public {\n        addressVariable = _address;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractG {\n    bytes32 public value;\n\n    function putValue(bytes32 _value) public {\n        value = _value;\n    }\n\n    function anotherFunction() public pure returns (bytes32) {\n        return \"Sample\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractH {\n    uint256 public variable;\n\n    function refreshVariable(uint256 _value) public {\n        variable = _value;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractI {\n    int public value;\n\n    function incrementValue() public {\n        value += 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractJ {\n    bool public state;\n\n    function switchState() public {\n        state = !state;\n    }\n}"
      }
    }
  },
  {
    "Changes72": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Remove support for the <code>b</code>, <code>f</code>, and <code>v</code> escape sequences in code.\nThey can still be inserted via hexadecimal escapes, e.g. <code>x08</code>, <code>x0c</code>, and <code>x0b</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorCharOne {\n    string public missingChar = \"Missing character: \\b\";\n    function retrieveMissingChar() public view returns (string memory) {\n        return missingChar;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/132.sol:1:80:\n  |\n1 |  ...  {     string public missingChar = \"Missing character: \\b\";     function retrieveMissingChar ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorCharTwo {\n    string public feedError = \"Feed error: \\f\";\n    function fetchFeedError() public view returns (string memory) {\n        return feedError;\n    }\n    function additional() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/133.sol:1:78:\n  |\n1 |  ... wo {     string public feedError = \"Feed error: \\f\";     function fetchFeedError() pu ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorCharThree {\n    string public tabError = \"Tab error: \\v\";\n    function getTabError() public view returns (string memory) {\n        return tabError;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/134.sol:1:79:\n  |\n1 |  ... ree {     string public tabError = \"Tab error: \\v\";     function getTabError() publi ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract DataError {\n    string public dataBreak = \"Data break: \\b\";\n    function getDataBreak() public view returns (string memory) {\n        return dataBreak;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/135.sol:1:75:\n  |\n1 |  ... or {     string public dataBreak = \"Data break: \\b\";     function getDataBreak() publ ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract InfoError {\n    string public verticalError = \"Vertical error: \\v\";\n    function getVerticalError() public view returns (string memory) {\n        return verticalError;\n    }\n    function extraMethod() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/136.sol:1:79:\n  |\n1 |  ...      string public verticalError = \"Vertical error: \\v\";     function getVerticalError()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract CharError {\n    string public characterIssue = \"Character issue: \\f\";\n    function getCharacterIssue() public view returns (string memory) {\n        return characterIssue;\n    }\n    function randomFunction() public pure returns (uint) {\n        return 321;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/137.sol:1:80:\n  |\n1 |  ...     string public characterIssue = \"Character issue: \\f\";     function getCharacterIssue() ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract SoundError {\n    string public soundIssue = \"Sound issue: \\b\";\n    function getSoundIssue() public view returns (string memory) {\n        return soundIssue;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/138.sol:1:77:\n  |\n1 |  ... r {     string public soundIssue = \"Sound issue: \\b\";     function getSoundIssue() pub ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract TabIssue {\n    string public tabulationIssue = \"Tabulation issue: \\v\";\n    function getTabulationIssue() public view returns (string memory) {\n        return tabulationIssue;\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 789;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/139.sol:1:80:\n  |\n1 |  ...    string public tabulationIssue = \"Tabulation issue: \\v\";     function getTabulationIssue( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract FeedError {\n    string public lineFeedError = \"Line feed error: \\f\";\n    function getLineFeedError() public view returns (string memory) {\n        return lineFeedError;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/140.sol:1:79:\n  |\n1 |  ...      string public lineFeedError = \"Line feed error: \\f\";     function getLineFeedError()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract VisualError {\n    string public visualError = \"Visual error: \\b\";\n    function getVisualError() public view returns (string memory) {\n        return visualError;\n    }\n    function additionalFeature() public pure returns (string memory) {\n        return \"Feature\";\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/141.sol:1:79:\n  |\n1 |  ...  {     string public visualError = \"Visual error: \\b\";     function getVisualError() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ErrorCharOne {\n    string public missingChar = \"Missing character: \\x08\";\n    function retrieveMissingChar() public view returns (string memory) {\n        return missingChar;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ErrorCharTwo {\n    string public feedError = \"Feed error: \\x0c\";\n    function fetchFeedError() public view returns (string memory) {\n        return feedError;\n    }\n    function additional() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ErrorCharThree {\n    string public tabError = \"Tab error: \\x0b\";\n    function getTabError() public view returns (string memory) {\n        return tabError;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract DataError {\n    string public dataBreak = \"Data break: \\x08\";\n    function getDataBreak() public view returns (string memory) {\n        return dataBreak;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract InfoError {\n    string public verticalError = \"Vertical error: \\x0b\";\n    function getVerticalError() public view returns (string memory) {\n        return verticalError;\n    }\n    function extraMethod() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract CharError {\n    string public characterIssue = \"Character issue: \\x0c\";\n    function getCharacterIssue() public view returns (string memory) {\n        return characterIssue;\n    }\n    function randomFunction() public pure returns (uint) {\n        return 321;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract SoundError {\n    string public soundIssue = \"Sound issue: \\x08\";\n    function getSoundIssue() public view returns (string memory) {\n        return soundIssue;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract TabIssue {\n    string public tabulationIssue = \"Tabulation issue: \\x0b\";\n    function getTabulationIssue() public view returns (string memory) {\n        return tabulationIssue;\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 789;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract FeedError {\n    string public lineFeedError = \"Line feed error: \\x0c\";\n    function getLineFeedError() public view returns (string memory) {\n        return lineFeedError;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract VisualError {\n    string public visualError = \"Visual error: \\x08\";\n    function getVisualError() public view returns (string memory) {\n        return visualError;\n    }\n    function additionalFeature() public pure returns (string memory) {\n        return \"Feature\";\n    }\n}"
      }
    }
  },
  {
    "Changes73": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The global variables <code>tx.origin</code> and <code>msg.sender</code> have the type <code>address</code> instead of\n<code>address payable</code>. One can convert them into <code>address payable</code> by using an explicit\nconversion, i.e., <code>payable(tx.origin)</code> or <code>payable(msg.sender)</code>.This change was done since the compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible.Change <code>msg.sender.transfer(x)</code> to <code>payable(msg.sender).transfer(x)</code> or use a stored variable of <code>address payable</code> type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentDispatcher {\n    function dispatchPayment() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/142.sol:1:109:\n  |\n1 | pragma solidity^0.8.0; contract PaymentDispatcher {     function dispatchPayment() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                             ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract FeeDistributor {\n    function distributeFee() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function extraFeature() public pure returns (int) { return 2024; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/143.sol:1:104:\n  |\n1 |  ... buteFee() public payable {         msg.sender.transfer(msg.value);     }     function ext ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneySender {\n    function sendMoney() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function helperFunction() public pure returns (string memory) { return \"Extra\"; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/144.sol:1:97:\n  |\n1 |  ... ndMoney() public payable {         msg.sender.transfer(msg.value);     }     function hel ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ExpenseReimburser {\n    function reimburse() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/145.sol:1:103:\n  |\n1 | pragma solidity^0.8.0; contract ExpenseReimburser {     function reimburse() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                       ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueCollector {\n    function collectRevenue() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function additionalLogic() public pure returns (bool) { return false; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/146.sol:1:107:\n  |\n1 |  ... Revenue() public payable {         msg.sender.transfer(msg.value);     }     function add ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract WealthAllocator {\n    function allocateWealth() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/147.sol:1:106:\n  |\n1 | pragma solidity^0.8.0; contract WealthAllocator {     function allocateWealth() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                          ^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantIssuer {\n    function issueGrant() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/148.sol:1:98:\n  |\n1 | pragma solidity^0.8.0; contract GrantIssuer {     function issueGrant() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                  ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract CashoutProcessor {\n    function processCashout() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function unusedMethod() public pure {}\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/149.sol:1:107:\n  |\n1 |  ... Cashout() public payable {         msg.sender.transfer(msg.value);     }     function unu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract BenefitPayer {\n    function payBenefit() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/150.sol:1:99:\n  |\n1 | pragma solidity^0.8.0; contract BenefitPayer {     function payBenefit() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                   ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract RefundIssuer {\n    function issueRefund() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function someUtility() public pure returns (uint) { return 999; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/151.sol:1:100:\n  |\n1 |  ... eRefund() public payable {         msg.sender.transfer(msg.value);     }     function som ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract PaymentDispatcher {\n    function dispatchPayment() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract FeeDistributor {\n    function distributeFee() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function extraFeature() public pure returns (int) { return 2024; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract MoneySender {\n    function sendMoney() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function helperFunction() public pure returns (string memory) { return \"Extra\"; }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ExpenseReimburser {\n    function reimburse() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract RevenueCollector {\n    function collectRevenue() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function additionalLogic() public pure returns (bool) { return false; }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract WealthAllocator {\n    function allocateWealth() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract GrantIssuer {\n    function issueGrant() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract CashoutProcessor {\n    function processCashout() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function unusedMethod() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract BenefitPayer {\n    function payBenefit() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract RefundIssuer {\n    function issueRefund() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function someUtility() public pure returns (uint) { return 999; }\n}"
      }
    }
  },
  {
    "Changes74": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The <code>chainid</code> builtin in inline assembly is now considered <code>view</code> instead of <code>pure</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainProcessor {\n    function processChainID() public pure returns (uint256) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid\n        }\n        return chainID;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/152.sol:1:180:\n  |\n1 |  ...  assembly {             chainID := chainid         }         return chainID;  ...\n  |                                         ^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainData {\n    function accessChainData() public pure returns (uint256) {\n        uint256 data;\n        assembly {\n            data := chainid\n        }\n        return data;\n    }\n    function extraFuncA() public pure returns (uint256) { return 100; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/153.sol:1:170:\n  |\n1 |  ...     assembly {             data := chainid         }         return data;     ...\n  |                                         ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkIdentifier {\n    function getNetworkIdentifier() public pure returns (uint256) {\n        uint256 networkId;\n        assembly {\n            networkId := chainid\n        }\n        return networkId;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/154.sol:1:193:\n  |\n1 |  ... ssembly {             networkId := chainid         }         return networkId ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract BlockChainID {\n    function getBlockChainID() public pure returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid\n        }\n        return id;\n    }\n    function helperOne() public pure returns (uint256) { return 101; }\n    function helperTwo() public pure returns (uint256) { return 102; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/155.sol:1:169:\n  |\n1 |  ...       assembly {             id := chainid         }         return id;     } ...\n  |                                         ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainLink {\n    function linkToChain() public pure returns (uint256) {\n        uint256 link;\n        assembly {\n            link := chainid\n        }\n        return link;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/156.sol:1:166:\n  |\n1 |  ...     assembly {             link := chainid         }         return link;     ...\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainGather {\n    function gatherChainInfo() public pure returns (uint256) {\n        uint256 info;\n        assembly {\n            info := chainid\n        }\n        return info;\n    }\n    function unrelatedFunc() public pure returns (uint256) { return 42; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/157.sol:1:172:\n  |\n1 |  ...     assembly {             info := chainid         }         return info;     ...\n  |                                         ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkChain {\n    function fetchNetworkChain() public pure returns (uint256) {\n        uint256 networkChain;\n        assembly {\n            networkChain := chainid\n        }\n        return networkChain;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/158.sol:1:191:\n  |\n1 |  ... mbly {             networkChain := chainid         }         return networkCh ...\n  |                                         ^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract BlockchainRetriever {\n    function retrieveBlockchain() public pure returns (uint256) {\n        uint256 blockchain;\n        assembly {\n            blockchain := chainid\n        }\n        return blockchain;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/159.sol:1:195:\n  |\n1 |  ... sembly {             blockchain := chainid         }         return blockchai ...\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainReveal {\n    function revealChain() public pure returns (uint256) {\n        uint256 reveal;\n        assembly {\n            reveal := chainid\n        }\n        return reveal;\n    }\n    function additional() public pure returns (uint256) { return 777; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/160.sol:1:172:\n  |\n1 |  ...   assembly {             reveal := chainid         }         return reveal;   ...\n  |                                         ^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainDiscovery {\n    function discoverChain() public pure returns (uint256) {\n        uint256 discovery;\n        assembly {\n            discovery := chainid\n        }\n        return discovery;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/161.sol:1:183:\n  |\n1 |  ... ssembly {             discovery := chainid         }         return discovery ...\n  |                                         ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ChainProcessor {\n    function processChainID() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ChainData {\n    function accessChainData() public view returns (uint256) {\n        return block.chainid;\n    }\n    function extraFuncA() public pure returns (uint256) { return 100; }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract NetworkIdentifier {\n    function getNetworkIdentifier() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract BlockChainID {\n    function getBlockChainID() public view returns (uint256) {\n        return block.chainid;\n    }\n    function helperOne() public pure returns (uint256) { return 101; }\n    function helperTwo() public pure returns (uint256) { return 102; }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ChainLink {\n    function linkToChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ChainGather {\n    function gatherChainInfo() public view returns (uint256) {\n        return block.chainid;\n    }\n    function unrelatedFunc() public pure returns (uint256) { return 42; }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract NetworkChain {\n    function fetchNetworkChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract BlockchainRetriever {\n    function retrieveBlockchain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ChainReveal {\n    function revealChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function additional() public pure returns (uint256) { return 777; }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ChainDiscovery {\n    function discoverChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}"
      }
    }
  },
  {
    "Changes75": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Unary negation cannot be used on unsigned integers anymore, only on signed integers.Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. <code>type(uint256).max - x + 1</code>, while ensuring that <code>x</code> is not zero)",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract IntegerNegative {\n    function negate(uint p) public pure returns (uint) {\n        return -p;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/162.sol:1:123:\n  |\n1 | pragma solidity^0.8.0; contract IntegerNegative {     function negate(uint p) public pure returns (uint) {         return -p;     } }\n  |                                                                                                                           ^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract UnsignedError {\n    function error(uint q) public pure returns (uint) {\n        return -q;\n    }\n    function helperFunc() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/163.sol:1:120:\n  |\n1 |  ... re returns (uint) {         return -q;     }     function helperFunc() p ...\n  |                                         ^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueReversal {\n    function reverseValue(uint r) public pure returns (uint) {\n        return -r;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/164.sol:1:127:\n  |\n1 | pragma solidity^0.8.0; contract ValueReversal {     function reverseValue(uint r) public pure returns (uint) {         return -r;     } }\n  |                                                                                                                               ^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract SimpleMath {\n    function negate(uint s) public pure returns (uint) {\n        return -s;\n    }\n    function doExtra() public pure {}\n    function anotherExtra() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/165.sol:1:118:\n  |\n1 |  ... re returns (uint) {         return -s;     }     function doExtra() publ ...\n  |                                         ^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract CalculationError {\n    function makeError(uint t) public pure returns (uint) {\n        return -t;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/166.sol:1:127:\n  |\n1 | pragma solidity^0.8.0; contract CalculationError {     function makeError(uint t) public pure returns (uint) {         return -t;     } }\n  |                                                                                                                               ^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Inversion {\n    function invertValue(uint u) public pure returns (uint) {\n        return -u;\n    }\n    function anotherFunc() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/167.sol:1:122:\n  |\n1 |  ... re returns (uint) {         return -u;     }     function anotherFunc()  ...\n  |                                         ^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract SignFlip {\n    function flipSign(uint v) public pure returns (uint) {\n        return -v;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/168.sol:1:118:\n  |\n1 | pragma solidity^0.8.0; contract SignFlip {     function flipSign(uint v) public pure returns (uint) {         return -v;     } }\n  |                                                                                                                      ^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract NegativeOutput {\n    function outputNegative(uint w) public pure returns (uint) {\n        return -w;\n    }\n    function justAFunction() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/169.sol:1:130:\n  |\n1 |  ... re returns (uint) {         return -w;     }     function justAFunction( ...\n  |                                         ^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ZeroSubtract {\n    function subtractFromMax(uint x) public pure returns (uint) {\n        return -x;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/170.sol:1:129:\n  |\n1 | pragma solidity^0.8.0; contract ZeroSubtract {     function subtractFromMax(uint x) public pure returns (uint) {         return -x;     } }\n  |                                                                                                                                 ^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract DirectNegation {\n    function directlyNegate(uint y) public pure returns (uint) {\n        return -y;\n    }\n    function extraOne() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/171.sol:1:130:\n  |\n1 |  ... re returns (uint) {         return -y;     }     function extraOne() pub ...\n  |                                         ^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract IntegerNegative {\n    function negate(uint p) public pure returns (uint) {\n        return type(uint).max - p + 1;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract UnsignedError {\n    function error(uint q) public pure returns (uint) {\n        return type(uint).max - q + 1;\n    }\n    function helperFunc() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ValueReversal {\n    function reverseValue(uint r) public pure returns (uint) {\n        return type(uint).max - r + 1;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract SimpleMath {\n    function negate(uint s) public pure returns (uint) {\n        return type(uint).max - s + 1;\n    }\n    function doExtra() public pure {}\n    function anotherExtra() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract CalculationError {\n    function makeError(uint t) public pure returns (uint) {\n        return type(uint).max - t + 1;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Inversion {\n    function invertValue(uint u) public pure returns (uint) {\n        return type(uint).max - u + 1;\n    }\n    function anotherFunc() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract SignFlip {\n    function flipSign(uint v) public pure returns (uint) {\n        return type(uint).max - v + 1;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract NegativeOutput {\n    function outputNegative(uint w) public pure returns (uint) {\n        return type(uint).max - w + 1;\n    }\n    function justAFunction() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ZeroSubtract {\n    function subtractFromMax(uint x) public pure returns (uint) {\n        return type(uint).max - x + 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract DirectNegation {\n    function directlyNegate(uint y) public pure returns (uint) {\n        return type(uint).max - y + 1;\n    }\n    function extraOne() public pure {}\n}"
      }
    }
  },
  {
    "Changes76": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractEE {\n    byte itemEE;\n    function setItemEE(byte newValue) public {\n        itemEE = newValue;\n    }\n    function extraFunctionEE() public pure returns (string memory) {\n        return \"Extra EE\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/2.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractEE {     byte itemEE;     function setItemEE(byt ...\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractFF {\n    byte itemFF;\n    function modifyItemFF(byte newValue) public {\n        itemFF = newValue;\n    }\n    function randomFunctionFF() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/3.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractFF {     byte itemFF;     function modifyItemFF( ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractGG {\n    byte itemGG;\n    function updateItemGG(byte newValue) public {\n        itemGG = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/4.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractGG {     byte itemGG;     function updateItemGG(byte newValue) public {         itemGG = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractHH {\n    byte itemHH;\n    function changeItemHH(byte newValue) public {\n        itemHH = newValue;\n    }\n    function helperFunctionHH() public pure returns (int) {\n        return 256;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/5.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractHH {     byte itemHH;     function changeItemHH( ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractII {\n    byte itemII;\n    function adjustItemII(byte newValue) public {\n        itemII = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/6.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractII {     byte itemII;     function adjustItemII(byte newValue) public {         itemII = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractJJ {\n    byte itemJJ;\n    function setItemJJ(byte newValue) public {\n        itemJJ = newValue;\n    }\n    function extraFunctionJJ() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/7.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractJJ {     byte itemJJ;     function setItemJJ(byt ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractKK {\n    byte itemKK;\n    function deployItemKK(byte newValue) public {\n        itemKK = newValue;\n    }\n    function dummyFunctionKK() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/8.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractKK {     byte itemKK;     function deployItemKK( ...\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractLL {\n    byte itemLL;\n    function storeItemLL(byte newValue) public {\n        itemLL = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/9.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractLL {     byte itemLL;     function storeItemLL(byte newValue) public {         itemLL = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractMM {\n    byte itemMM;\n    function replaceItemMM(byte newValue) public {\n        itemMM = newValue;\n    }\n    function extraFunctionMM() public pure returns (int) {\n        return -123;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/10.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractMM {     byte itemMM;     function replaceItemMM ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractNN {\n    byte itemNN;\n    function refreshItemNN(byte newValue) public {\n        itemNN = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/11.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractNN {     byte itemNN;     function refreshItemNN(byte newValue) public {         itemNN = newValue;     } }\n  |                                                  ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractEE {\n    bytes1 itemEE;\n    function setItemEE(bytes1 newValue) public {\n        itemEE = newValue;\n    }\n    function extraFunctionEE() public pure returns (string memory) {\n        return \"Extra EE\";\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractFF {\n    bytes1 itemFF;\n    function modifyItemFF(bytes1 newValue) public {\n        itemFF = newValue;\n    }\n    function randomFunctionFF() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractGG {\n    bytes1 itemGG;\n    function updateItemGG(bytes1 newValue) public {\n        itemGG = newValue;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractHH {\n    bytes1 itemHH;\n    function changeItemHH(bytes1 newValue) public {\n        itemHH = newValue;\n    }\n    function helperFunctionHH() public pure returns (int) {\n        return 256;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractII {\n    bytes1 itemII;\n    function adjustItemII(bytes1 newValue) public {\n        itemII = newValue;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractJJ {\n    bytes1 itemJJ;\n    function setItemJJ(bytes1 newValue) public {\n        itemJJ = newValue;\n    }\n    function extraFunctionJJ() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractKK {\n    bytes1 itemKK;\n    function deployItemKK(bytes1 newValue) public {\n        itemKK = newValue;\n    }\n    function dummyFunctionKK() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractLL {\n    bytes1 itemLL;\n    function storeItemLL(bytes1 newValue) public {\n        itemLL = newValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractMM {\n    bytes1 itemMM;\n    function replaceItemMM(bytes1 newValue) public {\n        itemMM = newValue;\n    }\n    function extraFunctionMM() public pure returns (int) {\n        return -123;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractNN {\n    bytes1 itemNN;\n    function refreshItemNN(bytes1 newValue) public {\n        itemNN = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes77": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions from negative literals and literals larger than <code>type(uint160).max</code> to\n<code>address</code> are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyOne {\n    function convertNegativeThirtyOne() public pure returns (address) {\n        int neg = -31;\n        return address(uint160(neg));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/12.sol:1:172:\n  |\n1 |  ...  neg = -31;         return address(uint160(neg));     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyTwo {\n    function makeAddressNegative() public pure returns (address) {\n        int negative = -32;\n        return address(uint160(negative));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/13.sol:1:172:\n  |\n1 |  ... tive = -32;         return address(uint160(negative));     }     function extraMethod() ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyThree {\n    function negativeToAddressThirtyThree() public pure returns (address) {\n        int num = -33;\n        return address(uint160(num));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/14.sol:1:178:\n  |\n1 |  ...  num = -33;         return address(uint160(num));     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFour {\n    function addressFromNegThirtyFour() public pure returns (address) {\n        int numNeg = -34;\n        return address(uint160(numNeg));\n    }\n    function checkValue() public pure returns (uint) {\n        return 34;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/15.sol:1:176:\n  |\n1 |  ... mNeg = -34;         return address(uint160(numNeg));     }     function checkValue()  ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFive {\n    function convertNegToAddrThirtyFive() public pure returns (address) {\n        int negInt = -35;\n        return address(uint160(negInt));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/16.sol:1:178:\n  |\n1 |  ... gInt = -35;         return address(uint160(negInt));     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySix {\n    function castNegativeInteger() public pure returns (address) {\n        int negative = -36;\n        return address(uint160(negative));\n    }\n    function unrelatedFunction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/17.sol:1:172:\n  |\n1 |  ... tive = -36;         return address(uint160(negative));     }     function unrelatedFunc ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySeven {\n    function negativeToIntAddress() public pure returns (address) {\n        int badNumber = -37;\n        return address(uint160(badNumber));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/18.sol:1:176:\n  |\n1 |  ... mber = -37;         return address(uint160(badNumber));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyEight {\n    function castToAddressFromNeg() public pure returns (address) {\n        int negativeValue = -38;\n        return address(uint160(negativeValue));\n    }\n    function returnValue() public pure returns (int) {\n        return -38;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/19.sol:1:180:\n  |\n1 |  ... alue = -38;         return address(uint160(negativeValue));     }     function returnValue() ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyNine {\n    function negativeValueToAddress() public pure returns (address) {\n        int value = -39;\n        return address(uint160(value));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/20.sol:1:173:\n  |\n1 |  ... alue = -39;         return address(uint160(value));     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractForty {\n    function negativeToAddressConversion() public pure returns (address) {\n        int negativeForty = -40;\n        return address(uint160(negativeForty));\n    }\n    function simpleFunc() public pure returns (uint) {\n        return 40;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/21.sol:1:181:\n  |\n1 |  ... orty = -40;         return address(uint160(negativeForty));     }     function simpleFunc()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyOne {\n    function validOperation() public pure returns (uint) {\n        int neg = -31;\n        return uint(neg);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyTwo {\n    function makeAddressPositive() public pure returns (address) {\n        uint positive = 32;\n        return address(uint160(positive));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyThree {\n    function positiveToAddress() public pure returns (address) {\n        uint num = 33;\n        return address(uint160(num));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFour {\n    function addressFromPositive() public pure returns (address) {\n        uint numPos = 34;\n        return address(uint160(numPos));\n    }\n    function checkValue() public pure returns (uint) {\n        return 34;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFive {\n    function convertPosToAddr() public pure returns (address) {\n        uint posInt = 35;\n        return address(uint160(posInt));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySix {\n    function castPositiveInteger() public pure returns (address) {\n        uint positive = 36;\n        return address(uint160(positive));\n    }\n    function unrelatedFunction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySeven {\n    function positiveToIntAddress() public pure returns (address) {\n        uint goodNumber = 37;\n        return address(uint160(goodNumber));\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyEight {\n    function castToAddressFromPos() public pure returns (address) {\n        uint positiveValue = 38;\n        return address(uint160(positiveValue));\n    }\n    function returnValue() public pure returns (int) {\n        return -38;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyNine {\n    function positiveValueToAddress() public pure returns (address) {\n        uint value = 39;\n        return address(uint160(value));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractForty {\n    function positiveToAddressConversion() public pure returns (address) {\n        uint positiveForty = 40;\n        return address(uint160(positiveForty));\n    }\n    function simpleFunc() public pure returns (uint) {\n        return 40;\n    }\n}"
      }
    }
  },
  {
    "Changes78": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and an integer type <code>T</code> are only allowed if the literal\nlies between <code>type(T).min</code> and <code>type(T).max</code>. In particular, replace usages of <code>uint(-1)</code>\nwith <code>type(uint).max</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyOne {\n    function deriveCeiling() public pure returns (uint) {\n        uint ceiling = uint(-1);\n        return ceiling;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/22.sol:1:134:\n  |\n1 |  ... ns (uint) {         uint ceiling = uint(-1);         return ceiling;     } }\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyTwo {\n    function calculateMaxCap() public pure returns (uint) {\n        uint maxCap = uint(-1);\n        return maxCap;\n    }\n    function randomHelper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/23.sol:1:135:\n  |\n1 |  ... rns (uint) {         uint maxCap = uint(-1);         return maxCap;     }      ...\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyThree {\n    function establishLimit() public pure returns (uint) {\n        uint limit = uint(-1);\n        return limit;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/24.sol:1:135:\n  |\n1 |  ... urns (uint) {         uint limit = uint(-1);         return limit;     } }\n  |                                         ^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFour {\n    function reachMaximum() public pure returns (uint) {\n        uint maximumReach = uint(-1);\n        return maximumReach;\n    }\n    function extraFunctionFive() public pure returns (string memory) {\n        return \"Just a string\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/25.sol:1:139:\n  |\n1 |  ... int) {         uint maximumReach = uint(-1);         return maximumReach;      ...\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFive {\n    function pinpointCeiling() public pure returns (uint) {\n        uint ceilingPinpoint = uint(-1);\n        return ceilingPinpoint;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/26.sol:1:145:\n  |\n1 |  ... ) {         uint ceilingPinpoint = uint(-1);         return ceilingPinpoint;   ...\n  |                                         ^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySix {\n    function getExtremeValue() public pure returns (uint) {\n        uint extremeValue = uint(-1);\n        return extremeValue;\n    }\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 567;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/27.sol:1:141:\n  |\n1 |  ... int) {         uint extremeValue = uint(-1);         return extremeValue;      ...\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySeven {\n    function calculateBoundaryMax() public pure returns (uint) {\n        uint boundaryCalculation = uint(-1);\n        return boundaryCalculation;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/28.sol:1:155:\n  |\n1 |  ...         uint boundaryCalculation = uint(-1);         return boundaryCalculatio ...\n  |                                         ^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyEight {\n    function derivePeak() public pure returns (uint) {\n        uint peakDerivation = uint(-1);\n        return peakDerivation;\n    }\n    function extraFunctionSix() public pure returns (int) {\n        return -999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/29.sol:1:140:\n  |\n1 |  ... t) {         uint peakDerivation = uint(-1);         return peakDerivation;    ...\n  |                                         ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyNine {\n    function secureMaximum() public pure returns (uint) {\n        uint secureMax = uint(-1);\n        return secureMax;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/30.sol:1:137:\n  |\n1 |  ...  (uint) {         uint secureMax = uint(-1);         return secureMax;     } }\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleForty {\n    function identifyMaxValue() public pure returns (uint) {\n        uint maxValue = uint(-1);\n        return maxValue;\n    }\n    function unrelatedTwo() public pure returns (string memory) {\n        return \"Random text\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/31.sol:1:134:\n  |\n1 |  ... s (uint) {         uint maxValue = uint(-1);         return maxValue;     }    ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyOne {\n    function deriveCeiling() public pure returns (uint) {\n        uint ceiling = type(uint).max;\n        return ceiling;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyTwo {\n    function calculateMaxCap() public pure returns (uint) {\n        uint maxCap = type(uint).max;\n        return maxCap;\n    }\n    function randomHelper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyThree {\n    function establishLimit() public pure returns (uint) {\n        uint limit = type(uint).max;\n        return limit;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFour {\n    function reachMaximum() public pure returns (uint) {\n        uint maximumReach = type(uint).max;\n        return maximumReach;\n    }\n    function extraFunctionFive() public pure returns (string memory) {\n        return \"Just a string\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFive {\n    function pinpointCeiling() public pure returns (uint) {\n        uint ceilingPinpoint = type(uint).max;\n        return ceilingPinpoint;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySix {\n    function getExtremeValue() public pure returns (uint) {\n        uint extremeValue = type(uint).max;\n        return extremeValue;\n    }\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 567;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySeven {\n    function calculateBoundaryMax() public pure returns (uint) {\n        uint boundaryCalculation = type(uint).max;\n        return boundaryCalculation;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyEight {\n    function derivePeak() public pure returns (uint) {\n        uint peakDerivation = type(uint).max;\n        return peakDerivation;\n    }\n    function extraFunctionSix() public pure returns (int) {\n        return -999;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyNine {\n    function secureMaximum() public pure returns (uint) {\n        uint secureMax = type(uint).max;\n        return secureMax;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ExampleForty {\n    function identifyMaxValue() public pure returns (uint) {\n        uint maxValue = type(uint).max;\n        return maxValue;\n    }\n    function unrelatedTwo() public pure returns (string memory) {\n        return \"Random text\";\n    }\n}"
      }
    }
  },
  {
    "Changes79": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and enums are only allowed if the literal can\nrepresent a value in the enum.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    enum Speed { Slow, Fast }\n    Speed public carSpeed;\n    function setSpeed() public {\n        carSpeed = Speed(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example32.Speed\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/32.sol:1:155:\n  |\n1 |  ... peed() public {         carSpeed = Speed(3);     } }\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    enum Frequency { Never, Rarely, Often, Always }\n    Frequency public loginFrequency;\n    function setFrequency() public {\n        loginFrequency = Frequency(5);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example33.Frequency\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/33.sol:1:197:\n  |\n1 |  ...  public {         loginFrequency = Frequency(5);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    enum Status { Single, Married, Divorced }\n    Status public maritalStatus;\n    function updateStatus() public {\n        maritalStatus = Status(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example34.Status\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/34.sol:1:186:\n  |\n1 |  ... ) public {         maritalStatus = Status(4);     } }\n  |                                         ^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    enum Direction { Up, Down, Left, Right }\n    Direction public swipeDirection;\n    function swipe() public {\n        swipeDirection = Direction(5);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example35.Direction\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/35.sol:1:183:\n  |\n1 |  ...  public {         swipeDirection = Direction(5);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    enum Action { Buy, Sell, Hold }\n    Action public tradingAction;\n    function takeAction() public {\n        tradingAction = Action(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example36.Action\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/36.sol:1:174:\n  |\n1 |  ... ) public {         tradingAction = Action(4);     } }\n  |                                         ^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    enum Condition { Good, Fair, Poor }\n    Condition public itemCondition;\n    function setCondition() public {\n        itemCondition = Condition(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example37.Condition\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/37.sol:1:183:\n  |\n1 |  ... ) public {         itemCondition = Condition(4);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    enum Temperature { Cold, Warm, Hot }\n    Temperature public waterTemperature;\n    function setTemperature() public {\n        waterTemperature = Temperature(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example38.Temperature\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/38.sol:1:194:\n  |\n1 |  ... ublic {         waterTemperature = Temperature(4);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    enum Position { First, Second, Third }\n    Position public racePosition;\n    function setPosition() public {\n        racePosition = Position(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example39.Position\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/39.sol:1:182:\n  |\n1 |  ... () public {         racePosition = Position(4);     } }\n  |                                         ^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    enum Response { Yes, No }\n    Response public userResponse;\n    function setResponse() public {\n        userResponse = Response(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example40.Response\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/40.sol:1:169:\n  |\n1 |  ... () public {         userResponse = Response(3);     } }\n  |                                         ^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    enum Quality { High, Medium, Low }\n    Quality public productQuality;\n    function adjustQuality() public {\n        productQuality = Quality(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example41.Quality\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/41.sol:1:183:\n  |\n1 |  ...  public {         productQuality = Quality(4);     } }\n  |                                         ^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    enum Speed { Slow, Fast }\n    Speed public carSpeed;\n    function setSpeed() public {\n        carSpeed = Speed(1);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    enum Frequency { Never, Rarely, Often, Always }\n    Frequency public loginFrequency;\n    function setFrequency() public {\n        loginFrequency = Frequency(3);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    enum Status { Single, Married, Divorced }\n    Status public maritalStatus;\n    function updateStatus() public {\n        maritalStatus = Status(2);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    enum Direction { Up, Down, Left, Right }\n    Direction public swipeDirection;\n    function swipe() public {\n        swipeDirection = Direction(3);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    enum Action { Buy, Sell, Hold }\n    Action public tradingAction;\n    function takeAction() public {\n        tradingAction = Action(2);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    enum Condition { Good, Fair, Poor }\n    Condition public itemCondition;\n    function setCondition() public {\n        itemCondition = Condition(2);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    enum Temperature { Cold, Warm, Hot }\n    Temperature public waterTemperature;\n    function setTemperature() public {\n        waterTemperature = Temperature(2);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    enum Position { First, Second, Third }\n    Position public racePosition;\n    function setPosition() public {\n        racePosition = Position(2);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    enum Response { Yes, No }\n    Response public userResponse;\n    function setResponse() public {\n        userResponse = Response(1);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    enum Quality { High, Medium, Low }\n    Quality public productQuality;\n    function adjustQuality() public {\n        productQuality = Quality(2);\n    }\n}"
      }
    }
  },
  {
    "Changes80": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and <code>address</code> type (e.g. <code>address(literal)</code>) have the\ntype <code>address</code> instead of <code>address payable</code>. One can get a payable address type by using an\nexplicit conversion, i.e., <code>payable(literal)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    function issuePayments(address employee, uint256 salary) public {\n        address payable payrollAccount = address(0xFFF);\n        payrollAccount.transfer(salary);\n    }\n\n    function sumOfSquares(uint[] memory nums) public pure returns (uint total) {\n        total = 0;\n        for (uint i = 0; i < nums.length; i++) {\n            total += nums[i] * nums[i];\n        }\n        return total;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/42.sol:1:124:\n  |\n1 |  ... , uint256 salary) public {         address payable payrollAccount = address(0xFFF);         payrollAccount.transfer(s ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    function payDividends(address investor, uint256 dividends) public {\n        address payable investmentAccount = address(0x111);\n        investmentAccount.transfer(dividends);\n    }\n\n    function sumOfEvens(uint limit) public pure returns (uint sum) {\n        sum = 0;\n        for (uint i = 0; i <= limit; i += 2) {\n            sum += i;\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/43.sol:1:126:\n  |\n1 |  ... int256 dividends) public {         address payable investmentAccount = address(0x111);         investmentAccount.transfe ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    function clearDebt(address debtor, uint256 amount) public {\n        address payable debtAccount = address(0x222);\n        debtAccount.transfer(amount);\n    }\n\n    function powerOfTwo(uint n) public pure returns (uint) {\n        return 2**n;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/44.sol:1:118:\n  |\n1 |  ... , uint256 amount) public {         address payable debtAccount = address(0x222);         debtAccount.transfer(amou ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    function grantScholarship(address student, uint256 scholarship) public {\n        address payable schoolAccount = address(0x333);\n        schoolAccount.transfer(scholarship);\n    }\n\n    function isPrime(uint num) public pure returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/45.sol:1:131:\n  |\n1 |  ... t256 scholarship) public {         address payable schoolAccount = address(0x333);         schoolAccount.transfer(sc ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    function refundCustomer(address customer, uint256 refundAmount) public {\n        address payable refundAccount = address(0x444);\n        refundAccount.transfer(refundAmount);\n    }\n\n    function factorial(uint n) public pure returns (uint result) {\n        result = 1;\n        for (uint i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/46.sol:1:131:\n  |\n1 |  ... 256 refundAmount) public {         address payable refundAccount = address(0x444);         refundAccount.transfer(re ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    function payOutInsurance(address insured, uint256 claimAmount) public {\n        address payable insuranceAccount = address(0x555);\n        insuranceAccount.transfer(claimAmount);\n    }\n\n    function calculateModulus(uint a, uint b) public pure returns (uint) {\n        return a % b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/47.sol:1:130:\n  |\n1 |  ... t256 claimAmount) public {         address payable insuranceAccount = address(0x555);         insuranceAccount.transfer ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    function settleBill(address vendor, uint256 billAmount) public {\n        address payable vendorAccount = address(0x666);\n        vendorAccount.transfer(billAmount);\n    }\n\n    function countOddNumbers(uint limit) public pure returns (uint count) {\n        for (uint i = 1; i < limit; i += 2) {\n            count++;\n        }\n        return count;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/48.sol:1:123:\n  |\n1 |  ... nt256 billAmount) public {         address payable vendorAccount = address(0x666);         vendorAccount.transfer(bi ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    function payRoyalties(address author, uint256 royalties) public {\n        address payable royaltyAccount = address(0x777);\n        royaltyAccount.transfer(royalties);\n    }\n\n    function fibonacci(uint n) public pure returns (uint) {\n        if (n == 0) return 0;\n        else if (n == 1) return 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/49.sol:1:124:\n  |\n1 |  ... int256 royalties) public {         address payable royaltyAccount = address(0x777);         royaltyAccount.transfer(r ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    function distributeInterest(address accountHolder, uint256 interest) public {\n        address payable bankAccount = address(0x888);\n        bankAccount.transfer(interest);\n    }\n\n    function sumOfArray(uint[] memory array) public pure returns (uint sum) {\n        for (uint i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/50.sol:1:136:\n  |\n1 |  ... uint256 interest) public {         address payable bankAccount = address(0x888);         bankAccount.transfer(inte ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    function redeemPoints(address member, uint256 points) public {\n        address payable membershipAccount = address(0x999);\n        membershipAccount.transfer(points);\n    }\n\n    function generatePrimes(uint limit) public pure returns (uint[] memory primes) {\n        bool[] memory isPrime = new bool[](limit + 1);\n        for (uint i = 2; i <= limit; i++) isPrime[i] = true;\n        for (uint p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (uint j = p * p; j <= limit; j += p) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        uint count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) count++;\n        }\n        primes = new uint[](count);\n        count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) {\n                primes[count++] = i;\n            }\n        }\n        return primes;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/51.sol:1:121:\n  |\n1 |  ... , uint256 points) public {         address payable membershipAccount = address(0x999);         membershipAccount.transfe ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    function issuePayments(address employee, uint256 salary) public {\n        address payable payrollAccount = payable(employee);\n        payrollAccount.transfer(salary);\n    }\n\n    function sumOfSquares(uint[] memory nums) public pure returns (uint total) {\n        total = 0;\n        for (uint i = 0; i < nums.length; i++) {\n            total += nums[i] * nums[i];\n        }\n        return total;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    function payDividends(address investor, uint256 dividends) public {\n        address payable investmentAccount = payable(investor);\n        investmentAccount.transfer(dividends);\n    }\n\n    function sumOfEvens(uint limit) public pure returns (uint sum) {\n        sum = 0;\n        for (uint i = 0; i <= limit; i += 2) {\n            sum += i;\n        }\n        return sum;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    function clearDebt(address debtor, uint256 amount) public {\n        address payable debtAccount = payable(debtor);\n        debtAccount.transfer(amount);\n    }\n\n    function powerOfTwo(uint n) public pure returns (uint) {\n        return 2**n;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    function grantScholarship(address student, uint256 scholarship) public {\n        address payable schoolAccount = payable(student);\n        schoolAccount.transfer(scholarship);\n    }\n\n    function isPrime(uint num) public pure returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    function refundCustomer(address customer, uint256 refundAmount) public {\n        address payable refundAccount = payable(customer);\n        refundAccount.transfer(refundAmount);\n    }\n\n    function factorial(uint n) public pure returns (uint result) {\n        result = 1;\n        for (uint i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    function payOutInsurance(address insured, uint256 claimAmount) public {\n        address payable insuranceAccount = payable(insured);\n        insuranceAccount.transfer(claimAmount);\n    }\n\n    function calculateModulus(uint a, uint b) public pure returns (uint) {\n        return a % b;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    function settleBill(address vendor, uint256 billAmount) public {\n        address payable vendorAccount = payable(vendor);\n        vendorAccount.transfer(billAmount);\n    }\n\n    function countOddNumbers(uint limit) public pure returns (uint count) {\n        for (uint i = 1; i < limit; i += 2) {\n            count++;\n        }\n        return count;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    function payRoyalties(address author, uint256 royalties) public {\n        address payable royaltyAccount = payable(author);\n        royaltyAccount.transfer(royalties);\n    }\n\n    function fibonacci(uint n) public pure returns (uint) {\n        if (n == 0) return 0;\n        else if (n == 1) return 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    function distributeInterest(address accountHolder, uint256 interest) public {\n        address payable bankAccount = payable(accountHolder);\n        bankAccount.transfer(interest);\n    }\n\n    function sumOfArray(uint[] memory array) public pure returns (uint sum) {\n        for (uint i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    function redeemPoints(address member, uint256 points) public {\n        address payable membershipAccount = payable(member);\n        membershipAccount.transfer(points);\n    }\n\n    function generatePrimes(uint limit) public pure returns (uint[] memory primes) {\n        bool[] memory isPrime = new bool[](limit + 1);\n        for (uint i = 2; i <= limit; i++) isPrime[i] = true;\n        for (uint p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (uint j = p * p; j <= limit; j += p) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        uint count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) count++;\n        }\n        primes = new uint[](count);\n        count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) {\n                primes[count++] = i;\n            }\n        }\n        return primes;\n    }\n}"
      }
    }
  },
  {
    "Changes81": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/types.html#address-literals\"><span class=\"std std-ref\">Address literals</a> have the type <code>address</code> instead of <code>address\npayable</code>. They can be converted to <code>address payable</code> by using an explicit conversion, e.g.\n<code>payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract11 {\n    address payable public account11;\n    constructor() {\n        account11 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/52.sol:1:124:\n  |\n1 |  ... onstructor() {         account11 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract12 {\n    address payable public account12;\n    constructor() {\n        account12 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/53.sol:1:124:\n  |\n1 |  ... onstructor() {         account12 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract13 {\n    address payable public account13;\n    constructor() {\n        account13 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/54.sol:1:124:\n  |\n1 |  ... onstructor() {         account13 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract14 {\n    address payable public account14;\n    constructor() {\n        account14 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/55.sol:1:124:\n  |\n1 |  ... onstructor() {         account14 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract15 {\n    address payable public account15;\n    constructor() {\n        account15 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/56.sol:1:124:\n  |\n1 |  ... onstructor() {         account15 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract16 {\n    address payable public account16;\n    constructor() {\n        account16 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random6() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/57.sol:1:124:\n  |\n1 |  ... onstructor() {         account16 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random6() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract17 {\n    address payable public account17;\n    constructor() {\n        account17 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random7() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/58.sol:1:124:\n  |\n1 |  ... onstructor() {         account17 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random7() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract18 {\n    address payable public account18;\n    constructor() {\n        account18 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random8() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/59.sol:1:124:\n  |\n1 |  ... onstructor() {         account18 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random8() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract19 {\n    address payable public account19;\n    constructor() {\n        account19 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/60.sol:1:124:\n  |\n1 |  ... onstructor() {         account19 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract20 {\n    address payable public account20;\n    constructor() {\n        account20 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/61.sol:1:124:\n  |\n1 |  ... onstructor() {         account20 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Contract11 {\n    address payable public account11;\n    constructor() {\n        account11 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Contract12 {\n    address payable public account12;\n    constructor() {\n        account12 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Contract13 {\n    address payable public account13;\n    constructor() {\n        account13 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Contract14 {\n    address payable public account14;\n    constructor() {\n        account14 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Contract15 {\n    address payable public account15;\n    constructor() {\n        account15 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Contract16 {\n    address payable public account16;\n    constructor() {\n        account16 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random6() public {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Contract17 {\n    address payable public account17;\n    constructor() {\n        account17 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random7() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Contract18 {\n    address payable public account18;\n    constructor() {\n        account18 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random8() public {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Contract19 {\n    address payable public account19;\n    constructor() {\n        account19 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Contract20 {\n    address payable public account20;\n    constructor() {\n        account20 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}"
      }
    }
  },
  {
    "Changes82": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>address(uint)</code> and <code>uint(address)</code>: converting both type-category and width. Replace this by\n<code>address(uint160(uint))</code> and <code>uint(uint160(address))</code> respectively.Add intermediate explicit type conversions if required.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Reevaluate {\n    function reevaluateUintToAddress(uint ab) public pure returns (address) {\n        return address(ab);\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a function\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/62.sol:1:139:\n  |\n1 |  ... returns (address) {         return address(ab);     }     function randomFunction ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Reinterpret {\n    function reinterpretAddressToUint(address ac) public pure returns (uint) {\n        return uint(ac);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/63.sol:1:141:\n  |\n1 |  ... re returns (uint) {         return uint(ac);     } }\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Reorganize {\n    function reorganizeUintToAddress(uint ad) public pure returns (address) {\n        return address(ad);\n    }\n    function secondaryAction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/64.sol:1:139:\n  |\n1 |  ... returns (address) {         return address(ad);     }     function secondaryActio ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Reposition {\n    function repositionAddressToUint(address ae) public pure returns (uint) {\n        return uint(ae);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/65.sol:1:139:\n  |\n1 |  ... re returns (uint) {         return uint(ae);     } }\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Reconstruct {\n    function reconstructUintToAddress(uint af) public pure returns (address) {\n        return address(af);\n    }\n    function unusedMethod() public pure returns (int) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/66.sol:1:141:\n  |\n1 |  ... returns (address) {         return address(af);     }     function unusedMethod() ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Reintegrate {\n    function reintegrateAddressToUint(address ag) public pure returns (uint) {\n        return uint(ag);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/67.sol:1:141:\n  |\n1 |  ... re returns (uint) {         return uint(ag);     } }\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Redistribute {\n    function redistributeUintToAddress(uint ah) public pure returns (address) {\n        return address(ah);\n    }\n    function extraHelper() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/68.sol:1:143:\n  |\n1 |  ... returns (address) {         return address(ah);     }     function extraHelper()  ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Remodel {\n    function remodelAddressToUint(address ai) public pure returns (uint) {\n        return uint(ai);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/69.sol:1:133:\n  |\n1 | pragma solidity^0.8.0; contract Remodel {     function remodelAddressToUint(address ai) public pure returns (uint) {         return uint(ai);     } }\n  |                                                                                                                                     ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Revamp {\n    function revampUintToAddress(uint aj) public pure returns (address) {\n        return address(aj);\n    }\n    function optionalFunction() public pure returns (uint) {\n        return 256;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/70.sol:1:131:\n  |\n1 |  ... returns (address) {         return address(aj);     }     function optionalFuncti ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Retrofit {\n    function retrofitAddressToUint(address ak) public pure returns (uint) {\n        return uint(ak);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/71.sol:1:135:\n  |\n1 |  ... re returns (uint) {         return uint(ak);     } }\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Reevaluate {\n    function reevaluateUintToAddress(uint ab) public pure returns (address) {\n        return address(uint160(ab));\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a function\";\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Reinterpret {\n    function reinterpretAddressToUint(address ac) public pure returns (uint) {\n        return uint(uint160(ac));\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Reorganize {\n    function reorganizeUintToAddress(uint ad) public pure returns (address) {\n        return address(uint160(ad));\n    }\n    function secondaryAction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Reposition {\n    function repositionAddressToUint(address ae) public pure returns (uint) {\n        return uint(uint160(ae));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Reconstruct {\n    function reconstructUintToAddress(uint af) public pure returns (address) {\n        return address(uint160(af));\n    }\n    function unusedMethod() public pure returns (int) {\n        return 999;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Reintegrate {\n    function reintegrateAddressToUint(address ag) public pure returns (uint) {\n        return uint(uint160(ag));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Redistribute {\n    function redistributeUintToAddress(uint ah) public pure returns (address) {\n        return address(uint160(ah));\n    }\n    function extraHelper() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Remodel {\n    function remodelAddressToUint(address ai) public pure returns (uint) {\n        return uint(uint160(ai));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Revamp {\n    function revampUintToAddress(uint aj) public pure returns (address) {\n        return address(uint160(aj));\n    }\n    function optionalFunction() public pure returns (uint) {\n        return 256;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Retrofit {\n    function retrofitAddressToUint(address ak) public pure returns (uint) {\n        return uint(uint160(ak));\n    }\n}"
      }
    }
  },
  {
    "Changes83": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>payable(uint160)</code>, <code>payable(bytes20)</code> and <code>payable(integer-literal)</code>: converting both\ntype-category and state-mutability. Replace this by <code>payable(address(uint160))</code>,\n<code>payable(address(bytes20))</code> and <code>payable(address(integer-literal))</code> respectively. Note that\n<code>payable(0)</code> is valid and is an exception to the rule.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ProfitDistributor {\n    function distributeProfit(uint160 profit) public pure returns (address payable) {\n        return payable(profit);\n    }\n    function checkProfit() public pure returns (uint) {\n        return 1000;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/72.sol:1:154:\n  |\n1 |  ... (address payable) {         return payable(profit);     }     function checkProfit()  ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetRegistrar {\n    function registerAsset(uint160 asset) public pure returns (address payable) {\n        return payable(asset);\n    }\n    function isActiveRegistrar() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/73.sol:1:147:\n  |\n1 |  ... (address payable) {         return payable(asset);     }     function isActiveRegist ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract DebtManager {\n    function manageDebt(uint160 debt) public pure returns (address payable) {\n        return payable(debt);\n    }\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra Function\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/74.sol:1:140:\n  |\n1 |  ... (address payable) {         return payable(debt);     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract CashFlowProcessor {\n    function processCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(cashFlow);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/75.sol:1:155:\n  |\n1 |  ... (address payable) {         return payable(cashFlow);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract LiabilityHandler {\n    function handleLiability(uint160 liability) public pure returns (address payable) {\n        return payable(liability);\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/76.sol:1:155:\n  |\n1 |  ... (address payable) {         return payable(liability);     }     function extraData() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IncomeProcessor {\n    function processIncome(uint160 income) public pure returns (address payable) {\n        return payable(income);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/77.sol:1:149:\n  |\n1 |  ... (address payable) {         return payable(income);     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract TaxCollector {\n    function collectTax(uint160 taxAmount) public pure returns (address payable) {\n        return payable(taxAmount);\n    }\n    function getTaxRate() public pure returns (uint) {\n        return 15;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/78.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(taxAmount);     }     function getTaxRate() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract FundingController {\n    function controlFunding(uint160 funding) public pure returns (address payable) {\n        return payable(funding);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/79.sol:1:153:\n  |\n1 |  ... (address payable) {         return payable(funding);     } }\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneyHandler {\n    function handleMoney(uint160 money) public pure returns (address payable) {\n        return payable(money);\n    }\n    function checkBalance() public pure returns (int) {\n        return 1000;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/80.sol:1:143:\n  |\n1 |  ... (address payable) {         return payable(money);     }     function checkBalance() ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantAllocator {\n    function allocateGrant(uint160 grant) public pure returns (address payable) {\n        return payable(grant);\n    }\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/81.sol:1:147:\n  |\n1 |  ... (address payable) {         return payable(grant);     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ProfitDistributor {\n    function distributeProfit(uint160 profit) public pure returns (address payable) {\n        return payable(address(uint160(profit)));\n    }\n    function checkProfit() public pure returns (uint) {\n        return 1000;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract AssetRegistrar {\n    function registerAsset(uint160 asset) public pure returns (address payable) {\n        return payable(address(uint160(asset)));\n    }\n    function isActiveRegistrar() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract DebtManager {\n    function manageDebt(uint160 debt) public pure returns (address payable) {\n        return payable(address(uint160(debt)));\n    }\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra Function\";\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract CashFlowProcessor {\n    function processCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(address(uint160(cashFlow)));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract LiabilityHandler {\n    function handleLiability(uint160 liability) public pure returns (address payable) {\n        return payable(address(uint160(liability)));\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IncomeProcessor {\n    function processIncome(uint160 income) public pure returns (address payable) {\n        return payable(address(uint160(income)));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract TaxCollector {\n    function collectTax(uint160 taxAmount) public pure returns (address payable) {\n        return payable(address(uint160(taxAmount)));\n    }\n    function getTaxRate() public pure returns (uint) {\n        return 15;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract FundingController {\n    function controlFunding(uint160 funding) public pure returns (address payable) {\n        return payable(address(uint160(funding)));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract MoneyHandler {\n    function handleMoney(uint160 money) public pure returns (address payable) {\n        return payable(address(uint160(money)));\n    }\n    function checkBalance() public pure returns (int) {\n        return 1000;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract GrantAllocator {\n    function allocateGrant(uint160 grant) public pure returns (address payable) {\n        return payable(address(uint160(grant)));\n    }\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}"
      }
    }
  },
  {
    "Changes84": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>int80(bytes10)</code> and <code>bytes10(int80)</code>: converting both type-category and sign. Replace this by\n<code>int80(uint80(bytes10))</code> and <code>bytes10(uint80(int80)</code> respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterGamma {\n    function gammaConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function extraGammaFunction() public pure returns (uint256) {\n        return 255;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/82.sol:1:136:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function extraGammaFunc ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract DataReformer {\n    function reformData(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function randomGammaMethod() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/83.sol:1:132:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function randomGammaMet ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract TypeModifier {\n    function modifyType(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/84.sol:1:132:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract RapidConverter {\n    function rapidConversion(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function helperGamma() public pure returns (int) {\n        return 321;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/85.sol:1:139:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function helperGamma()  ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract BytesToIntegerConverter {\n    function bytesToInteger(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/86.sol:1:147:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IntegerToBytesConverter {\n    function integerToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/87.sol:1:147:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract EasyTransform {\n    function easyConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function additionalGammaMethod() public pure returns (string memory) {\n        return \"ExtraString\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/88.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function additionalGamm ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract BasicTypeModifier {\n    function basicConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/89.sol:1:139:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract DataTranscoder {\n    function transcodeData(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function extraGammaAction() public pure returns (uint) {\n        return 888;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/90.sol:1:137:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function extraGammaActi ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract DataTransmuter {\n    function transmuteData(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function dummyGammaValue() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/91.sol:1:137:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function dummyGammaValu ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ConverterGamma {\n    function gammaConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function extraGammaFunction() public pure returns (uint256) {\n        return 255;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract DataReformer {\n    function reformData(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function randomGammaMethod() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract TypeModifier {\n    function modifyType(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract RapidConverter {\n    function rapidConversion(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function helperGamma() public pure returns (int) {\n        return 321;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract BytesToIntegerConverter {\n    function bytesToInteger(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IntegerToBytesConverter {\n    function integerToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract EasyTransform {\n    function easyConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function additionalGammaMethod() public pure returns (string memory) {\n        return \"ExtraString\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract BasicTypeModifier {\n    function basicConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract DataTranscoder {\n    function transcodeData(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function extraGammaAction() public pure returns (uint) {\n        return 888;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract DataTransmuter {\n    function transmuteData(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function dummyGammaValue() public pure returns (bool) {\n        return false;\n    }\n}"
      }
    }
  },
  {
    "Changes85": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>Contract(uint)</code>: converting both type-category and width. Replace this by\n<code>Contract(address(uint160(uint)))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverOne {\n    function modify(uint index) public pure returns (address) {\n        address result = address(index);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/92.sol:1:136:\n  |\n1 |  ... ddress) {         address result = address(index);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverTwo {\n    function shift(uint data) public pure returns (address) {\n        address addr = address(data);\n        return addr;\n    }\n    function helperFunction() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/93.sol:1:132:\n  |\n1 |  ... (address) {         address addr = address(data);         return addr;     }     fu ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverThree {\n    function update(uint num) public pure returns (address) {\n        address addr = address(num);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/94.sol:1:134:\n  |\n1 |  ... (address) {         address addr = address(num);         return addr;     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverFour {\n    function calculate(uint input) public pure returns (address) {\n        address variable = address(input);\n        return variable;\n    }\n    function extraMethod() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/95.sol:1:142:\n  |\n1 |  ... ress) {         address variable = address(input);         return variable;     }    ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverFive {\n    function process(uint value) public pure returns (address) {\n        address addr = address(value);\n        return addr;\n    }\n    function anotherExtra() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/96.sol:1:136:\n  |\n1 |  ... (address) {         address addr = address(value);         return addr;     }     fu ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverSix {\n    function convert(uint data) public pure returns (address) {\n        address resultAddr = address(data);\n        return resultAddr;\n    }\n    function additionalMethod() public pure {}\n    function extraHelper() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/97.sol:1:140:\n  |\n1 |  ... ss) {         address resultAddr = address(data);         return resultAddr;     }  ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverSeven {\n    function transmit(uint amount) public pure returns (address) {\n        address result = address(amount);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/98.sol:1:141:\n  |\n1 |  ... ddress) {         address result = address(amount);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverEight {\n    function deliver(uint quantity) public pure returns (address) {\n        address output = address(quantity);\n        return output;\n    }\n    function unused() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/99.sol:1:142:\n  |\n1 |  ... ddress) {         address output = address(quantity);         return output;     }      ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverNine {\n    function fetch(uint number) public pure returns (address) {\n        address addr = address(number);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/100.sol:1:135:\n  |\n1 |  ... (address) {         address addr = address(number);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverTen {\n    function derive(uint param) public pure returns (address) {\n        address addressVar = address(param);\n        return addressVar;\n    }\n    function methodOne() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/101.sol:1:140:\n  |\n1 |  ... ss) {         address addressVar = address(param);         return addressVar;     }  ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ResolverOne {\n    function modify(uint index) public pure returns (address) {\n        address result = address(uint160(index));\n        return result;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ResolverTwo {\n    function shift(uint data) public pure returns (address) {\n        address addr = address(uint160(data));\n        return addr;\n    }\n    function helperFunction() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ResolverThree {\n    function update(uint num) public pure returns (address) {\n        address addr = address(uint160(num));\n        return addr;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ResolverFour {\n    function calculate(uint input) public pure returns (address) {\n        address variable = address(uint160(input));\n        return variable;\n    }\n    function extraMethod() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ResolverFive {\n    function process(uint value) public pure returns (address) {\n        address addr = address(uint160(value));\n        return addr;\n    }\n    function anotherExtra() public pure {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ResolverSix {\n    function convert(uint data) public pure returns (address) {\n        address resultAddr = address(uint160(data));\n        return resultAddr;\n    }\n    function additionalMethod() public pure {}\n    function extraHelper() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ResolverSeven {\n    function transmit(uint amount) public pure returns (address) {\n        address result = address(uint160(amount));\n        return result;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ResolverEight {\n    function deliver(uint quantity) public pure returns (address) {\n        address output = address(uint160(quantity));\n        return output;\n    }\n    function unused() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ResolverNine {\n    function fetch(uint number) public pure returns (address) {\n        address addr = address(uint160(number));\n        return addr;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ResolverTen {\n    function derive(uint param) public pure returns (address) {\n        address addressVar = address(uint160(param));\n        return addressVar;\n    }\n    function methodOne() public pure {}\n}"
      }
    }
  },
  {
    "Changes86": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Function call options can only be given once, i.e. <code>c.f{gas: 10000}{value: 1}()</code> is invalid and has to be changed to <code>c.f{gas: 10000, value: 1}()</code>.Combine <code>c.f{gas: 10000}{value: 1}()</code> to <code>c.f{gas: 10000, value: 1}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract FundingAllocation {\n    address payable public fundsAllocator;\n    function allocateFunds() public {\n        fundsAllocator.call{gas: 3000}{value: 2 ether}(\"\");\n    }\n    function validateAllocation() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/102.sol:1:142:\n  |\n1 |  ... n allocateFunds() public {         fundsAllocator.call{gas: 3000}{value: 2 ether}(\"\");     }     function validateAl ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract LoanIssuer {\n    address payable public issuer;\n    function issueLoan() public {\n        issuer.call{gas: 4000}{value: 5 ether}(\"\");\n    }\n    function recordIssuance() public {}\n    function loanSummary() public pure returns (string memory) {\n        return \"Loan Issued\";\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/103.sol:1:123:\n  |\n1 |  ... ction issueLoan() public {         issuer.call{gas: 4000}{value: 5 ether}(\"\");     }     function recordIssu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceManagement {\n    address payable public manager;\n    function manageResources() public {\n        manager.call{gas: 2500}{value: 1 ether}(\"\");\n    }\n    function reportStatus() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/104.sol:1:138:\n  |\n1 |  ... manageResources() public {         manager.call{gas: 2500}{value: 1 ether}(\"\");     }     function reportStat ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract InvestmentPortfolio {\n    address payable public portfolioManager;\n    function managePortfolio() public {\n        portfolioManager.call{gas: 5000}{value: 6 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/105.sol:1:148:\n  |\n1 |  ... managePortfolio() public {         portfolioManager.call{gas: 5000}{value: 6 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract DonationPlatform {\n    address payable public charity;\n    function sendDonation() public {\n        charity.call{gas: 3500}{value: 3 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/106.sol:1:133:\n  |\n1 |  ... on sendDonation() public {         charity.call{gas: 3500}{value: 3 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract RiskAssessment {\n    address payable public assessor;\n    function assessRisk() public {\n        assessor.call{gas: 5500}{value: 4 ether}(\"\");\n    }\n    function getRiskLevel() public pure returns (uint) {\n        return 5;\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/107.sol:1:130:\n  |\n1 |  ... tion assessRisk() public {         assessor.call{gas: 5500}{value: 4 ether}(\"\");     }     function getRiskLev ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract WealthDistribution {\n    address payable public distributor;\n    function distributeWealth() public {\n        distributor.call{gas: 6000}{value: 2.5 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/108.sol:1:143:\n  |\n1 |  ... istributeWealth() public {         distributor.call{gas: 6000}{value: 2.5 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract TalentFund {\n    address payable public talent;\n    function fundTalent() public {\n        talent.call{gas: 4500}{value: 1 ether}(\"\");\n    }\n    function monitorFunds() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/109.sol:1:124:\n  |\n1 |  ... tion fundTalent() public {         talent.call{gas: 4500}{value: 1 ether}(\"\");     }     function monitorFun ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    address payable public processor;\n    function processPayment() public {\n        processor.call{gas: 7000}{value: 5 ether}(\"\");\n    }\n    function finalizeProcess() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/110.sol:1:137:\n  |\n1 |  ...  processPayment() public {         processor.call{gas: 7000}{value: 5 ether}(\"\");     }     function finalizePr ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract EmergencyFund {\n    address payable public emergency;\n    function releaseFunds() public {\n        emergency.call{gas: 8000}{value: 7 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/111.sol:1:132:\n  |\n1 |  ... on releaseFunds() public {         emergency.call{gas: 8000}{value: 7 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract FundingAllocation {\n    address payable public fundsAllocator;\n    function allocateFunds() public {\n        fundsAllocator.call{gas: 3000, value: 2 ether}(\"\");\n    }\n    function validateAllocation() public {}\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract LoanIssuer {\n    address payable public issuer;\n    function issueLoan() public {\n        issuer.call{gas: 4000, value: 5 ether}(\"\");\n    }\n    function recordIssuance() public {}\n    function loanSummary() public pure returns (string memory) {\n        return \"Loan Issued\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ResourceManagement {\n    address payable public manager;\n    function manageResources() public {\n        manager.call{gas: 2500, value: 1 ether}(\"\");\n    }\n    function reportStatus() public {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract InvestmentPortfolio {\n    address payable public portfolioManager;\n    function managePortfolio() public {\n        portfolioManager.call{gas: 5000, value: 6 ether}(\"\");\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract DonationPlatform {\n    address payable public charity;\n    function sendDonation() public {\n        charity.call{gas: 3500, value: 3 ether}(\"\");\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract RiskAssessment {\n    address payable public assessor;\n    function assessRisk() public {\n        assessor.call{gas: 5500, value: 4 ether}(\"\");\n    }\n    function getRiskLevel() public pure returns (uint) {\n        return 5;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract WealthDistribution {\n    address payable public distributor;\n    function distributeWealth() public {\n        distributor.call{gas: 6000, value: 2.5 ether}(\"\");\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract TalentFund {\n    address payable public talent;\n    function fundTalent() public {\n        talent.call{gas: 4500, value: 1 ether}(\"\");\n    }\n    function monitorFunds() public {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    address payable public processor;\n    function processPayment() public {\n        processor.call{gas: 7000, value: 5 ether}(\"\");\n    }\n    function finalizeProcess() public {}\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract EmergencyFund {\n    address payable public emergency;\n    function releaseFunds() public {\n        emergency.call{gas: 8000, value: 7 ether}(\"\");\n    }\n}"
      }
    }
  },
  {
    "Changes87": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The global functions <code>log0</code>, <code>log1</code>, <code>log2</code>, <code>log3</code> and <code>log4</code> have been removed.Use inline assembly as a replacement for <code>log0</code>, \u2026, <code>log4</code>.13.These are low-level functions that were largely unused. Their behavior can be accessed from inline assembly.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract SignalLogger {\n    function logSignal(uint256 signalValue) public {\n        bytes memory signalBytes = abi.encodePacked(signalValue);\n        assembly {\n            log0(signalBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/112.sol:1:198:\n  |\n1 |  ... e);         assembly {             log0(signalBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ReviewTracker {\n    function trackReview(int256 reviewScore) public {\n        bytes memory reviewData = abi.encodePacked(reviewScore);\n        assembly {\n            log1(reviewData, reviewScore)\n        }\n    }\n    function additionalMethod() public pure returns (uint) { return 100; }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/113.sol:1:199:\n  |\n1 |  ... e);         assembly {             log1(reviewData, reviewScore)         } ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract QueryLogger {\n    function logQuery(bytes32 queryHash) public {\n        assembly {\n            log4(queryHash, queryHash, queryHash, queryHash, queryHash)\n        }\n    }\n    function helper() public pure {}\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/114.sol:1:128:\n  |\n1 |  ... c {         assembly {             log4(queryHash, queryHash, queryHash, q ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ActivityTracker {\n    function trackActivity(uint256 activityCode) public {\n        bytes memory activityData = abi.encodePacked(activityCode);\n        assembly {\n            log3(activityData, activityCode, activityCode, activityCode)\n        }\n    }\n}",
          "error message": "Error: Function expects 5 arguments but got 4.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/115.sol:1:208:\n  |\n1 |  ... e);         assembly {             log3(activityData, activityCode, activi ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ChallengeLogger {\n    function logChallenge(uint256 challengeId) public {\n        bytes memory challengeBytes = abi.encodePacked(challengeId);\n        assembly {\n            log2(challengeBytes, challengeId, challengeId)\n        }\n    }\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/116.sol:1:207:\n  |\n1 |  ... d);         assembly {             log2(challengeBytes, challengeId, chall ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IssueLogger {\n    function logIssue(uint256 issueNumber) public {\n        bytes memory issueBytes = abi.encodePacked(issueNumber);\n        assembly {\n            log0(issueBytes)\n        }\n    }\n    function anotherHelper() public pure {}\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/117.sol:1:195:\n  |\n1 |  ... r);         assembly {             log0(issueBytes)         }     }     fu ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract AlertRecorder {\n    function recordAlert(string memory alertText) public {\n        bytes memory alertBytes = bytes(alertText);\n        assembly {\n            log0(alertBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/118.sol:1:191:\n  |\n1 |  ... t);         assembly {             log0(alertBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract UpdateNotifier {\n    function notifyUpdate(uint256 updateTag) public {\n        bytes memory updateBytes = abi.encodePacked(updateTag);\n        assembly {\n            log1(updateBytes, updateTag)\n        }\n    }\n    function extraFeature() public pure {}\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/119.sol:1:199:\n  |\n1 |  ... g);         assembly {             log1(updateBytes, updateTag)         }  ...\n  |                                         ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract FeedbackTracker {\n    function trackFeedback(uint256 feedbackNumber) public {\n        bytes memory feedbackBytes = abi.encodePacked(feedbackNumber);\n        assembly {\n            log2(feedbackBytes, feedbackNumber, feedbackNumber)\n        }\n    }\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/120.sol:1:213:\n  |\n1 |  ... r);         assembly {             log2(feedbackBytes, feedbackNumber, fee ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract NotificationDispatcher {\n    function dispatchNotification(string memory notificationMessage) public {\n        bytes memory notificationBytes = bytes(notificationMessage);\n        assembly {\n            log1(notificationBytes, notificationMessage)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/121.sol:1:236:\n  |\n1 |  ... e);         assembly {             log1(notificationBytes, notificationMes ...\n  |                                         ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract SignalLogger {\n    event SignalLogged(uint256 signalValue);\n    function logSignal(uint256 signalValue) public {\n        emit SignalLogged(signalValue);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ReviewTracker {\n    event ReviewTracked(int256 reviewScore);\n    function trackReview(int256 reviewScore) public {\n        emit ReviewTracked(reviewScore);\n    }\n    function additionalMethod() public pure returns (uint) { return 100; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract QueryLogger {\n    event QueryLogged(bytes32 queryHash);\n    function logQuery(bytes32 queryHash) public {\n        emit QueryLogged(queryHash);\n    }\n    function helper() public pure {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ActivityTracker {\n    event ActivityTracked(uint256 activityCode);\n    function trackActivity(uint256 activityCode) public {\n        emit ActivityTracked(activityCode);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ChallengeLogger {\n    event ChallengeLogged(uint256 challengeId);\n    function logChallenge(uint256 challengeId) public {\n        emit ChallengeLogged(challengeId);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IssueLogger {\n    event IssueLogged(uint256 issueNumber);\n    function logIssue(uint256 issueNumber) public {\n        emit IssueLogged(issueNumber);\n    }\n    function anotherHelper() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract AlertRecorder {\n    event AlertRecorded(string alertText);\n    function recordAlert(string memory alertText) public {\n        emit AlertRecorded(alertText);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract UpdateNotifier {\n    event UpdateNotified(uint256 updateTag);\n    function notifyUpdate(uint256 updateTag) public {\n        emit UpdateNotified(updateTag);\n    }\n    function extraFeature() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract FeedbackTracker {\n    event FeedbackTracked(uint256 feedbackNumber);\n    function trackFeedback(uint256 feedbackNumber) public {\n        emit FeedbackTracked(feedbackNumber);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract NotificationDispatcher {\n    event NotificationDispatched(string notificationMessage);\n    function dispatchNotification(string memory notificationMessage) public {\n        emit NotificationDispatched(notificationMessage);\n    }\n}"
      }
    }
  },
  {
    "Changes88": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Declarations with the name <code>this</code>, <code>super</code> and <code>_</code> are disallowed, with the exception of\npublic functions and events. The exception is to make it possible to declare interfaces of contracts\nimplemented in languages other than Solidity that do permit such function names.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorOne {\n    uint256 public super;\n\n    function updateSuper(uint256 val) public {\n        super = val;\n    }\n\n    function extraOne() public pure returns (uint256) {\n        return 10;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/122.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract ErrorOne {     uint256 public super;      function updateSuper(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorTwo {\n    string public this;\n\n    function setThis(string calldata val) public {\n        this = val;\n    }\n\n    function extraTwo() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/123.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract ErrorTwo {     string public this;      function setThis(string call ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorThree {\n    bool public _;\n\n    function toggle_() public {\n        _ = !_;\n    }\n\n    function extraThree() public pure returns (string memory) {\n        return \"toggle\";\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/124.sol:1:51:\n  |\n1 |  ... ^0.8.0;  contract ErrorThree {     bool public _;      function toggle_() public {  ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorFour {\n    uint256 public this;\n\n    function modifyThis(uint256 newValue) public {\n        this = newValue;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/125.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ErrorFour {     uint256 public this;      function modifyThis(uint256  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorFive {\n    bytes32 public super;\n\n    function changeSuper(bytes32 newVal) public {\n        super = newVal;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/126.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ErrorFive {     bytes32 public super;      function changeSuper(bytes32 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorSix {\n    uint256 public _;\n\n    function increment_() public {\n        _ += 1;\n    }\n\n    function extraSix() public pure returns (uint256) {\n        return _;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/127.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract ErrorSix {     uint256 public _;      function increment_() public ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorSeven {\n    address public this;\n\n    function updateThis(address newVal) public {\n        this = newVal;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/128.sol:1:51:\n  |\n1 |  ... ^0.8.0;  contract ErrorSeven {     address public this;      function updateThis(address  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorEight {\n    int256 public super;\n\n    function decrementSuper(int256 decrementValue) public {\n        super -= decrementValue;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/129.sol:1:51:\n  |\n1 |  ... ^0.8.0;  contract ErrorEight {     int256 public super;      function decrementSuper(int2 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorNine {\n    uint256 public this;\n\n    function refreshThis(uint256 value) public {\n        this = value;\n    }\n\n    function extraNine() public pure returns (uint256) {\n        return 100;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/130.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ErrorNine {     uint256 public this;      function refreshThis(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorTen {\n    string public _;\n\n    function set_(string calldata newVal) public {\n        _ = newVal;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/131.sol:1:49:\n  |\n1 | pragma solidity^0.8.0;  contract ErrorTen {     string public _;      function set_(string calldata newVal) public {         _ = newVal;     } }\n  |                                                 ^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract FixedOne {\n    uint256 public value;\n\n    function updateValue(uint256 val) public {\n        value = val;\n    }\n\n    function extraOne() public pure returns (uint256) {\n        return 10;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract FixedTwo {\n    string public variable;\n\n    function setVariable(string calldata val) public {\n        variable = val;\n    }\n\n    function extraTwo() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract FixedThree {\n    bool public state;\n\n    function toggleState() public {\n        state = !state;\n    }\n\n    function extraThree() public pure returns (string memory) {\n        return \"toggle\";\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract FixedFour {\n    uint256 public value;\n\n    function modifyValue(uint256 newValue) public {\n        value = newValue;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract FixedFive {\n    bytes32 public value;\n\n    function changeValue(bytes32 newVal) public {\n        value = newVal;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract FixedSix {\n    uint256 public value;\n\n    function incrementValue() public {\n        value += 1;\n    }\n\n    function extraSix() public pure returns (uint256) {\n        return value;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract FixedSeven {\n    address public addressValue;\n\n    function updateAddress(address newVal) public {\n        addressValue = newVal;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract FixedEight {\n    int256 public value;\n\n    function decrementValue(int256 decrementValue) public {\n        value -= decrementValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract FixedNine {\n    uint256 public value;\n\n    function refreshValue(uint256 newVal) public {\n        value = newVal;\n    }\n\n    function extraNine() public pure returns (uint256) {\n        return 100;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract FixedTen {\n    string public value;\n\n    function setValue(string calldata newVal) public {\n        value = newVal;\n    }\n}"
      }
    }
  },
  {
    "Changes89": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Remove support for the <code>b</code>, <code>f</code>, and <code>v</code> escape sequences in code.\nThey can still be inserted via hexadecimal escapes, e.g. <code>x08</code>, <code>x0c</code>, and <code>x0b</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharOne {\n    string public sequenceOne = \"Invalid sequence: \\b\";\n    function getSequenceOne() public view returns (string memory) {\n        return sequenceOne;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/132.sol:1:82:\n  |\n1 |  ...  {     string public sequenceOne = \"Invalid sequence: \\b\";     function getSequenceOne() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharTwo {\n    string public sequenceTwo = \"Invalid sequence: \\f\";\n    function getSequenceTwo() public view returns (string memory) {\n        return sequenceTwo;\n    }\n    function randomExtra() public pure returns (int) {\n        return 22;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/133.sol:1:82:\n  |\n1 |  ...  {     string public sequenceTwo = \"Invalid sequence: \\f\";     function getSequenceTwo() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharThree {\n    string public sequenceThree = \"Invalid sequence: \\v\";\n    function getSequenceThree() public view returns (string memory) {\n        return sequenceThree;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/134.sol:1:86:\n  |\n1 |  ...      string public sequenceThree = \"Invalid sequence: \\v\";     function getSequenceThree()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharFour {\n    string public sequenceFour = \"Invalid sequence: \\b\";\n    function getSequenceFour() public view returns (string memory) {\n        return sequenceFour;\n    }\n    function unusedFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/135.sol:1:84:\n  |\n1 |  ... {     string public sequenceFour = \"Invalid sequence: \\b\";     function getSequenceFour() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharFive {\n    string public sequenceFive = \"Invalid sequence: \\v\";\n    function getSequenceFive() public view returns (string memory) {\n        return sequenceFive;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/136.sol:1:84:\n  |\n1 |  ... {     string public sequenceFive = \"Invalid sequence: \\v\";     function getSequenceFive() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharSix {\n    string public sequenceSix = \"Invalid sequence: \\f\";\n    function getSequenceSix() public view returns (string memory) {\n        return sequenceSix;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/137.sol:1:82:\n  |\n1 |  ...  {     string public sequenceSix = \"Invalid sequence: \\f\";     function getSequenceSix() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharSeven {\n    string public sequenceSeven = \"Invalid sequence: \\b\";\n    function getSequenceSeven() public view returns (string memory) {\n        return sequenceSeven;\n    }\n    function helperFunction() public pure returns (uint) {\n        return 777;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/138.sol:1:86:\n  |\n1 |  ...      string public sequenceSeven = \"Invalid sequence: \\b\";     function getSequenceSeven()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharEight {\n    string public sequenceEight = \"Invalid sequence: \\v\";\n    function getSequenceEight() public view returns (string memory) {\n        return sequenceEight;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/139.sol:1:86:\n  |\n1 |  ...      string public sequenceEight = \"Invalid sequence: \\v\";     function getSequenceEight()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharNine {\n    string public sequenceNine = \"Invalid sequence: \\f\";\n    function getSequenceNine() public view returns (string memory) {\n        return sequenceNine;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/140.sol:1:84:\n  |\n1 |  ... {     string public sequenceNine = \"Invalid sequence: \\f\";     function getSequenceNine() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharTen {\n    string public sequenceTen = \"Invalid sequence: \\b\";\n    function getSequenceTen() public view returns (string memory) {\n        return sequenceTen;\n    }\n    function additionalMethod() public pure returns (string memory) {\n        return \"Additional content\";\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/141.sol:1:82:\n  |\n1 |  ...  {     string public sequenceTen = \"Invalid sequence: \\b\";     function getSequenceTen() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract InvalidCharOne {\n    string public sequenceOne = \"Invalid sequence: \\x08\";\n    function getSequenceOne() public view returns (string memory) {\n        return sequenceOne;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract InvalidCharTwo {\n    string public sequenceTwo = \"Invalid sequence: \\x0c\";\n    function getSequenceTwo() public view returns (string memory) {\n        return sequenceTwo;\n    }\n    function randomExtra() public pure returns (int) {\n        return 22;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract InvalidCharThree {\n    string public sequenceThree = \"Invalid sequence: \\x0b\";\n    function getSequenceThree() public view returns (string memory) {\n        return sequenceThree;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract InvalidCharFour {\n    string public sequenceFour = \"Invalid sequence: \\x08\";\n    function getSequenceFour() public view returns (string memory) {\n        return sequenceFour;\n    }\n    function unusedFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract InvalidCharFive {\n    string public sequenceFive = \"Invalid sequence: \\x0b\";\n    function getSequenceFive() public view returns (string memory) {\n        return sequenceFive;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract InvalidCharSix {\n    string public sequenceSix = \"Invalid sequence: \\x0c\";\n    function getSequenceSix() public view returns (string memory) {\n        return sequenceSix;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract InvalidCharSeven {\n    string public sequenceSeven = \"Invalid sequence: \\x08\";\n    function getSequenceSeven() public view returns (string memory) {\n        return sequenceSeven;\n    }\n    function helperFunction() public pure returns (uint) {\n        return 777;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract InvalidCharEight {\n    string public sequenceEight = \"Invalid sequence: \\x0b\";\n    function getSequenceEight() public view returns (string memory) {\n        return sequenceEight;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract InvalidCharNine {\n    string public sequenceNine = \"Invalid sequence: \\x0c\";\n    function getSequenceNine() public view returns (string memory) {\n        return sequenceNine;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract InvalidCharTen {\n    string public sequenceTen = \"Invalid sequence: \\x08\";\n    function getSequenceTen() public view returns (string memory) {\n        return sequenceTen;\n    }\n    function additionalMethod() public pure returns (string memory) {\n        return \"Additional content\";\n    }\n}"
      }
    }
  },
  {
    "Changes90": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The global variables <code>tx.origin</code> and <code>msg.sender</code> have the type <code>address</code> instead of\n<code>address payable</code>. One can convert them into <code>address payable</code> by using an explicit\nconversion, i.e., <code>payable(tx.origin)</code> or <code>payable(msg.sender)</code>.This change was done since the compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible.Change <code>msg.sender.transfer(x)</code> to <code>payable(msg.sender).transfer(x)</code> or use a stored variable of <code>address payable</code> type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetAllocator {\n    function allocateAsset() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/142.sol:1:104:\n  |\n1 | pragma solidity^0.8.0; contract AssetAllocator {     function allocateAsset() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                        ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueDistributor {\n    function distributeRevenue() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function extraProcess() public pure returns (int) { return 100; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/143.sol:1:112:\n  |\n1 |  ... Revenue() public payable {         msg.sender.transfer(msg.value);     }     function ext ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ExpenseRefunder {\n    function refundExpense() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function helper() public pure returns (string memory) { return \"Helper\"; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/144.sol:1:105:\n  |\n1 |  ... Expense() public payable {         msg.sender.transfer(msg.value);     }     function hel ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract BonusPayer {\n    function payBonus() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/145.sol:1:95:\n  |\n1 | pragma solidity^0.8.0; contract BonusPayer {     function payBonus() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                               ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ProfitHandler {\n    function handleProfit() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function doSomething() public pure returns (bool) { return true; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/146.sol:1:102:\n  |\n1 |  ... eProfit() public payable {         msg.sender.transfer(msg.value);     }     function doS ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract DonationCollector {\n    function collectDonation() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/147.sol:1:109:\n  |\n1 | pragma solidity^0.8.0; contract DonationCollector {     function collectDonation() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                             ^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract StipendIssuer {\n    function issueStipend() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/148.sol:1:102:\n  |\n1 | pragma solidity^0.8.0; contract StipendIssuer {     function issueStipend() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                      ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract RewardDisburser {\n    function disburseReward() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function additionalFeature() public pure {}\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/149.sol:1:106:\n  |\n1 |  ... eReward() public payable {         msg.sender.transfer(msg.value);     }     function add ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ScholarshipDistributor {\n    function distributeScholarship() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/150.sol:1:120:\n  |\n1 |  ... larship() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentHandler {\n    function handlePayment() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function utilityFunction() public pure returns (uint) { return 777; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/151.sol:1:104:\n  |\n1 |  ... Payment() public payable {         msg.sender.transfer(msg.value);     }     function uti ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract AssetAllocator {\n    function allocateAsset() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract RevenueDistributor {\n    function distributeRevenue() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function extraProcess() public pure returns (int) { return 100; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ExpenseRefunder {\n    function refundExpense() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function helper() public pure returns (string memory) { return \"Helper\"; }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract BonusPayer {\n    function payBonus() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ProfitHandler {\n    function handleProfit() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function doSomething() public pure returns (bool) { return true; }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract DonationCollector {\n    function collectDonation() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract StipendIssuer {\n    function issueStipend() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract RewardDisburser {\n    function disburseReward() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function additionalFeature() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ScholarshipDistributor {\n    function distributeScholarship() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract PaymentHandler {\n    function handlePayment() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function utilityFunction() public pure returns (uint) { return 777; }\n}"
      }
    }
  },
  {
    "Changes91": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The <code>chainid</code> builtin in inline assembly is now considered <code>view</code> instead of <code>pure</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainInterface {\n    function interfaceChain() public pure returns (uint256) {\n        uint256 cID;\n        assembly {\n            cID := chainid\n        }\n        return cID;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/152.sol:1:172:\n  |\n1 |  ...      assembly {             cID := chainid         }         return cID;      ...\n  |                                         ^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkPortal {\n    function portalNetwork() public pure returns (uint256) {\n        uint256 netID;\n        assembly {\n            netID := chainid\n        }\n        return netID;\n    }\n    function randomOne() public pure returns (uint256) { return 301; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/153.sol:1:174:\n  |\n1 |  ...    assembly {             netID := chainid         }         return netID;    ...\n  |                                         ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainRegistry {\n    function registryChain() public pure returns (uint256) {\n        uint256 registry;\n        assembly {\n            registry := chainid\n        }\n        return registry;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/154.sol:1:180:\n  |\n1 |  ... assembly {             registry := chainid         }         return registry; ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkCore {\n    function coreNetwork() public pure returns (uint256) {\n        uint256 coreID;\n        assembly {\n            coreID := chainid\n        }\n        return coreID;\n    }\n    function helperA() public pure returns (uint256) { return 505; }\n    function helperB() public pure returns (uint256) { return 506; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/155.sol:1:172:\n  |\n1 |  ...   assembly {             coreID := chainid         }         return coreID;   ...\n  |                                         ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainControl {\n    function controlChain() public pure returns (uint256) {\n        uint256 control;\n        assembly {\n            control := chainid\n        }\n        return control;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/156.sol:1:176:\n  |\n1 |  ...  assembly {             control := chainid         }         return control;  ...\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainMechanism {\n    function mechanismChain() public pure returns (uint256) {\n        uint256 mechanism;\n        assembly {\n            mechanism := chainid\n        }\n        return mechanism;\n    }\n    function extraA() public pure returns (uint256) { return 707; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/157.sol:1:184:\n  |\n1 |  ... ssembly {             mechanism := chainid         }         return mechanism ...\n  |                                         ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkInterface {\n    function interfaceNetwork() public pure returns (uint256) {\n        uint256 iface;\n        assembly {\n            iface := chainid\n        }\n        return iface;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/158.sol:1:180:\n  |\n1 |  ...    assembly {             iface := chainid         }         return iface;    ...\n  |                                         ^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainSystem {\n    function systemChain() public pure returns (uint256) {\n        uint256 system;\n        assembly {\n            system := chainid\n        }\n        return system;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/159.sol:1:172:\n  |\n1 |  ...   assembly {             system := chainid         }         return system;   ...\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainOperation {\n    function operationChain() public pure returns (uint256) {\n        uint256 operation;\n        assembly {\n            operation := chainid\n        }\n        return operation;\n    }\n    function unrelatedA() public pure returns (uint256) { return 809; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/160.sol:1:184:\n  |\n1 |  ... ssembly {             operation := chainid         }         return operation ...\n  |                                         ^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkSignal {\n    function signalNetwork() public pure returns (uint256) {\n        uint256 signal;\n        assembly {\n            signal := chainid\n        }\n        return signal;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/161.sol:1:176:\n  |\n1 |  ...   assembly {             signal := chainid         }         return signal;   ...\n  |                                         ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ChainInterface {\n    function interfaceChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract NetworkPortal {\n    function portalNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n    function randomOne() public pure returns (uint256) { return 301; }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ChainRegistry {\n    function registryChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract NetworkCore {\n    function coreNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n    function helperA() public pure returns (uint256) { return 505; }\n    function helperB() public pure returns (uint256) { return 506; }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ChainControl {\n    function controlChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ChainMechanism {\n    function mechanismChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function extraA() public pure returns (uint256) { return 707; }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract NetworkInterface {\n    function interfaceNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ChainSystem {\n    function systemChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ChainOperation {\n    function operationChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function unrelatedA() public pure returns (uint256) { return 809; }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract NetworkSignal {\n    function signalNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n}"
      }
    }
  },
  {
    "Changes92": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Unary negation cannot be used on unsigned integers anymore, only on signed integers.Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. <code>type(uint256).max - x + 1</code>, while ensuring that <code>x</code> is not zero)",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueFlipper {\n    function flipValue(uint param1) public pure returns (uint) {\n        return -param1;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/162.sol:1:128:\n  |\n1 | pragma solidity^0.8.0; contract ValueFlipper {     function flipValue(uint param1) public pure returns (uint) {         return -param1;     } }\n  |                                                                                                                                ^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ReverseLogic {\n    function reverse(uint param2) public pure returns (uint) {\n        return -param2;\n    }\n    function doSomething() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/163.sol:1:126:\n  |\n1 |  ... re returns (uint) {         return -param2;     }     function doSomething()  ...\n  |                                         ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract NumberNegator {\n    function negateNumber(uint param3) public pure returns (uint) {\n        return -param3;\n    }\n    function extraHelper() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/164.sol:1:132:\n  |\n1 |  ... re returns (uint) {         return -param3;     }     function extraHelper()  ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueInverter {\n    function invert(uint param4) public pure returns (uint) {\n        return -param4;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/165.sol:1:126:\n  |\n1 | pragma solidity^0.8.0; contract ValueInverter {     function invert(uint param4) public pure returns (uint) {         return -param4;     } }\n  |                                                                                                                              ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract UnsignedSubtractor {\n    function subtractFrom(uint param5) public pure returns (uint) {\n        return -param5;\n    }\n    function anotherExtra() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/166.sol:1:137:\n  |\n1 |  ... re returns (uint) {         return -param5;     }     function anotherExtra() ...\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract DirectNegation {\n    function directlyNegate(uint param6) public pure returns (uint) {\n        return -param6;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/167.sol:1:135:\n  |\n1 | pragma solidity^0.8.0; contract DirectNegation {     function directlyNegate(uint param6) public pure returns (uint) {         return -param6;     } }\n  |                                                                                                                                       ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract OppositeGenerator {\n    function generateOpposite(uint param7) public pure returns (uint) {\n        return -param7;\n    }\n    function unusedFunc() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/168.sol:1:140:\n  |\n1 |  ... re returns (uint) {         return -param7;     }     function unusedFunc() p ...\n  |                                         ^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract NegativeReturner {\n    function returnNegative(uint param8) public pure returns (uint) {\n        return -param8;\n    }\n    function simpleTask() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/169.sol:1:137:\n  |\n1 |  ... re returns (uint) {         return -param8;     }     function simpleTask() p ...\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ZeroSubtractor {\n    function subtractZero(uint param9) public pure returns (uint) {\n        return -param9;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/170.sol:1:133:\n  |\n1 | pragma solidity^0.8.0; contract ZeroSubtractor {     function subtractZero(uint param9) public pure returns (uint) {         return -param9;     } }\n  |                                                                                                                                     ^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract NegateValue {\n    function negate(uint param10) public pure returns (uint) {\n        return -param10;\n    }\n    function someFunction() public pure {}\n    function someOtherFunction() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/171.sol:1:125:\n  |\n1 |  ... re returns (uint) {         return -param10;     }     function someFunction() ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ValueFlipper {\n    function flipValue(uint param1) public pure returns (uint) {\n        return type(uint).max - param1 + 1;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ReverseLogic {\n    function reverse(uint param2) public pure returns (uint) {\n        return type(uint).max - param2 + 1;\n    }\n    function doSomething() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract NumberNegator {\n    function negateNumber(uint param3) public pure returns (uint) {\n        return type(uint).max - param3 + 1;\n    }\n    function extraHelper() public pure {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ValueInverter {\n    function invert(uint param4) public pure returns (uint) {\n        return type(uint).max - param4 + 1;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract UnsignedSubtractor {\n    function subtractFrom(uint param5) public pure returns (uint) {\n        return type(uint).max - param5 + 1;\n    }\n    function anotherExtra() public pure {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract DirectNegation {\n    function directlyNegate(uint param6) public pure returns (uint) {\n        return type(uint).max - param6 + 1;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract OppositeGenerator {\n    function generateOpposite(uint param7) public pure returns (uint) {\n        return type(uint).max - param7 + 1;\n    }\n    function unusedFunc() public pure {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract NegativeReturner {\n    function returnNegative(uint param8) public pure returns (uint) {\n        return type(uint).max - param8 + 1;\n    }\n    function simpleTask() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ZeroSubtractor {\n    function subtractZero(uint param9) public pure returns (uint) {\n        return type(uint).max - param9 + 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract NegateValue {\n    function negate(uint param10) public pure returns (uint) {\n        return type(uint).max - param10 + 1;\n    }\n    function someFunction() public pure {}\n    function someOtherFunction() public pure {}\n}"
      }
    }
  },
  {
    "Changes93": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractU {\n    byte itemU;\n    function deployItemU(byte newValue) public {\n        itemU = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/2.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractU {     byte itemU;     function deployItemU(byte newValue) public {         itemU = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractV {\n    byte itemV;\n    function saveItemV(byte newValue) public {\n        itemV = newValue;\n    }\n    function additionalFunctionV() public pure returns (uint) {\n        return 2024;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/3.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractV {     byte itemV;     function saveItemV(byte ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractW {\n    byte itemW;\n    function updateItemW(byte newValue) public {\n        itemW = newValue;\n    }\n    function extraFunctionW1() public pure returns (bool) {\n        return false;\n    }\n    function extraFunctionW2() public pure returns (uint) {\n        return 256;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/4.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractW {     byte itemW;     function updateItemW(by ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractX {\n    byte itemX;\n    function modifyItemX(byte newValue) public {\n        itemX = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/5.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractX {     byte itemX;     function modifyItemX(byte newValue) public {         itemX = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractY {\n    byte itemY;\n    function setItemY(byte newValue) public {\n        itemY = newValue;\n    }\n    function dummyFunctionY() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/6.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractY {     byte itemY;     function setItemY(byte  ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractZ {\n    byte itemZ;\n    function adjustItemZ(byte newValue) public {\n        itemZ = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/7.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractZ {     byte itemZ;     function adjustItemZ(byte newValue) public {         itemZ = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractAA {\n    byte itemAA;\n    function changeItemAA(byte newValue) public {\n        itemAA = newValue;\n    }\n    function helperFunctionAA() public pure returns (uint) {\n        return 88;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/8.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractAA {     byte itemAA;     function changeItemAA( ...\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractBB {\n    byte itemBB;\n    function shiftItemBB(byte newValue) public {\n        itemBB = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/9.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractBB {     byte itemBB;     function shiftItemBB(byte newValue) public {         itemBB = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractCC {\n    byte itemCC;\n    function replaceItemCC(byte newValue) public {\n        itemCC = newValue;\n    }\n    function randomFunctionCC() public pure returns (int) {\n        return -7;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/10.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractCC {     byte itemCC;     function replaceItemCC ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractDD {\n    byte itemDD;\n    function refreshItemDD(byte newValue) public {\n        itemDD = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/11.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractDD {     byte itemDD;     function refreshItemDD(byte newValue) public {         itemDD = newValue;     } }\n  |                                                  ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractU {\n    bytes1 itemU;\n    function deployItemU(bytes1 newValue) public {\n        itemU = newValue;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractV {\n    bytes1 itemV;\n    function saveItemV(bytes1 newValue) public {\n        itemV = newValue;\n    }\n    function additionalFunctionV() public pure returns (uint) {\n        return 2024;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractW {\n    bytes1 itemW;\n    function updateItemW(bytes1 newValue) public {\n        itemW = newValue;\n    }\n    function extraFunctionW1() public pure returns (bool) {\n        return false;\n    }\n    function extraFunctionW2() public pure returns (uint) {\n        return 256;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractX {\n    bytes1 itemX;\n    function modifyItemX(bytes1 newValue) public {\n        itemX = newValue;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractY {\n    bytes1 itemY;\n    function setItemY(bytes1 newValue) public {\n        itemY = newValue;\n    }\n    function dummyFunctionY() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractZ {\n    bytes1 itemZ;\n    function adjustItemZ(bytes1 newValue) public {\n        itemZ = newValue;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractAA {\n    bytes1 itemAA;\n    function changeItemAA(bytes1 newValue) public {\n        itemAA = newValue;\n    }\n    function helperFunctionAA() public pure returns (uint) {\n        return 88;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractBB {\n    bytes1 itemBB;\n    function shiftItemBB(bytes1 newValue) public {\n        itemBB = newValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractCC {\n    bytes1 itemCC;\n    function replaceItemCC(bytes1 newValue) public {\n        itemCC = newValue;\n    }\n    function randomFunctionCC() public pure returns (int) {\n        return -7;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractDD {\n    bytes1 itemDD;\n    function refreshItemDD(bytes1 newValue) public {\n        itemDD = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes94": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "In external function and contract creation calls, Ether and gas is now specified using a new syntax:\n<code>x.f{gas: 10000, value: 2 ether}(arg1, arg2)</code>.\nThe old syntax \u2013 <code>x.f.gas(10000).value(2 ether)(arg1, arg2)</code> \u2013 will cause an error.Change <code>x.f.value(...)()</code> to <code>x.f{value: ...}()</code>. Similarly <code>(new C).value(...)()</code> to <code>new C{value: ...}()</code> and <code>x.f.gas(...).value(...)()</code> to <code>x.f{gas: ..., value: ...}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    function actionK() external payable {\n    }\n}\n\ncontract Example11 {\n    ContractK contractK;\n\n    function triggerActionK() public {\n        contractK.actionK.value(0.3 ether)();\n    }\n\n    function miscellaneousFunction11() public pure returns(string memory) {\n        return \"Miscellaneous 11\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionK() public {         contractK.actionK.value(0.3 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    function actionL() external payable {\n    }\n}\n\ncontract Example12 {\n    ContractL contractL;\n\n    function triggerActionL() public {\n        contractL.actionL.value(0.2 ether)();\n    }\n\n    function miscellaneousFunction12() public pure returns(string memory) {\n        return \"Miscellaneous 12\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionL() public {         contractL.actionL.value(0.2 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    function actionM() external payable {\n    }\n}\n\ncontract Example13 {\n    ContractM contractM;\n\n    function triggerActionM() public {\n        contractM.actionM.value(1.5 ether)();\n    }\n\n    function miscellaneousFunction13() public pure returns(string memory) {\n        return \"Miscellaneous 13\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionM() public {         contractM.actionM.value(1.5 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    function actionN() external payable {\n    }\n}\n\ncontract Example14 {\n    ContractN contractN;\n\n    function triggerActionN() public {\n        contractN.actionN.value(0.05 ether)();\n    }\n\n    function miscellaneousFunction14() public pure returns(string memory) {\n        return \"Miscellaneous 14\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionN() public {         contractN.actionN.value(0.05 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    function actionO() external payable {\n    }\n}\n\ncontract Example15 {\n    ContractO contractO;\n\n    function triggerActionO() public {\n        contractO.actionO.value(2.5 ether)();\n    }\n\n    function miscellaneousFunction15() public pure returns(string memory) {\n        return \"Miscellaneous 15\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionO() public {         contractO.actionO.value(2.5 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    function actionP() external payable {\n    }\n}\n\ncontract Example16 {\n    ContractP contractP;\n\n    function triggerActionP() public {\n        contractP.actionP.value(0.4 ether)();\n    }\n\n    function miscellaneousFunction16() public pure returns(string memory) {\n        return \"Miscellaneous 16\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionP() public {         contractP.actionP.value(0.4 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    function actionQ() external payable {\n    }\n}\n\ncontract Example17 {\n    ContractQ contractQ;\n\n    function triggerActionQ() public {\n        contractQ.actionQ.value(3 ether)();\n    }\n\n    function miscellaneousFunction17() public pure returns(string memory) {\n        return \"Miscellaneous 17\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionQ() public {         contractQ.actionQ.value(3 ether)();     }      function mi ...\n                                        ^---------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    function actionR() external payable {\n    }\n}\n\ncontract Example18 {\n    ContractR contractR;\n\n    function triggerActionR() public {\n        contractR.actionR.value(0.75 ether)();\n    }\n\n    function miscellaneousFunction18() public pure returns(string memory) {\n        return \"Miscellaneous 18\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionR() public {         contractR.actionR.value(0.75 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    function actionS() external payable {\n    }\n}\n\ncontract Example19 {\n    ContractS contractS;\n\n    function triggerActionS() public {\n        contractS.actionS.value(1.25 ether)();\n    }\n\n    function miscellaneousFunction19() public pure returns(string memory) {\n        return \"Miscellaneous 19\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionS() public {         contractS.actionS.value(1.25 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    function actionT() external payable {\n    }\n}\n\ncontract Example20 {\n    ContractT contractT;\n\n    function triggerActionT() public {\n        contractT.actionT.value(0.125 ether)();\n    }\n\n    function miscellaneousFunction20() public pure returns(string memory) {\n        return \"Miscellaneous 20\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionT() public {         contractT.actionT.value(0.125 ether)();     }      functio ...\n                                        ^---------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    function actionK() external payable {\n    }\n}\n\ncontract Example11 {\n    ContractK contractK;\n\n    function triggerActionK() public {\n        contractK.actionK{value: 0.3 ether}();\n    }\n\n    function miscellaneousFunction11() public pure returns(string memory) {\n        return \"Miscellaneous 11\";\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    function actionL() external payable {\n    }\n}\n\ncontract Example12 {\n    ContractL contractL;\n\n    function triggerActionL() public {\n        contractL.actionL{value: 0.2 ether}();\n    }\n\n    function miscellaneousFunction12() public pure returns(string memory) {\n        return \"Miscellaneous 12\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    function actionM() external payable {\n    }\n}\n\ncontract Example13 {\n    ContractM contractM;\n\n    function triggerActionM() public {\n        contractM.actionM{value: 1.5 ether}();\n    }\n\n    function miscellaneousFunction13() public pure returns(string memory) {\n        return \"Miscellaneous 13\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    function actionN() external payable {\n    }\n}\n\ncontract Example14 {\n    ContractN contractN;\n\n    function triggerActionN() public {\n        contractN.actionN{value: 0.05 ether}();\n    }\n\n    function miscellaneousFunction14() public pure returns(string memory) {\n        return \"Miscellaneous 14\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    function actionO() external payable {\n    }\n}\n\ncontract Example15 {\n    ContractO contractO;\n\n    function triggerActionO() public {\n        contractO.actionO{value: 2.5 ether}();\n    }\n\n    function miscellaneousFunction15() public pure returns(string memory) {\n        return \"Miscellaneous 15\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    function actionP() external payable {\n    }\n}\n\ncontract Example16 {\n    ContractP contractP;\n\n    function triggerActionP() public {\n        contractP.actionP{value: 0.4 ether}();\n    }\n\n    function miscellaneousFunction16() public pure returns(string memory) {\n        return \"Miscellaneous 16\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    function actionQ() external payable {\n    }\n}\n\ncontract Example17 {\n    ContractQ contractQ;\n\n    function triggerActionQ() public {\n        contractQ.actionQ{value: 3 ether}();\n    }\n\n    function miscellaneousFunction17() public pure returns(string memory) {\n        return \"Miscellaneous 17\";\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    function actionR() external payable {\n    }\n}\n\ncontract Example18 {\n    ContractR contractR;\n\n    function triggerActionR() public {\n        contractR.actionR{value: 0.75 ether}();\n    }\n\n    function miscellaneousFunction18() public pure returns(string memory) {\n        return \"Miscellaneous 18\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    function actionS() external payable {\n    }\n}\n\ncontract Example19 {\n    ContractS contractS;\n\n    function triggerActionS() public {\n        contractS.actionS{value: 1.25 ether}();\n    }\n\n    function miscellaneousFunction19() public pure returns(string memory) {\n        return \"Miscellaneous 19\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    function actionT() external payable {\n    }\n}\n\ncontract Example20 {\n    ContractT contractT;\n\n    function triggerActionT() public {\n        contractT.actionT{value: 0.125 ether}();\n    }\n\n    function miscellaneousFunction20() public pure returns(string memory) {\n        return \"Miscellaneous 20\";\n    }\n}"
      }
    }
  },
  {
    "Changes95": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The global variable <code>now</code> is deprecated, <code>block.timestamp</code> should be used instead.\nThe single identifier <code>now</code> is too generic for a global variable and could give the impression\nthat it changes during transaction processing, whereas <code>block.timestamp</code> correctly\nreflects the fact that it is just a property of the block.Change <code>now</code> to <code>block.timestamp</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public lastCheckpoint;\n\n    function markCheckpoint() public {\n        lastCheckpoint = now;\n    }\n\n    uint public checkpointsMade;\n\n    function incrementCheckpoints() public {\n        checkpointsMade++;\n    }\n}",
          "error message": ":1:143: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ...  public {         lastCheckpoint = now;     }      uint public checkpoint ...\n                                        ^-^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public lastReset;\n\n    function reset() public {\n        lastReset = now;\n    }\n\n    uint public resetCount;\n\n    function incrementResetCount() public {\n        resetCount++;\n    }\n}",
          "error message": ":1:124: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... set() public {         lastReset = now;     }      uint public resetCount ...\n                                        ^-^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public lastEntry;\n\n    function logEntry() public {\n        lastEntry = now;\n    }\n\n    uint public entriesLogged;\n\n    function incrementEntriesLogged() public {\n        entriesLogged++;\n    }\n}",
          "error message": ":1:127: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... try() public {         lastEntry = now;     }      uint public entriesLog ...\n                                        ^-^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public lastSignIn;\n\n    function signIn() public {\n        lastSignIn = now;\n    }\n\n    uint public signInCount;\n\n    function incrementSignInCount() public {\n        signInCount++;\n    }\n}",
          "error message": ":1:127: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... In() public {         lastSignIn = now;     }      uint public signInCoun ...\n                                        ^-^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public lastRegistration;\n\n    function register() public {\n        lastRegistration = now;\n    }\n\n    uint public registrationCount;\n\n    function incrementRegistrationCount() public {\n        registrationCount++;\n    }\n}",
          "error message": ":1:141: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ublic {         lastRegistration = now;     }      uint public registrati ...\n                                        ^-^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public lastActivity;\n\n    function recordActivity() public {\n        lastActivity = now;\n    }\n\n    uint public activityCount;\n\n    function incrementActivityCount() public {\n        activityCount++;\n    }\n}",
          "error message": ":1:139: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastActivity = now;     }      uint public activityCo ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public lastPurchase;\n\n    function makePurchase() public {\n        lastPurchase = now;\n    }\n\n    uint public purchaseCount;\n\n    function incrementPurchaseCount() public {\n        purchaseCount++;\n    }\n}",
          "error message": ":1:137: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastPurchase = now;     }      uint public purchaseCo ...\n                                        ^-^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public lastDownload;\n\n    function download() public {\n        lastDownload = now;\n    }\n\n    uint public downloadCount;\n\n    function incrementDownloadCount() public {\n        downloadCount++;\n    }\n}",
          "error message": ":1:133: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastDownload = now;     }      uint public downloadCo ...\n                                        ^-^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public lastModification;\n\n    function modify() public {\n        lastModification = now;\n    }\n\n    uint public modificationsMade;\n\n    function incrementModifications() public {\n        modificationsMade++;\n    }\n}",
          "error message": ":1:139: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ublic {         lastModification = now;     }      uint public modificati ...\n                                        ^-^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public lastQuery;\n\n    function query() public {\n        lastQuery = now;\n    }\n\n    uint public queryCount;\n\n    function incrementQueryCount() public {\n        queryCount++;\n    }\n}",
          "error message": ":1:124: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ery() public {         lastQuery = now;     }      uint public queryCount ...\n                                        ^-^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public lastCheckpoint;\n\n    function markCheckpoint() public {\n        lastCheckpoint = block.timestamp;\n    }\n\n    uint public checkpointsMade;\n\n    function incrementCheckpoints() public {\n        checkpointsMade++;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public lastReset;\n\n    function reset() public {\n        lastReset = block.timestamp;\n    }\n\n    uint public resetCount;\n\n    function incrementResetCount() public {\n        resetCount++;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public lastEntry;\n\n    function logEntry() public {\n        lastEntry = block.timestamp;\n    }\n\n    uint public entriesLogged;\n\n    function incrementEntriesLogged() public {\n        entriesLogged++;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public lastSignIn;\n\n    function signIn() public {\n        lastSignIn = block.timestamp;\n    }\n\n    uint public signInCount;\n\n    function incrementSignInCount() public {\n        signInCount++;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public lastRegistration;\n\n    function register() public {\n        lastRegistration = block.timestamp;\n    }\n\n    uint public registrationCount;\n\n    function incrementRegistrationCount() public {\n        registrationCount++;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public lastActivity;\n\n    function recordActivity() public {\n        lastActivity = block.timestamp;\n    }\n\n    uint public activityCount;\n\n    function incrementActivityCount() public {\n        activityCount++;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public lastPurchase;\n\n    function makePurchase() public {\n        lastPurchase = block.timestamp;\n    }\n\n    uint public purchaseCount;\n\n    function incrementPurchaseCount() public {\n        purchaseCount++;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public lastDownload;\n\n    function download() public {\n        lastDownload = block.timestamp;\n    }\n\n    uint public downloadCount;\n\n    function incrementDownloadCount() public {\n        downloadCount++;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public lastModification;\n\n    function modify() public {\n        lastModification = block.timestamp;\n    }\n\n    uint public modificationsMade;\n\n    function incrementModifications() public {\n        modificationsMade++;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public lastQuery;\n\n    function query() public {\n        lastQuery = block.timestamp;\n    }\n\n    uint public queryCount;\n\n    function incrementQueryCount() public {\n        queryCount++;\n    }\n}"
      }
    }
  },
  {
    "Changes96": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "NatSpec comments on variables are only allowed for public state variables and not\nfor local or internal variables.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public length;\n\n    function setLength(uint256 _length) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localLength = _length;\n        length = localLength;\n    }\n\n    function getLength() public view returns (uint256) {\n        return length;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:528: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public width;\n\n    function setWidth(uint256 _width) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localWidth = _width;\n        width = localWidth;\n    }\n\n    function getWidth() public view returns (uint256) {\n        return width;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:632: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public height;\n\n    function setHeight(uint256 _height) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localHeight = _height;\n        height = localHeight;\n    }\n\n    function getHeight() public view returns (uint256) {\n        return height;\n    }\n}",
          "error message": ":1:421: ParserError: Function, variable, struct or modifier declaration expected.\n ... 6) {         return height;     } }\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public depth;\n\n    function setDepth(uint256 _depth) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localDepth = _depth;\n        depth = localDepth;\n    }\n\n    function getDepth() public view returns (uint256) {\n        return depth;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:519: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public radius;\n\n    function setRadius(uint256 _radius) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localRadius = _radius;\n        radius = localRadius;\n    }\n\n    function getRadius() public view returns (uint256) {\n        return radius;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
          "error message": ":1:531: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 1\";     } }\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public diameter;\n\n    function setDiameter(uint256 _diameter) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localDiameter = _diameter;\n        diameter = localDiameter;\n    }\n\n    function getDiameter() public view returns (uint256) {\n        return diameter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:659: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public volume;\n\n    function setVolume(uint256 _volume) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localVolume = _volume;\n        volume = localVolume;\n    }\n\n    function getVolume() public view returns (uint256) {\n        return volume;\n    }\n}",
          "error message": ":1:421: ParserError: Function, variable, struct or modifier declaration expected.\n ... 6) {         return volume;     } }\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public area;\n\n    function setArea(uint256 _area) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localArea = _area;\n        area = localArea;\n    }\n\n    function getArea() public view returns (uint256) {\n        return area;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:510: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public perimeter;\n\n    function setPerimeter(uint256 _perimeter) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localPerimeter = _perimeter;\n        perimeter = localPerimeter;\n    }\n\n    function getPerimeter() public view returns (uint256) {\n        return perimeter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
          "error message": ":1:558: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 1\";     } }\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public circumference;\n\n    function setCircumference(uint256 _circumference) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localCircumference = _circumference;\n        circumference = localCircumference;\n    }\n\n    function getCircumference() public view returns (uint256) {\n        return circumference;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:704: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    uint256 public length;\n\n    function setLength(uint256 _length) public {\n        uint256 localLength = _length;\n        length = localLength;\n    }\n\n    function getLength() public view returns (uint256) {\n        return length;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    uint256 public width;\n\n    function setWidth(uint256 _width) public {\n        uint256 localWidth = _width;\n        width = localWidth;\n    }\n\n    function getWidth() public view returns (uint256) {\n        return width;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    uint256 public height;\n\n    function setHeight(uint256 _height) public {\n        uint256 localHeight = _height;\n        height = localHeight;\n    }\n\n    function getHeight() public view returns (uint256) {\n        return height;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    uint256 public depth;\n\n    function setDepth(uint256 _depth) public {\n        uint256 localDepth = _depth;\n        depth = localDepth;\n    }\n\n    function getDepth() public view returns (uint256) {\n        return depth;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    uint256 public radius;\n\n    function setRadius(uint256 _radius) public {\n        uint256 localRadius = _radius;\n        radius = localRadius;\n    }\n\n    function getRadius() public view returns (uint256) {\n        return radius;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    uint256 public diameter;\n\n    function setDiameter(uint256 _diameter) public {\n        uint256 localDiameter = _diameter;\n        diameter = localDiameter;\n    }\n\n    function getDiameter() public view returns (uint256) {\n        return diameter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    uint256 public volume;\n\n    function setVolume(uint256 _volume) public {\n        uint256 localVolume = _volume;\n        volume = localVolume;\n    }\n\n    function getVolume() public view returns (uint256) {\n        return volume;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    uint256 public area;\n\n    function setArea(uint256 _area) public {\n        uint256 localArea = _area;\n        area = localArea;\n    }\n\n    function getArea() public view returns (uint256) {\n        return area;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    uint256 public perimeter;\n\n    function setPerimeter(uint256 _perimeter) public {\n        uint256 localPerimeter = _perimeter;\n        perimeter = localPerimeter;\n    }\n\n    function getPerimeter() public view returns (uint256) {\n        return perimeter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    uint256 public circumference;\n\n    function setCircumference(uint256 _circumference) public {\n        uint256 localCircumference = _circumference;\n        circumference = localCircumference;\n    }\n\n    function getCircumference() public view returns (uint256) {\n        return circumference;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}"
      }
    }
  },
  {
    "Changes97": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The token <code>gwei</code> is a keyword now (used to specify, e.g. <code>2 gwei</code> as a number)\nand cannot be used as an identifier.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public gwei;\n    uint public amount;\n\n    constructor(uint _amount) public {\n        gwei = 450;\n        amount = _amount;\n    }\n\n    function setGweiAmount(uint _gwei, uint _amount) public {\n        gwei = _gwei;\n        amount = _amount;\n    }\n\n    function getGweiAmount() public view returns (uint, uint) {\n        return (gwei, amount);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example11 {     uint public gwei;     uint public amount;      cons ...\n                                        ^--^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public gwei;\n    bool public isActive;\n\n    constructor() public {\n        gwei = 900;\n        isActive = true;\n    }\n\n    function toggleActive() public {\n        isActive = !isActive;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gwei, isActive);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example12 {     uint public gwei;     bool public isActive;      co ...\n                                        ^--^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public gwei;\n    uint public rate;\n\n    constructor(uint _rate) public {\n        gwei = 600;\n        rate = _rate;\n    }\n\n    function setGweiRate(uint _gwei, uint _rate) public {\n        gwei = _gwei;\n        rate = _rate;\n    }\n\n    function getGweiRate() public view returns (uint, uint) {\n        return (gwei, rate);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example13 {     uint public gwei;     uint public rate;      constr ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public gwei;\n\n    constructor() public {\n        gwei = 350;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGwei() public view returns (uint) {\n        return gwei;\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example14 {     uint public gwei;      constructor() public {       ...\n                                        ^--^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public gwei;\n    address public owner;\n\n    constructor(address _owner) public {\n        gwei = 250;\n        owner = _owner;\n    }\n\n    function setOwnerGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiOwner() public view returns (uint, address) {\n        return (gwei, owner);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example15 {     uint public gwei;     address public owner;      co ...\n                                        ^--^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public gwei;\n    string public description;\n\n    constructor(string memory _description) public {\n        gwei = 700;\n        description = _description;\n    }\n\n    function modifyGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiDescription() public view returns (uint, string memory) {\n        return (gwei, description);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example16 {     uint public gwei;     string public description;    ...\n                                        ^--^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public gwei;\n    bool public status;\n\n    constructor() public {\n        gwei = 80;\n        status = false;\n    }\n\n    function setGweiStatus(uint _gwei, bool _status) public {\n        gwei = _gwei;\n        status = _status;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gwei, status);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example17 {     uint public gwei;     bool public status;      cons ...\n                                        ^--^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public gwei;\n    uint public price;\n\n    constructor(uint _price) public {\n        gwei = 100;\n        price = _price;\n    }\n\n    function setGweiPrice(uint _gwei, uint _price) public {\n        gwei = _gwei;\n        price = _price;\n    }\n\n    function getGweiPrice() public view returns (uint, uint) {\n        return (gwei, price);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example18 {     uint public gwei;     uint public price;      const ...\n                                        ^--^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public gwei;\n    uint public count;\n\n    constructor() public {\n        gwei = 123;\n        count = 0;\n    }\n\n    function incrementCount() public {\n        count++;\n    }\n\n    function setGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiCount() public view returns (uint, uint) {\n        return (gwei, count);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example19 {     uint public gwei;     uint public count;      const ...\n                                        ^--^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public gwei;\n    string public info;\n\n    constructor(string memory _info) public {\n        gwei = 987;\n        info = _info;\n    }\n\n    function updateGweiInfo(uint _gwei, string memory _info) public {\n        gwei = _gwei;\n        info = _info;\n    }\n\n    function getGweiInfo() public view returns (uint, string memory) {\n        return (gwei, info);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example20 {     uint public gwei;     string public info;      cons ...\n                                        ^--^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public gweiValue;\n    uint public amount;\n\n    constructor(uint _amount) public {\n        gweiValue = 450;\n        amount = _amount;\n    }\n\n    function setGweiAmount(uint _gwei, uint _amount) public {\n        gweiValue = _gwei;\n        amount = _amount;\n    }\n\n    function getGweiAmount() public view returns (uint, uint) {\n        return (gweiValue, amount);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public gweiValue;\n    bool public isActive;\n\n    constructor() public {\n        gweiValue = 900;\n        isActive = true;\n    }\n\n    function toggleActive() public {\n        isActive = !isActive;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gweiValue, isActive);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public gweiValue;\n    uint public rate;\n\n    constructor(uint _rate) public {\n        gweiValue = 600;\n        rate = _rate;\n    }\n\n    function setGweiRate(uint _gwei, uint _rate) public {\n        gweiValue = _gwei;\n        rate = _rate;\n    }\n\n    function getGweiRate() public view returns (uint, uint) {\n        return (gweiValue, rate);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public gweiValue;\n\n    constructor() public {\n        gweiValue = 350;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGwei() public view returns (uint) {\n        return gweiValue;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public gweiValue;\n    address public owner;\n\n    constructor(address _owner) public {\n        gweiValue = 250;\n        owner = _owner;\n    }\n\n    function setOwnerGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiOwner() public view returns (uint, address) {\n        return (gweiValue, owner);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public gweiValue;\n    string public description;\n\n    constructor(string memory _description) public {\n        gweiValue = 700;\n        description = _description;\n    }\n\n    function modifyGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiDescription() public view returns (uint, string memory) {\n        return (gweiValue, description);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public gweiValue;\n    bool public status;\n\n    constructor() public {\n        gweiValue = 80;\n        status = false;\n    }\n\n    function setGweiStatus(uint _gwei, bool _status) public {\n        gweiValue = _gwei;\n        status = _status;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gweiValue, status);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public gweiValue;\n    uint public price;\n\n    constructor(uint _price) public {\n        gweiValue = 100;\n        price = _price;\n    }\n\n    function setGweiPrice(uint _gwei, uint _price) public {\n        gweiValue = _gwei;\n        price = _price;\n    }\n\n    function getGweiPrice() public view returns (uint, uint) {\n        return (gweiValue, price);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public gweiValue;\n    uint public count;\n\n    constructor() public {\n        gweiValue = 123;\n        count = 0;\n    }\n\n    function incrementCount() public {\n        count++;\n    }\n\n    function setGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiCount() public view returns (uint, uint) {\n        return (gweiValue, count);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public gweiValue;\n    string public info;\n\n    constructor(string memory _info) public {\n        gweiValue = 987;\n        info = _info;\n    }\n\n    function updateGweiInfo(uint _gwei, string memory _info) public {\n        gweiValue = _gwei;\n        info = _info;\n    }\n\n    function getGweiInfo() public view returns (uint, string memory) {\n        return (gweiValue, info);\n    }\n}"
      }
    }
  },
  {
    "Changes98": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Disallow <code>.</code> in user-defined function and variable names in inline assembly.\nIt is still valid if you use Solidity in Yul-only mode.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint256 public finalOutput;\n\n    function compute() public {\n        uint256 x = 17;\n        uint256 y = 27;\n        uint256 res;\n\n        assembly {\n            function sumValues(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let result.val := sumValues(x, y)\n\n            res := result.val\n        }\n\n        finalOutput = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 123;\n    }\n}",
          "error message": ":1:314: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let result.val := sumValues(x, y)              re ...\n                                        ^--------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint256 public finalResult;\n\n    function calculate() public {\n        uint256 m = 21;\n        uint256 n = 15;\n        uint256 res;\n\n        assembly {\n            function sumNumbers(a, b) -> totalSum {\n                totalSum := add(a, b)\n            }\n\n            let total.result := sumNumbers(m, n)\n\n            res := total.result\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:323: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let total.result := sumNumbers(m, n)              r ...\n                                        ^----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint256 public output;\n\n    function execute() public {\n        uint256 p = 19;\n        uint256 q = 23;\n        uint256 res;\n\n        assembly {\n            function addValues(c, d) -> sum {\n                sum := add(c, d)\n            }\n\n            let var.sum := addValues(p, q)\n\n            res := var.sum\n        }\n\n        output = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Test\";\n    }\n\n    function unrelatedFunction2() public pure returns (uint256) {\n        return 456;\n    }\n}",
          "error message": ":1:305: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  d)             }              let var.sum := addValues(p, q)              re ...\n                                        ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint256 public resultValue;\n\n    function computeResult() public {\n        uint256 w = 11;\n        uint256 z = 18;\n        uint256 res;\n\n        assembly {\n            function calculateSum(e, f) -> finalSum {\n                finalSum := add(e, f)\n            }\n\n            let res.total := calculateSum(w, z)\n\n            res := res.total\n        }\n\n        resultValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}",
          "error message": ":1:329: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  f)             }              let res.total := calculateSum(w, z)              ...\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint256 public finalOutcome;\n\n    function perform() public {\n        uint256 a = 14;\n        uint256 b = 16;\n        uint256 res;\n\n        assembly {\n            function computeTotal(x, y) -> totalSum {\n                totalSum := add(x, y)\n            }\n\n            let total.value := computeTotal(a, b)\n\n            res := total.value\n        }\n\n        finalOutcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 789;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:324: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  y)             }              let total.value := computeTotal(a, b)              ...\n                                        ^---------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint256 public result;\n\n    function calculate() public {\n        uint256 x = 13;\n        uint256 y = 14;\n        uint256 res;\n\n        assembly {\n            function addNumbers(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let calc.sum := addNumbers(x, y)\n\n            res := calc.sum\n        }\n\n        result = res;\n    }\n}",
          "error message": ":1:308: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let calc.sum := addNumbers(x, y)              r ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint256 public finalValue;\n\n    function runCalculation() public {\n        uint256 p = 10;\n        uint256 q = 30;\n        uint256 res;\n\n        assembly {\n            function getTotal(m, n) -> totalSum {\n                totalSum := add(m, n)\n            }\n\n            let sum.result := getTotal(p, q)\n\n            res := sum.result\n        }\n\n        finalValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
          "error message": ":1:325: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  n)             }              let sum.result := getTotal(p, q)              res ...\n                                        ^--------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint256 public outputValue;\n\n    function executeCalculation() public {\n        uint256 g = 12;\n        uint256 h = 24;\n        uint256 res;\n\n        assembly {\n            function findSum(i, j) -> sumResult {\n                sumResult := add(i, j)\n            }\n\n            let result.sum := findSum(g, h)\n\n            res := result.sum\n        }\n\n        outputValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 111;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:331: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  j)             }              let result.sum := findSum(g, h)              res  ...\n                                        ^--------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint256 public outcome;\n\n    function performCalculation() public {\n        uint256 w = 25;\n        uint256 z = 5;\n        uint256 res;\n\n        assembly {\n            function computeSum(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let total.result := computeSum(w, z)\n\n            res := total.result\n        }\n\n        outcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:321: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let total.result := computeSum(w, z)              r ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint256 public finalResult;\n\n    function calculateTotal() public {\n        uint256 x = 8;\n        uint256 y = 22;\n        uint256 res;\n\n        assembly {\n            function calculate(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let result.sum := calculate(x, y)\n\n            res := result.sum\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 888;\n    }\n\n    function unrelatedFunction2() public pure returns (string memory) {\n        return \"World\";\n    }\n}",
          "error message": ":1:316: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let result.sum := calculate(x, y)              re ...\n                                        ^--------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint256 public finalOutput;\n\n    function compute() public {\n        uint256 x = 17;\n        uint256 y = 27;\n        uint256 res;\n\n        assembly {\n            function sumValues(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let resultVal := sumValues(x, y)\n\n            res := resultVal\n        }\n\n        finalOutput = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 123;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint256 public finalResult;\n\n    function calculate() public {\n        uint256 m = 21;\n        uint256 n = 15;\n        uint256 res;\n\n        assembly {\n            function sumNumbers(a, b) -> totalSum {\n                totalSum := add(a, b)\n            }\n\n            let totalResult := sumNumbers(m, n)\n\n            res := totalResult\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint256 public output;\n\n    function execute() public {\n        uint256 p = 19;\n        uint256 q = 23;\n        uint256 res;\n\n        assembly {\n            function addValues(c, d) -> sum {\n                sum := add(c, d)\n            }\n\n            let varSum := addValues(p, q)\n\n            res := varSum\n        }\n\n        output = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Test\";\n    }\n\n    function unrelatedFunction2() public pure returns (uint256) {\n        return 456;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint256 public resultValue;\n\n    function computeResult() public {\n        uint256 w = 11;\n        uint256 z = 18;\n        uint256 res;\n\n        assembly {\n            function calculateSum(e, f) -> finalSum {\n                finalSum := add(e, f)\n            }\n\n            let resTotal := calculateSum(w, z)\n\n            res := resTotal\n        }\n\n        resultValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint256 public finalOutcome;\n\n    function perform() public {\n        uint256 a = 14;\n        uint256 b = 16;\n        uint256 res;\n\n        assembly {\n            function computeTotal(x, y) -> totalSum {\n                totalSum := add(x, y)\n            }\n\n            let totalValue := computeTotal(a, b)\n\n            res := totalValue\n        }\n\n        finalOutcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 789;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint256 public result;\n\n    function calculate() public {\n        uint256 x = 13;\n        uint256 y = 14;\n        uint256 res;\n\n        assembly {\n            function addNumbers(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let calcSum := addNumbers(x, y)\n\n            res := calcSum\n        }\n\n        result = res;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint256 public finalValue;\n\n    function runCalculation() public {\n        uint256 p = 10;\n        uint256 q = 30;\n        uint256 res;\n\n        assembly {\n            function getTotal(m, n) -> totalSum {\n                totalSum := add(m, n)\n            }\n\n            let sumResult := getTotal(p, q)\n\n            res := sumResult\n        }\n\n        finalValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint256 public outputValue;\n\n    function executeCalculation() public {\n        uint256 g = 12;\n        uint256 h = 24;\n        uint256 res;\n\n        assembly {\n            function findSum(i, j) -> sumResult {\n                sumResult := add(i, j)\n            }\n\n            let resultSum := findSum(g, h)\n\n            res := resultSum\n        }\n\n        outputValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 111;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint256 public outcome;\n\n    function performCalculation() public {\n        uint256 w = 25;\n        uint256 z = 5;\n        uint256 res;\n\n        assembly {\n            function computeSum(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let totalResult := computeSum(w, z)\n\n            res := totalResult\n        }\n\n        outcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint256 public finalResult;\n\n    function calculateTotal() public {\n        uint256 x = 8;\n        uint256 y = 22;\n        uint256 res;\n\n        assembly {\n            function calculate(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let resultSum := calculate(x, y)\n\n            res := resultSum\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 888;\n    }\n\n    function unrelatedFunction2() public pure returns (string memory) {\n        return \"World\";\n    }\n}"
      }
    }
  },
  {
    "Changes99": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Slot and offset of storage pointer variable <code>x</code> are accessed via <code>x.slot</code>\nand <code>x.offset</code> instead of <code>x_slot</code> and <code>x_offset</code>.Change <code>_slot</code> and <code>_offset</code> suffixes in inline assembly to <code>.slot</code> and <code>.offset</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Customer {\n        uint id;\n    }\n\n    Customer public customer;\n\n    constructor() public {\n        customer.id = 123;\n    }\n\n    function getCustomerPointer() public view returns (uint slot, uint offset) {\n        uint customerSlot;\n        uint customerOffset;\n        assembly {\n            customerSlot := customer_slot\n            customerOffset := customer_offset\n        }\n        return (customerSlot, customerOffset);\n    }\n}",
          "error message": ":1:368: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... mbly {             customerSlot := customer_slot             customerOffset := cust ...\n                                        ^-----------^\n:1:412: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... slot             customerOffset := customer_offset         }         return (customer ...\n                                        ^-------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Ticket {\n        uint number;\n    }\n\n    Ticket public ticket;\n\n    constructor() public {\n        ticket.number = 456;\n    }\n\n    function fetchTicketPointer() public view returns (uint slot, uint offset) {\n        uint ticketSlot;\n        uint ticketOffset;\n        assembly {\n            ticketSlot := ticket_slot\n            ticketOffset := ticket_offset\n        }\n        return (ticketSlot, ticketOffset);\n    }\n}",
          "error message": ":1:362: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             ticketSlot := ticket_slot             ticketOffset := ticket ...\n                                        ^---------^\n:1:402: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... t_slot             ticketOffset := ticket_offset         }         return (ticketSl ...\n                                        ^-----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Box {\n        uint size;\n    }\n\n    Box public box;\n\n    constructor() public {\n        box.size = 789;\n    }\n\n    function retrieveBoxPointer() public view returns (uint slot, uint offset) {\n        uint boxSlot;\n        uint boxOffset;\n        assembly {\n            boxSlot := box_slot\n            boxOffset := box_offset\n        }\n        return (boxSlot, boxOffset);\n    }\n\n    function dummyFunctionOne() public pure returns (uint) {\n        return 1;\n    }\n}",
          "error message": ":1:337: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  assembly {             boxSlot := box_slot             boxOffset := box_offse ...\n                                        ^------^\n:1:371: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  box_slot             boxOffset := box_offset         }         return (boxSlot, ...\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Car {\n        uint speed;\n    }\n\n    Car public car;\n\n    constructor() public {\n        car.speed = 200;\n    }\n\n    function getCarPointer() public view returns (uint slot, uint offset) {\n        uint carSlot;\n        uint carOffset;\n        assembly {\n            carSlot := car_slot\n            carOffset := car_offset\n        }\n        return (carSlot, carOffset);\n    }\n}",
          "error message": ":1:334: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  assembly {             carSlot := car_slot             carOffset := car_offse ...\n                                        ^------^\n:1:368: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  car_slot             carOffset := car_offset         }         return (carSlot, ...\n                                        ^--------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Book {\n        uint pages;\n    }\n\n    Book public book;\n\n    constructor() public {\n        book.pages = 300;\n    }\n\n    function fetchBookPointer() public view returns (uint slot, uint offset) {\n        uint bookSlot;\n        uint bookOffset;\n        assembly {\n            bookSlot := book_slot\n            bookOffset := book_offset\n        }\n        return (bookSlot, bookOffset);\n    }\n\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 2;\n    }\n\n    function extraDummyFunctionTwo() public pure returns (uint) {\n        return 3;\n    }\n}",
          "error message": ":1:344: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             bookSlot := book_slot             bookOffset := book_off ...\n                                        ^-------^\n:1:380: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ook_slot             bookOffset := book_offset         }         return (bookSlot ...\n                                        ^---------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Movie {\n        uint duration;\n    }\n\n    Movie public movie;\n\n    constructor() public {\n        movie.duration = 120;\n    }\n\n    function getMoviePointer() public view returns (uint slot, uint offset) {\n        uint movieSlot;\n        uint movieOffset;\n        assembly {\n            movieSlot := movie_slot\n            movieOffset := movie_offset\n        }\n        return (movieSlot, movieOffset);\n    }\n}",
          "error message": ":1:356: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             movieSlot := movie_slot             movieOffset := movie_o ...\n                                        ^--------^\n:1:394: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ie_slot             movieOffset := movie_offset         }         return (movieSlo ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Laptop {\n        uint ram;\n    }\n\n    Laptop public laptop;\n\n    constructor() public {\n        laptop.ram = 16;\n    }\n\n    function retrieveLaptopPointer() public view returns (uint slot, uint offset) {\n        uint laptopSlot;\n        uint laptopOffset;\n        assembly {\n            laptopSlot := laptop_slot\n            laptopOffset := laptop_offset\n        }\n        return (laptopSlot, laptopOffset);\n    }\n}",
          "error message": ":1:358: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             laptopSlot := laptop_slot             laptopOffset := laptop ...\n                                        ^---------^\n:1:398: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... p_slot             laptopOffset := laptop_offset         }         return (laptopSl ...\n                                        ^-----------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Phone {\n        uint storage;\n    }\n\n    Phone public phone;\n\n    constructor() public {\n        phone.storage = 64;\n    }\n\n    function getPhonePointer() public view returns (uint slot, uint offset) {\n        uint phoneSlot;\n        uint phoneOffset;\n        assembly {\n            phoneSlot := phone_slot\n            phoneOffset := phone_offset\n        }\n        return (phoneSlot, phoneOffset);\n    }\n}",
          "error message": ":1:78: ParserError: Expected identifier but got 'storage'\n ...  {     struct Phone {         uint storage;     }      Phone public phone;    ...\n                                        ^-----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Chair {\n        uint legs;\n    }\n\n    Chair public chair;\n\n    constructor() public {\n        chair.legs = 4;\n    }\n\n    function fetchChairPointer() public view returns (uint slot, uint offset) {\n        uint chairSlot;\n        uint chairOffset;\n        assembly {\n            chairSlot := chair_slot\n            chairOffset := chair_offset\n        }\n        return (chairSlot, chairOffset);\n    }\n\n    function extraFunctionOne() public pure returns (string memory) {\n        return \"extra1\";\n    }\n}",
          "error message": ":1:348: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             chairSlot := chair_slot             chairOffset := chair_o ...\n                                        ^--------^\n:1:386: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ir_slot             chairOffset := chair_offset         }         return (chairSlo ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct House {\n        uint rooms;\n    }\n\n    House public house;\n\n    constructor() public {\n        house.rooms = 5;\n    }\n\n    function retrieveHousePointer() public view returns (uint slot, uint offset) {\n        uint houseSlot;\n        uint houseOffset;\n        assembly {\n            houseSlot := house_slot\n            houseOffset := house_offset\n        }\n        return (houseSlot, houseOffset);\n    }\n\n    function extraFunctionTwo() public pure returns (string memory) {\n        return \"extra2\";\n    }\n}",
          "error message": ":1:353: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             houseSlot := house_slot             houseOffset := house_o ...\n                                        ^--------^\n:1:391: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... se_slot             houseOffset := house_offset         }         return (houseSlo ...\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Customer {\n        uint id;\n    }\n\n    Customer public customer;\n\n    constructor() public {\n        customer.id = 123;\n    }\n\n    function getCustomerPointer() public view returns (uint slot, uint offset) {\n        uint customerSlot;\n        uint customerOffset;\n        assembly {\n            customerSlot := customer.slot\n            customerOffset := customer.offset\n        }\n        return (customerSlot, customerOffset);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Ticket {\n        uint number;\n    }\n\n    Ticket public ticket;\n\n    constructor() public {\n        ticket.number = 456;\n    }\n\n    function fetchTicketPointer() public view returns (uint slot, uint offset) {\n        uint ticketSlot;\n        uint ticketOffset;\n        assembly {\n            ticketSlot := ticket.slot\n            ticketOffset := ticket.offset\n        }\n        return (ticketSlot, ticketOffset);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Box {\n        uint size;\n    }\n\n    Box public box;\n\n    constructor() public {\n        box.size = 789;\n    }\n\n    function retrieveBoxPointer() public view returns (uint slot, uint offset) {\n        uint boxSlot;\n        uint boxOffset;\n        assembly {\n            boxSlot := box.slot\n            boxOffset := box.offset\n        }\n        return (boxSlot, boxOffset);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Car {\n        uint speed;\n    }\n\n    Car public car;\n\n    constructor() public {\n        car.speed = 200;\n    }\n\n    function getCarPointer() public view returns (uint slot, uint offset) {\n        uint carSlot;\n        uint carOffset;\n        assembly {\n            carSlot := car.slot\n            carOffset := car.offset\n        }\n        return (carSlot, carOffset);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Book {\n        uint pages;\n    }\n\n    Book public book;\n\n    constructor() public {\n        book.pages = 300;\n    }\n\n    function fetchBookPointer() public view returns (uint slot, uint offset) {\n        uint bookSlot;\n        uint bookOffset;\n        assembly {\n            bookSlot := book.slot\n            bookOffset := book.offset\n        }\n        return (bookSlot, bookOffset);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Movie {\n        uint duration;\n    }\n\n    Movie public movie;\n\n    constructor() public {\n        movie.duration = 120;\n    }\n\n    function getMoviePointer() public view returns (uint slot, uint offset) {\n        uint movieSlot;\n        uint movieOffset;\n        assembly {\n            movieSlot := movie.slot\n            movieOffset := movie.offset\n        }\n        return (movieSlot, movieOffset);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Laptop {\n        uint ram;\n    }\n\n    Laptop public laptop;\n\n    constructor() public {\n        laptop.ram = 16;\n    }\n\n    function retrieveLaptopPointer() public view returns (uint slot, uint offset) {\n        uint laptopSlot;\n        uint laptopOffset;\n        assembly {\n            laptopSlot := laptop.slot\n            laptopOffset := laptop.offset\n        }\n        return (laptopSlot, laptopOffset);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Phone {\n        uint storage;\n    }\n\n    Phone public phone;\n\n    constructor() public {\n        phone.storage = 64;\n    }\n\n    function getPhonePointer() public view returns (uint slot, uint offset) {\n        uint phoneSlot;\n        uint phoneOffset;\n        assembly {\n            phoneSlot := phone.slot\n            phoneOffset := phone.offset\n        }\n        return (phoneSlot, phoneOffset);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Chair {\n        uint legs;\n    }\n\n    Chair public chair;\n\n    constructor() public {\n        chair.legs = 4;\n    }\n\n    function fetchChairPointer() public view returns (uint slot, uint offset) {\n        uint chairSlot;\n        uint chairOffset;\n        assembly {\n            chairSlot := chair.slot\n            chairOffset := chair.offset\n        }\n        return (chairSlot, chairOffset);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct House {\n        uint rooms;\n    }\n\n    House public house;\n\n    constructor() public {\n        house.rooms = 5;\n    }\n\n    function retrieveHousePointer() public view returns (uint slot, uint offset) {\n        uint houseSlot;\n        uint houseOffset;\n        assembly {\n            houseSlot := house.slot\n            houseOffset := house.offset\n        }\n        return (houseSlot, houseOffset);\n    }\n}"
      }
    }
  },
  {
    "Changes100": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "If a struct or array contains a mapping, it can only be used in storage.\nPreviously, mapping members were silently skipped in memory, which\nis confusing and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct11 {\n    struct ExampleStruct {\n        uint256 data;\n        mapping(address => uint256) balances;\n    }\n    \n    ExampleStruct[] public examples;\n\n    function createStruct(uint256 _data) public {\n        ExampleStruct memory newExample;\n        newExample.data = _data;\n        examples.push(newExample);\n    }\n\n    function setBalance(uint256 index, address user, uint256 amount) public {\n        examples[index].balances[user] = amount;\n    }\n\n    function getBalance(uint256 index, address user) public view returns (uint256) {\n        return examples[index].balances[user];\n    }\n\n    function dummyFuncA() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:256: TypeError: Type struct MappingInStruct11.ExampleStruct is only valid in storage because it contains a (nested) mapping.\n ... ct(uint256 _data) public {         ExampleStruct memory newExample;         newExample.data = _data;  ...\n                                        ^-----------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct12 {\n    struct InfoStruct {\n        uint256 id;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _id) public {\n        InfoStruct memory newInfo;\n        newInfo.id = _id;\n        infos.push(newInfo);\n    }\n\n    function updateHoldings(uint256 index, address user, uint256 value) public {\n        infos[index].holdings[user] = value;\n    }\n\n    function fetchHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n\n    function dummyFuncB() public pure returns (string memory) {\n        return \"DummyB\";\n    }\n\n    function dummyFuncC() public pure returns (uint256) {\n        return 256;\n    }\n}",
          "error message": ":1:238: TypeError: Type struct MappingInStruct12.InfoStruct is only valid in storage because it contains a (nested) mapping.\n ... Info(uint256 _id) public {         InfoStruct memory newInfo;         newInfo.id = _id;         ...\n                                        ^-----------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct13 {\n    struct RecordStruct {\n        uint256 identifier;\n        mapping(address => uint256) funds;\n    }\n    \n    RecordStruct[] public records;\n\n    function addRecord(uint256 _identifier) public {\n        RecordStruct memory newRecord;\n        newRecord.identifier = _identifier;\n        records.push(newRecord);\n    }\n\n    function modifyFunds(uint256 index, address user, uint256 amount) public {\n        records[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return records[index].funds[user];\n    }\n}",
          "error message": ":1:259: TypeError: Type struct MappingInStruct13.RecordStruct is only valid in storage because it contains a (nested) mapping.\n ... t256 _identifier) public {         RecordStruct memory newRecord;         newRecord.identifier = _i ...\n                                        ^---------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct14 {\n    struct AssetStruct {\n        uint256 assetId;\n        mapping(address => uint256) userBalances;\n    }\n    \n    AssetStruct[] public assets;\n\n    function registerAsset(uint256 _assetId) public {\n        AssetStruct memory newAsset;\n        newAsset.assetId = _assetId;\n        assets.push(newAsset);\n    }\n\n    function setAssetBalance(uint256 index, address user, uint256 amount) public {\n        assets[index].userBalances[user] = amount;\n    }\n\n    function getAssetBalance(uint256 index, address user) public view returns (uint256) {\n        return assets[index].userBalances[user];\n    }\n\n    function dummyFuncD() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:261: TypeError: Type struct MappingInStruct14.AssetStruct is only valid in storage because it contains a (nested) mapping.\n ... uint256 _assetId) public {         AssetStruct memory newAsset;         newAsset.assetId = _asset ...\n                                        ^-------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct15 {\n    struct ExampleData {\n        uint256 key;\n        mapping(address => uint256) accounts;\n    }\n    \n    ExampleData[] public dataCollection;\n\n    function addExample(uint256 _key) public {\n        ExampleData memory newExample;\n        newExample.key = _key;\n        dataCollection.push(newExample);\n    }\n\n    function setAccount(uint256 index, address user, uint256 value) public {\n        dataCollection[index].accounts[user] = value;\n    }\n\n    function getAccount(uint256 index, address user) public view returns (uint256) {\n        return dataCollection[index].accounts[user];\n    }\n\n    function dummyFuncE() public pure returns (uint256) {\n        return 1000;\n    }\n}",
          "error message": ":1:254: TypeError: Type struct MappingInStruct15.ExampleData is only valid in storage because it contains a (nested) mapping.\n ... ple(uint256 _key) public {         ExampleData memory newExample;         newExample.key = _key;    ...\n                                        ^---------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct16 {\n    struct CustomStruct {\n        uint256 id;\n        mapping(address => uint256) balances;\n    }\n    \n    CustomStruct[] public customStructs;\n\n    function createCustomStruct(uint256 _id) public {\n        CustomStruct memory newStruct;\n        newStruct.id = _id;\n        customStructs.push(newStruct);\n    }\n\n    function updateBalance(uint256 index, address user, uint256 amount) public {\n        customStructs[index].balances[user] = amount;\n    }\n\n    function viewBalance(uint256 index, address user) public view returns (uint256) {\n        return customStructs[index].balances[user];\n    }\n}",
          "error message": ":1:261: TypeError: Type struct MappingInStruct16.CustomStruct is only valid in storage because it contains a (nested) mapping.\n ... ruct(uint256 _id) public {         CustomStruct memory newStruct;         newStruct.id = _id;       ...\n                                        ^---------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct17 {\n    struct HolderStruct {\n        uint256 value;\n        mapping(address => uint256) funds;\n    }\n    \n    HolderStruct[] public holders;\n\n    function addHolder(uint256 _value) public {\n        HolderStruct memory newHolder;\n        newHolder.value = _value;\n        holders.push(newHolder);\n    }\n\n    function changeFunds(uint256 index, address user, uint256 amount) public {\n        holders[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return holders[index].funds[user];\n    }\n\n    function dummyFuncF() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:249: TypeError: Type struct MappingInStruct17.HolderStruct is only valid in storage because it contains a (nested) mapping.\n ... r(uint256 _value) public {         HolderStruct memory newHolder;         newHolder.value = _value; ...\n                                        ^---------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct18 {\n    struct DataStruct {\n        uint256 number;\n        mapping(address => uint256) userBalances;\n    }\n    \n    DataStruct[] public dataEntries;\n\n    function addData(uint256 _number) public {\n        DataStruct memory newData;\n        newData.number = _number;\n        dataEntries.push(newData);\n    }\n\n    function setUserBalance(uint256 index, address user, uint256 value) public {\n        dataEntries[index].userBalances[user] = value;\n    }\n\n    function getUserBalance(uint256 index, address user) public view returns (uint256) {\n        return dataEntries[index].userBalances[user];\n    }\n}",
          "error message": ":1:256: TypeError: Type struct MappingInStruct18.DataStruct is only valid in storage because it contains a (nested) mapping.\n ... (uint256 _number) public {         DataStruct memory newData;         newData.number = _number; ...\n                                        ^-----------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct19 {\n    struct ItemStruct {\n        uint256 id;\n        mapping(address => uint256) allocations;\n    }\n    \n    ItemStruct[] public items;\n\n    function createItem(uint256 _id) public {\n        ItemStruct memory newItem;\n        newItem.id = _id;\n        items.push(newItem);\n    }\n\n    function updateAllocation(uint256 index, address user, uint256 amount) public {\n        items[index].allocations[user] = amount;\n    }\n\n    function getAllocation(uint256 index, address user) public view returns (uint256) {\n        return items[index].allocations[user];\n    }\n\n    function dummyFuncG() public pure returns (uint256) {\n        return 99;\n    }\n}",
          "error message": ":1:244: TypeError: Type struct MappingInStruct19.ItemStruct is only valid in storage because it contains a (nested) mapping.\n ... Item(uint256 _id) public {         ItemStruct memory newItem;         newItem.id = _id;         ...\n                                        ^-----------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct20 {\n    struct InfoStruct {\n        uint256 value;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _value) public {\n        InfoStruct memory newInfo;\n        newInfo.value = _value;\n        infos.push(newInfo);\n    }\n\n    function setHoldings(uint256 index, address user, uint256 amount) public {\n        infos[index].holdings[user] = amount;\n    }\n\n    function getHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n\n    function dummyFuncH() public pure returns (bool) {\n        return true;\n    }\n\n    function dummyFuncI() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
          "error message": ":1:244: TypeError: Type struct MappingInStruct20.InfoStruct is only valid in storage because it contains a (nested) mapping.\n ... o(uint256 _value) public {         InfoStruct memory newInfo;         newInfo.value = _value;   ...\n                                        ^-----------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct11 {\n    struct ExampleStruct {\n        uint256 data;\n        mapping(address => uint256) balances;\n    }\n    \n    ExampleStruct[] public examples;\n\n    function createStruct(uint256 _data) public {\n        ExampleStruct storage newExample = examples.push();\n        newExample.data = _data;\n    }\n\n    function setBalance(uint256 index, address user, uint256 amount) public {\n        examples[index].balances[user] = amount;\n    }\n\n    function getBalance(uint256 index, address user) public view returns (uint256) {\n        return examples[index].balances[user];\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct12 {\n    struct InfoStruct {\n        uint256 id;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _id) public {\n        InfoStruct storage newInfo = infos.push();\n        newInfo.id = _id;\n    }\n\n    function updateHoldings(uint256 index, address user, uint256 value) public {\n        infos[index].holdings[user] = value;\n    }\n\n    function fetchHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct13 {\n    struct RecordStruct {\n        uint256 identifier;\n        mapping(address => uint256) funds;\n    }\n    \n    RecordStruct[] public records;\n\n    function addRecord(uint256 _identifier) public {\n        RecordStruct storage newRecord = records.push();\n        newRecord.identifier = _identifier;\n    }\n\n    function modifyFunds(uint256 index, address user, uint256 amount) public {\n        records[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return records[index].funds[user];\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct14 {\n    struct AssetStruct {\n        uint256 assetId;\n        mapping(address => uint256) userBalances;\n    }\n    \n    AssetStruct[] public assets;\n\n    function registerAsset(uint256 _assetId) public {\n        AssetStruct storage newAsset = assets.push();\n        newAsset.assetId = _assetId;\n    }\n\n    function setAssetBalance(uint256 index, address user, uint256 amount) public {\n        assets[index].userBalances[user] = amount;\n    }\n\n    function getAssetBalance(uint256 index, address user) public view returns (uint256) {\n        return assets[index].userBalances[user];\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct15 {\n    struct ExampleData {\n        uint256 key;\n        mapping(address => uint256) accounts;\n    }\n    \n    ExampleData[] public dataCollection;\n\n    function addExample(uint256 _key) public {\n        ExampleData storage newExample = dataCollection.push();\n        newExample.key = _key;\n    }\n\n    function setAccount(uint256 index, address user, uint256 value) public {\n        dataCollection[index].accounts[user] = value;\n    }\n\n    function getAccount(uint256 index, address user) public view returns (uint256) {\n        return dataCollection[index].accounts[user];\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct16 {\n    struct CustomStruct {\n        uint256 id;\n        mapping(address => uint256) balances;\n    }\n    \n    CustomStruct[] public customStructs;\n\n    function createCustomStruct(uint256 _id) public {\n        CustomStruct storage newStruct = customStructs.push();\n        newStruct.id = _id;\n    }\n\n    function updateBalance(uint256 index, address user, uint256 amount) public {\n        customStructs[index].balances[user] = amount;\n    }\n\n    function viewBalance(uint256 index, address user) public view returns (uint256) {\n        return customStructs[index].balances[user];\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct17 {\n    struct HolderStruct {\n        uint256 value;\n        mapping(address => uint256) funds;\n    }\n    \n    HolderStruct[] public holders;\n\n    function addHolder(uint256 _value) public {\n        HolderStruct storage newHolder = holders.push();\n        newHolder.value = _value;\n    }\n\n    function changeFunds(uint256 index, address user, uint256 amount) public {\n        holders[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return holders[index].funds[user];\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct18 {\n    struct DataStruct {\n        uint256 number;\n        mapping(address => uint256) userBalances;\n    }\n    \n    DataStruct[] public dataEntries;\n\n    function addData(uint256 _number) public {\n        DataStruct storage newData = dataEntries.push();\n        newData.number = _number;\n    }\n\n    function setUserBalance(uint256 index, address user, uint256 value) public {\n        dataEntries[index].userBalances[user] = value;\n    }\n\n    function getUserBalance(uint256 index, address user) public view returns (uint256) {\n        return dataEntries[index].userBalances[user];\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct19 {\n    struct ItemStruct {\n        uint256 id;\n        mapping(address => uint256) allocations;\n    }\n    \n    ItemStruct[] public items;\n\n    function createItem(uint256 _id) public {\n        ItemStruct storage newItem = items.push();\n        newItem.id = _id;\n    }\n\n    function updateAllocation(uint256 index, address user, uint256 amount) public {\n        items[index].allocations[user] = amount;\n    }\n\n    function getAllocation(uint256 index, address user) public view returns (uint256) {\n        return items[index].allocations[user];\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct20 {\n    struct InfoStruct {\n        uint256 value;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _value) public {\n        InfoStruct storage newInfo = infos.push();\n        newInfo.value = _value;\n    }\n\n    function setHoldings(uint256 index, address user, uint256 amount) public {\n        infos[index].holdings[user] = amount;\n    }\n\n    function getHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n}"
      }
    }
  },
  {
    "Changes101": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Assignments to structs or arrays in storage does not work if they contain\nmappings.\nPreviously, mappings were silently skipped during the copy operation, which\nis misleading and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Dataset {\n        mapping(address => uint) data;\n        uint total;\n    }\n\n    Dataset dataset1;\n    Dataset dataset2;\n\n    function addData(address _addr, uint _value) public {\n        dataset1.data[_addr] = _value;\n        dataset1.total += _value;\n    }\n\n    function cloneDataset() public {\n        dataset2 = dataset1;\n    }\n\n    function getTotal() public view returns (uint) {\n        return dataset2.total;\n    }\n}",
          "error message": ":1:361: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on cloneDataset() public {         dataset2 = dataset1;     }      function ge ...\n                                        ^------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Holder {\n        mapping(address => uint) items;\n        uint itemCount;\n    }\n\n    Holder holder1;\n    Holder holder2;\n\n    function addItem(address _addr, uint _item) public {\n        holder1.items[_addr] = _item;\n        holder1.itemCount += _item;\n    }\n\n    function duplicateHolder() public {\n        holder2 = holder1;\n    }\n\n    function getItemCount() public view returns (uint) {\n        return holder2.itemCount;\n    }\n\n    function anotherFunc() public pure returns (string memory) {\n        return \"Another\";\n    }\n}",
          "error message": ":1:364: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... duplicateHolder() public {         holder2 = holder1;     }      function get ...\n                                        ^-----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint entryCount;\n    }\n\n    Log log1;\n    Log log2;\n\n    function addEntry(address _addr, uint _entry) public {\n        log1.entries[_addr] = _entry;\n        log1.entryCount += _entry;\n    }\n\n    function copyLog() public {\n        log2 = log1;\n    }\n\n    function getEntryCount() public view returns (uint) {\n        return log2.entryCount;\n    }\n\n    function extraFunc() public pure returns (bool) {\n        return true;\n    }\n\n    function yetAnotherFunc() public pure returns (uint) {\n        return 101;\n    }\n}",
          "error message": ":1:345: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... unction copyLog() public {         log2 = log1;     }      function getEnt ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Table {\n        mapping(address => uint) values;\n        uint valueCount;\n    }\n\n    Table table1;\n    Table table2;\n\n    function setValue(address _addr, uint _value) public {\n        table1.values[_addr] = _value;\n        table1.valueCount += _value;\n    }\n\n    function cloneTable() public {\n        table2 = table1;\n    }\n\n    function getValueCount() public view returns (uint) {\n        return table2.valueCount;\n    }\n}",
          "error message": ":1:360: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... tion cloneTable() public {         table2 = table1;     }      function getV ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Registry {\n        mapping(address => uint) records;\n        uint recordTotal;\n    }\n\n    Registry registry1;\n    Registry registry2;\n\n    function addRecord(address _addr, uint _record) public {\n        registry1.records[_addr] = _record;\n        registry1.recordTotal += _record;\n    }\n\n    function copyRegistry() public {\n        registry2 = registry1;\n    }\n\n    function getRecordTotal() public view returns (uint) {\n        return registry2.recordTotal;\n    }\n\n    function func1() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:391: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on copyRegistry() public {         registry2 = registry1;     }      function g ...\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Database {\n        mapping(address => uint) entries;\n        uint entrySum;\n    }\n\n    Database db1;\n    Database db2;\n\n    function addEntry(address _addr, uint _entry) public {\n        db1.entries[_addr] = _entry;\n        db1.entrySum += _entry;\n    }\n\n    function replicateDatabase() public {\n        db2 = db1;\n    }\n\n    function getEntrySum() public view returns (uint) {\n        return db2.entrySum;\n    }\n}",
          "error message": ":1:362: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... plicateDatabase() public {         db2 = db1;     }      function getEntr ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Storage {\n        mapping(address => uint) tokens;\n        uint tokenTotal;\n    }\n\n    Storage storage1;\n    Storage storage2;\n\n    function addToken(address _addr, uint _token) public {\n        storage1.tokens[_addr] = _token;\n        storage1.tokenTotal += _token;\n    }\n\n    function copyStorage() public {\n        storage2 = storage1;\n    }\n\n    function getTokenTotal() public view returns (uint) {\n        return storage2.tokenTotal;\n    }\n\n    function dummy() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": ":1:375: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... ion copyStorage() public {         storage2 = storage1;     }      function ge ...\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Archive {\n        mapping(address => uint) files;\n        uint fileCount;\n    }\n\n    Archive archive1;\n    Archive archive2;\n\n    function addFile(address _addr, uint _file) public {\n        archive1.files[_addr] = _file;\n        archive1.fileCount += _file;\n    }\n\n    function cloneArchive() public {\n        archive2 = archive1;\n    }\n\n    function getFileCount() public view returns (uint) {\n        return archive2.fileCount;\n    }\n}",
          "error message": ":1:368: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on cloneArchive() public {         archive2 = archive1;     }      function ge ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Network {\n        mapping(address => uint) nodes;\n        uint nodeCount;\n    }\n\n    Network network1;\n    Network network2;\n\n    function addNode(address _addr, uint _node) public {\n        network1.nodes[_addr] = _node;\n        network1.nodeCount += _node;\n    }\n\n    function duplicateNetwork() public {\n        network2 = network1;\n    }\n\n    function getNodeCount() public view returns (uint) {\n        return network2.nodeCount;\n    }\n\n    function dummyFunc() public pure returns (string memory) {\n        return \"Node\";\n    }\n\n    function anotherDummyFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:372: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... uplicateNetwork() public {         network2 = network1;     }      function ge ...\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Cache {\n        mapping(address => uint) items;\n        uint itemTotal;\n    }\n\n    Cache cache1;\n    Cache cache2;\n\n    function addItem(address _addr, uint _item) public {\n        cache1.items[_addr] = _item;\n        cache1.itemTotal += _item;\n    }\n\n    function replicateCache() public {\n        cache2 = cache1;\n    }\n\n    function getItemTotal() public view returns (uint) {\n        return cache2.itemTotal;\n    }\n}",
          "error message": ":1:356: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ...  replicateCache() public {         cache2 = cache1;     }      function getI ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Dataset {\n        mapping(address => uint) data;\n        uint total;\n    }\n    Dataset dataset1;\n    Dataset dataset2;\n    function addData(address _addr, uint _value) public {\n        dataset1.data[_addr] = _value;\n        dataset1.total += _value;\n    }\n    function cloneDataset() public {\n        dataset2.total = dataset1.total;\n    }\n    function getTotal() public view returns (uint) {\n        return dataset2.total;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Holder {\n        mapping(address => uint) items;\n        uint itemCount;\n    }\n    Holder holder1;\n    Holder holder2;\n    function addItem(address _addr, uint _item) public {\n        holder1.items[_addr] = _item;\n        holder1.itemCount += _item;\n    }\n    function duplicateHolder() public {\n        holder2.itemCount = holder1.itemCount;\n    }\n    function getItemCount() public view returns (uint) {\n        return holder2.itemCount;\n    }\n    function anotherFunc() public pure returns (string memory) {\n        return \"Another\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint entryCount;\n    }\n    Log log1;\n    Log log2;\n    function addEntry(address _addr, uint _entry) public {\n        log1.entries[_addr] = _entry;\n        log1.entryCount += _entry;\n    }\n    function copyLog() public {\n        log2.entryCount = log1.entryCount;\n    }\n    function getEntryCount() public view returns (uint) {\n        return log2.entryCount;\n    }\n    function extraFunc() public pure returns (bool) {\n        return true;\n    }\n    function yetAnotherFunc() public pure returns (uint) {\n        return 101;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Table {\n        mapping(address => uint) values;\n        uint valueCount;\n    }\n    Table table1;\n    Table table2;\n    function setValue(address _addr, uint _value) public {\n        table1.values[_addr] = _value;\n        table1.valueCount += _value;\n    }\n    function cloneTable() public {\n        table2.valueCount = table1.valueCount;\n    }\n    function getValueCount() public view returns (uint) {\n        return table2.valueCount;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Registry {\n        mapping(address => uint) records;\n        uint recordTotal;\n    }\n    Registry registry1;\n    Registry registry2;\n    function addRecord(address _addr, uint _record) public {\n        registry1.records[_addr] = _record;\n        registry1.recordTotal += _record;\n    }\n    function copyRegistry() public {\n        registry2.recordTotal = registry1.recordTotal;\n    }\n    function getRecordTotal() public view returns (uint) {\n        return registry2.recordTotal;\n    }\n    function func1() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Database {\n        mapping(address => uint) entries;\n        uint entrySum;\n    }\n    Database db1;\n    Database db2;\n    function addEntry(address _addr, uint _entry) public {\n        db1.entries[_addr] = _entry;\n        db1.entrySum += _entry;\n    }\n    function replicateDatabase() public {\n        db2.entrySum = db1.entrySum;\n    }\n    function getEntrySum() public view returns (uint) {\n        return db2.entrySum;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Storage {\n        mapping(address => uint) tokens;\n        uint tokenTotal;\n    }\n    Storage storage1;\n    Storage storage2;\n    function addToken(address _addr, uint _token) public {\n        storage1.tokens[_addr] = _token;\n        storage1.tokenTotal += _token;\n    }\n    function copyStorage() public {\n        storage2.tokenTotal = storage1.tokenTotal;\n    }\n    function getTokenTotal() public view returns (uint) {\n        return storage2.tokenTotal;\n    }\n    function dummy() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Archive {\n        mapping(address => uint) files;\n        uint fileCount;\n    }\n    Archive archive1;\n    Archive archive2;\n    function addFile(address _addr, uint _file) public {\n        archive1.files[_addr] = _file;\n        archive1.fileCount += _file;\n    }\n    function cloneArchive() public {\n        archive2.fileCount = archive1.fileCount;\n    }\n    function getFileCount() public view returns (uint) {\n        return archive2.fileCount;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Network {\n        mapping(address => uint) nodes;\n        uint nodeCount;\n    }\n    Network network1;\n    Network network2;\n    function addNode(address _addr, uint _node) public {\n        network1.nodes[_addr] = _node;\n        network1.nodeCount += _node;\n    }\n    function duplicateNetwork() public {\n        network2.nodeCount = network1.nodeCount;\n    }\n    function getNodeCount() public view returns (uint) {\n        return network2.nodeCount;\n    }\n    function dummyFunc() public pure returns (string memory) {\n        return \"Node\";\n    }\n    function anotherDummyFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Cache {\n        mapping(address => uint) items;\n        uint itemTotal;\n    }\n    Cache cache1;\n    Cache cache2;\n    function addItem(address _addr, uint _item) public {\n        cache1.items[_addr] = _item;\n        cache1.itemTotal += _item;\n    }\n    function replicateCache() public {\n        cache2.itemTotal = cache1.itemTotal;\n    }\n    function getItemTotal() public view returns (uint) {\n        return cache2.itemTotal;\n    }\n}"
      }
    }
  },
  {
    "Changes102": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Multiple events with the same name and parameter types in the same\ninheritance hierarchy are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function submitReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n}\n\ncontract DerivedContract11 is BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function fileReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n\n    function nonRelatedFunction() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Non-related\"));\n    }\n\n    function anotherNonRelatedFunction() public pure returns (uint256) {\n        return 789;\n    }\n}",
          "error message": ":1:251: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract11 is BaseContract11 {     event ReportEvent(uint256 indexed reportId);      function fileReport(uint256 _ ...\n                                        ^------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0; contract BaseContract11 {     event ReportEvent(uint256 indexed reportId);      function submitReport(uint256 ...\n                                        ^------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function function12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n}\n\ncontract DerivedContract12 is BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function derivedFunction12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n\n    function helperFunction12() public pure returns (uint256) {\n        return 120;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract12 is BaseContract12 {     event Event12(uint256 indexed id12);      function derivedFunction12(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract12 {     event Event12(uint256 indexed id12);      function function12(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function function13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n}\n\ncontract DerivedContract13 is BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function derivedFunction13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n\n    function additionalFunction13() public pure returns (bool) {\n        return true;\n    }\n\n    function anotherFunction13() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract13 is BaseContract13 {     event Event13(uint256 indexed id13);      function derivedFunction13(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract13 {     event Event13(uint256 indexed id13);      function function13(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function function14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n}\n\ncontract DerivedContract14 is BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function derivedFunction14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n\n    function unrelatedFunction14() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Unrelated\"));\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract14 is BaseContract14 {     event Event14(uint256 indexed id14);      function derivedFunction14(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract14 {     event Event14(uint256 indexed id14);      function function14(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function function15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n}\n\ncontract DerivedContract15 is BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function derivedFunction15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n\n    function extraFunction15() public pure returns (uint256) {\n        return 150;\n    }\n\n    function anotherExtraFunction15() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract15 is BaseContract15 {     event Event15(uint256 indexed id15);      function derivedFunction15(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract15 {     event Event15(uint256 indexed id15);      function function15(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function function16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}\n\ncontract DerivedContract16 is BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function derivedFunction16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract16 is BaseContract16 {     event Event16(uint256 indexed id16);      function derivedFunction16(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract16 {     event Event16(uint256 indexed id16);      function function16(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function function17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n\n    function unrelatedFunction17() public pure returns (int256) {\n        return -17;\n    }\n}\n\ncontract DerivedContract17 is BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function derivedFunction17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n}",
          "error message": ":1:323: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract17 is BaseContract17 {     event Event17(uint256 indexed id17);      function derivedFunction17(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract17 {     event Event17(uint256 indexed id17);      function function17(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function function18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n}\n\ncontract DerivedContract18 is BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function derivedFunction18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n\n    function anotherUnrelatedFunction18() public pure returns (address) {\n        return address(this);\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract18 is BaseContract18 {     event Event18(uint256 indexed id18);      function derivedFunction18(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract18 {     event Event18(uint256 indexed id18);      function function18(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function function19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n}\n\ncontract DerivedContract19 is BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function derivedFunction19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n\n    function nonRelatedFunction19() public pure returns (uint256) {\n        return 190;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract19 is BaseContract19 {     event Event19(uint256 indexed id19);      function derivedFunction19(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract19 {     event Event19(uint256 indexed id19);      function function19(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function function20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n\n    function unrelatedFunction20() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}\n\ncontract DerivedContract20 is BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function derivedFunction20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n}",
          "error message": ":1:338: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract20 is BaseContract20 {     event Event20(uint256 indexed id20);      function derivedFunction20(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract20 {     event Event20(uint256 indexed id20);      function function20(uint256 _ ...\n                                        ^----------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function submitReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n}\n\ncontract DerivedContract11 is BaseContract11 {\n    function fileReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n\n    function nonRelatedFunction() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Non-related\"));\n    }\n\n    function anotherNonRelatedFunction() public pure returns (uint256) {\n        return 789;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function function12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n}\n\ncontract DerivedContract12 is BaseContract12 {\n    function derivedFunction12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n\n    function helperFunction12() public pure returns (uint256) {\n        return 120;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function function13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n}\n\ncontract DerivedContract13 is BaseContract13 {\n    function derivedFunction13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n\n    function additionalFunction13() public pure returns (bool) {\n        return true;\n    }\n\n    function anotherFunction13() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function function14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n}\n\ncontract DerivedContract14 is BaseContract14 {\n    function derivedFunction14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n\n    function unrelatedFunction14() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Unrelated\"));\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function function15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n}\n\ncontract DerivedContract15 is BaseContract15 {\n    function derivedFunction15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n\n    function extraFunction15() public pure returns (uint256) {\n        return 150;\n    }\n\n    function anotherExtraFunction15() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function function16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}\n\ncontract DerivedContract16 is BaseContract16 {\n    function derivedFunction16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function function17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n\n    function unrelatedFunction17() public pure returns (int256) {\n        return -17;\n    }\n}\n\ncontract DerivedContract17 is BaseContract17 {\n    function derivedFunction17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function function18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n}\n\ncontract DerivedContract18 is BaseContract18 {\n    function derivedFunction18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n\n    function anotherUnrelatedFunction18() public pure returns (address) {\n        return address(this);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function function19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n}\n\ncontract DerivedContract19 is BaseContract19 {\n    function derivedFunction19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n\n    function nonRelatedFunction19() public pure returns (uint256) {\n        return 190;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function function20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n\n    function unrelatedFunction20() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}\n\ncontract DerivedContract20 is BaseContract20 {\n    function derivedFunction20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n}"
      }
    }
  },
  {
    "Changes103": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "<code>using A for B</code> only affects the contract it is mentioned in.\nPreviously, the effect was inherited. Now, you have to repeat the <code>using</code>\nstatement in all derived contracts that make use of the feature.Repeat the <code>using A for B</code> statements in all derived contracts if needed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Operations {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Operations: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract A {\n    using Operations for uint;\n\n    uint public aValue;\n\n    function setAValue(uint _value) public {\n        aValue = _value;\n    }\n\n    function subtractAValue(uint _value) public {\n        aValue = aValue.subtract(_value);\n    }\n}\n\ncontract B is A {\n    uint public bValue;\n\n    function setBValue(uint _value) public {\n        bValue = _value;\n    }\n\n    function subtractBValue(uint _value) public {\n        bValue = bValue.subtract(_value);\n    }\n}",
          "error message": ":1:642: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ...  _value) public {         bValue = bValue.subtract(_value);     } }\n                                        ^-------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Calculate {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"Calculate: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract X {\n    using Calculate for uint;\n\n    uint public xValue;\n\n    function setXValue(uint _value) public {\n        xValue = _value;\n    }\n\n    function multiplyXValue(uint _value) public {\n        xValue = xValue.multiply(_value);\n    }\n}\n\ncontract Y is X {\n    uint public yValue;\n\n    function setYValue(uint _value) public {\n        yValue = _value;\n    }\n\n    function multiplyYValue(uint _value) public {\n        yValue = yValue.multiply(_value);\n    }\n}",
          "error message": ":1:666: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ...  _value) public {         yValue = yValue.multiply(_value);     } }\n                                        ^-------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary CalcLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"CalcLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract Master {\n    using CalcLib for uint;\n\n    uint public masterValue;\n\n    function setMasterValue(uint _value) public {\n        masterValue = _value;\n    }\n\n    function addMasterValue(uint _value) public {\n        masterValue = masterValue.add(_value);\n    }\n}\n\ncontract Slave is Master {\n    uint public slaveValue;\n\n    function setSlaveValue(uint _value) public {\n        slaveValue = _value;\n    }\n\n    function addSlaveValue(uint _value) public {\n        slaveValue = slaveValue.add(_value);\n    }\n}",
          "error message": ":1:694: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         slaveValue = slaveValue.add(_value);     } }\n                                        ^------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary NumberLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"NumberLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Origin {\n    using NumberLib for uint;\n\n    uint public originValue;\n\n    function setOriginValue(uint _value) public {\n        originValue = _value;\n    }\n\n    function subtractOriginValue(uint _value) public {\n        originValue = originValue.subtract(_value);\n    }\n}\n\ncontract Copy is Origin {\n    uint public copyValue;\n\n    function setCopyValue(uint _value) public {\n        copyValue = _value;\n    }\n\n    function subtractCopyValue(uint _value) public {\n        copyValue = copyValue.subtract(_value);\n    }\n}",
          "error message": ":1:697: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         copyValue = copyValue.subtract(_value);     } }\n                                        ^----------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary MyLibrary {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"MyLibrary: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Prime {\n    using MyLibrary for uint;\n\n    uint public primeValue;\n\n    function setPrimeValue(uint _value) public {\n        primeValue = _value;\n    }\n\n    function multiplyPrimeValue(uint _value) public {\n        primeValue = primeValue.multiply(_value);\n    }\n}\n\ncontract Secondary is Prime {\n    uint public secondaryValue;\n\n    function setSecondaryValue(uint _value) public {\n        secondaryValue = _value;\n    }\n\n    function multiplySecondaryValue(uint _value) public {\n        secondaryValue = secondaryValue.multiply(_value);\n    }\n}",
          "error message": ":1:746: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ...  public {         secondaryValue = secondaryValue.multiply(_value);     } }\n                                        ^---------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary UtilsLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"UtilsLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Initial {\n    using UtilsLib for uint;\n\n    uint public initialValue;\n\n    function setInitialValue(uint _value) public {\n        initialValue = _value;\n    }\n\n    function divideInitialValue(uint _value) public {\n        initialValue = initialValue.divide(_value);\n    }\n}\n\ncontract Final is Initial {\n    uint public finalValue;\n\n    function setFinalValue(uint _value) public {\n        finalValue = _value;\n    }\n\n    function divideFinalValue(uint _value) public {\n        finalValue = finalValue.divide(_value);\n    }\n}",
          "error message": ":1:695: TypeError: Member \"divide\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         finalValue = finalValue.divide(_value);     } }\n                                        ^---------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary ExtraLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ExtraLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract First {\n    using ExtraLib for uint;\n\n    uint public firstValue;\n\n    function setFirstValue(uint _value) public {\n        firstValue = _value;\n    }\n\n    function addFirstValue(uint _value) public {\n        firstValue = firstValue.add(_value);\n    }\n}\n\ncontract Second is First {\n    uint public secondValue;\n\n    function setSecondValue(uint _value) public {\n        secondValue = _value;\n    }\n\n    function addSecondValue(uint _value) public {\n        secondValue = secondValue.add(_value);\n    }\n}",
          "error message": ":1:695: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         secondValue = secondValue.add(_value);     } }\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary OperationLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"OperationLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Root {\n    using OperationLib for uint;\n\n    uint public rootValue;\n\n    function setRootValue(uint _value) public {\n        rootValue = _value;\n    }\n\n    function subtractRootValue(uint _value) public {\n        rootValue = rootValue.subtract(_value);\n    }\n}\n\ncontract Branch is Root {\n    uint public branchValue;\n\n    function setBranchValue(uint _value) public {\n        branchValue = _value;\n    }\n\n    function subtractBranchValue(uint _value) public {\n        branchValue = branchValue.subtract(_value);\n    }\n}",
          "error message": ":1:702: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         branchValue = branchValue.subtract(_value);     } }\n                                        ^------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary CalculationLib {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"CalculationLib: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Main {\n    using CalculationLib for uint;\n\n    uint public mainValue;\n\n    function setMainValue(uint _value) public {\n        mainValue = _value;\n    }\n\n    function multiplyMainValue(uint _value) public {\n        mainValue = mainValue.multiply(_value);\n    }\n}\n\ncontract Side is Main {\n    uint public sideValue;\n\n    function setSideValue(uint _value) public {\n        sideValue = _value;\n    }\n\n    function multiplySideValue(uint _value) public {\n        sideValue = sideValue.multiply(_value);\n    }\n}",
          "error message": ":1:723: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         sideValue = sideValue.multiply(_value);     } }\n                                        ^----------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary HelperLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"HelperLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Alpha {\n    using HelperLib for uint;\n\n    uint public alphaValue;\n\n    function setAlphaValue(uint _value) public {\n        alphaValue = _value;\n    }\n\n    function divideAlphaValue(uint _value) public {\n        alphaValue = alphaValue.divide(_value);\n    }\n}\n\ncontract Beta is Alpha {\n    uint public betaValue;\n\n    function setBetaValue(uint _value) public {\n        betaValue = _value;\n    }\n\n    function divideBetaValue(uint _value) public {\n        betaValue = betaValue.divide(_value);\n    }\n}",
          "error message": ":1:676: TypeError: Member \"divide\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         betaValue = betaValue.divide(_value);     } }\n                                        ^--------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary Operations {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Operations: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract A {\n    using Operations for uint;\n    uint public aValue;\n    function setAValue(uint _value) public {\n        aValue = _value;\n    }\n    function subtractAValue(uint _value) public {\n        aValue = aValue.subtract(_value);\n    }\n}\n\ncontract B is A {\n    using Operations for uint;\n    uint public bValue;\n    function setBValue(uint _value) public {\n        bValue = _value;\n    }\n    function subtractBValue(uint _value) public {\n        bValue = bValue.subtract(_value);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary Calculate {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"Calculate: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract X {\n    using Calculate for uint;\n    uint public xValue;\n    function setXValue(uint _value) public {\n        xValue = _value;\n    }\n    function multiplyXValue(uint _value) public {\n        xValue = xValue.multiply(_value);\n    }\n}\n\ncontract Y is X {\n    using Calculate for uint;\n    uint public yValue;\n    function setYValue(uint _value) public {\n        yValue = _value;\n    }\n    function multiplyYValue(uint _value) public {\n        yValue = yValue.multiply(_value);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary CalcLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"CalcLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract Master {\n    using CalcLib for uint;\n    uint public masterValue;\n    function setMasterValue(uint _value) public {\n        masterValue = _value;\n    }\n    function addMasterValue(uint _value) public {\n        masterValue = masterValue.add(_value);\n    }\n}\n\ncontract Slave is Master {\n    using CalcLib for uint;\n    uint public slaveValue;\n    function setSlaveValue(uint _value) public {\n        slaveValue = _value;\n    }\n    function addSlaveValue(uint _value) public {\n        slaveValue = slaveValue.add(_value);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary NumberLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"NumberLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Origin {\n    using NumberLib for uint;\n    uint public originValue;\n    function setOriginValue(uint _value) public {\n        originValue = _value;\n    }\n    function subtractOriginValue(uint _value) public {\n        originValue = originValue.subtract(_value);\n    }\n}\n\ncontract Copy is Origin {\n    using NumberLib for uint;\n    uint public copyValue;\n    function setCopyValue(uint _value) public {\n        copyValue = _value;\n    }\n    function subtractCopyValue(uint _value) public {\n        copyValue = copyValue.subtract(_value);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary MyLibrary {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"MyLibrary: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Prime {\n    using MyLibrary for uint;\n    uint public primeValue;\n    function setPrimeValue(uint _value) public {\n        primeValue = _value;\n    }\n    function multiplyPrimeValue(uint _value) public {\n        primeValue = primeValue.multiply(_value);\n    }\n}\n\ncontract Secondary is Prime {\n    using MyLibrary for uint;\n    uint public secondaryValue;\n    function setSecondaryValue(uint _value) public {\n        secondaryValue = _value;\n    }\n    function multiplySecondaryValue(uint _value) public {\n        secondaryValue = secondaryValue.multiply(_value);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary UtilsLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"UtilsLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Initial {\n    using UtilsLib for uint;\n    uint public initialValue;\n    function setInitialValue(uint _value) public {\n        initialValue = _value;\n    }\n    function divideInitialValue(uint _value) public {\n        initialValue = initialValue.divide(_value);\n    }\n}\n\ncontract Final is Initial {\n    using UtilsLib for uint;\n    uint public finalValue;\n    function setFinalValue(uint _value) public {\n        finalValue = _value;\n    }\n    function divideFinalValue(uint _value) public {\n        finalValue = finalValue.divide(_value);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary ExtraLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ExtraLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract First {\n    using ExtraLib for uint;\n    uint public firstValue;\n    function setFirstValue(uint _value) public {\n        firstValue = _value;\n    }\n    function addFirstValue(uint _value) public {\n        firstValue = firstValue.add(_value);\n    }\n}\n\ncontract Second is First {\n    using ExtraLib for uint;\n    uint public secondValue;\n    function setSecondValue(uint _value) public {\n        secondValue = _value;\n    }\n    function addSecondValue(uint _value) public {\n        secondValue = secondValue.add(_value);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary OperationLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"OperationLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Root {\n    using OperationLib for uint;\n    uint public rootValue;\n    function setRootValue(uint _value) public {\n        rootValue = _value;\n    }\n    function subtractRootValue(uint _value) public {\n        rootValue = rootValue.subtract(_value);\n    }\n}\n\ncontract Branch is Root {\n    using OperationLib for uint;\n    uint public branchValue;\n    function setBranchValue(uint _value) public {\n        branchValue = _value;\n    }\n    function subtractBranchValue(uint _value) public {\n        branchValue = branchValue.subtract(_value);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary CalculationLib {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"CalculationLib: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Main {\n    using CalculationLib for uint;\n    uint public mainValue;\n    function setMainValue(uint _value) public {\n        mainValue = _value;\n    }\n    function multiplyMainValue(uint _value) public {\n        mainValue = mainValue.multiply(_value);\n    }\n}\n\ncontract Side is Main {\n    using CalculationLib for uint;\n    uint public sideValue;\n    function setSideValue(uint _value) public {\n        sideValue = _value;\n    }\n    function multiplySideValue(uint _value) public {\n        sideValue = sideValue.multiply(_value);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary HelperLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"HelperLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Alpha {\n    using HelperLib for uint;\n    uint public alphaValue;\n    function setAlphaValue(uint _value) public {\n        alphaValue = _value;\n    }\n    function divideAlphaValue(uint _value) public {\n        alphaValue = alphaValue.divide(_value);\n    }\n}\n\ncontract Beta is Alpha {\n    using HelperLib for uint;\n    uint public betaValue;\n    function setBetaValue(uint _value) public {\n        betaValue = _value;\n    }\n    function divideBetaValue(uint _value) public {\n        betaValue = betaValue.divide(_value);\n    }\n}"
      }
    }
  },
  {
    "Changes104": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Shifts by signed types are disallowed.\nPreviously, shifts by negative amounts were allowed, but reverted at runtime.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    int public output;\n\n    function shiftLeft(int x, int y) public {\n        output = x << y;\n    }\n}",
          "error message": ":1:133: TypeError: Operator << not compatible with types int256 and int256\npragma solidity^0.7.0;  contract Example11 {     int public output;      function shiftLeft(int x, int y) public {         output = x << y;     } }\n                                                                                                                                    ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    int public shiftResult;\n\n    function performRightShift(int a, int b) public {\n        shiftResult = a >> b;\n    }\n\n    function dummyFunction2() public pure returns (int) {\n        return 50;\n    }\n}",
          "error message": ":1:151: TypeError: Operator >> not compatible with types int256 and int256\n ...  b) public {         shiftResult = a >> b;     }      function dummyFunction ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    int public shifted;\n\n    function leftShift(int x, int y) public {\n        shifted = x << y;\n    }\n}",
          "error message": ":1:135: TypeError: Operator << not compatible with types int256 and int256\npragma solidity^0.7.0;  contract Example13 {     int public shifted;      function leftShift(int x, int y) public {         shifted = x << y;     } }\n                                                                                                                                      ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    int public resultShift;\n\n    function rightShift(int number, int shiftBy) public {\n        resultShift = number >> shiftBy;\n    }\n\n    function additionalFunction1() public pure returns (int) {\n        return 99;\n    }\n}",
          "error message": ":1:155: TypeError: Operator >> not compatible with types int256 and int256\n ... By) public {         resultShift = number >> shiftBy;     }      function additionalFun ...\n                                        ^---------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    int public finalShift;\n\n    function shiftLeftBy(int input, int shiftAmount) public {\n        finalShift = input << shiftAmount;\n    }\n\n    function anotherDummyFunction() public pure returns (int) {\n        return 15;\n    }\n\n    function extraFunction() public pure returns (int) {\n        return 200;\n    }\n}",
          "error message": ":1:157: TypeError: Operator << not compatible with types int256 and int256\n ... unt) public {         finalShift = input << shiftAmount;     }      function anotherDummyF ...\n                                        ^------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    int public shiftedValue;\n\n    function shiftOperation(int base, int offset) public {\n        shiftedValue = base << offset;\n    }\n}",
          "error message": ":1:158: TypeError: Operator << not compatible with types int256 and int256\n ... t) public {         shiftedValue = base << offset;     } }\n                                        ^------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    int public result;\n\n    function performShift(int x, int y) public {\n        result = x << y;\n    }\n\n    function auxiliaryFunction() public pure returns (int) {\n        return 3;\n    }\n}",
          "error message": ":1:136: TypeError: Operator << not compatible with types int256 and int256\n ... , int y) public {         result = x << y;     }      function auxiliaryFunc ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    int public shiftOutcome;\n\n    function leftShift(int a, int b) public {\n        shiftOutcome = a << b;\n    }\n}",
          "error message": ":1:145: TypeError: Operator << not compatible with types int256 and int256\n ... b) public {         shiftOutcome = a << b;     } }\n                                        ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    int public data;\n\n    function shiftLeftBy(int number, int shiftBy) public {\n        data = number << shiftBy;\n    }\n\n    function unusedFunction() public pure returns (int) {\n        return -5;\n    }\n}",
          "error message": ":1:142: TypeError: Operator << not compatible with types int256 and int256\n ... t shiftBy) public {         data = number << shiftBy;     }      function unusedFunctio ...\n                                        ^---------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    int public shiftedResult;\n\n    function rightShiftOperation(int num, int shiftAmount) public {\n        shiftedResult = num >> shiftAmount;\n    }\n\n    function extraFunction1() public pure returns (int) {\n        return 101;\n    }\n}",
          "error message": ":1:169: TypeError: Operator >> not compatible with types int256 and int256\n ... ) public {         shiftedResult = num >> shiftAmount;     }      function extraFunction ...\n                                        ^----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    int public output;\n\n    function shiftLeft(int x, uint y) public {\n        output = x << y;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    int public shiftResult;\n\n    function performRightShift(int a, uint b) public {\n        shiftResult = a >> b;\n    }\n\n    function dummyFunction2() public pure returns (int) {\n        return 50;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    int public shifted;\n\n    function leftShift(int x, uint y) public {\n        shifted = x << y;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    int public resultShift;\n\n    function rightShift(int number, uint shiftBy) public {\n        resultShift = number >> shiftBy;\n    }\n\n    function additionalFunction1() public pure returns (int) {\n        return 99;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    int public finalShift;\n\n    function shiftLeftBy(int input, uint shiftAmount) public {\n        finalShift = input << shiftAmount;\n    }\n\n    function anotherDummyFunction() public pure returns (int) {\n        return 15;\n    }\n\n    function extraFunction() public pure returns (int) {\n        return 200;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    int public shiftedValue;\n\n    function shiftOperation(int base, uint offset) public {\n        shiftedValue = base << offset;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    int public result;\n\n    function performShift(int x, uint y) public {\n        result = x << y;\n    }\n\n    function auxiliaryFunction() public pure returns (int) {\n        return 3;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    int public shiftOutcome;\n\n    function leftShift(int a, uint b) public {\n        shiftOutcome = a << b;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    int public data;\n\n    function shiftLeftBy(int number, uint shiftBy) public {\n        data = number << shiftBy;\n    }\n\n    function unusedFunction() public pure returns (int) {\n        return -5;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    int public shiftedResult;\n\n    function rightShiftOperation(int num, uint shiftAmount) public {\n        shiftedResult = num >> shiftAmount;\n    }\n\n    function extraFunction1() public pure returns (int) {\n        return 101;\n    }\n}"
      }
    }
  },
  {
    "Changes105": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The <code>finney</code> and <code>szabo</code> denominations are removed.\nThey are rarely used and do not make the actual amount readily visible. Instead, explicit\nvalues like <code>1e20</code> or the very common <code>gwei</code> can be used.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public feeInFinney = 3 finney;\n\n    function payFee() public payable {\n        require(msg.value >= feeInFinney, \"Fee is 3 finney\");\n    }\n\n    function getFee() public view returns (uint) {\n        return feeInFinney;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": ":1:78: ParserError: Expected ';' but got identifier\n ...  {     uint public feeInFinney = 3 finney;      function payFee() public pay ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public donationInSzabo = 25 szabo;\n\n    function donate() public payable {\n        require(msg.value >= donationInSzabo, \"Minimum donation is 25 szabo\");\n    }\n\n    function getDonation() public view returns (uint) {\n        return donationInSzabo;\n    }\n\n    function anotherFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:83: ParserError: Expected ';' but got identifier\n ...   uint public donationInSzabo = 25 szabo;      function donate() public pay ...\n                                        ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public valueInFinney = 5 finney;\n\n    function setValue(uint newValue) public {\n        valueInFinney = newValue * 1 finney;\n    }\n\n    function getValue() public view returns (uint) {\n        return valueInFinney;\n    }\n\n    function randomFunc() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
          "error message": ":1:80: ParserError: Expected ';' but got identifier\n ...      uint public valueInFinney = 5 finney;      function setValue(uint newVa ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public minSzabo = 30 szabo;\n\n    function deposit() public payable {\n        require(msg.value >= minSzabo, \"Must deposit at least 30 szabo\");\n    }\n\n    function getMin() public view returns (uint) {\n        return minSzabo;\n    }\n}",
          "error message": ":1:76: ParserError: Expected ';' but got identifier\n ... 14 {     uint public minSzabo = 30 szabo;      function deposit() public pa ...\n                                        ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public maxFinney = 50 finney;\n\n    function setMax(uint newMax) public {\n        maxFinney = newMax * 1 finney;\n    }\n\n    function getMax() public view returns (uint) {\n        return maxFinney;\n    }\n}",
          "error message": ":1:77: ParserError: Expected ';' but got identifier\n ... 5 {     uint public maxFinney = 50 finney;      function setMax(uint newMax) ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public requiredSzabo = 75 szabo;\n\n    function sendFunds() public payable {\n        require(msg.value >= requiredSzabo, \"Need at least 75 szabo\");\n    }\n\n    function getRequired() public view returns (uint) {\n        return requiredSzabo;\n    }\n\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:81: ParserError: Expected ';' but got identifier\n ...     uint public requiredSzabo = 75 szabo;      function sendFunds() public  ...\n                                        ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public feeFinney = 4 finney;\n\n    function pay() public payable {\n        require(msg.value >= feeFinney, \"Fee is 4 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return feeFinney;\n    }\n\n    function additionalFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": ":1:76: ParserError: Expected ';' but got identifier\n ... 17 {     uint public feeFinney = 4 finney;      function pay() public payabl ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public amountSzabo = 40 szabo;\n\n    function contribute() public payable {\n        require(msg.value >= amountSzabo, \"Contribution must be at least 40 szabo\");\n    }\n\n    function getAmount() public view returns (uint) {\n        return amountSzabo;\n    }\n}",
          "error message": ":1:79: ParserError: Expected ';' but got identifier\n ... {     uint public amountSzabo = 40 szabo;      function contribute() public ...\n                                        ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public rateFinney = 6 finney;\n\n    function invest() public payable {\n        require(msg.value >= rateFinney, \"Investment rate is 6 finney\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rateFinney;\n    }\n\n    function someFunction() public pure returns (string memory) {\n        return \"some\";\n    }\n}",
          "error message": ":1:77: ParserError: Expected ';' but got identifier\n ... 9 {     uint public rateFinney = 6 finney;      function invest() public pay ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public thresholdSzabo = 100 szabo;\n\n    function setThreshold(uint newThreshold) public {\n        thresholdSzabo = newThreshold * 1 szabo;\n    }\n\n    function getThreshold() public view returns (uint) {\n        return thresholdSzabo;\n    }\n}",
          "error message": ":1:83: ParserError: Expected ';' but got identifier\n ...   uint public thresholdSzabo = 100 szabo;      function setThreshold(uint n ...\n                                        ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public feeInWei = 3e15;\n\n    function payFee() public payable {\n        require(msg.value >= feeInWei, \"Fee is 3 finney equivalent in wei\");\n    }\n\n    function getFee() public view returns (uint) {\n        return feeInWei;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public donationInWei = 25e12;\n\n    function donate() public payable {\n        require(msg.value >= donationInWei, \"Minimum donation is 25 szabo equivalent in wei\");\n    }\n\n    function getDonation() public view returns (uint) {\n        return donationInWei;\n    }\n\n    function anotherFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public valueInWei = 5e15;\n\n    function setValue(uint newValue) public {\n        valueInWei = newValue * 1e15;\n    }\n\n    function getValue() public view returns (uint) {\n        return valueInWei;\n    }\n\n    function randomFunc() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public minWei = 30e12;\n\n    function deposit() public payable {\n        require(msg.value >= minWei, \"Must deposit at least 30 szabo equivalent in wei\");\n    }\n\n    function getMin() public view returns (uint) {\n        return minWei;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public maxWei = 50e15;\n\n    function setMax(uint newMax) public {\n        maxWei = newMax * 1e15;\n    }\n\n    function getMax() public view returns (uint) {\n        return maxWei;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public requiredWei = 75e12;\n\n    function sendFunds() public payable {\n        require(msg.value >= requiredWei, \"Need at least 75 szabo equivalent in wei\");\n    }\n\n    function getRequired() public view returns (uint) {\n        return requiredWei;\n    }\n\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public feeWei = 4e15;\n\n    function pay() public payable {\n        require(msg.value >= feeWei, \"Fee is 4 finney equivalent in wei\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return feeWei;\n    }\n\n    function additionalFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public amountWei = 40e12;\n\n    function contribute() public payable {\n        require(msg.value >= amountWei, \"Contribution must be at least 40 szabo equivalent in wei\");\n    }\n\n    function getAmount() public view returns (uint) {\n        return amountWei;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public rateWei = 6e15;\n\n    function invest() public payable {\n        require(msg.value >= rateWei, \"Investment rate is 6 finney equivalent in wei\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rateWei;\n    }\n\n    function someFunction() public pure returns (string memory) {\n        return \"some\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public thresholdWei = 100e12;\n\n    function setThreshold(uint newThreshold) public {\n        thresholdWei = newThreshold * 1e12;\n    }\n\n    function getThreshold() public view returns (uint) {\n        return thresholdWei;\n    }\n}"
      }
    }
  },
  {
    "Changes106": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "In external function and contract creation calls, Ether and gas is now specified using a new syntax:\n<code>x.f{gas: 10000, value: 2 ether}(arg1, arg2)</code>.\nThe old syntax \u2013 <code>x.f.gas(10000).value(2 ether)(arg1, arg2)</code> \u2013 will cause an error.Change <code>x.f.value(...)()</code> to <code>x.f{value: ...}()</code>. Similarly <code>(new C).value(...)()</code> to <code>new C{value: ...}()</code> and <code>x.f.gas(...).value(...)()</code> to <code>x.f{gas: ..., value: ...}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract FundAllocator {\n    address payable public account;\n    constructor(address payable _account) public {\n        account = _account;\n    }\n    function allocate() public payable {\n        (bool allocated, ) = account.call.gas(3100).value(msg.value)(\"\");\n        require(allocated, \"Allocation failed\");\n    }\n    function helperFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... ble {         (bool allocated, ) = account.call.gas(3100).value(msg.value)(\"\");        ...\n                                        ^--------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract WealthManager {\n    address payable public manager;\n    constructor(address payable _manager) public {\n        manager = _manager;\n    }\n    function manageWealth() public payable {\n        (bool managed, ) = manager.call.gas(4200).value(msg.value)(\"\");\n        require(managed, \"Management failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... yable {         (bool managed, ) = manager.call.gas(4200).value(msg.value)(\"\");        ...\n                                        ^--------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract AssetDistributor {\n    address payable public distributor;\n    constructor(address payable _distributor) public {\n        distributor = _distributor;\n    }\n    function distributeAssets() public payable {\n        (bool distributed, ) = distributor.call.gas(5300).value(msg.value)(\"\");\n        require(distributed, \"Distribution failed\");\n    }\n    function extraMethod() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... e {         (bool distributed, ) = distributor.call.gas(5300).value(msg.value)(\"\");        ...\n                                        ^------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract MoneyHandler {\n    address payable public handler;\n    constructor(address payable _handler) public {\n        handler = _handler;\n    }\n    function handleFunds() public payable {\n        (bool handled, ) = handler.call.gas(6400).value(msg.value)(\"\");\n        require(handled, \"Handling failed\");\n    }\n    function calculateSomething() public pure returns (uint) {\n        return 12345;\n    }\n    function dummy() public pure {}\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... yable {         (bool handled, ) = handler.call.gas(6400).value(msg.value)(\"\");        ...\n                                        ^--------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract CashFlowController {\n    address payable public controller;\n    constructor(address payable _controller) public {\n        controller = _controller;\n    }\n    function controlCashFlow() public payable {\n        (bool controlled, ) = controller.call.gas(3500).value(msg.value)(\"\");\n        require(controlled, \"Control failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... le {         (bool controlled, ) = controller.call.gas(3500).value(msg.value)(\"\");        ...\n                                        ^-----------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract RevenueCollector {\n    address payable public collector;\n    constructor(address payable _collector) public {\n        collector = _collector;\n    }\n    function collectRevenue() public payable {\n        (bool collected, ) = collector.call.gas(4600).value(msg.value)(\"\");\n        require(collected, \"Collection failed\");\n    }\n    function nonEssentialFunction() public pure returns (string memory) {\n        return \"Non-Essential\";\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... ble {         (bool collected, ) = collector.call.gas(4600).value(msg.value)(\"\");        ...\n                                        ^----------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract PaymentFacilitator {\n    address payable public facilitator;\n    constructor(address payable _facilitator) public {\n        facilitator = _facilitator;\n    }\n    function facilitatePayment() public payable {\n        (bool facilitated, ) = facilitator.call.gas(5700).value(msg.value)(\"\");\n        require(facilitated, \"Payment facilitation failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... e {         (bool facilitated, ) = facilitator.call.gas(5700).value(msg.value)(\"\");        ...\n                                        ^------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract CapitalFlowManager {\n    address payable public manager;\n    constructor(address payable _manager) public {\n        manager = _manager;\n    }\n    function manageCapitalFlow() public payable {\n        (bool managed, ) = manager.call.gas(3800).value(msg.value)(\"\");\n        require(managed, \"Capital flow management failed\");\n    }\n    function unused() public pure {}\n    function anotherDummy() public pure {}\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... yable {         (bool managed, ) = manager.call.gas(3800).value(msg.value)(\"\");        ...\n                                        ^--------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract CashMover {\n    address payable public mover;\n    constructor(address payable _mover) public {\n        mover = _mover;\n    }\n    function moveCash() public payable {\n        (bool moved, ) = mover.call.gas(4900).value(msg.value)(\"\");\n        require(moved, \"Cash move failed\");\n    }\n    function extra() public pure returns (uint) {\n        return 88;\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... payable {         (bool moved, ) = mover.call.gas(4900).value(msg.value)(\"\");        ...\n                                        ^------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract ResourceController {\n    address payable public controller;\n    constructor(address payable _controller) public {\n        controller = _controller;\n    }\n    function controlResources() public payable {\n        (bool controlled, ) = controller.call.gas(6000).value(msg.value)(\"\");\n        require(controlled, \"Resource control failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... le {         (bool controlled, ) = controller.call.gas(6000).value(msg.value)(\"\");        ...\n                                        ^-----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract FundAllocator {\n    address payable public account;\n    constructor(address payable _account) public {\n        account = _account;\n    }\n    function allocate() public payable {\n        (bool allocated, ) = account.call{gas: 3100, value: msg.value}(\"\");\n        require(allocated, \"Allocation failed\");\n    }\n    function helperFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract WealthManager {\n    address payable public manager;\n    constructor(address payable _manager) public {\n        manager = _manager;\n    }\n    function manageWealth() public payable {\n        (bool managed, ) = manager.call{gas: 4200, value: msg.value}(\"\");\n        require(managed, \"Management failed\");\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract AssetDistributor {\n    address payable public distributor;\n    constructor(address payable _distributor) public {\n        distributor = _distributor;\n    }\n    function distributeAssets() public payable {\n        (bool distributed, ) = distributor.call{gas: 5300, value: msg.value}(\"\");\n        require(distributed, \"Distribution failed\");\n    }\n    function extraMethod() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract MoneyHandler {\n    address payable public handler;\n    constructor(address payable _handler) public {\n        handler = _handler;\n    }\n    function handleFunds() public payable {\n        (bool handled, ) = handler.call{gas: 6400, value: msg.value}(\"\");\n        require(handled, \"Handling failed\");\n    }\n    function calculateSomething() public pure returns (uint) {\n        return 12345;\n    }\n    function dummy() public pure {}\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract CashFlowController {\n    address payable public controller;\n    constructor(address payable _controller) public {\n        controller = _controller;\n    }\n    function controlCashFlow() public payable {\n        (bool controlled, ) = controller.call{gas: 3500, value: msg.value}(\"\");\n        require(controlled, \"Control failed\");\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract RevenueCollector {\n    address payable public collector;\n    constructor(address payable _collector) public {\n        collector = _collector;\n    }\n    function collectRevenue() public payable {\n        (bool collected, ) = collector.call{gas: 4600, value: msg.value}(\"\");\n        require(collected, \"Collection failed\");\n    }\n    function nonEssentialFunction() public pure returns (string memory) {\n        return \"Non-Essential\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract PaymentFacilitator {\n    address payable public facilitator;\n    constructor(address payable _facilitator) public {\n        facilitator = _facilitator;\n    }\n    function facilitatePayment() public payable {\n        (bool facilitated, ) = facilitator.call{gas: 5700, value: msg.value}(\"\");\n        require(facilitated, \"Payment facilitation failed\");\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract CapitalFlowManager {\n    address payable public manager;\n    constructor(address payable _manager) public {\n        manager = _manager;\n    }\n    function manageCapitalFlow() public payable {\n        (bool managed, ) = manager.call{gas: 3800, value: msg.value}(\"\");\n        require(managed, \"Capital flow management failed\");\n    }\n    function unused() public pure {}\n    function anotherDummy() public pure {}\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract CashMover {\n    address payable public mover;\n    constructor(address payable _mover) public {\n        mover = _mover;\n    }\n    function moveCash() public payable {\n        (bool moved, ) = mover.call{gas: 4900, value: msg.value}(\"\");\n        require(moved, \"Cash move failed\");\n    }\n    function extra() public pure returns (uint) {\n        return 88;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract ResourceController {\n    address payable public controller;\n    constructor(address payable _controller) public {\n        controller = _controller;\n    }\n    function controlResources() public payable {\n        (bool controlled, ) = controller.call{gas: 6000, value: msg.value}(\"\");\n        require(controlled, \"Resource control failed\");\n    }\n}"
      }
    }
  },
  {
    "Changes107": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The global variable <code>now</code> is deprecated, <code>block.timestamp</code> should be used instead.\nThe single identifier <code>now</code> is too generic for a global variable and could give the impression\nthat it changes during transaction processing, whereas <code>block.timestamp</code> correctly\nreflects the fact that it is just a property of the block.Change <code>now</code> to <code>block.timestamp</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeCapture {\n    function captureCurrent() public view returns (uint) {\n        return now;\n    }\n    function extraHelper() public pure returns (int) {\n        return 2024;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function extraHelper()  ...\n                                        ^-^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract EventScheduler {\n    function getEventTime() public view returns (uint) {\n        return now;\n    }\n    function additionalMethod() public pure returns (uint) {\n        return 1000;\n    }\n    function extraDataMethod() public pure returns (string memory) {\n        return \"ExtraInfo\";\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function additionalMeth ...\n                                        ^-^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract BlockWatcher {\n    function watchBlockTime() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract BlockWatcher {     function watchBlockTime() public view returns (uint) {         return now;     } }\n                                                                                                                         ^-^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract CurrentTime {\n    function queryCurrentTime() public view returns (uint) {\n        return now;\n    }\n    function unusedMethod() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function unusedMethod() ...\n                                        ^-^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract SystemClock {\n    function getSystemClock() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract SystemClock {     function getSystemClock() public view returns (uint) {         return now;     } }\n                                                                                                                        ^-^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeQuery {\n    function queryTime() public view returns (uint) {\n        return now;\n    }\n    function helperFunction() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function helperFunction ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract Clock {\n    function currentClock() public view returns (uint) {\n        return now;\n    }\n    function simpleFunction() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function simpleFunction ...\n                                        ^-^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeLog {\n    function logTime() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract TimeLog {     function logTime() public view returns (uint) {         return now;     } }\n                                                                                                             ^-^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract InstantTime {\n    function getInstantTime() public view returns (uint) {\n        return now;\n    }\n    function randomOutput() public pure returns (uint) {\n        return 2023;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function randomOutput() ...\n                                        ^-^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract TemporalCheck {\n    function checkTimeNow() public view returns (uint) {\n        return now;\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function randomFunction ...\n                                        ^-^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract TimeCapture {\n    function captureCurrent() public view returns (uint) {\n        return block.timestamp;\n    }\n    function extraHelper() public pure returns (int) {\n        return 2024;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract EventScheduler {\n    function getEventTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function additionalMethod() public pure returns (uint) {\n        return 1000;\n    }\n    function extraDataMethod() public pure returns (string memory) {\n        return \"ExtraInfo\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract BlockWatcher {\n    function watchBlockTime() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract CurrentTime {\n    function queryCurrentTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function unusedMethod() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract SystemClock {\n    function getSystemClock() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract TimeQuery {\n    function queryTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function helperFunction() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract Clock {\n    function currentClock() public view returns (uint) {\n        return block.timestamp;\n    }\n    function simpleFunction() public pure returns (int) {\n        return 42;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract TimeLog {\n    function logTime() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract InstantTime {\n    function getInstantTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function randomOutput() public pure returns (uint) {\n        return 2023;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract TemporalCheck {\n    function checkTimeNow() public view returns (uint) {\n        return block.timestamp;\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"random\";\n    }\n}"
      }
    }
  },
  {
    "Changes108": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The token <code>gwei</code> is a keyword now (used to specify, e.g. <code>2 gwei</code> as a number)\nand cannot be used as an identifier.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract Example11 {\n    uint public gwei;\n    uint public volume;\n\n    constructor(uint initialVolume) {\n        gwei = 101;\n        volume = initialVolume;\n    }\n\n    function adjustVolume(uint newVolume) public {\n        volume = newVolume;\n    }\n\n    function getVolume() public view returns (uint) {\n        return volume;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example11 {     uint public gwei;     uint public volume;      cons ...\n                                        ^--^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract Example12 {\n    uint public gwei;\n    uint public capacity;\n\n    constructor(uint initialCapacity) {\n        gwei = 202;\n        capacity = initialCapacity;\n    }\n\n    function setCapacity(uint newCapacity) public {\n        capacity = newCapacity;\n    }\n\n    function getCapacity() public view returns (uint) {\n        return capacity;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example12 {     uint public gwei;     uint public capacity;      co ...\n                                        ^--^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract Example13 {\n    uint public gwei;\n    uint public load;\n\n    constructor(uint initialLoad) {\n        gwei = 303;\n        load = initialLoad;\n    }\n\n    function modifyLoad(uint newLoad) public {\n        load = newLoad;\n    }\n\n    function getLoad() public view returns (uint) {\n        return load;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example13 {     uint public gwei;     uint public load;      constr ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract Example14 {\n    uint public gwei;\n    uint public speed;\n\n    constructor(uint initialSpeed) {\n        gwei = 404;\n        speed = initialSpeed;\n    }\n\n    function updateSpeed(uint newSpeed) public {\n        speed = newSpeed;\n    }\n\n    function getSpeed() public view returns (uint) {\n        return speed;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example14 {     uint public gwei;     uint public speed;      const ...\n                                        ^--^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract Example15 {\n    uint public gwei;\n    uint public energy;\n\n    constructor(uint initialEnergy) {\n        gwei = 505;\n        energy = initialEnergy;\n    }\n\n    function adjustEnergy(uint newEnergy) public {\n        energy = newEnergy;\n    }\n\n    function getEnergy() public view returns (uint) {\n        return energy;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example15 {     uint public gwei;     uint public energy;      cons ...\n                                        ^--^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract Example16 {\n    uint public gwei;\n    uint public intensity;\n\n    constructor(uint initialIntensity) {\n        gwei = 606;\n        intensity = initialIntensity;\n    }\n\n    function setIntensity(uint newIntensity) public {\n        intensity = newIntensity;\n    }\n\n    function getIntensity() public view returns (uint) {\n        return intensity;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example16 {     uint public gwei;     uint public intensity;      c ...\n                                        ^--^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract Example17 {\n    uint public gwei;\n    uint public density;\n\n    constructor(uint initialDensity) {\n        gwei = 707;\n        density = initialDensity;\n    }\n\n    function modifyDensity(uint newDensity) public {\n        density = newDensity;\n    }\n\n    function getDensity() public view returns (uint) {\n        return density;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example17 {     uint public gwei;     uint public density;      con ...\n                                        ^--^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract Example18 {\n    uint public gwei;\n    uint public mass;\n\n    constructor(uint initialMass) {\n        gwei = 808;\n        mass = initialMass;\n    }\n\n    function updateMass(uint newMass) public {\n        mass = newMass;\n    }\n\n    function getMass() public view returns (uint) {\n        return mass;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example18 {     uint public gwei;     uint public mass;      constr ...\n                                        ^--^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract Example19 {\n    uint public gwei;\n    uint public force;\n\n    constructor(uint initialForce) {\n        gwei = 909;\n        force = initialForce;\n    }\n\n    function setForce(uint newForce) public {\n        force = newForce;\n    }\n\n    function getForce() public view returns (uint) {\n        return force;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example19 {     uint public gwei;     uint public force;      const ...\n                                        ^--^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract Example20 {\n    uint public gwei;\n    uint public pressure;\n\n    constructor(uint initialPressure) {\n        gwei = 1001;\n        pressure = initialPressure;\n    }\n\n    function adjustPressure(uint newPressure) public {\n        pressure = newPressure;\n    }\n\n    function getPressure() public view returns (uint) {\n        return pressure;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example20 {     uint public gwei;     uint public pressure;      co ...\n                                        ^--^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract Example11 {\n    uint public unitPrice;\n    uint public volume;\n\n    constructor(uint initialVolume) {\n        unitPrice = 101;\n        volume = initialVolume;\n    }\n\n    function adjustVolume(uint newVolume) public {\n        volume = newVolume;\n    }\n\n    function getVolume() public view returns (uint) {\n        return volume;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract Example12 {\n    uint public unitPrice;\n    uint public capacity;\n\n    constructor(uint initialCapacity) {\n        unitPrice = 202;\n        capacity = initialCapacity;\n    }\n\n    function setCapacity(uint newCapacity) public {\n        capacity = newCapacity;\n    }\n\n    function getCapacity() public view returns (uint) {\n        return capacity;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract Example13 {\n    uint public unitPrice;\n    uint public load;\n\n    constructor(uint initialLoad) {\n        unitPrice = 303;\n        load = initialLoad;\n    }\n\n    function modifyLoad(uint newLoad) public {\n        load = newLoad;\n    }\n\n    function getLoad() public view returns (uint) {\n        return load;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract Example14 {\n    uint public unitPrice;\n    uint public speed;\n\n    constructor(uint initialSpeed) {\n        unitPrice = 404;\n        speed = initialSpeed;\n    }\n\n    function updateSpeed(uint newSpeed) public {\n        speed = newSpeed;\n    }\n\n    function getSpeed() public view returns (uint) {\n        return speed;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract Example15 {\n    uint public unitPrice;\n    uint public energy;\n\n    constructor(uint initialEnergy) {\n        unitPrice = 505;\n        energy = initialEnergy;\n    }\n\n    function adjustEnergy(uint newEnergy) public {\n        energy = newEnergy;\n    }\n\n    function getEnergy() public view returns (uint) {\n        return energy;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract Example16 {\n    uint public unitPrice;\n    uint public intensity;\n\n    constructor(uint initialIntensity) {\n        unitPrice = 606;\n        intensity = initialIntensity;\n    }\n\n    function setIntensity(uint newIntensity) public {\n        intensity = newIntensity;\n    }\n\n    function getIntensity() public view returns (uint) {\n        return intensity;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract Example17 {\n    uint public unitPrice;\n    uint public density;\n\n    constructor(uint initialDensity) {\n        unitPrice = 707;\n        density = initialDensity;\n    }\n\n    function modifyDensity(uint newDensity) public {\n        density = newDensity;\n    }\n\n    function getDensity() public view returns (uint) {\n        return density;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract Example18 {\n    uint public unitPrice;\n    uint public mass;\n\n    constructor(uint initialMass) {\n        unitPrice = 808;\n        mass = initialMass;\n    }\n\n    function updateMass(uint newMass) public {\n        mass = newMass;\n    }\n\n    function getMass() public view returns (uint) {\n        return mass;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract Example19 {\n    uint public unitPrice;\n    uint public force;\n\n    constructor(uint initialForce) {\n        unitPrice = 909;\n        force = initialForce;\n    }\n\n    function setForce(uint newForce) public {\n        force = newForce;\n    }\n\n    function getForce() public view returns (uint) {\n        return force;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract Example20 {\n    uint public unitPrice;\n    uint public pressure;\n\n    constructor(uint initialPressure) {\n        unitPrice = 1001;\n        pressure = initialPressure;\n    }\n\n    function adjustPressure(uint newPressure) public {\n        pressure = newPressure;\n    }\n\n    function getPressure() public view returns (uint) {\n        return pressure;\n    }\n}"
      }
    }
  },
  {
    "Changes109": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Disallow <code>.</code> in user-defined function and variable names in inline assembly.\nIt is still valid if you use Solidity in Yul-only mode.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleOne {\n    function computeAmount() public pure returns (uint) {\n        uint x;\n        assembly {\n            let temp.amount := 150\n            x := add(temp.amount, 50)\n        }\n        return x;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let temp.amount := 150             x := add(temp.a ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleTwo {\n    function calculateTotal() public pure returns (uint) {\n        uint y;\n        assembly {\n            let total.value := 80\n            y := add(total.value, 20)\n        }\n        return y;\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 1000;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let total.value := 80             y := add(total.v ...\n                                        ^---------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleThree {\n    function getResult() public pure returns (uint) {\n        uint z;\n        assembly {\n            let result.value := 90\n            z := add(result.value, 10)\n        }\n        return z;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let result.value := 90             z := add(result. ...\n                                        ^----------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleFour {\n    function generateNumber() public pure returns (uint) {\n        uint a;\n        assembly {\n            let number.amount := 200\n            a := add(number.amount, 100)\n        }\n        return a;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let number.amount := 200             a := add(number ...\n                                        ^-----------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleFive {\n    function retrieveValue() public pure returns (uint) {\n        uint b;\n        assembly {\n            let value.info := 65\n            b := add(value.info, 35)\n        }\n        return b;\n    }\n    function extraFuncOne() public pure returns (uint) {\n        return 250;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let value.info := 65             b := add(value.i ...\n                                        ^--------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleSix {\n    function gatherDetails() public pure returns (uint) {\n        uint c;\n        assembly {\n            let details.info := 110\n            c := add(details.info, 90)\n        }\n        return c;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let details.info := 110             c := add(detail ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleSeven {\n    function deriveResult() public pure returns (uint) {\n        uint d;\n        assembly {\n            let result.data := 120\n            d := add(result.data, 30)\n        }\n        return d;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let result.data := 120             d := add(result ...\n                                        ^---------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleEight {\n    function extractInfo() public pure returns (uint) {\n        uint e;\n        assembly {\n            let info.part := 140\n            e := add(info.part, 60)\n        }\n        return e;\n    }\n    function extraFuncTwo() public pure returns (uint) {\n        return 360;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let info.part := 140             e := add(info.p ...\n                                        ^-------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleNine {\n    function obtainValue() public pure returns (uint) {\n        uint f;\n        assembly {\n            let value.amount := 170\n            f := add(value.amount, 30)\n        }\n        return f;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let value.amount := 170             f := add(value. ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyExampleTen {\n    function fetchDetail() public pure returns (uint) {\n        uint g;\n        assembly {\n            let detail.info := 95\n            g := add(detail.info, 5)\n        }\n        return g;\n    }\n    function additionalFunction() public pure returns (uint) {\n        return 450;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let detail.info := 95             g := add(detail. ...\n                                        ^---------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract AssemblyExampleOne {\n    function computeAmount() public pure returns (uint) {\n        uint x;\n        assembly {\n            let tempAmount := 150\n            x := add(tempAmount, 50)\n        }\n        return x;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract AssemblyExampleTwo {\n    function calculateTotal() public pure returns (uint) {\n        uint y;\n        assembly {\n            let totalValue := 80\n            y := add(totalValue, 20)\n        }\n        return y;\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 1000;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract AssemblyExampleThree {\n    function getResult() public pure returns (uint) {\n        uint z;\n        assembly {\n            let resultValue := 90\n            z := add(resultValue, 10)\n        }\n        return z;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract AssemblyExampleFour {\n    function generateNumber() public pure returns (uint) {\n        uint a;\n        assembly {\n            let numberAmount := 200\n            a := add(numberAmount, 100)\n        }\n        return a;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract AssemblyExampleFive {\n    function retrieveValue() public pure returns (uint) {\n        uint b;\n        assembly {\n            let valueInfo := 65\n            b := add(valueInfo, 35)\n        }\n        return b;\n    }\n    function extraFuncOne() public pure returns (uint) {\n        return 250;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract AssemblyExampleSix {\n    function gatherDetails() public pure returns (uint) {\n        uint c;\n        assembly {\n            let detailsInfo := 110\n            c := add(detailsInfo, 90)\n        }\n        return c;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract AssemblyExampleSeven {\n    function deriveResult() public pure returns (uint) {\n        uint d;\n        assembly {\n            let resultData := 120\n            d := add(resultData, 30)\n        }\n        return d;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract AssemblyExampleEight {\n    function extractInfo() public pure returns (uint) {\n        uint e;\n        assembly {\n            let infoPart := 140\n            e := add(infoPart, 60)\n        }\n        return e;\n    }\n    function extraFuncTwo() public pure returns (uint) {\n        return 360;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract AssemblyExampleNine {\n    function obtainValue() public pure returns (uint) {\n        uint f;\n        assembly {\n            let valueAmount := 170\n            f := add(valueAmount, 30)\n        }\n        return f;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract AssemblyExampleTen {\n    function fetchDetail() public pure returns (uint) {\n        uint g;\n        assembly {\n            let detailInfo := 95\n            g := add(detailInfo, 5)\n        }\n        return g;\n    }\n    function additionalFunction() public pure returns (uint) {\n        return 450;\n    }\n}"
      }
    }
  },
  {
    "Changes110": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Slot and offset of storage pointer variable <code>x</code> are accessed via <code>x.slot</code>\nand <code>x.offset</code> instead of <code>x_slot</code> and <code>x_offset</code>.Change <code>_slot</code> and <code>_offset</code> suffixes in inline assembly to <code>.slot</code> and <code>.offset</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Profile {\n        uint256 age;\n    }\n\n    Profile private profile;\n\n    function setAge(uint256 _age) public {\n        profile.age = _age;\n    }\n\n    function getAge() public view returns (uint256) {\n        return profile.age;\n    }\n\n    function storageSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 profileSlot;\n        uint256 profileOffset;\n        \n        assembly {\n            profileSlot := profile_slot\n            profileOffset := profile_offset\n        }\n        \n        return (profileSlot, profileOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             profileSlot := profile_slot             profileOffset := profi ...\n                                        ^----------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Record {\n        uint256 value;\n    }\n\n    Record private record;\n\n    function setValue(uint256 _value) public {\n        record.value = _value;\n    }\n\n    function getValue() public view returns (uint256) {\n        return record.value;\n    }\n\n    function findSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 recordSlot;\n        uint256 recordOffset;\n        \n        assembly {\n            recordSlot := record_slot\n            recordOffset := record_offset\n        }\n        \n        return (recordSlot, recordOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             recordSlot := record_slot             recordOffset := record ...\n                                        ^---------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Item {\n        uint256 price;\n    }\n\n    Item private item;\n\n    function setPrice(uint256 _price) public {\n        item.price = _price;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return item.price;\n    }\n\n    function retrieveStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 itemSlot;\n        uint256 itemOffset;\n        \n        assembly {\n            itemSlot := item_slot\n            itemOffset := item_offset\n        }\n        \n        return (itemSlot, itemOffset);\n    }\n\n    function dummyFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             itemSlot := item_slot             itemOffset := item_off ...\n                                        ^-------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Entry {\n        uint256 amount;\n    }\n\n    Entry private entry;\n\n    function setAmount(uint256 _amount) public {\n        entry.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return entry.amount;\n    }\n\n    function accessStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 entrySlot;\n        uint256 entryOffset;\n        \n        assembly {\n            entrySlot := entry_slot\n            entryOffset := entry_offset\n        }\n        \n        return (entrySlot, entryOffset);\n    }\n\n    function dummyFunction2() public pure returns (uint256) {\n        return 100;\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             entrySlot := entry_slot             entryOffset := entry_o ...\n                                        ^--------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Detail {\n        uint256 score;\n    }\n\n    Detail private detail;\n\n    function setScore(uint256 _score) public {\n        detail.score = _score;\n    }\n\n    function getScore() public view returns (uint256) {\n        return detail.score;\n    }\n\n    function storageDetails() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 detailSlot;\n        uint256 detailOffset;\n        \n        assembly {\n            detailSlot := detail_slot\n            detailOffset := detail_offset\n        }\n        \n        return (detailSlot, detailOffset);\n    }\n\n    function dummyFunction3() public pure returns (string memory) {\n        return \"Solidity\";\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             detailSlot := detail_slot             detailOffset := detail ...\n                                        ^---------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Property {\n        uint256 size;\n    }\n\n    Property private property;\n\n    function setSize(uint256 _size) public {\n        property.size = _size;\n    }\n\n    function getSize() public view returns (uint256) {\n        return property.size;\n    }\n\n    function retrieveSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 propertySlot;\n        uint256 propertyOffset;\n        \n        assembly {\n            propertySlot := property_slot\n            propertyOffset := property_offset\n        }\n        \n        return (propertySlot, propertyOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... mbly {             propertySlot := property_slot             propertyOffset := prop ...\n                                        ^-----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Token {\n        uint256 balance;\n    }\n\n    Token private token;\n\n    function setBalance(uint256 _balance) public {\n        token.balance = _balance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return token.balance;\n    }\n\n    function getStoragePointers() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 tokenSlot;\n        uint256 tokenOffset;\n        \n        assembly {\n            tokenSlot := token_slot\n            tokenOffset := token_offset\n        }\n        \n        return (tokenSlot, tokenOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             tokenSlot := token_slot             tokenOffset := token_o ...\n                                        ^--------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Value {\n        uint256 amount;\n    }\n\n    Value private value;\n\n    function setAmount(uint256 _amount) public {\n        value.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return value.amount;\n    }\n\n    function fetchSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 valueSlot;\n        uint256 valueOffset;\n        \n        assembly {\n            valueSlot := value_slot\n            valueOffset := value_offset\n        }\n        \n        return (valueSlot, valueOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             valueSlot := value_slot             valueOffset := value_o ...\n                                        ^--------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Account {\n        uint256 balance;\n    }\n\n    Account private account;\n\n    function setBalance(uint256 _balance) public {\n        account.balance = _balance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return account.balance;\n    }\n\n    function retrieveSlotInfo() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 accountSlot;\n        uint256 accountOffset;\n        \n        assembly {\n            accountSlot := account_slot\n            accountOffset := account_offset\n        }\n        \n        return (accountSlot, accountOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             accountSlot := account_slot             accountOffset := accou ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Holder {\n        uint256 quantity;\n    }\n\n    Holder private holder;\n\n    function setQuantity(uint256 _quantity) public {\n        holder.quantity = _quantity;\n    }\n\n    function getQuantity() public view returns (uint256) {\n        return holder.quantity;\n    }\n\n    function storageLocation() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 holderSlot;\n        uint256 holderOffset;\n        \n        assembly {\n            holderSlot := holder_slot\n            holderOffset := holder_offset\n        }\n        \n        return (holderSlot, holderOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             holderSlot := holder_slot             holderOffset := holder ...\n                                        ^---------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Profile {\n        uint256 age;\n    }\n\n    Profile private profile;\n\n    function setAge(uint256 _age) public {\n        profile.age = _age;\n    }\n\n    function getAge() public view returns (uint256) {\n        return profile.age;\n    }\n\n    function storageSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 profileSlot;\n        uint256 profileOffset;\n        \n        assembly {\n            profileSlot := profile.slot\n            profileOffset := profile.offset\n        }\n        \n        return (profileSlot, profileOffset);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Record {\n        uint256 value;\n    }\n\n    Record private record;\n\n    function setValue(uint256 _value) public {\n        record.value = _value;\n    }\n\n    function getValue() public view returns (uint256) {\n        return record.value;\n    }\n\n    function findSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 recordSlot;\n        uint256 recordOffset;\n        \n        assembly {\n            recordSlot := record.slot\n            recordOffset := record.offset\n        }\n        \n        return (recordSlot, recordOffset);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Item {\n        uint256 price;\n    }\n\n    Item private item;\n\n    function setPrice(uint256 _price) public {\n        item.price = _price;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return item.price;\n    }\n\n    function retrieveStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 itemSlot;\n        uint256 itemOffset;\n        \n        assembly {\n            itemSlot := item.slot\n            itemOffset := item.offset\n        }\n        \n        return (itemSlot, itemOffset);\n    }\n\n    function dummyFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Entry {\n        uint256 amount;\n    }\n\n    Entry private entry;\n\n    function setAmount(uint256 _amount) public {\n        entry.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return entry.amount;\n    }\n\n    function accessStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 entrySlot;\n        uint256 entryOffset;\n        \n        assembly {\n            entrySlot := entry.slot\n            entryOffset := entry.offset\n        }\n        \n        return (entrySlot, entryOffset);\n    }\n\n    function dummyFunction2() public pure returns (uint256) {\n        return 100;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Detail {\n        uint256 score;\n    }\n\n    Detail private detail;\n\n    function setScore(uint256 _score) public {\n        detail.score = _score;\n    }\n\n    function getScore() public view returns (uint256) {\n        return detail.score;\n    }\n\n    function storageDetails() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 detailSlot;\n        uint256 detailOffset;\n        \n        assembly {\n            detailSlot := detail.slot\n            detailOffset := detail.offset\n        }\n        \n        return (detailSlot, detailOffset);\n    }\n\n    function dummyFunction3() public pure returns (string memory) {\n        return \"Solidity\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Property {\n        uint256 size;\n    }\n\n    Property private property;\n\n    function setSize(uint256 _size) public {\n        property.size = _size;\n    }\n\n    function getSize() public view returns (uint256) {\n        return property.size;\n    }\n\n    function retrieveSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 propertySlot;\n        uint256 propertyOffset;\n        \n        assembly {\n            propertySlot := property.slot\n            propertyOffset := property.offset\n        }\n        \n        return (propertySlot, propertyOffset);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Token {\n        uint256 balance;\n    }\n\n    Token private token;\n\n    function setBalance(uint256 _balance) public {\n        token.balance = _balance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return token.balance;\n    }\n\n    function getStoragePointers() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 tokenSlot;\n        uint256 tokenOffset;\n        \n        assembly {\n            tokenSlot := token.slot\n            tokenOffset := token.offset\n        }\n        \n        return (tokenSlot, tokenOffset);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Value {\n        uint256 amount;\n    }\n\n    Value private value;\n\n    function setAmount(uint256 _amount) public {\n        value.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return value.amount;\n    }\n\n    function fetchSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 valueSlot;\n        uint256 valueOffset;\n        \n        assembly {\n            valueSlot := value.slot\n            valueOffset := value.offset\n        }\n        \n        return (valueSlot, valueOffset);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Account {\n        uint256 balance;\n    }\n\n    Account private account;\n\n    function setBalance(uint256 _balance) public {\n        account.balance = _balance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return account.balance;\n    }\n\n    function retrieveSlotInfo() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 accountSlot;\n        uint256 accountOffset;\n        \n        assembly {\n            accountSlot := account.slot\n            accountOffset := account.offset\n        }\n        \n        return (accountSlot, accountOffset);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Holder {\n        uint256 quantity;\n    }\n\n    Holder private holder;\n\n    function setQuantity(uint256 _quantity) public {\n        holder.quantity = _quantity;\n    }\n\n    function getQuantity() public view returns (uint256) {\n        return holder.quantity;\n    }\n\n    function storageLocation() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 holderSlot;\n        uint256 holderOffset;\n        \n        assembly {\n            holderSlot := holder.slot\n            holderOffset := holder.offset\n        }\n        \n        return (holderSlot, holderOffset);\n    }\n}"
      }
    }
  },
  {
    "Changes111": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "If a struct or array contains a mapping, it can only be used in storage.\nPreviously, mapping members were silently skipped in memory, which\nis confusing and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Detail {\n        uint amount;\n        mapping(address => uint) credits;\n    }\n\n    Detail[] public details;\n\n    function addDetail(uint _amount) public {\n        Detail memory newDetail;\n        newDetail.amount = _amount;\n        details.push(newDetail);\n    }\n\n    function setCredit(uint index, address user, uint credit) public {\n        details[index].credits[user] = credit;\n    }\n\n    function getCredit(uint index, address user) public view returns (uint) {\n        return details[index].credits[user];\n    }\n}",
          "error message": "Error: Type struct Example11.Detail is only valid in storage because it contains a (nested) mapping.\n ... ail(uint _amount) public {         Detail memory newDetail;         newDetail.amount = _amoun ...\n                                        ^---------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Account {\n        uint balance;\n        mapping(address => uint) allowances;\n    }\n\n    Account[] public accounts;\n\n    function addAccount(uint _balance) public {\n        Account memory newAccount;\n        newAccount.balance = _balance;\n        accounts.push(newAccount);\n    }\n\n    function updateAllowance(uint index, address user, uint allowance) public {\n        accounts[index].allowances[user] = allowance;\n    }\n\n    function viewAllowance(uint index, address user) public view returns (uint) {\n        return accounts[index].allowances[user];\n    }\n\n    function dummyFunction7() public pure returns (string memory) {\n        return \"Dummy function 7\";\n    }\n}",
          "error message": "Error: Type struct Example12.Account is only valid in storage because it contains a (nested) mapping.\n ... nt(uint _balance) public {         Account memory newAccount;         newAccount.balance = _bal ...\n                                        ^-----------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Member {\n        uint id;\n        mapping(address => uint) votes;\n    }\n\n    Member[] public members;\n\n    function registerMember(uint _id) public {\n        Member memory newMember;\n        newMember.id = _id;\n        members.push(newMember);\n    }\n\n    function castVote(uint index, address user, uint vote) public {\n        members[index].votes[user] = vote;\n    }\n\n    function getVote(uint index, address user) public view returns (uint) {\n        return members[index].votes[user];\n    }\n}",
          "error message": "Error: Type struct Example13.Member is only valid in storage because it contains a (nested) mapping.\n ... rMember(uint _id) public {         Member memory newMember;         newMember.id = _id;       ...\n                                        ^---------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Client {\n        uint clientId;\n        mapping(address => uint) balances;\n    }\n\n    Client[] public clients;\n\n    function addClient(uint _clientId) public {\n        Client memory newClient;\n        newClient.clientId = _clientId;\n        clients.push(newClient);\n    }\n\n    function updateBalance(uint index, address user, uint balance) public {\n        clients[index].balances[user] = balance;\n    }\n\n    function getBalance(uint index, address user) public view returns (uint) {\n        return clients[index].balances[user];\n    }\n\n    function dummyFunction8() public pure returns (uint) {\n        return 50;\n    }\n}",
          "error message": "Error: Type struct Example14.Client is only valid in storage because it contains a (nested) mapping.\n ... t(uint _clientId) public {         Client memory newClient;         newClient.clientId = _cli ...\n                                        ^---------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Transaction {\n        uint id;\n        mapping(address => uint) amounts;\n    }\n\n    Transaction[] public transactions;\n\n    function addTransaction(uint _id) public {\n        Transaction memory newTransaction;\n        newTransaction.id = _id;\n        transactions.push(newTransaction);\n    }\n\n    function updateAmount(uint index, address user, uint amount) public {\n        transactions[index].amounts[user] = amount;\n    }\n\n    function getAmount(uint index, address user) public view returns (uint) {\n        return transactions[index].amounts[user];\n    }\n}",
          "error message": "Error: Type struct Example15.Transaction is only valid in storage because it contains a (nested) mapping.\n ... saction(uint _id) public {         Transaction memory newTransaction;         newTransaction.id = _id;  ...\n                                        ^-------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Package {\n        uint packageId;\n        mapping(address => uint) weights;\n    }\n\n    Package[] public packages;\n\n    function addPackage(uint _packageId) public {\n        Package memory newPackage;\n        newPackage.packageId = _packageId;\n        packages.push(newPackage);\n    }\n\n    function setWeight(uint index, address user, uint weight) public {\n        packages[index].weights[user] = weight;\n    }\n\n    function getWeight(uint index, address user) public view returns (uint) {\n        return packages[index].weights[user];\n    }\n}",
          "error message": "Error: Type struct Example16.Package is only valid in storage because it contains a (nested) mapping.\n ... (uint _packageId) public {         Package memory newPackage;         newPackage.packageId = _p ...\n                                        ^-----------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Asset {\n        uint assetId;\n        mapping(address => uint) values;\n    }\n\n    Asset[] public assets;\n\n    function registerAsset(uint _assetId) public {\n        Asset memory newAsset;\n        newAsset.assetId = _assetId;\n        assets.push(newAsset);\n    }\n\n    function setValue(uint index, address user, uint value) public {\n        assets[index].values[user] = value;\n    }\n\n    function getValue(uint index, address user) public view returns (uint) {\n        return assets[index].values[user];\n    }\n\n    function dummyFunction9() public pure returns (bool) {\n        return false;\n    }\n\n    function dummyFunction10() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": "Error: Type struct Example17.Asset is only valid in storage because it contains a (nested) mapping.\n ... et(uint _assetId) public {         Asset memory newAsset;         newAsset.assetId = _asset ...\n                                        ^-------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct ContractDetail {\n        uint contractId;\n        mapping(address => uint) penalties;\n    }\n\n    ContractDetail[] public contractDetails;\n\n    function addContractDetail(uint _contractId) public {\n        ContractDetail memory newContractDetail;\n        newContractDetail.contractId = _contractId;\n        contractDetails.push(newContractDetail);\n    }\n\n    function setPenalty(uint index, address user, uint penalty) public {\n        contractDetails[index].penalties[user] = penalty;\n    }\n\n    function getPenalty(uint index, address user) public view returns (uint) {\n        return contractDetails[index].penalties[user];\n    }\n}",
          "error message": "Error: Type struct Example18.ContractDetail is only valid in storage because it contains a (nested) mapping.\n ... uint _contractId) public {         ContractDetail memory newContractDetail;         newContractDetail.contrac ...\n                                        ^-------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Task {\n        uint taskId;\n        mapping(address => uint) hours;\n    }\n\n    Task[] public tasks;\n\n    function addTask(uint _taskId) public {\n        Task memory newTask;\n        newTask.taskId = _taskId;\n        tasks.push(newTask);\n    }\n\n    function setHours(uint index, address user, uint hour) public {\n        tasks[index].hours[user] = hour;\n    }\n\n    function getHours(uint index, address user) public view returns (uint) {\n        return tasks[index].hours[user];\n    }\n\n    function dummyFunction11() public pure returns (string memory) {\n        return \"Dummy function 11\";\n    }\n}",
          "error message": "Error: Expected identifier but got 'hours'\n ... ;         mapping(address => uint) hours;     }      Task[] public tasks;   ...\n                                        ^---^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Product {\n        uint productId;\n        mapping(address => uint) quantities;\n    }\n\n    Product[] public products;\n\n    function addProduct(uint _productId) public {\n        Product memory newProduct;\n        newProduct.productId = _productId;\n        products.push(newProduct);\n    }\n\n    function setQuantity(uint index, address user, uint quantity) public {\n        products[index].quantities[user] = quantity;\n    }\n\n    function getQuantity(uint index, address user) public view returns (uint) {\n        return products[index].quantities[user];\n    }\n\n    function dummyFunction12() public pure returns (uint) {\n        return 20;\n    }\n}",
          "error message": "Error: Type struct Example20.Product is only valid in storage because it contains a (nested) mapping.\n ... (uint _productId) public {         Product memory newProduct;         newProduct.productId = _p ...\n                                        ^-----------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Detail {\n        uint amount;\n        mapping(address => uint) credits;\n    }\n\n    Detail[] public details;\n\n    function addDetail(uint _amount) public {\n        details.push();\n        Detail storage newDetail = details[details.length - 1];\n        newDetail.amount = _amount;\n    }\n\n    function setCredit(uint index, address user, uint credit) public {\n        details[index].credits[user] = credit;\n    }\n\n    function getCredit(uint index, address user) public view returns (uint) {\n        return details[index].credits[user];\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Account {\n        uint balance;\n        mapping(address => uint) allowances;\n    }\n\n    Account[] public accounts;\n\n    function addAccount(uint _balance) public {\n        accounts.push();\n        Account storage newAccount = accounts[accounts.length - 1];\n        newAccount.balance = _balance;\n    }\n\n    function updateAllowance(uint index, address user, uint allowance) public {\n        accounts[index].allowances[user] = allowance;\n    }\n\n    function viewAllowance(uint index, address user) public view returns (uint) {\n        return accounts[index].allowances[user];\n    }\n\n    function dummyFunction7() public pure returns (string memory) {\n        return \"Dummy function 7\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Member {\n        uint id;\n        mapping(address => uint) votes;\n    }\n\n    Member[] public members;\n\n    function registerMember(uint _id) public {\n        members.push();\n        Member storage newMember = members[members.length - 1];\n        newMember.id = _id;\n    }\n\n    function castVote(uint index, address user, uint vote) public {\n        members[index].votes[user] = vote;\n    }\n\n    function getVote(uint index, address user) public view returns (uint) {\n        return members[index].votes[user];\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Client {\n        uint clientId;\n        mapping(address => uint) balances;\n    }\n\n    Client[] public clients;\n\n    function addClient(uint _clientId) public {\n        clients.push();\n        Client storage newClient = clients[clients.length - 1];\n        newClient.clientId = _clientId;\n    }\n\n    function updateBalance(uint index, address user, uint balance) public {\n        clients[index].balances[user] = balance;\n    }\n\n    function getBalance(uint index, address user) public view returns (uint) {\n        return clients[index].balances[user];\n    }\n\n    function dummyFunction8() public pure returns (uint) {\n        return 50;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Transaction {\n        uint id;\n        mapping(address => uint) amounts;\n    }\n\n    Transaction[] public transactions;\n\n    function addTransaction(uint _id) public {\n        transactions.push();\n        Transaction storage newTransaction = transactions[transactions.length - 1];\n        newTransaction.id = _id;\n    }\n\n    function updateAmount(uint index, address user, uint amount) public {\n        transactions[index].amounts[user] = amount;\n    }\n\n    function getAmount(uint index, address user) public view returns (uint) {\n        return transactions[index].amounts[user];\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Package {\n        uint packageId;\n        mapping(address => uint) weights;\n    }\n\n    Package[] public packages;\n\n    function addPackage(uint _packageId) public {\n        packages.push();\n        Package storage newPackage = packages[packages.length - 1];\n        newPackage.packageId = _packageId;\n    }\n\n    function setWeight(uint index, address user, uint weight) public {\n        packages[index].weights[user] = weight;\n    }\n\n    function getWeight(uint index, address user) public view returns (uint) {\n        return packages[index].weights[user];\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Asset {\n        uint assetId;\n        mapping(address => uint) values;\n    }\n\n    Asset[] public assets;\n\n    function registerAsset(uint _assetId) public {\n        assets.push();\n        Asset storage newAsset = assets[assets.length - 1];\n        newAsset.assetId = _assetId;\n    }\n\n    function setValue(uint index, address user, uint value) public {\n        assets[index].values[user] = value;\n    }\n\n    function getValue(uint index, address user) public view returns (uint) {\n        return assets[index].values[user];\n    }\n\n    function dummyFunction9() public pure returns (bool) {\n        return false;\n    }\n\n    function dummyFunction10() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct ContractDetail {\n        uint contractId;\n        mapping(address => uint) penalties;\n    }\n\n    ContractDetail[] public contractDetails;\n\n    function addContractDetail(uint _contractId) public {\n        contractDetails.push();\n        ContractDetail storage newContractDetail = contractDetails[contractDetails.length - 1];\n        newContractDetail.contractId = _contractId;\n    }\n\n    function setPenalty(uint index, address user, uint penalty) public {\n        contractDetails[index].penalties[user] = penalty;\n    }\n\n    function getPenalty(uint index, address user) public view returns (uint) {\n        return contractDetails[index].penalties[user];\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Task {\n        uint taskId;\n        mapping(address => uint) hours;\n    }\n\n    Task[] public tasks;\n\n    function addTask(uint _taskId) public {\n        tasks.push();\n        Task storage newTask = tasks[tasks.length - 1];\n        newTask.taskId = _taskId;\n    }\n\n    function setHours(uint index, address user, uint hour) public {\n        tasks[index].hours[user] = hour;\n    }\n\n    function getHours(uint index, address user) public view returns (uint) {\n        return tasks[index].hours[user];\n    }\n\n    function dummyFunction11() public pure returns (string memory) {\n        return \"Dummy function 11\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Product {\n        uint productId;\n        mapping(address => uint) quantities;\n    }\n\n    Product[] public products;\n\n    function addProduct(uint _productId) public {\n        products.push();\n        Product storage newProduct = products[products.length - 1];\n        newProduct.productId = _productId;\n    }\n\n    function setQuantity(uint index, address user, uint quantity) public {\n        products[index].quantities[user] = quantity;\n    }\n\n    function getQuantity(uint index, address user) public view returns (uint) {\n        return products[index].quantities[user];\n    }\n\n    function dummyFunction12() public pure returns (uint) {\n        return 20;\n    }\n}"
      }
    }
  },
  {
    "Changes112": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Assignments to structs or arrays in storage does not work if they contain\nmappings.\nPreviously, mappings were silently skipped during the copy operation, which\nis misleading and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Stats {\n        mapping(address => uint) scores;\n        uint total;\n    }\n\n    Stats[] public statsList;\n\n    function addStats() public {\n        Stats storage newStats = statsList.push();\n        newStats.total = 1000;\n        statsList[11] = newStats;\n    }\n\n    function updateScores(uint idx, address user, uint value) public {\n        Stats storage stats = statsList[idx];\n        stats.scores[user] = value;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...     newStats.total = 1000;         statsList[11] = newStats;     }      function up ...\n                                        ^-----------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Config {\n        mapping(address => uint) parameters;\n        uint limit;\n    }\n\n    Config[] public configList;\n\n    function addConfig() public {\n        Config storage newConfig = configList.push();\n        newConfig.limit = 1100;\n        configList[12] = newConfig;\n    }\n\n    function modifyParameters(uint idx, address user, uint val) public {\n        Config storage config = configList[idx];\n        config.parameters[user] = val;\n    }\n    \n    function dummyFunction5() public pure returns (string memory) {\n        return \"Test\";\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...    newConfig.limit = 1100;         configList[12] = newConfig;     }      function m ...\n                                        ^------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Transaction {\n        mapping(address => uint) amounts;\n        uint balance;\n    }\n\n    Transaction[] public transactionList;\n\n    function addTransaction() public {\n        Transaction storage newTransaction = transactionList.push();\n        newTransaction.balance = 1200;\n        transactionList[13] = newTransaction;\n    }\n\n    function updateAmounts(uint idx, address user, uint amount) public {\n        Transaction storage transaction = transactionList[idx];\n        transaction.amounts[user] = amount;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ... ransaction.balance = 1200;         transactionList[13] = newTransaction;     }      funct ...\n                                        ^-----------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct User {\n        mapping(address => uint) details;\n        uint id;\n    }\n\n    User[] public userList;\n\n    function addUser() public {\n        User storage newUser = userList.push();\n        newUser.id = 1300;\n        userList[14] = newUser;\n    }\n\n    function changeDetails(uint idx, address user, uint value) public {\n        User storage usr = userList[idx];\n        usr.details[user] = value;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...         newUser.id = 1300;         userList[14] = newUser;     }      function cha ...\n                                        ^----------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Metadata {\n        mapping(address => uint) values;\n        uint count;\n    }\n\n    Metadata[] public metadataList;\n\n    function addMetadata() public {\n        Metadata storage newMetadata = metadataList.push();\n        newMetadata.count = 1400;\n        metadataList[15] = newMetadata;\n    }\n\n    function updateValues(uint idx, address user, uint val) public {\n        Metadata storage metadata = metadataList[idx];\n        metadata.values[user] = val;\n    }\n    \n    function dummyFunction6() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...  newMetadata.count = 1400;         metadataList[15] = newMetadata;     }      function ...\n                                        ^--------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Data {\n        mapping(address => uint) records;\n        uint amount;\n    }\n\n    Data[] public dataList;\n\n    function addData() public {\n        Data storage newData = dataList.push();\n        newData.amount = 1500;\n        dataList[16] = newData;\n    }\n\n    function updateRecords(uint idx, address user, uint value) public {\n        Data storage data = dataList[idx];\n        data.records[user] = value;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...     newData.amount = 1500;         dataList[16] = newData;     }      function upd ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint total;\n    }\n\n    Log[] public logList;\n\n    function addLog() public {\n        Log storage newLog = logList.push();\n        newLog.total = 1600;\n        logList[17] = newLog;\n    }\n\n    function modifyEntries(uint idx, address user, uint val) public {\n        Log storage log = logList[idx];\n        log.entries[user] = val;\n    }\n    \n    function dummyFunction7() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...       newLog.total = 1600;         logList[17] = newLog;     }      function modi ...\n                                        ^---------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Registry {\n        mapping(address => uint) items;\n        uint count;\n    }\n\n    Registry[] public registryList;\n\n    function addRegistry() public {\n        Registry storage newRegistry = registryList.push();\n        newRegistry.count = 1700;\n        registryList[18] = newRegistry;\n    }\n\n    function updateItems(uint idx, address user, uint amount) public {\n        Registry storage registry = registryList[idx];\n        registry.items[user] = amount;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...  newRegistry.count = 1700;         registryList[18] = newRegistry;     }      function ...\n                                        ^--------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Container {\n        mapping(address => uint) contents;\n        uint volume;\n    }\n\n    Container[] public containerList;\n\n    function addContainer() public {\n        Container storage newContainer = containerList.push();\n        newContainer.volume = 1800;\n        containerList[19] = newContainer;\n    }\n\n    function modifyContents(uint idx, address user, uint value) public {\n        Container storage container = containerList[idx];\n        container.contents[user] = value;\n    }\n    \n    function dummyFunction8() public pure returns (address) {\n        return address(0);\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ... ewContainer.volume = 1800;         containerList[19] = newContainer;     }      functio ...\n                                        ^---------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Box {\n        mapping(address => uint) items;\n        uint size;\n    }\n\n    Box[] public boxList;\n\n    function addBox() public {\n        Box storage newBox = boxList.push();\n        newBox.size = 1900;\n        boxList[20] = newBox;\n    }\n\n    function updateItems(uint idx, address user, uint amount) public {\n        Box storage box = boxList[idx];\n        box.items[user] = amount;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...        newBox.size = 1900;         boxList[20] = newBox;     }      function upda ...\n                                        ^---------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Stats {\n        mapping(address => uint) scores;\n        uint total;\n    }\n\n    Stats[] public statsList;\n\n    function addStats() public {\n        Stats storage newStats = statsList.push();\n        newStats.total = 1000;\n    }\n\n    function updateScores(uint idx, address user, uint value) public {\n        Stats storage stats = statsList[idx];\n        stats.scores[user] = value;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Config {\n        mapping(address => uint) parameters;\n        uint limit;\n    }\n\n    Config[] public configList;\n\n    function addConfig() public {\n        Config storage newConfig = configList.push();\n        newConfig.limit = 1100;\n    }\n\n    function modifyParameters(uint idx, address user, uint val) public {\n        Config storage config = configList[idx];\n        config.parameters[user] = val;\n    }\n    \n    function dummyFunction5() public pure returns (string memory) {\n        return \"Test\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Transaction {\n        mapping(address => uint) amounts;\n        uint balance;\n    }\n\n    Transaction[] public transactionList;\n\n    function addTransaction() public {\n        Transaction storage newTransaction = transactionList.push();\n        newTransaction.balance = 1200;\n    }\n\n    function updateAmounts(uint idx, address user, uint amount) public {\n        Transaction storage transaction = transactionList[idx];\n        transaction.amounts[user] = amount;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct User {\n        mapping(address => uint) details;\n        uint id;\n    }\n\n    User[] public userList;\n\n    function addUser() public {\n        User storage newUser = userList.push();\n        newUser.id = 1300;\n    }\n\n    function changeDetails(uint idx, address user, uint value) public {\n        User storage usr = userList[idx];\n        usr.details[user] = value;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Metadata {\n        mapping(address => uint) values;\n        uint count;\n    }\n\n    Metadata[] public metadataList;\n\n    function addMetadata() public {\n        Metadata storage newMetadata = metadataList.push();\n        newMetadata.count = 1400;\n    }\n\n    function updateValues(uint idx, address user, uint val) public {\n        Metadata storage metadata = metadataList[idx];\n        metadata.values[user] = val;\n    }\n    \n    function dummyFunction6() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Data {\n        mapping(address => uint) records;\n        uint amount;\n    }\n\n    Data[] public dataList;\n\n    function addData() public {\n        Data storage newData = dataList.push();\n        newData.amount = 1500;\n    }\n\n    function updateRecords(uint idx, address user, uint value) public {\n        Data storage data = dataList[idx];\n        data.records[user] = value;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint total;\n    }\n\n    Log[] public logList;\n\n    function addLog() public {\n        Log storage newLog = logList.push();\n        newLog.total = 1600;\n    }\n\n    function modifyEntries(uint idx, address user, uint val) public {\n        Log storage log = logList[idx];\n        log.entries[user] = val;\n    }\n    \n    function dummyFunction7() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Registry {\n        mapping(address => uint) items;\n        uint count;\n    }\n\n    Registry[] public registryList;\n\n    function addRegistry() public {\n        Registry storage newRegistry = registryList.push();\n        newRegistry.count = 1700;\n    }\n\n    function updateItems(uint idx, address user, uint amount) public {\n        Registry storage registry = registryList[idx];\n        registry.items[user] = amount;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Container {\n        mapping(address => uint) contents;\n        uint volume;\n    }\n\n    Container[] public containerList;\n\n    function addContainer() public {\n        Container storage newContainer = containerList.push();\n        newContainer.volume = 1800;\n    }\n\n    function modifyContents(uint idx, address user, uint value) public {\n        Container storage container = containerList[idx];\n        container.contents[user] = value;\n    }\n    \n    function dummyFunction8() public pure returns (address) {\n        return address(0);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Box {\n        mapping(address => uint) items;\n        uint size;\n    }\n\n    Box[] public boxList;\n\n    function addBox() public {\n        Box storage newBox = boxList.push();\n        newBox.size = 1900;\n    }\n\n    function updateItems(uint idx, address user, uint amount) public {\n        Box storage box = boxList[idx];\n        box.items[user] = amount;\n    }\n}"
      }
    }
  },
  {
    "Changes113": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Visibility (<code>public</code> / <code>internal</code>) is not needed for constructors anymore:\nTo prevent a contract from being created, it can be marked <code>abstract</code>.\nThis makes the visibility concept for constructors obsolete.Remove the <code>public</code> keyword from every constructor.Remove the <code>internal</code> keyword from every constructor and add <code>abstract</code> to the contract (if not already present).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract AlphaContract1 {\n    address public supervisor;\n\n    constructor() internal {\n        supervisor = msg.sender;\n    }\n\n    function getSupervisor() public view returns (address) {\n        return supervisor;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...    address public supervisor;      constructor() internal {         supervisor = msg.sender;     }      function getSupervisor() publ ...\n                                        ^-------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BetaContract2 {\n    address public coordinator;\n\n    constructor() internal {\n        coordinator = msg.sender;\n    }\n\n    function getCoordinator() public view returns (address) {\n        return coordinator;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...   address public coordinator;      constructor() internal {         coordinator = msg.sender;     }      function getCoordinator() pub ...\n                                        ^--------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract GammaContract3 {\n    address public chiefOfficer;\n\n    constructor() internal {\n        chiefOfficer = msg.sender;\n    }\n\n    function getChiefOfficer() public view returns (address) {\n        return chiefOfficer;\n    }\n\n    function isChiefOfficer(address _address) public view returns (bool) {\n        return _address == chiefOfficer;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...  address public chiefOfficer;      constructor() internal {         chiefOfficer = msg.sender;     }      function getChiefOfficer() pu ...\n                                        ^---------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract DeltaContract4 {\n    address public leader;\n\n    constructor() internal {\n        leader = msg.sender;\n    }\n\n    function getLeader() public view returns (address) {\n        return leader;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...  {     address public leader;      constructor() internal {         leader = msg.sender;     }      function getLeader() public v ...\n                                        ^---------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract EpsilonContract5 {\n    address public director;\n\n    constructor() internal {\n        director = msg.sender;\n    }\n\n    function getDirector() public view returns (address) {\n        return director;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...      address public director;      constructor() internal {         director = msg.sender;     }      function getDirector() public ...\n                                        ^-----------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ZetaContract6 {\n    address public guardian;\n\n    constructor() internal {\n        guardian = msg.sender;\n    }\n\n    function getGuardian() public view returns (address) {\n        return guardian;\n    }\n\n    function isGuardian(address _address) public view returns (bool) {\n        return _address == guardian;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...      address public guardian;      constructor() internal {         guardian = msg.sender;     }      function getGuardian() public ...\n                                        ^-----------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract EtaContract7 {\n    address public head;\n\n    constructor() internal {\n        head = msg.sender;\n    }\n\n    function getHead() public view returns (address) {\n        return head;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... t7 {     address public head;      constructor() internal {         head = msg.sender;     }      function getHead() public vie ...\n                                        ^-------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ThetaContract8 {\n    address public principal;\n\n    constructor() internal {\n        principal = msg.sender;\n    }\n\n    function getPrincipal() public view returns (address) {\n        return principal;\n    }\n\n    function getWelcomeMessage() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...     address public principal;      constructor() internal {         principal = msg.sender;     }      function getPrincipal() publi ...\n                                        ^------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract IotaContract9 {\n    address public boss;\n\n    constructor() internal {\n        boss = msg.sender;\n    }\n\n    function getBoss() public view returns (address) {\n        return boss;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... t9 {     address public boss;      constructor() internal {         boss = msg.sender;     }      function getBoss() public vie ...\n                                        ^-------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract KappaContract10 {\n    address public controller;\n\n    constructor() internal {\n        controller = msg.sender;\n    }\n\n    function getController() public view returns (address) {\n        return controller;\n    }\n\n    function getStatus() public pure returns (string memory) {\n        return \"Active\";\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...    address public controller;      constructor() internal {         controller = msg.sender;     }      function getController() publ ...\n                                        ^-------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nabstract contract AlphaContract1 {\n    address public supervisor;\n\n    constructor() {\n        supervisor = msg.sender;\n    }\n\n    function getSupervisor() public view returns (address) {\n        return supervisor;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nabstract contract BetaContract2 {\n    address public coordinator;\n\n    constructor() {\n        coordinator = msg.sender;\n    }\n\n    function getCoordinator() public view returns (address) {\n        return coordinator;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nabstract contract GammaContract3 {\n    address public chiefOfficer;\n\n    constructor() {\n        chiefOfficer = msg.sender;\n    }\n\n    function getChiefOfficer() public view returns (address) {\n        return chiefOfficer;\n    }\n\n    function isChiefOfficer(address _address) public view returns (bool) {\n        return _address == chiefOfficer;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nabstract contract DeltaContract4 {\n    address public leader;\n\n    constructor() {\n        leader = msg.sender;\n    }\n\n    function getLeader() public view returns (address) {\n        return leader;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nabstract contract EpsilonContract5 {\n    address public director;\n\n    constructor() {\n        director = msg.sender;\n    }\n\n    function getDirector() public view returns (address) {\n        return director;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nabstract contract ZetaContract6 {\n    address public guardian;\n\n    constructor() {\n        guardian = msg.sender;\n    }\n\n    function getGuardian() public view returns (address) {\n        return guardian;\n    }\n\n    function isGuardian(address _address) public view returns (bool) {\n        return _address == guardian;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nabstract contract EtaContract7 {\n    address public head;\n\n    constructor() {\n        head = msg.sender;\n    }\n\n    function getHead() public view returns (address) {\n        return head;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nabstract contract ThetaContract8 {\n    address public principal;\n\n    constructor() {\n        principal = msg.sender;\n    }\n\n    function getPrincipal() public view returns (address) {\n        return principal;\n    }\n\n    function getWelcomeMessage() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nabstract contract IotaContract9 {\n    address public boss;\n\n    constructor() {\n        boss = msg.sender;\n    }\n\n    function getBoss() public view returns (address) {\n        return boss;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nabstract contract KappaContract10 {\n    address public controller;\n\n    constructor() {\n        controller = msg.sender;\n    }\n\n    function getController() public view returns (address) {\n        return controller;\n    }\n\n    function getStatus() public pure returns (string memory) {\n        return \"Active\";\n    }\n}"
      }
    }
  },
  {
    "Changes114": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Type Checker: Disallow <code>virtual</code> for library functions:\nSince libraries cannot be inherited from, library functions should not be virtual.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib11 {\n    function factorial(uint256 n) public pure virtual returns (uint256) {\n        if (n == 0) {\n            return 1;\n        } else {\n            return n * factorial(n - 1);\n        }\n    }\n}\n\ncontract Example11 {\n    using Lib11 for uint256;\n\n    function calculateFactorial(uint256 n) public pure returns (uint256) {\n        return n.factorial();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib11 {     function factorial(uint256 n) publi ... * factorial(n - 1);         }     } }  contract Example11 {     using  ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib12 {\n    function max(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n\ncontract Example12 {\n    using Lib12 for uint256;\n\n    function findMax(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.max(b);\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib12 {     function max(uint256 a, uint256 b) public pure virtual returns (uint256) {         return a >= b ? a : b;     } }  contract Example12 {     using  ...\n                                        ^-------------------------------------------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib13 {\n    function min(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        return a <= b ? a : b;\n    }\n}\n\ncontract Example13 {\n    using Lib13 for uint256;\n\n    function findMin(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.min(b);\n    }\n\n    function dummyFunction() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib13 {     function min(uint256 a, uint256 b) public pure virtual returns (uint256) {         return a <= b ? a : b;     } }  contract Example13 {     using  ...\n                                        ^-------------------------------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib14 {\n    function abs(int256 a) public pure virtual returns (int256) {\n        return a >= 0 ? a : -a;\n    }\n}\n\ncontract Example14 {\n    using Lib14 for int256;\n\n    function getAbsolute(int256 a) public pure returns (int256) {\n        return a.abs();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib14 {     function abs(int256 a) public pure virtual returns (int256) {         return a >= 0 ? a : -a;     } }  contract Example14 {     using  ...\n                                        ^-------------------------------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib15 {\n    function isPositive(int256 a) public pure virtual returns (bool) {\n        return a > 0;\n    }\n}\n\ncontract Example15 {\n    using Lib15 for int256;\n\n    function checkPositive(int256 a) public pure returns (bool) {\n        return a.isPositive();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib15 {     function isPositive(int256 a) public pure virtual returns (bool) {         return a > 0;     } }  contract Example15 {     using  ...\n                                        ^--------------------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib16 {\n    function gcd(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        while (b != 0) {\n            uint256 temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n\ncontract Example16 {\n    using Lib16 for uint256;\n\n    function calculateGCD(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.gcd(b);\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib16 {     function gcd(uint256 a, uint256 b)  ... ;         }         return a;     } }  contract Example16 {     using  ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib17 {\n    function lcm(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        return (a * b);\n    }\n}\n\ncontract Example17 {\n    using Lib17 for uint256;\n\n    function calculateLCM(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.lcm(b);\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib17 {     function lcm(uint256 a, uint256 b) public pure virtual returns (uint256) {         return (a * b);     } }  contract Example17 {     using  ...\n                                        ^------------------------------------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib18 {\n    function isPrime(uint256 num) public pure virtual returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint256 i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\ncontract Example18 {\n    using Lib18 for uint256;\n\n    function checkPrime(uint256 num) public pure returns (bool) {\n        return num.isPrime();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib18 {     function isPrime(uint256 num) publi ...        }         return true;     } }  contract Example18 {     using  ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib19 {\n    function fibonacci(uint256 n) public pure virtual returns (uint256) {\n        if (n == 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        } else {\n            return fibonacci(n - 1) + fibonacci(n - 2);\n        }\n    }\n}\n\ncontract Example19 {\n    using Lib19 for uint256;\n\n    function calculateFibonacci(uint256 n) public pure returns (uint256) {\n        return n.fibonacci();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib19 {     function fibonacci(uint256 n) publi ... + fibonacci(n - 2);         }     } }  contract Example19 {     using  ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib20 {\n    function isOdd(uint256 a) public pure virtual returns (bool) {\n        return a % 2 != 0;\n    }\n}\n\ncontract Example20 {\n    using Lib20 for uint256;\n\n    function checkOdd(uint256 a) public pure returns (bool) {\n        return a.isOdd();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib20 {     function isOdd(uint256 a) public pure virtual returns (bool) {         return a % 2 != 0;     } }  contract Example20 {     using  ...\n                                        ^---------------------------------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary Lib11 {\n    function factorial(uint256 n) public pure returns (uint256) {\n        if (n == 0) {\n            return 1;\n        } else {\n            return n * factorial(n - 1);\n        }\n    }\n}\n\ncontract Example11 {\n    using Lib11 for uint256;\n\n    function calculateFactorial(uint256 n) public pure returns (uint256) {\n        return n.factorial();\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary Lib12 {\n    function max(uint256 a, uint256 b) public pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n}\n\ncontract Example12 {\n    using Lib12 for uint256;\n\n    function findMax(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.max(b);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary Lib13 {\n    function min(uint256 a, uint256 b) public pure returns (uint256) {\n        return a <= b ? a : b;\n    }\n}\n\ncontract Example13 {\n    using Lib13 for uint256;\n\n    function findMin(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.min(b);\n    }\n\n    function dummyFunction() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary Lib14 {\n    function abs(int256 a) public pure returns (int256) {\n        return a >= 0 ? a : -a;\n    }\n}\n\ncontract Example14 {\n    using Lib14 for int256;\n\n    function getAbsolute(int256 a) public pure returns (int256) {\n        return a.abs();\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary Lib15 {\n    function isPositive(int256 a) public pure returns (bool) {\n        return a > 0;\n    }\n}\n\ncontract Example15 {\n    using Lib15 for int256;\n\n    function checkPositive(int256 a) public pure returns (bool) {\n        return a.isPositive();\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary Lib16 {\n    function gcd(uint256 a, uint256 b) public pure returns (uint256) {\n        while (b != 0) {\n            uint256 temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}\n\ncontract Example16 {\n    using Lib16 for uint256;\n\n    function calculateGCD(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.gcd(b);\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary Lib17 {\n    function lcm(uint256 a, uint256 b) public pure returns (uint256) {\n        return (a * b);\n    }\n}\n\ncontract Example17 {\n    using Lib17 for uint256;\n\n    function calculateLCM(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.lcm(b);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary Lib18 {\n    function isPrime(uint256 num) public pure returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint256 i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\ncontract Example18 {\n    using Lib18 for uint256;\n\n    function checkPrime(uint256 num) public pure returns (bool) {\n        return num.isPrime();\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary Lib19 {\n    function fibonacci(uint256 n) public pure returns (uint256) {\n        if (n == 0) {\n            return 0;\n        } else if (n == 1) {\n            return 1;\n        } else {\n            return fibonacci(n - 1) + fibonacci(n - 2);\n        }\n    }\n}\n\ncontract Example19 {\n    using Lib19 for uint256;\n\n    function calculateFibonacci(uint256 n) public pure returns (uint256) {\n        return n.fibonacci();\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary Lib20 {\n    function isOdd(uint256 a) public pure returns (bool) {\n        return a % 2 != 0;\n    }\n}\n\ncontract Example20 {\n    using Lib20 for uint256;\n\n    function checkOdd(uint256 a) public pure returns (bool) {\n        return a.isOdd();\n    }\n}"
      }
    }
  },
  {
    "Changes115": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Multiple events with the same name and parameter types in the same\ninheritance hierarchy are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Alpha {\n    event LogEvent(uint256 indexed id, string message);\n\n    function fireEvent(uint256 _id, string memory _message) public {\n        emit LogEvent(_id, _message);\n    }\n}\n\ncontract BetaA is Alpha {\n    event LogEvent(uint256 indexed id, string message);\n\n    function fireEventA(uint256 _id, string memory _message) public {\n        emit LogEvent(_id, _message);\n    }\n}\n\ncontract BetaB is Alpha {\n    event LogEvent(uint256 indexed id, string message);\n\n    function fireEventB(uint256 _id, string memory _message) public {\n        emit LogEvent(_id, _message);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... } }  contract BetaA is Alpha {     event LogEvent(uint256 indexed id, string message);      function fireEventA(uint256 _ ..."
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Creator {\n    event Notification(uint256 indexed code, string description);\n\n    function notify(uint256 _code, string memory _description) public {\n        emit Notification(_code, _description);\n    }\n}\n\ncontract Actor1 is Creator {\n    event Notification(uint256 indexed code, string description);\n\n    function notify1(uint256 _code, string memory _description) public {\n        emit Notification(_code, _description);\n    }\n}\n\ncontract Actor2 is Creator {\n    event Notification(uint256 indexed code, string description);\n\n    function notify2(uint256 _code, string memory _description) public {\n        emit Notification(_code, _description);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...   contract Actor1 is Creator {     event Notification(uint256 indexed code, string description);      function notify1(uint256 _cod ..."
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseEntity {\n    event Status(uint256 indexed index, string detail);\n\n    function setStatus(uint256 _index, string memory _detail) public {\n        emit Status(_index, _detail);\n    }\n}\n\ncontract Entity1 is BaseEntity {\n    event Status(uint256 indexed index, string detail);\n\n    function setStatus1(uint256 _index, string memory _detail) public {\n        emit Status(_index, _detail);\n    }\n}\n\ncontract Entity2 is BaseEntity {\n    event Status(uint256 indexed index, string detail);\n\n    function setStatus2(uint256 _index, string memory _detail) public {\n        emit Status(_index, _detail);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... ntract Entity1 is BaseEntity {     event Status(uint256 indexed index, string detail);      function setStatus1(uint256 _ ..."
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ParentContract {\n    event Record(uint256 indexed id, string info);\n\n    function addRecord(uint256 _id, string memory _info) public {\n        emit Record(_id, _info);\n    }\n}\n\ncontract ChildContractA is ParentContract {\n    event Record(uint256 indexed id, string info);\n\n    function addRecordA(uint256 _id, string memory _info) public {\n        emit Record(_id, _info);\n    }\n}\n\ncontract ChildContractB is ParentContract {\n    event Record(uint256 indexed id, string info);\n\n    function addRecordB(uint256 _id, string memory _info) public {\n        emit Record(_id, _info);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... dContractA is ParentContract {     event Record(uint256 indexed id, string info);      function addRecordA(uint256 _ ..."
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Master {\n    event Entry(uint256 indexed key, string data);\n\n    function logEntry(uint256 _key, string memory _data) public {\n        emit Entry(_key, _data);\n    }\n}\n\ncontract UnitA is Master {\n    event Entry(uint256 indexed key, string data);\n\n    function logEntryA(uint256 _key, string memory _data) public {\n        emit Entry(_key, _data);\n    }\n}\n\ncontract UnitB is Master {\n    event Entry(uint256 indexed key, string data);\n\n    function logEntryB(uint256 _key, string memory _data) public {\n        emit Entry(_key, _data);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...  }  contract UnitA is Master {     event Entry(uint256 indexed key, string data);      function logEntryA(uint256 _k ..."
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Source {\n    event Alert(uint256 indexed id, string notification);\n\n    function triggerAlert(uint256 _id, string memory _notification) public {\n        emit Alert(_id, _notification);\n    }\n}\n\ncontract BranchA is Source {\n    event Alert(uint256 indexed id, string notification);\n\n    function triggerAlertA(uint256 _id, string memory _notification) public {\n        emit Alert(_id, _notification);\n    }\n}\n\ncontract BranchB is Source {\n    event Alert(uint256 indexed id, string notification);\n\n    function triggerAlertB(uint256 _id, string memory _notification) public {\n        emit Alert(_id, _notification);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...   contract BranchA is Source {     event Alert(uint256 indexed id, string notification);      function triggerAlertA(uint25 ..."
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Top {\n    event Notification(uint256 indexed code, string message);\n\n    function sendNotification(uint256 _code, string memory _message) public {\n        emit Notification(_code, _message);\n    }\n}\n\ncontract Bottom1 is Top {\n    event Notification(uint256 indexed code, string message);\n\n    function sendNotification1(uint256 _code, string memory _message) public {\n        emit Notification(_code, _message);\n    }\n}\n\ncontract Bottom2 is Top {\n    event Notification(uint256 indexed code, string message);\n\n    function sendNotification2(uint256 _code, string memory _message) public {\n        emit Notification(_code, _message);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... } }  contract Bottom1 is Top {     event Notification(uint256 indexed code, string message);      function sendNotification1(ui ..."
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract RootContract {\n    event Signal(uint256 indexed id, string text);\n\n    function emitSignal(uint256 _id, string memory _text) public {\n        emit Signal(_id, _text);\n    }\n}\n\ncontract Node1 is RootContract {\n    event Signal(uint256 indexed id, string text);\n\n    function emitSignal1(uint256 _id, string memory _text) public {\n        emit Signal(_id, _text);\n    }\n}\n\ncontract Node2 is RootContract {\n    event Signal(uint256 indexed id, string text);\n\n    function emitSignal2(uint256 _id, string memory _text) public {\n        emit Signal(_id, _text);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... ntract Node1 is RootContract {     event Signal(uint256 indexed id, string text);      function emitSignal1(uint256  ..."
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract CoreContract {\n    event Log(uint256 indexed id, string info);\n\n    function generateLog(uint256 _id, string memory _info) public {\n        emit Log(_id, _info);\n    }\n}\n\ncontract SegmentA is CoreContract {\n    event Log(uint256 indexed id, string info);\n\n    function generateLogA(uint256 _id, string memory _info) public {\n        emit Log(_id, _info);\n    }\n}\n\ncontract SegmentB is CoreContract {\n    event Log(uint256 indexed id, string info);\n\n    function generateLogB(uint256 _id, string memory _info) public {\n        emit Log(_id, _info);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... act SegmentA is CoreContract {     event Log(uint256 indexed id, string info);      function generateLogA(uint256 ..."
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract OriginContract {\n    event LogData(uint256 indexed key, string detail);\n\n    function recordLogData(uint256 _key, string memory _detail) public {\n        emit LogData(_key, _detail);\n    }\n}\n\ncontract PartA is OriginContract {\n    event LogData(uint256 indexed key, string detail);\n\n    function recordLogDataA(uint256 _key, string memory _detail) public {\n        emit LogData(_key, _detail);\n    }\n}\n\ncontract PartB is OriginContract {\n    event LogData(uint256 indexed key, string detail);\n\n    function recordLogDataB(uint256 _key, string memory _detail) public {\n        emit LogData(_key, _detail);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... ract PartA is OriginContract {     event LogData(uint256 indexed key, string detail);      function recordLogDataA(uint2 ..."
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Alpha {\n    event LogEvent(uint256 indexed id, string message);\n\n    function fireEvent(uint256 _id, string memory _message) public {\n        emit LogEvent(_id, _message);\n    }\n}\n\ncontract BetaA is Alpha {\n    event LogEventA(uint256 indexed id, string message);\n\n    function fireEventA(uint256 _id, string memory _message) public {\n        emit LogEventA(_id, _message);\n    }\n}\n\ncontract BetaB is Alpha {\n    event LogEventB(uint256 indexed id, string message);\n\n    function fireEventB(uint256 _id, string memory _message) public {\n        emit LogEventB(_id, _message);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Creator {\n    event Notification(uint256 indexed code, string description);\n\n    function notify(uint256 _code, string memory _description) public {\n        emit Notification(_code, _description);\n    }\n}\n\ncontract Actor1 is Creator {\n    event Notification1(uint256 indexed code, string description);\n\n    function notify1(uint256 _code, string memory _description) public {\n        emit Notification1(_code, _description);\n    }\n}\n\ncontract Actor2 is Creator {\n    event Notification2(uint256 indexed code, string description);\n\n    function notify2(uint256 _code, string memory _description) public {\n        emit Notification2(_code, _description);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract BaseEntity {\n    event Status(uint256 indexed index, string detail);\n\n    function setStatus(uint256 _index, string memory _detail) public {\n        emit Status(_index, _detail);\n    }\n}\n\ncontract Entity1 is BaseEntity {\n    event Status1(uint256 indexed index, string detail);\n\n    function setStatus1(uint256 _index, string memory _detail) public {\n        emit Status1(_index, _detail);\n    }\n}\n\ncontract Entity2 is BaseEntity {\n    event Status2(uint256 indexed index, string detail);\n\n    function setStatus2(uint256 _index, string memory _detail) public {\n        emit Status2(_index, _detail);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ParentContract {\n    event Record(uint256 indexed id, string info);\n\n    function addRecord(uint256 _id, string memory _info) public {\n        emit Record(_id, _info);\n    }\n}\n\ncontract ChildContractA is ParentContract {\n    event RecordA(uint256 indexed id, string info);\n\n    function addRecordA(uint256 _id, string memory _info) public {\n        emit RecordA(_id, _info);\n    }\n}\n\ncontract ChildContractB is ParentContract {\n    event RecordB(uint256 indexed id, string info);\n\n    function addRecordB(uint256 _id, string memory _info) public {\n        emit RecordB(_id, _info);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Master {\n    event Entry(uint256 indexed key, string data);\n\n    function logEntry(uint256 _key, string memory _data) public {\n        emit Entry(_key, _data);\n    }\n}\n\ncontract UnitA is Master {\n    event EntryA(uint256 indexed key, string data);\n\n    function logEntryA(uint256 _key, string memory _data) public {\n        emit EntryA(_key, _data);\n    }\n}\n\ncontract UnitB is Master {\n    event EntryB(uint256 indexed key, string data);\n\n    function logEntryB(uint256 _key, string memory _data) public {\n        emit EntryB(_key, _data);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Source {\n    event Alert(uint256 indexed id, string notification);\n\n    function triggerAlert(uint256 _id, string memory _notification) public {\n        emit Alert(_id, _notification);\n    }\n}\n\ncontract BranchA is Source {\n    event AlertA(uint256 indexed id, string notification);\n\n    function triggerAlertA(uint256 _id, string memory _notification) public {\n        emit AlertA(_id, _notification);\n    }\n}\n\ncontract BranchB is Source {\n    event AlertB(uint256 indexed id, string notification);\n\n    function triggerAlertB(uint256 _id, string memory _notification) public {\n        emit AlertB(_id, _notification);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Top {\n    event Notification(uint256 indexed code, string message);\n\n    function sendNotification(uint256 _code, string memory _message) public {\n        emit Notification(_code, _message);\n    }\n}\n\ncontract Bottom1 is Top {\n    event Notification1(uint256 indexed code, string message);\n\n    function sendNotification1(uint256 _code, string memory _message) public {\n        emit Notification1(_code, _message);\n    }\n}\n\ncontract Bottom2 is Top {\n    event Notification2(uint256 indexed code, string message);\n\n    function sendNotification2(uint256 _code, string memory _message) public {\n        emit Notification2(_code, _message);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract RootContract {\n    event Signal(uint256 indexed id, string text);\n\n    function emitSignal(uint256 _id, string memory _text) public {\n        emit Signal(_id, _text);\n    }\n}\n\ncontract Node1 is RootContract {\n    event Signal1(uint256 indexed id, string text);\n\n    function emitSignal1(uint256 _id, string memory _text) public {\n        emit Signal1(_id, _text);\n    }\n}\n\ncontract Node2 is RootContract {\n    event Signal2(uint256 indexed id, string text);\n\n    function emitSignal2(uint256 _id, string memory _text) public {\n        emit Signal2(_id, _text);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract CoreContract {\n    event Log(uint256 indexed id, string info);\n\n    function generateLog(uint256 _id, string memory _info) public {\n        emit Log(_id, _info);\n    }\n}\n\ncontract SegmentA is CoreContract {\n    event LogA(uint256 indexed id, string info);\n\n    function generateLogA(uint256 _id, string memory _info) public {\n        emit LogA(_id, _info);\n    }\n}\n\ncontract SegmentB is CoreContract {\n    event LogB(uint256 indexed id, string info);\n\n    function generateLogB(uint256 _id, string memory _info) public {\n        emit LogB(_id, _info);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract OriginContract {\n    event LogData(uint256 indexed key, string detail);\n\n    function recordLogData(uint256 _key, string memory _detail) public {\n        emit LogData(_key, _detail);\n    }\n}\n\ncontract PartA is OriginContract {\n    event LogDataA(uint256 indexed key, string detail);\n\n    function recordLogDataA(uint256 _key, string memory _detail) public {\n        emit LogDataA(_key, _detail);\n    }\n}\n\ncontract PartB is OriginContract {\n    event LogDataB(uint256 indexed key, string detail);\n\n    function recordLogDataB(uint256 _key, string memory _detail) public {\n        emit LogDataB(_key, _detail);\n    }\n}"
      }
    }
  },
  {
    "Changes116": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "<code>using A for B</code> only affects the contract it is mentioned in.\nPreviously, the effect was inherited. Now, you have to repeat the <code>using</code>\nstatement in all derived contracts that make use of the feature.Repeat the <code>using A for B</code> statements in all derived contracts if needed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary BasicMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"BasicMath: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Root {\n    using BasicMath for uint256;\n    \n    uint256 public rootValue;\n    \n    function multiply(uint256 _value) public {\n        rootValue = _value.mul(3);\n    }\n}\n\ncontract Branch is Root {\n    function expand(uint256 _value) public {\n        rootValue = _value.mul(6);\n    }\n}",
          "error message": "Error: Member \"mul\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         rootValue = _value.mul(6);     } }\n                                        ^--------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary DivOperations {\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DivOperations: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Divider {\n    using DivOperations for uint256;\n    \n    uint256 public dividerValue;\n    \n    function divide(uint256 _value) public {\n        dividerValue = _value.div(4);\n    }\n}\n\ncontract Splitter is Divider {\n    function split(uint256 _value) public {\n        dividerValue = _value.div(5);\n    }\n}",
          "error message": "Error: Member \"div\" not found or not visible after argument-dependent lookup in uint256.\n ... e) public {         dividerValue = _value.div(5);     } }\n                                        ^--------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Modulus {\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Modulus: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract BaseMod {\n    using Modulus for uint256;\n    \n    uint256 public baseModValue;\n    \n    function modulo(uint256 _value) public {\n        baseModValue = _value.mod(4);\n    }\n}\n\ncontract DerivedMod is BaseMod {\n    function remainder(uint256 _value) public {\n        baseModValue = _value.mod(6);\n    }\n}",
          "error message": "Error: Member \"mod\" not found or not visible after argument-dependent lookup in uint256.\n ... e) public {         baseModValue = _value.mod(6);     } }\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Exponentiation {\n    function pow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 result = 1;\n        for (uint256 i = 0; i < exp; i++) {\n            result = result * base;\n        }\n        return result;\n    }\n}\n\ncontract Power {\n    using Exponentiation for uint256;\n    \n    uint256 public powerValue;\n    \n    function exponent(uint256 _base, uint256 _exp) public {\n        powerValue = _base.pow(_exp);\n    }\n}\n\ncontract Exponent is Power {\n    function raise(uint256 _base, uint256 _exp) public {\n        powerValue = _base.pow(_exp + 2);\n    }\n}",
          "error message": "Error: Member \"pow\" not found or not visible after argument-dependent lookup in uint256.\n ... exp) public {         powerValue = _base.pow(_exp + 2);     } }\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Percentage {\n    function addPercentage(uint256 a, uint256 percent) internal pure returns (uint256) {\n        return a + (a * percent / 100);\n    }\n}\n\ncontract Amount {\n    using Percentage for uint256;\n    \n    uint256 public amountValue;\n    \n    function addPercent(uint256 _value, uint256 _percent) public {\n        amountValue = _value.addPercentage(_percent);\n    }\n}\n\ncontract Fraction is Amount {\n    function increase(uint256 _value, uint256 _percent) public {\n        amountValue = _value.addPercentage(_percent + 3);\n    }\n}",
          "error message": "Error: Member \"addPercentage\" not found or not visible after argument-dependent lookup in uint256.\n ... nt) public {         amountValue = _value.addPercentage(_percent + 3);     } }\n                                        ^------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Averages {\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b) / 2;\n    }\n}\n\ncontract AverageCalculator {\n    using Averages for uint256;\n    \n    uint256 public averageValue;\n    \n    function calculateAverage(uint256 _a, uint256 _b) public {\n        averageValue = _a.average(_b);\n    }\n}\n\ncontract MeanCalculator is AverageCalculator {\n    function calculateMean(uint256 _a, uint256 _b) public {\n        averageValue = _a.average(_b + 2);\n    }\n}",
          "error message": "Error: Member \"average\" not found or not visible after argument-dependent lookup in uint256.\n ... b) public {         averageValue = _a.average(_b + 2);     } }\n                                        ^--------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Incrementer {\n    function increment(uint256 a) internal pure returns (uint256) {\n        return a + 1;\n    }\n}\n\ncontract Incremental {\n    using Incrementer for uint256;\n    \n    uint256 public incrementalValue;\n    \n    function addOne(uint256 _value) public {\n        incrementalValue = _value.increment();\n    }\n}\n\ncontract Increment is Incremental {\n    function addTwo(uint256 _value) public {\n        incrementalValue = _value.increment() + 1;\n    }\n}",
          "error message": "Error: Member \"increment\" not found or not visible after argument-dependent lookup in uint256.\n ... ublic {         incrementalValue = _value.increment() + 1;     } }\n                                        ^--------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Doubling {\n    function double(uint256 a) internal pure returns (uint256) {\n        return a * 2;\n    }\n}\n\ncontract Double {\n    using Doubling for uint256;\n    \n    uint256 public doubleValue;\n    \n    function doubleAmount(uint256 _value) public {\n        doubleValue = _value.double();\n    }\n}\n\ncontract DoublePlus is Double {\n    function doubleAndAdd(uint256 _value) public {\n        doubleValue = _value.double() + 2;\n    }\n}",
          "error message": "Error: Member \"double\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         doubleValue = _value.double() + 2;     } }\n                                        ^-----------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Squarer {\n    function square(uint256 a) internal pure returns (uint256) {\n        return a * a;\n    }\n}\n\ncontract SquareCalculator {\n    using Squarer for uint256;\n    \n    uint256 public squareValue;\n    \n    function calculateSquare(uint256 _value) public {\n        squareValue = _value.square();\n    }\n}\n\ncontract SquarerPlus is SquareCalculator {\n    function calculateSquarePlus(uint256 _value) public {\n        squareValue = _value.square() + 5;\n    }\n}",
          "error message": "Error: Member \"square\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         squareValue = _value.square() + 5;     } }\n                                        ^-----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Enhancer {\n    function enhance(uint256 a) internal pure returns (uint256) {\n        return a + 100;\n    }\n}\n\ncontract BasicEnhancer {\n    using Enhancer for uint256;\n    \n    uint256 public enhancedValue;\n    \n    function enhanceValue(uint256 _value) public {\n        enhancedValue = _value.enhance();\n    }\n}\n\ncontract AdvancedEnhancer is BasicEnhancer {\n    function doubleEnhance(uint256 _value) public {\n        enhancedValue = _value.enhance() * 2;\n    }\n}",
          "error message": "Error: Member \"enhance\" not found or not visible after argument-dependent lookup in uint256.\n ... ) public {         enhancedValue = _value.enhance() * 2;     } }\n                                        ^------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary BasicMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"BasicMath: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Root {\n    using BasicMath for uint256;\n    \n    uint256 public rootValue;\n    \n    function multiply(uint256 _value) public {\n        rootValue = _value.mul(3);\n    }\n}\n\ncontract Branch is Root {\n    using BasicMath for uint256;\n\n    function expand(uint256 _value) public {\n        rootValue = _value.mul(6);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary DivOperations {\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DivOperations: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Divider {\n    using DivOperations for uint256;\n    \n    uint256 public dividerValue;\n    \n    function divide(uint256 _value) public {\n        dividerValue = _value.div(4);\n    }\n}\n\ncontract Splitter is Divider {\n    using DivOperations for uint256;\n\n    function split(uint256 _value) public {\n        dividerValue = _value.div(5);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary Modulus {\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Modulus: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract BaseMod {\n    using Modulus for uint256;\n    \n    uint256 public baseModValue;\n    \n    function modulo(uint256 _value) public {\n        baseModValue = _value.mod(4);\n    }\n}\n\ncontract DerivedMod is BaseMod {\n    using Modulus for uint256;\n\n    function remainder(uint256 _value) public {\n        baseModValue = _value.mod(6);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary Exponentiation {\n    function pow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 result = 1;\n        for (uint256 i = 0; i < exp; i++) {\n            result = result * base;\n        }\n        return result;\n    }\n}\n\ncontract Power {\n    using Exponentiation for uint256;\n    \n    uint256 public powerValue;\n    \n    function exponent(uint256 _base, uint256 _exp) public {\n        powerValue = _base.pow(_exp);\n    }\n}\n\ncontract Exponent is Power {\n    using Exponentiation for uint256;\n\n    function raise(uint256 _base, uint256 _exp) public {\n        powerValue = _base.pow(_exp + 2);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary Percentage {\n    function addPercentage(uint256 a, uint256 percent) internal pure returns (uint256) {\n        return a + (a * percent / 100);\n    }\n}\n\ncontract Amount {\n    using Percentage for uint256;\n    \n    uint256 public amountValue;\n    \n    function addPercent(uint256 _value, uint256 _percent) public {\n        amountValue = _value.addPercentage(_percent);\n    }\n}\n\ncontract Fraction is Amount {\n    using Percentage for uint256;\n\n    function increase(uint256 _value, uint256 _percent) public {\n        amountValue = _value.addPercentage(_percent + 3);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary Averages {\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b) / 2;\n    }\n}\n\ncontract AverageCalculator {\n    using Averages for uint256;\n    \n    uint256 public averageValue;\n    \n    function calculateAverage(uint256 _a, uint256 _b) public {\n        averageValue = _a.average(_b);\n    }\n}\n\ncontract MeanCalculator is AverageCalculator {\n    using Averages for uint256;\n\n    function calculateMean(uint256 _a, uint256 _b) public {\n        averageValue = _a.average(_b + 2);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary Incrementer {\n    function increment(uint256 a) internal pure returns (uint256) {\n        return a + 1;\n    }\n}\n\ncontract Incremental {\n    using Incrementer for uint256;\n    \n    uint256 public incrementalValue;\n    \n    function addOne(uint256 _value) public {\n        incrementalValue = _value.increment();\n    }\n}\n\ncontract Increment is Incremental {\n    using Incrementer for uint256;\n\n    function addTwo(uint256 _value) public {\n        incrementalValue = _value.increment() + 1;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary Doubling {\n    function double(uint256 a) internal pure returns (uint256) {\n        return a * 2;\n    }\n}\n\ncontract Double {\n    using Doubling for uint256;\n    \n    uint256 public doubleValue;\n    \n    function doubleAmount(uint256 _value) public {\n        doubleValue = _value.double();\n    }\n}\n\ncontract DoublePlus is Double {\n    using Doubling for uint256;\n\n    function doubleAndAdd(uint256 _value) public {\n        doubleValue = _value.double() + 2;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary Squarer {\n    function square(uint256 a) internal pure returns (uint256) {\n        return a * a;\n    }\n}\n\ncontract SquareCalculator {\n    using Squarer for uint256;\n    \n    uint256 public squareValue;\n    \n    function calculateSquare(uint256 _value) public {\n        squareValue = _value.square();\n    }\n}\n\ncontract SquarerPlus is SquareCalculator {\n    using Squarer for uint256;\n\n    function calculateSquarePlus(uint256 _value) public {\n        squareValue = _value.square() + 5;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary Enhancer {\n    function enhance(uint256 a) internal pure returns (uint256) {\n        return a + 100;\n    }\n}\n\ncontract BasicEnhancer {\n    using Enhancer for uint256;\n    \n    uint256 public enhancedValue;\n    \n    function enhanceValue(uint256 _value) public {\n        enhancedValue = _value.enhance();\n    }\n}\n\ncontract AdvancedEnhancer is BasicEnhancer {\n    using Enhancer for uint256;\n\n    function doubleEnhance(uint256 _value) public {\n        enhancedValue = _value.enhance() * 2;\n    }\n}"
      }
    }
  },
  {
    "Changes117": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Shifts by signed types are disallowed.\nPreviously, shifts by negative amounts were allowed, but reverted at runtime.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftExample2 {\n    function shiftLeftExample(int8 a, int8 b) public pure returns (int8) {\n        return a << b;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return a << b;     } }\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitShiftOperations {\n    function performBitShift(int8 x, int8 y) public pure returns (int8) {\n        return x << y;\n    }\n\n    function extraMethod1() public pure returns (uint256) {\n        return 1234;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return x << y;     }      function extraMethod1( ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftBits {\n    function shiftBitsLeft(int8 c, int8 d) public pure returns (int8) {\n        return c << d;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\npragma solidity^0.7.0;  contract ShiftBits {     function shiftBitsLeft(int8 c, int8 d) public pure returns (int8) {         return c << d;     } }\n                                                                                                                                    ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitwiseOperations {\n    function bitwiseShift(int8 e, int8 f) public pure returns (int8) {\n        return e << f;\n    }\n\n    function additionalFunction1() public pure returns (address) {\n        return address(0x123);\n    }\n\n    function additionalFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return e << f;     }      function additionalFun ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftOperation {\n    function shiftLeftOperation(int8 g, int8 h) public pure returns (int8) {\n        return g << h;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return g << h;     } }\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract LeftShiftOperations {\n    function performLeftShift(int8 m, int8 n) public pure returns (int8) {\n        return m << n;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return m << n;     } }\n                                        ^----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftLeftTest {\n    function testShift(int8 p, int8 q) public pure returns (int8) {\n        return p << q;\n    }\n\n    function dummyMethod() public pure returns (uint) {\n        return 9999;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return p << q;     }      function dummyMethod() ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftingBits {\n    function shiftLeftBits(int8 s, int8 t) public pure returns (int8) {\n        return s << t;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\npragma solidity^0.7.0;  contract ShiftingBits {     function shiftLeftBits(int8 s, int8 t) public pure returns (int8) {         return s << t;     } }\n                                                                                                                                       ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract LeftShiftBitwise {\n    function shiftBitsLeft(int8 u, int8 v) public pure returns (int8) {\n        return u << v;\n    }\n\n    function extraMethod2() public pure returns (uint256) {\n        return 5678;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return u << v;     }      function extraMethod2( ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitShiftHandler {\n    function handleBitShift(int8 w, int8 x) public pure returns (int8) {\n        return w << x;\n    }\n\n    function additionalMethod() public pure returns (address) {\n        return address(0xABC);\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return w << x;     }      function additionalMet ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ShiftExample2 {\n    function shiftLeftExample(uint8 a, uint8 b) public pure returns (uint8) {\n        return a << b;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract BitShiftOperations {\n    function performBitShift(uint8 x, uint8 y) public pure returns (uint8) {\n        return x << y;\n    }\n\n    function extraMethod1() public pure returns (uint256) {\n        return 1234;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ShiftBits {\n    function shiftBitsLeft(uint8 c, uint8 d) public pure returns (uint8) {\n        return c << d;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract BitwiseOperations {\n    function bitwiseShift(uint8 e, uint8 f) public pure returns (uint8) {\n        return e << f;\n    }\n\n    function additionalFunction1() public pure returns (address) {\n        return address(0x123);\n    }\n\n    function additionalFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ShiftOperation {\n    function shiftLeftOperation(uint8 g, uint8 h) public pure returns (uint8) {\n        return g << h;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract LeftShiftOperations {\n    function performLeftShift(uint8 m, uint8 n) public pure returns (uint8) {\n        return m << n;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ShiftLeftTest {\n    function testShift(uint8 p, uint8 q) public pure returns (uint8) {\n        return p << q;\n    }\n\n    function dummyMethod() public pure returns (uint) {\n        return 9999;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ShiftingBits {\n    function shiftLeftBits(uint8 s, uint8 t) public pure returns (uint8) {\n        return s << t;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract LeftShiftBitwise {\n    function shiftBitsLeft(uint8 u, uint8 v) public pure returns (uint8) {\n        return u << v;\n    }\n\n    function extraMethod2() public pure returns (uint256) {\n        return 5678;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract BitShiftHandler {\n    function handleBitShift(uint8 w, uint8 x) public pure returns (uint8) {\n        return w << x;\n    }\n\n    function additionalMethod() public pure returns (address) {\n        return address(0xABC);\n    }\n}"
      }
    }
  },
  {
    "Changes118": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The <code>finney</code> and <code>szabo</code> denominations are removed.\nThey are rarely used and do not make the actual amount readily visible. Instead, explicit\nvalues like <code>1e20</code> or the very common <code>gwei</code> can be used.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public amountInFinney = 2 finney;\n\n    function checkAmount() public view returns (uint) {\n        return amountInFinney;\n    }\n\n    function pay() public payable {\n        require(msg.value >= amountInFinney, \"Insufficient payment\");\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...     uint public amountInFinney = 2 finney;      function checkAmount() publi ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public valueInSzabo = 10 szabo;\n\n    function deposit() public payable {\n        require(msg.value >= valueInSzabo, \"Deposit must be at least 10 szabo\");\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...      uint public valueInSzabo = 10 szabo;      function deposit() public pa ...\n                                        ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public threshold = 5 finney;\n\n    function setThreshold(uint _newThreshold) public {\n        threshold = _newThreshold * 1 finney;\n    }\n\n    function isAboveThreshold(uint amount) public view returns (bool) {\n        return amount >= threshold;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... e3 {     uint public threshold = 5 finney;      function setThreshold(uint _ ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public smallAmount = 3 szabo;\n\n    function sendEther() public payable {\n        require(msg.value == smallAmount, \"Must send exactly 3 szabo\");\n    }\n\n    function currentAmount() public view returns (uint) {\n        return smallAmount;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...  {     uint public smallAmount = 3 szabo;      function sendEther() public  ...\n                                        ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public requiredAmount = 7 finney;\n\n    function receivePayment() public payable {\n        require(msg.value == requiredAmount, \"Must send 7 finney\");\n    }\n\n    function checkRequired() public view returns (uint) {\n        return requiredAmount;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...     uint public requiredAmount = 7 finney;      function receivePayment() pu ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public minimumSzabo = 50 szabo;\n\n    function contribute() public payable {\n        require(msg.value >= minimumSzabo, \"Contribution must be at least 50 szabo\");\n    }\n\n    function getMinimum() public view returns (uint) {\n        return minimumSzabo;\n    }\n\n    function dummyFunc() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...      uint public minimumSzabo = 50 szabo;      function contribute() public ...\n                                        ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public fee = 1 finney;\n\n    function payFee() public payable {\n        require(msg.value >= fee, \"Fee is 1 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return fee;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... Example7 {     uint public fee = 1 finney;      function payFee() public pay ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public donation = 20 szabo;\n\n    function donate() public payable {\n        require(msg.value == donation, \"Donate exactly 20 szabo\");\n    }\n\n    function getDonationAmount() public view returns (uint) {\n        return donation;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... e8 {     uint public donation = 20 szabo;      function donate() public pay ...\n                                        ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public cost = 15 finney;\n\n    function purchase() public payable {\n        require(msg.value >= cost, \"Cost is 15 finney\");\n    }\n\n    function getCost() public view returns (uint) {\n        return cost;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... ample9 {     uint public cost = 15 finney;      function purchase() public p ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public rate = 5 szabo;\n\n    function invest() public payable {\n        require(msg.value >= rate, \"Investment rate is 5 szabo\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rate;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... ample10 {     uint public rate = 5 szabo;      function invest() public pay ...\n                                        ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public amountInFinney = 2 * 1e15;\n\n    function checkAmount() public view returns (uint) {\n        return amountInFinney;\n    }\n\n    function pay() public payable {\n        require(msg.value >= amountInFinney, \"Insufficient payment\");\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public valueInSzabo = 10 * 1e12;\n\n    function deposit() public payable {\n        require(msg.value >= valueInSzabo, \"Deposit must be at least 10 szabo\");\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public threshold = 5 * 1e15;\n\n    function setThreshold(uint _newThreshold) public {\n        threshold = _newThreshold * 1e15;\n    }\n\n    function isAboveThreshold(uint amount) public view returns (bool) {\n        return amount >= threshold;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public smallAmount = 3 * 1e12;\n\n    function sendEther() public payable {\n        require(msg.value == smallAmount, \"Must send exactly 3 szabo\");\n    }\n\n    function currentAmount() public view returns (uint) {\n        return smallAmount;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public requiredAmount = 7 * 1e15;\n\n    function receivePayment() public payable {\n        require(msg.value == requiredAmount, \"Must send 7 finney\");\n    }\n\n    function checkRequired() public view returns (uint) {\n        return requiredAmount;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public minimumSzabo = 50 * 1e12;\n\n    function contribute() public payable {\n        require(msg.value >= minimumSzabo, \"Contribution must be at least 50 szabo\");\n    }\n\n    function getMinimum() public view returns (uint) {\n        return minimumSzabo;\n    }\n\n    function dummyFunc() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public fee = 1 * 1e15;\n\n    function payFee() public payable {\n        require(msg.value >= fee, \"Fee is 1 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return fee;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public donation = 20 * 1e12;\n\n    function donate() public payable {\n        require(msg.value == donation, \"Donate exactly 20 szabo\");\n    }\n\n    function getDonationAmount() public view returns (uint) {\n        return donation;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public cost = 15 * 1e15;\n\n    function purchase() public payable {\n        require(msg.value >= cost, \"Cost is 15 finney\");\n    }\n\n    function getCost() public view returns (uint) {\n        return cost;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public rate = 5 * 1e12;\n\n    function invest() public payable {\n        require(msg.value >= rate, \"Investment rate is 5 szabo\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rate;\n    }\n}"
      }
    }
  },
  {
    "Changes119": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractK {\n    byte itemK;\n    function resetItemK(byte newValue) public {\n        itemK = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/2.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractK {     byte itemK;     function resetItemK(byte newValue) public {         itemK = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractL {\n    byte itemL;\n    function loadItemL(byte newValue) public {\n        itemL = newValue;\n    }\n    function helperFunctionL() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/3.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractL {     byte itemL;     function loadItemL(byte ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractM {\n    byte itemM;\n    function pushItemM(byte newValue) public {\n        itemM = newValue;\n    }\n    function irrelevantM1() public pure returns (uint) {\n        return 42;\n    }\n    function irrelevantM2() public pure returns (uint) {\n        return 24;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/4.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractM {     byte itemM;     function pushItemM(byte ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractN {\n    byte itemN;\n    function storeItemN(byte newValue) public {\n        itemN = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/5.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractN {     byte itemN;     function storeItemN(byte newValue) public {         itemN = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractO {\n    byte itemO;\n    function editItemO(byte newValue) public {\n        itemO = newValue;\n    }\n    function dummyO() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/6.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractO {     byte itemO;     function editItemO(byte ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractP {\n    byte itemP;\n    function insertItemP(byte newValue) public {\n        itemP = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/7.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractP {     byte itemP;     function insertItemP(byte newValue) public {         itemP = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractQ {\n    byte itemQ;\n    function setItemQ(byte newValue) public {\n        itemQ = newValue;\n    }\n    function randomFunctionQ() public pure returns (int) {\n        return -123;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/8.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractQ {     byte itemQ;     function setItemQ(byte  ...\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractR {\n    byte itemR;\n    function alterItemR(byte newValue) public {\n        itemR = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/9.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractR {     byte itemR;     function alterItemR(byte newValue) public {         itemR = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractS {\n    byte itemS;\n    function modifyItemS(byte newValue) public {\n        itemS = newValue;\n    }\n    function extraFunctionS() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/10.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractS {     byte itemS;     function modifyItemS(by ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractT {\n    byte itemT;\n    function applyItemT(byte newValue) public {\n        itemT = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/11.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractT {     byte itemT;     function applyItemT(byte newValue) public {         itemT = newValue;     } }\n  |                                                 ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractK {\n    bytes1 itemK;\n    function resetItemK(bytes1 newValue) public {\n        itemK = newValue;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractL {\n    bytes1 itemL;\n    function loadItemL(bytes1 newValue) public {\n        itemL = newValue;\n    }\n    function helperFunctionL() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractM {\n    bytes1 itemM;\n    function pushItemM(bytes1 newValue) public {\n        itemM = newValue;\n    }\n    function irrelevantM1() public pure returns (uint) {\n        return 42;\n    }\n    function irrelevantM2() public pure returns (uint) {\n        return 24;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractN {\n    bytes1 itemN;\n    function storeItemN(bytes1 newValue) public {\n        itemN = newValue;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractO {\n    bytes1 itemO;\n    function editItemO(bytes1 newValue) public {\n        itemO = newValue;\n    }\n    function dummyO() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractP {\n    bytes1 itemP;\n    function insertItemP(bytes1 newValue) public {\n        itemP = newValue;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractQ {\n    bytes1 itemQ;\n    function setItemQ(bytes1 newValue) public {\n        itemQ = newValue;\n    }\n    function randomFunctionQ() public pure returns (int) {\n        return -123;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractR {\n    bytes1 itemR;\n    function alterItemR(bytes1 newValue) public {\n        itemR = newValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractS {\n    bytes1 itemS;\n    function modifyItemS(bytes1 newValue) public {\n        itemS = newValue;\n    }\n    function extraFunctionS() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractT {\n    bytes1 itemT;\n    function applyItemT(bytes1 newValue) public {\n        itemT = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes120": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions from negative literals and literals larger than <code>type(uint160).max</code> to\n<code>address</code> are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractEleven {\n    function negativeConversion() public pure returns (address) {\n        int data = -11;\n        return address(uint160(data));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/12.sol:1:164:\n  |\n1 |  ... data = -11;         return address(uint160(data));     } }\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwelve {\n    function convertMinus() public pure returns (address) {\n        int smallNeg = -12;\n        return address(uint160(smallNeg));\n    }\n    function unused() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/13.sol:1:162:\n  |\n1 |  ... lNeg = -12;         return address(uint160(smallNeg));     }     function unused() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirteen {\n    function makeNegativeAddress() public pure returns (address) {\n        int numNeg = -13;\n        return address(uint160(numNeg));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/14.sol:1:169:\n  |\n1 |  ... mNeg = -13;         return address(uint160(numNeg));     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractFourteen {\n    function processNegative() public pure returns (address) {\n        int bigNegative = -14;\n        return address(uint160(bigNegative));\n    }\n    function extraData() public pure returns (uint) {\n        return 2024;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/15.sol:1:170:\n  |\n1 |  ... tive = -14;         return address(uint160(bigNegative));     }     function extraData() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractFifteen {\n    function transformNeg() public pure returns (address) {\n        int moreNegative = -15;\n        return address(uint160(moreNegative));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/16.sol:1:167:\n  |\n1 |  ... tive = -15;         return address(uint160(moreNegative));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractSixteen {\n    function modifyNeg() public pure returns (address) {\n        int negIntVal = -16;\n        return address(uint160(negIntVal));\n    }\n    function randomFunc() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/17.sol:1:161:\n  |\n1 |  ... tVal = -16;         return address(uint160(negIntVal));     }     function randomFunc()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractSeventeen {\n    function invertToAddress() public pure returns (address) {\n        int negativeOne = -17;\n        return address(uint160(negativeOne));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/18.sol:1:171:\n  |\n1 |  ... eOne = -17;         return address(uint160(negativeOne));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractEighteen {\n    function switchNeg() public pure returns (address) {\n        int lesserNeg = -18;\n        return address(uint160(lesserNeg));\n    }\n    function helperFunc() public pure returns (uint) {\n        return 18;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/19.sol:1:162:\n  |\n1 |  ... rNeg = -18;         return address(uint160(lesserNeg));     }     function helperFunc()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractNineteen {\n    function addressFromNeg() public pure returns (address) {\n        int negativeCount = -19;\n        return address(uint160(negativeCount));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/20.sol:1:171:\n  |\n1 |  ... ount = -19;         return address(uint160(negativeCount));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwenty {\n    function flipNegative() public pure returns (address) {\n        int anotherNeg = -20;\n        return address(uint160(anotherNeg));\n    }\n    function additionalMethod() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/21.sol:1:164:\n  |\n1 |  ... rNeg = -20;         return address(uint160(anotherNeg));     }     function additionalMet ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractEleven {\n    function negativeConversion() public pure returns (uint) {\n        int data = -11;\n        return uint(data);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractTwelve {\n    function convertMinus() public pure returns (uint) {\n        int smallNeg = -12;\n        return uint(smallNeg);\n    }\n    function unused() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractThirteen {\n    function makeNegativeAddress() public pure returns (uint) {\n        int numNeg = -13;\n        return uint(numNeg);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractFourteen {\n    function processNegative() public pure returns (uint) {\n        int bigNegative = -14;\n        return uint(bigNegative);\n    }\n    function extraData() public pure returns (uint) {\n        return 2024;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractFifteen {\n    function transformNeg() public pure returns (uint) {\n        int moreNegative = -15;\n        return uint(moreNegative);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractSixteen {\n    function modifyNeg() public pure returns (uint) {\n        int negIntVal = -16;\n        return uint(negIntVal);\n    }\n    function randomFunc() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractSeventeen {\n    function invertToAddress() public pure returns (uint) {\n        int negativeOne = -17;\n        return uint(negativeOne);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractEighteen {\n    function switchNeg() public pure returns (uint) {\n        int lesserNeg = -18;\n        return uint(lesserNeg);\n    }\n    function helperFunc() public pure returns (uint) {\n        return 18;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractNineteen {\n    function addressFromNeg() public pure returns (uint) {\n        int negativeCount = -19;\n        return uint(negativeCount);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractTwenty {\n    function flipNegative() public pure returns (uint) {\n        int anotherNeg = -20;\n        return uint(anotherNeg);\n    }\n    function additionalMethod() public pure returns (int) {\n        return 42;\n    }\n}"
      }
    }
  },
  {
    "Changes121": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and an integer type <code>T</code> are only allowed if the literal\nlies between <code>type(T).min</code> and <code>type(T).max</code>. In particular, replace usages of <code>uint(-1)</code>\nwith <code>type(uint).max</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleEleven {\n    function computeCeiling() public pure returns (uint) {\n        uint ceiling = uint(-1);\n        return ceiling;\n    }\n    function helperOne() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/22.sol:1:132:\n  |\n1 |  ... ns (uint) {         uint ceiling = uint(-1);         return ceiling;     }     ...\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwelve {\n    function determineMax() public pure returns (uint) {\n        uint maximum = uint(-1);\n        return maximum;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/23.sol:1:130:\n  |\n1 |  ... ns (uint) {         uint maximum = uint(-1);         return maximum;     } }\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirteen {\n    function extractMaximum() public pure returns (uint) {\n        uint maxExtract = uint(-1);\n        return maxExtract;\n    }\n    function dummyFunc() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/24.sol:1:137:\n  |\n1 |  ... (uint) {         uint maxExtract = uint(-1);         return maxExtract;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleFourteen {\n    function reachBoundary() public pure returns (uint) {\n        uint boundaryReach = uint(-1);\n        return boundaryReach;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/25.sol:1:139:\n  |\n1 |  ... nt) {         uint boundaryReach = uint(-1);         return boundaryReach;     ...\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleFifteen {\n    function pullCeilingValue() public pure returns (uint) {\n        uint ceilingValue = uint(-1);\n        return ceilingValue;\n    }\n    function dummyOutput() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/26.sol:1:140:\n  |\n1 |  ... int) {         uint ceilingValue = uint(-1);         return ceilingValue;      ...\n  |                                         ^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleSixteen {\n    function generateMax() public pure returns (uint) {\n        uint generatedMax = uint(-1);\n        return generatedMax;\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Unrelated string\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/27.sol:1:135:\n  |\n1 |  ... int) {         uint generatedMax = uint(-1);         return generatedMax;      ...\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleSeventeen {\n    function secureLimit() public pure returns (uint) {\n        uint secureValue = uint(-1);\n        return secureValue;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/28.sol:1:136:\n  |\n1 |  ... uint) {         uint secureValue = uint(-1);         return secureValue;     } ...\n  |                                         ^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleEighteen {\n    function defineUpperBound() public pure returns (uint) {\n        uint upperBound = uint(-1);\n        return upperBound;\n    }\n    function extraFunc() public pure returns (int) {\n        return -100;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/29.sol:1:139:\n  |\n1 |  ... (uint) {         uint upperBound = uint(-1);         return upperBound;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleNineteen {\n    function pinpointMax() public pure returns (uint) {\n        uint pinpoint = uint(-1);\n        return pinpoint;\n    }\n    function unrelatedOne() public pure returns (uint) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/30.sol:1:132:\n  |\n1 |  ... s (uint) {         uint pinpoint = uint(-1);         return pinpoint;     }    ...\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwenty {\n    function identifyBoundary() public pure returns (uint) {\n        uint boundaryIdentify = uint(-1);\n        return boundaryIdentify;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/31.sol:1:143:\n  |\n1 |  ...  {         uint boundaryIdentify = uint(-1);         return boundaryIdentify;  ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ExampleEleven {\n    function computeCeiling() public pure returns (uint) {\n        uint ceiling = type(uint).max;\n        return ceiling;\n    }\n    function helperOne() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleTwelve {\n    function determineMax() public pure returns (uint) {\n        uint maximum = type(uint).max;\n        return maximum;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ExampleThirteen {\n    function extractMaximum() public pure returns (uint) {\n        uint maxExtract = type(uint).max;\n        return maxExtract;\n    }\n    function dummyFunc() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ExampleFourteen {\n    function reachBoundary() public pure returns (uint) {\n        uint boundaryReach = type(uint).max;\n        return boundaryReach;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ExampleFifteen {\n    function pullCeilingValue() public pure returns (uint) {\n        uint ceilingValue = type(uint).max;\n        return ceilingValue;\n    }\n    function dummyOutput() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ExampleSixteen {\n    function generateMax() public pure returns (uint) {\n        uint generatedMax = type(uint).max;\n        return generatedMax;\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Unrelated string\";\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ExampleSeventeen {\n    function secureLimit() public pure returns (uint) {\n        uint secureValue = type(uint).max;\n        return secureValue;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ExampleEighteen {\n    function defineUpperBound() public pure returns (uint) {\n        uint upperBound = type(uint).max;\n        return upperBound;\n    }\n    function extraFunc() public pure returns (int) {\n        return -100;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ExampleNineteen {\n    function pinpointMax() public pure returns (uint) {\n        uint pinpoint = type(uint).max;\n        return pinpoint;\n    }\n    function unrelatedOne() public pure returns (uint) {\n        return 999;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ExampleTwenty {\n    function identifyBoundary() public pure returns (uint) {\n        uint boundaryIdentify = type(uint).max;\n        return boundaryIdentify;\n    }\n}"
      }
    }
  },
  {
    "Changes122": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and enums are only allowed if the literal can\nrepresent a value in the enum.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example12 {\n    enum Action { Play, Pause, Stop }\n    Action public playerAction;\n    function setAction() public {\n        playerAction = Action(3);\n    }\n    function miscFunction() public pure returns (uint) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example12.Action\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/32.sol:1:173:\n  |\n1 |  ... () public {         playerAction = Action(3);     }     function miscFunction() ...\n  |                                         ^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example13 {\n    enum Direction { North, South, East, West }\n    Direction public compass;\n    function setDirection() public {\n        compass = Direction(4);\n    }\n    function anotherMiscFunction() public pure returns (string memory) {\n        return \"Direction function\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example13.Direction\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/33.sol:1:179:\n  |\n1 |  ... ction() public {         compass = Direction(4);     }     function anotherMiscFun ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example14 {\n    enum Gear { Park, Reverse, Neutral, Drive }\n    Gear public carGear;\n    function shiftGear() public {\n        carGear = Gear(5);\n    }\n    function utilityOne() public pure returns (bool) {\n        return false;\n    }\n    function utilityTwo() public pure returns (int) {\n        return -100;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example14.Gear\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/34.sol:1:171:\n  |\n1 |  ... tGear() public {         carGear = Gear(5);     }     function utilityOne() p ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example15 {\n    enum Mood { Happy, Sad, Excited, Anxious }\n    Mood public currentMood;\n    function updateMood() public {\n        currentMood = Mood(6);\n    }\n    function simpleFunction() public pure returns (bytes memory) {\n        return \"test\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 6\" to \"enum Example15.Mood\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/35.sol:1:179:\n  |\n1 |  ... d() public {         currentMood = Mood(6);     }     function simpleFunction ...\n  |                                         ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example16 {\n    enum Size { Small, Medium, Large }\n    Size public boxSize;\n    function setSize() public {\n        boxSize = Size(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example16.Size\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/36.sol:1:160:\n  |\n1 |  ... tSize() public {         boxSize = Size(3);     } }\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example17 {\n    enum Age { Young, Middle, Old }\n    Age public personAge;\n    function setAge() public {\n        personAge = Age(4);\n    }\n    function extraDetails() public pure returns (string memory) {\n        return \"Age details\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example17.Age\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/37.sol:1:159:\n  |\n1 |  ... Age() public {         personAge = Age(4);     }     function extraDetails() ...\n  |                                         ^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example18 {\n    enum Frequency { Rarely, Sometimes, Often, Always }\n    Frequency public usageFrequency;\n    function setFrequency() public {\n        usageFrequency = Frequency(8);\n    }\n    function helperFunction() public pure returns (uint) {\n        return 321;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 8\" to \"enum Example18.Frequency\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/38.sol:1:201:\n  |\n1 |  ...  public {         usageFrequency = Frequency(8);     }     function helperFunction ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example19 {\n    enum Season { Spring, Summer, Autumn, Winter }\n    Season public currentSeason;\n    function changeSeason() public {\n        currentSeason = Season(5);\n    }\n    function randomHelper() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example19.Season\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/39.sol:1:191:\n  |\n1 |  ... ) public {         currentSeason = Season(5);     }     function randomHelper() ...\n  |                                         ^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example20 {\n    enum Speed { Slow, Moderate, Fast }\n    Speed public vehicleSpeed;\n    function setSpeed() public {\n        vehicleSpeed = Speed(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example20.Speed\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/40.sol:1:173:\n  |\n1 |  ... () public {         vehicleSpeed = Speed(3);     } }\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example21 {\n    enum Response { Yes, No, Maybe }\n    Response public answer;\n    function setResponse() public {\n        answer = Response(4);\n    }\n    function anotherFunction() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example21.Response\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/41.sol:1:164:\n  |\n1 |  ... sponse() public {         answer = Response(4);     }     function anotherFunctio ...\n  |                                         ^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example12 {\n    enum Action { Play, Pause, Stop }\n    Action public playerAction;\n    function setAction(Action _action) public {\n        playerAction = _action;\n    }\n    function miscFunction() public pure returns (uint) {\n        return 999;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example13 {\n    enum Direction { North, South, East, West }\n    Direction public compass;\n    function setDirection(Direction _direction) public {\n        compass = _direction;\n    }\n    function anotherMiscFunction() public pure returns (string memory) {\n        return \"Direction function\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example14 {\n    enum Gear { Park, Reverse, Neutral, Drive }\n    Gear public carGear;\n    function shiftGear(Gear _gear) public {\n        carGear = _gear;\n    }\n    function utilityOne() public pure returns (bool) {\n        return false;\n    }\n    function utilityTwo() public pure returns (int) {\n        return -100;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example15 {\n    enum Mood { Happy, Sad, Excited, Anxious }\n    Mood public currentMood;\n    function updateMood(Mood _mood) public {\n        currentMood = _mood;\n    }\n    function simpleFunction() public pure returns (bytes memory) {\n        return \"test\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example16 {\n    enum Size { Small, Medium, Large }\n    Size public boxSize;\n    function setSize(Size _size) public {\n        boxSize = _size;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example17 {\n    enum Age { Young, Middle, Old }\n    Age public personAge;\n    function setAge(Age _age) public {\n        personAge = _age;\n    }\n    function extraDetails() public pure returns (string memory) {\n        return \"Age details\";\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example18 {\n    enum Frequency { Rarely, Sometimes, Often, Always }\n    Frequency public usageFrequency;\n    function setFrequency(Frequency _frequency) public {\n        usageFrequency = _frequency;\n    }\n    function helperFunction() public pure returns (uint) {\n        return 321;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example19 {\n    enum Season { Spring, Summer, Autumn, Winter }\n    Season public currentSeason;\n    function changeSeason(Season _season) public {\n        currentSeason = _season;\n    }\n    function randomHelper() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example20 {\n    enum Speed { Slow, Moderate, Fast }\n    Speed public vehicleSpeed;\n    function setSpeed(Speed _speed) public {\n        vehicleSpeed = _speed;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example21 {\n    enum Response { Yes, No, Maybe }\n    Response public answer;\n    function setResponse(Response _response) public {\n        answer = _response;\n    }\n    function anotherFunction() public pure returns (int) {\n        return 42;\n    }\n}"
      }
    }
  },
  {
    "Changes123": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and <code>address</code> type (e.g. <code>address(literal)</code>) have the\ntype <code>address</code> instead of <code>address payable</code>. One can get a payable address type by using an\nexplicit conversion, i.e., <code>payable(literal)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example12 {\n    function sendTokens(address recipient, uint256 amount) public {\n        address payable dest = address(0xAAA);\n        dest.transfer(amount);\n    }\n\n    function computeInterest(uint principal, uint rate, uint time) public pure returns (uint) {\n        return principal * rate * time / 100;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/42.sol:1:122:\n  |\n1 |  ... , uint256 amount) public {         address payable dest = address(0xAAA);         dest.transfer(amount);    ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example13 {\n    function distributeRewards(address addr, uint rewards) public {\n        address payable account = address(0xBBB);\n        account.transfer(rewards);\n    }\n\n    function getSum(uint[] memory data) public pure returns (uint) {\n        uint sum = 0;\n        for (uint i = 0; i < data.length; i++) {\n            sum += data[i];\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/43.sol:1:122:\n  |\n1 |  ... dr, uint rewards) public {         address payable account = address(0xBBB);         account.transfer(rewards) ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example14 {\n    function makePayment(address to, uint256 sum) public {\n        address payable payAddress = address(0xCCC);\n        payAddress.transfer(sum);\n    }\n\n    function doubleValue(uint value) public pure returns (uint) {\n        return value * 2;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/44.sol:1:113:\n  |\n1 |  ...  to, uint256 sum) public {         address payable payAddress = address(0xCCC);         payAddress.transfer(sum); ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example15 {\n    function dispatchFunds(address entity, uint quantity) public {\n        address payable wallet = address(0xDDD);\n        wallet.transfer(quantity);\n    }\n\n    function countParticipants(uint[] memory participants) public pure returns (uint) {\n        return participants.length;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/45.sol:1:121:\n  |\n1 |  ... y, uint quantity) public {         address payable wallet = address(0xDDD);         wallet.transfer(quantity) ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example16 {\n    function grantAccess(address user, uint funds) public {\n        address payable account = address(0xEEE);\n        account.transfer(funds);\n    }\n\n    function incrementCount(uint count) public pure returns (uint) {\n        return count + 1;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/46.sol:1:114:\n  |\n1 |  ... user, uint funds) public {         address payable account = address(0xEEE);         account.transfer(funds);  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example17 {\n    function releaseFunds(address receiver, uint payment) public {\n        address payable payee = address(0xFFF);\n        payee.transfer(payment);\n    }\n\n    function calculateDiscount(uint price, uint discountRate) public pure returns (uint) {\n        return price * discountRate / 100;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/47.sol:1:121:\n  |\n1 |  ... er, uint payment) public {         address payable payee = address(0xFFF);         payee.transfer(payment);  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example18 {\n    function transferAssets(address client, uint cash) public {\n        address payable holder = address(0x111);\n        holder.transfer(cash);\n    }\n\n    function getBalance() public pure returns (uint) {\n        return 1500;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/48.sol:1:118:\n  |\n1 |  ... lient, uint cash) public {         address payable holder = address(0x111);         holder.transfer(cash);    ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example19 {\n    function moveCapital(address user, uint amount) public {\n        address payable recipient = address(0x222);\n        recipient.transfer(amount);\n    }\n\n    function min(uint a, uint b) public pure returns (uint) {\n        return a < b ? a : b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/49.sol:1:115:\n  |\n1 |  ... ser, uint amount) public {         address payable recipient = address(0x222);         recipient.transfer(amount ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example20 {\n    function allocateGrant(address recipient, uint funds) public {\n        address payable agency = address(0x333);\n        agency.transfer(funds);\n    }\n\n    function max(uint a, uint b) public pure returns (uint) {\n        return a > b ? a : b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/50.sol:1:121:\n  |\n1 |  ... ient, uint funds) public {         address payable agency = address(0x333);         agency.transfer(funds);   ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example21 {\n    function remitSalaries(address employee, uint salary) public {\n        address payable worker = address(0x444);\n        worker.transfer(salary);\n    }\n\n    function squareNumber(uint num) public pure returns (uint) {\n        return num * num;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/51.sol:1:121:\n  |\n1 |  ... yee, uint salary) public {         address payable worker = address(0x444);         worker.transfer(salary);  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example12 {\n    function sendTokens(address recipient, uint256 amount) public {\n        address payable dest = payable(address(0xAAA));\n        dest.transfer(amount);\n    }\n\n    function computeInterest(uint principal, uint rate, uint time) public pure returns (uint) {\n        return principal * rate * time / 100;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example13 {\n    function distributeRewards(address addr, uint rewards) public {\n        address payable account = payable(address(0xBBB));\n        account.transfer(rewards);\n    }\n\n    function getSum(uint[] memory data) public pure returns (uint) {\n        uint sum = 0;\n        for (uint i = 0; i < data.length; i++) {\n            sum += data[i];\n        }\n        return sum;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example14 {\n    function makePayment(address to, uint256 sum) public {\n        address payable payAddress = payable(address(0xCCC));\n        payAddress.transfer(sum);\n    }\n\n    function doubleValue(uint value) public pure returns (uint) {\n        return value * 2;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example15 {\n    function dispatchFunds(address entity, uint quantity) public {\n        address payable wallet = payable(address(0xDDD));\n        wallet.transfer(quantity);\n    }\n\n    function countParticipants(uint[] memory participants) public pure returns (uint) {\n        return participants.length;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example16 {\n    function grantAccess(address user, uint funds) public {\n        address payable account = payable(address(0xEEE));\n        account.transfer(funds);\n    }\n\n    function incrementCount(uint count) public pure returns (uint) {\n        return count + 1;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example17 {\n    function releaseFunds(address receiver, uint payment) public {\n        address payable payee = payable(address(0xFFF));\n        payee.transfer(payment);\n    }\n\n    function calculateDiscount(uint price, uint discountRate) public pure returns (uint) {\n        return price * discountRate / 100;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example18 {\n    function transferAssets(address client, uint cash) public {\n        address payable holder = payable(address(0x111));\n        holder.transfer(cash);\n    }\n\n    function getBalance() public pure returns (uint) {\n        return 1500;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example19 {\n    function moveCapital(address user, uint amount) public {\n        address payable recipient = payable(address(0x222));\n        recipient.transfer(amount);\n    }\n\n    function min(uint a, uint b) public pure returns (uint) {\n        return a < b ? a : b;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example20 {\n    function allocateGrant(address recipient, uint funds) public {\n        address payable agency = payable(address(0x333));\n        agency.transfer(funds);\n    }\n\n    function max(uint a, uint b) public pure returns (uint) {\n        return a > b ? a : b;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example21 {\n    function remitSalaries(address employee, uint salary) public {\n        address payable worker = payable(address(0x444));\n        worker.transfer(salary);\n    }\n\n    function squareNumber(uint num) public pure returns (uint) {\n        return num * num;\n    }\n}"
      }
    }
  },
  {
    "Changes124": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/types.html#address-literals\"><span class=\"std std-ref\">Address literals</a> have the type <code>address</code> instead of <code>address\npayable</code>. They can be converted to <code>address payable</code> by using an explicit conversion, e.g.\n<code>payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract TransactionManager {\n    address payable public transactionAddress;\n    constructor() {\n        transactionAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/52.sol:1:150:\n  |\n1 |  ... r() {         transactionAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetTracker {\n    address payable public assetOwner;\n    constructor() {\n        assetOwner = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/53.sol:1:128:\n  |\n1 |  ... nstructor() {         assetOwner = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueStream {\n    address payable public revenueAddress;\n    constructor() {\n        revenueAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function helperFunction() public pure returns (string memory) { return \"Helper\"; }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/54.sol:1:137:\n  |\n1 |  ... uctor() {         revenueAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function helperFunction ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantDistributor {\n    address payable public grantee;\n    constructor() {\n        grantee = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function utilityFunction() internal {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/55.sol:1:126:\n  |\n1 |  ...  constructor() {         grantee = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function utilityFunctio ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract LoyaltyProgram {\n    address payable public participant;\n    constructor() {\n        participant = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function somethingUseless() private {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/56.sol:1:132:\n  |\n1 |  ... structor() {         participant = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function somethingUsele ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ScholarshipFund {\n    address payable public fundManager;\n    constructor() {\n        fundManager = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function extraFunction() external pure {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/57.sol:1:133:\n  |\n1 |  ... structor() {         fundManager = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract MembershipClub {\n    address payable public memberAccount;\n    constructor() {\n        memberAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function randomFunction() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/58.sol:1:136:\n  |\n1 |  ... ructor() {         memberAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function randomFunction ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract VendorContract {\n    address payable public vendor;\n    constructor() {\n        vendor = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function unnecessaryFunction() public pure {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/59.sol:1:122:\n  |\n1 |  ...   constructor() {         vendor = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function unnecessaryFun ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract TalentManagement {\n    address payable public talentAccount;\n    constructor() {\n        talentAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/60.sol:1:138:\n  |\n1 |  ... ructor() {         talentAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract AdvertisingCampaign {\n    address payable public advertiser;\n    constructor() {\n        advertiser = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function additionalMethod() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/61.sol:1:135:\n  |\n1 |  ... nstructor() {         advertiser = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function additionalMeth ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract TransactionManager {\n    address payable public transactionAddress;\n    constructor() {\n        transactionAddress = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract AssetTracker {\n    address payable public assetOwner;\n    constructor() {\n        assetOwner = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract RevenueStream {\n    address payable public revenueAddress;\n    constructor() {\n        revenueAddress = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function helperFunction() public pure returns (string memory) { return \"Helper\"; }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract GrantDistributor {\n    address payable public grantee;\n    constructor() {\n        grantee = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function utilityFunction() internal {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract LoyaltyProgram {\n    address payable public participant;\n    constructor() {\n        participant = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function somethingUseless() private {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ScholarshipFund {\n    address payable public fundManager;\n    constructor() {\n        fundManager = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function extraFunction() external pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract MembershipClub {\n    address payable public memberAccount;\n    constructor() {\n        memberAccount = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function randomFunction() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract VendorContract {\n    address payable public vendor;\n    constructor() {\n        vendor = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function unnecessaryFunction() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract TalentManagement {\n    address payable public talentAccount;\n    constructor() {\n        talentAccount = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract AdvertisingCampaign {\n    address payable public advertiser;\n    constructor() {\n        advertiser = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function additionalMethod() public {}\n}"
      }
    }
  },
  {
    "Changes125": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>address(uint)</code> and <code>uint(address)</code>: converting both type-category and width. Replace this by\n<code>address(uint160(uint))</code> and <code>uint(uint160(address))</code> respectively.Add intermediate explicit type conversions if required.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Encode {\n    function encodeUintToAddress(uint h) public pure returns (address) {\n        return address(h);\n    }\n    function helperFunction() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/62.sol:1:130:\n  |\n1 |  ... returns (address) {         return address(h);     }     function helperFunction ...\n  |                                         ^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Cast {\n    function castAddressToUint(address i) public pure returns (uint) {\n        return uint(i);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/63.sol:1:126:\n  |\n1 | pragma solidity^0.8.0; contract Cast {     function castAddressToUint(address i) public pure returns (uint) {         return uint(i);     } }\n  |                                                                                                                              ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Translate {\n    function translateUintToAddress(uint j) public pure returns (address) {\n        return address(j);\n    }\n    function anotherHelper() public pure returns (int) {\n        return 42;\n    }\n    function anotherOne() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/64.sol:1:136:\n  |\n1 |  ... returns (address) {         return address(j);     }     function anotherHelper( ...\n  |                                         ^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Reformat {\n    function reformatAddressToUint(address k) public pure returns (uint) {\n        return uint(k);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/65.sol:1:134:\n  |\n1 | pragma solidity^0.8.0; contract Reformat {     function reformatAddressToUint(address k) public pure returns (uint) {         return uint(k);     } }\n  |                                                                                                                                      ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Replicate {\n    function replicateUintToAddress(uint l) public pure returns (address) {\n        return address(l);\n    }\n    function irrelevant() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/66.sol:1:136:\n  |\n1 |  ... returns (address) {         return address(l);     }     function irrelevant() p ...\n  |                                         ^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ConvertX {\n    function convertXAddressToUint(address m) public pure returns (uint) {\n        return uint(m);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/67.sol:1:134:\n  |\n1 | pragma solidity^0.8.0; contract ConvertX {     function convertXAddressToUint(address m) public pure returns (uint) {         return uint(m);     } }\n  |                                                                                                                                      ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Morph {\n    function morphUintToAddress(uint n) public pure returns (address) {\n        return address(n);\n    }\n    function unused() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/68.sol:1:128:\n  |\n1 |  ... returns (address) {         return address(n);     }     function unused() publi ...\n  |                                         ^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Transition {\n    function transitionAddressToUint(address o) public pure returns (uint) {\n        return uint(o);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/69.sol:1:138:\n  |\n1 |  ... re returns (uint) {         return uint(o);     } }\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ShiftX {\n    function shiftXUintToAddress(uint p) public pure returns (address) {\n        return address(p);\n    }\n    function extraOne() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/70.sol:1:130:\n  |\n1 |  ... returns (address) {         return address(p);     }     function extraOne() pub ...\n  |                                         ^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Permute {\n    function permuteAddressToUint(address q) public pure returns (uint) {\n        return uint(q);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/71.sol:1:132:\n  |\n1 | pragma solidity^0.8.0; contract Permute {     function permuteAddressToUint(address q) public pure returns (uint) {         return uint(q);     } }\n  |                                                                                                                                    ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Encode {\n    function encodeUintToAddress(uint h) public pure returns (address) {\n        return address(uint160(h));\n    }\n    function helperFunction() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Cast {\n    function castAddressToUint(address i) public pure returns (uint) {\n        return uint(uint160(i));\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Translate {\n    function translateUintToAddress(uint j) public pure returns (address) {\n        return address(uint160(j));\n    }\n    function anotherHelper() public pure returns (int) {\n        return 42;\n    }\n    function anotherOne() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Reformat {\n    function reformatAddressToUint(address k) public pure returns (uint) {\n        return uint(uint160(k));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Replicate {\n    function replicateUintToAddress(uint l) public pure returns (address) {\n        return address(uint160(l));\n    }\n    function irrelevant() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ConvertX {\n    function convertXAddressToUint(address m) public pure returns (uint) {\n        return uint(uint160(m));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Morph {\n    function morphUintToAddress(uint n) public pure returns (address) {\n        return address(uint160(n));\n    }\n    function unused() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Transition {\n    function transitionAddressToUint(address o) public pure returns (uint) {\n        return uint(uint160(o));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ShiftX {\n    function shiftXUintToAddress(uint p) public pure returns (address) {\n        return address(uint160(p));\n    }\n    function extraOne() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Permute {\n    function permuteAddressToUint(address q) public pure returns (uint) {\n        return uint(uint160(q));\n    }\n}"
      }
    }
  },
  {
    "Changes126": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>payable(uint160)</code>, <code>payable(bytes20)</code> and <code>payable(integer-literal)</code>: converting both\ntype-category and state-mutability. Replace this by <code>payable(address(uint160))</code>,\n<code>payable(address(bytes20))</code> and <code>payable(address(integer-literal))</code> respectively. Note that\n<code>payable(0)</code> is valid and is an exception to the rule.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetManager {\n    function modifyAsset(uint160 assetId) public pure returns (address payable) {\n        return payable(assetId);\n    }\n    function countItems() public pure returns (uint) {\n        return 150;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/72.sol:1:145:\n  |\n1 |  ... (address payable) {         return payable(assetId);     }     function countItems() p ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract TokenDistributor {\n    function distributeToken(uint160 tokenId) public pure returns (address payable) {\n        return payable(tokenId);\n    }\n    function extraCheck() public pure returns (bool) {\n        return false;\n    }\n    function getVersion() public pure returns (string memory) {\n        return \"1.0\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/73.sol:1:153:\n  |\n1 |  ... (address payable) {         return payable(tokenId);     }     function extraCheck() p ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract BudgetController {\n    function controlBudget(uint160 budget) public pure returns (address payable) {\n        return payable(budget);\n    }\n    function isActiveUser() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/74.sol:1:150:\n  |\n1 |  ... (address payable) {         return payable(budget);     }     function isActiveUser() ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract CashFlowManager {\n    function manageCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(cashFlow);\n    }\n    function getBalance() public pure returns (uint256) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/75.sol:1:152:\n  |\n1 |  ... (address payable) {         return payable(cashFlow);     }     function getBalance() p ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ExpenseTracker {\n    function trackExpense(uint160 expense) public pure returns (address payable) {\n        return payable(expense);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/76.sol:1:148:\n  |\n1 |  ... (address payable) {         return payable(expense);     } }\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    function processPayment(uint160 paymentAmount) public pure returns (address payable) {\n        return payable(paymentAmount);\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/77.sol:1:158:\n  |\n1 |  ... (address payable) {         return payable(paymentAmount);     }     function extraData() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract FundManager {\n    function manageFund(uint160 fundAmount) public pure returns (address payable) {\n        return payable(fundAmount);\n    }\n    function logEvent() public pure returns (string memory) {\n        return \"Event logged\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/78.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(fundAmount);     }     function logEvent() pub ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueHandler {\n    function handleRevenue(uint160 revenue) public pure returns (address payable) {\n        return payable(revenue);\n    }\n    function checkStatus() public pure returns (bool) {\n        return true;\n    }\n    function extraFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/79.sol:1:149:\n  |\n1 |  ... (address payable) {         return payable(revenue);     }     function checkStatus()  ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceHandler {\n    function handleResource(uint160 resourceAmount) public pure returns (address payable) {\n        return payable(resourceAmount);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/80.sol:1:158:\n  |\n1 |  ... (address payable) {         return payable(resourceAmount);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentRedirector {\n    function redirectPayment(uint160 payment) public pure returns (address payable) {\n        return payable(payment);\n    }\n    function checkValidity() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/81.sol:1:154:\n  |\n1 |  ... (address payable) {         return payable(payment);     }     function checkValidity( ...\n  |                                         ^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract AssetManager {\n    function modifyAsset(uint160 assetId) public pure returns (address payable) {\n        return payable(address(assetId));\n    }\n    function countItems() public pure returns (uint) {\n        return 150;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract TokenDistributor {\n    function distributeToken(uint160 tokenId) public pure returns (address payable) {\n        return payable(address(tokenId));\n    }\n    function extraCheck() public pure returns (bool) {\n        return false;\n    }\n    function getVersion() public pure returns (string memory) {\n        return \"1.0\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract BudgetController {\n    function controlBudget(uint160 budget) public pure returns (address payable) {\n        return payable(address(budget));\n    }\n    function isActiveUser() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract CashFlowManager {\n    function manageCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(address(cashFlow));\n    }\n    function getBalance() public pure returns (uint256) {\n        return 999;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ExpenseTracker {\n    function trackExpense(uint160 expense) public pure returns (address payable) {\n        return payable(address(expense));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    function processPayment(uint160 paymentAmount) public pure returns (address payable) {\n        return payable(address(paymentAmount));\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract FundManager {\n    function manageFund(uint160 fundAmount) public pure returns (address payable) {\n        return payable(address(fundAmount));\n    }\n    function logEvent() public pure returns (string memory) {\n        return \"Event logged\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract RevenueHandler {\n    function handleRevenue(uint160 revenue) public pure returns (address payable) {\n        return payable(address(revenue));\n    }\n    function checkStatus() public pure returns (bool) {\n        return true;\n    }\n    function extraFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ResourceHandler {\n    function handleResource(uint160 resourceAmount) public pure returns (address payable) {\n        return payable(address(resourceAmount));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract PaymentRedirector {\n    function redirectPayment(uint160 payment) public pure returns (address payable) {\n        return payable(address(payment));\n    }\n    function checkValidity() public pure returns (bool) {\n        return false;\n    }\n}"
      }
    }
  },
  {
    "Changes127": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>int80(bytes10)</code> and <code>bytes10(int80)</code>: converting both type-category and sign. Replace this by\n<code>int80(uint80(bytes10))</code> and <code>bytes10(uint80(int80)</code> respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterAlpha {\n    function alphaConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function randomValue() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/82.sol:1:136:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function randomValue()  ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract DataProcessor {\n    function processData(int80 data) public pure returns (bytes10) {\n        return bytes10(data);\n    }\n    function generateValue() public pure returns (uint) {\n        return 300;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/83.sol:1:133:\n  |\n1 |  ... returns (bytes10) {         return bytes10(data);     }     function generateValue( ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract TypeChanger {\n    function changeType(bytes10 arg) public pure returns (int80) {\n        return int80(arg);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/84.sol:1:129:\n  |\n1 | pragma solidity^0.8.0; contract TypeChanger {     function changeType(bytes10 arg) public pure returns (int80) {         return int80(arg);     } }\n  |                                                                                                                                 ^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract QuickTransform {\n    function fastConvert(int80 arg) public pure returns (bytes10) {\n        return bytes10(arg);\n    }\n    function helperFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/85.sol:1:133:\n  |\n1 |  ... returns (bytes10) {         return bytes10(arg);     }     function helperFunction ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ByteToInteger {\n    function byteToInt(bytes10 byteArg) public pure returns (int80) {\n        return int80(byteArg);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/86.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(byteArg);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IntegerToByte {\n    function intToByte(int80 intArg) public pure returns (bytes10) {\n        return bytes10(intArg);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/87.sol:1:133:\n  |\n1 |  ... returns (bytes10) {         return bytes10(intArg);     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ConvertSimple {\n    function convertBytes(bytes10 simpleArg) public pure returns (int80) {\n        return int80(simpleArg);\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/88.sol:1:139:\n  |\n1 |  ... e returns (int80) {         return int80(simpleArg);     }     function extraMethod()  ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract BasicConverter {\n    function simpleByteToInt(bytes10 simpleByte) public pure returns (int80) {\n        return int80(simpleByte);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/89.sol:1:144:\n  |\n1 |  ... e returns (int80) {         return int80(simpleByte);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Encoder {\n    function encodeInput(bytes10 encodedData) public pure returns (int80) {\n        return int80(encodedData);\n    }\n    function dummyFunction() public pure returns (int) {\n        return 555;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/90.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(encodedData);     }     function dummyFunction( ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Decoder {\n    function decodeOutput(int80 decodedData) public pure returns (bytes10) {\n        return bytes10(decodedData);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/91.sol:1:135:\n  |\n1 |  ... returns (bytes10) {         return bytes10(decodedData);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ConverterAlpha {\n    function alphaConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function randomValue() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract DataProcessor {\n    function processData(int80 data) public pure returns (bytes10) {\n        return bytes10(uint80(data));\n    }\n    function generateValue() public pure returns (uint) {\n        return 300;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract TypeChanger {\n    function changeType(bytes10 arg) public pure returns (int80) {\n        return int80(uint80(arg));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract QuickTransform {\n    function fastConvert(int80 arg) public pure returns (bytes10) {\n        return bytes10(uint80(arg));\n    }\n    function helperFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ByteToInteger {\n    function byteToInt(bytes10 byteArg) public pure returns (int80) {\n        return int80(uint80(byteArg));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IntegerToByte {\n    function intToByte(int80 intArg) public pure returns (bytes10) {\n        return bytes10(uint80(intArg));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ConvertSimple {\n    function convertBytes(bytes10 simpleArg) public pure returns (int80) {\n        return int80(uint80(simpleArg));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract BasicConverter {\n    function simpleByteToInt(bytes10 simpleByte) public pure returns (int80) {\n        return int80(uint80(simpleByte));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Encoder {\n    function encodeInput(bytes10 encodedData) public pure returns (int80) {\n        return int80(uint80(encodedData));\n    }\n    function dummyFunction() public pure returns (int) {\n        return 555;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Decoder {\n    function decodeOutput(int80 decodedData) public pure returns (bytes10) {\n        return bytes10(uint80(decodedData));\n    }\n}"
      }
    }
  },
  {
    "Changes128": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>Contract(uint)</code>: converting both type-category and width. Replace this by\n<code>Contract(address(uint160(uint)))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractA {\n    function adjust(uint input) public pure returns (address) {\n        address addr = address(input);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/92.sol:1:132:\n  |\n1 |  ... (address) {         address addr = address(input);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractB {\n    function generate(uint num) public pure returns (address) {\n        address output = address(num);\n        return output;\n    }\n    function unrelatedFunction1() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/93.sol:1:134:\n  |\n1 |  ... ddress) {         address output = address(num);         return output;     }      ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractC {\n    function deliver(uint data) public pure returns (address) {\n        address result = address(data);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/94.sol:1:134:\n  |\n1 |  ... ddress) {         address result = address(data);         return result;     } }\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractD {\n    function resolve(uint input) public pure returns (address) {\n        address addressVar = address(input);\n        return addressVar;\n    }\n    function unrelatedFunction2() public pure {}\n    function unrelatedFunction3() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/95.sol:1:139:\n  |\n1 |  ... ss) {         address addressVar = address(input);         return addressVar;     }  ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractE {\n    function derive(uint value) public pure returns (address) {\n        address addr = address(value);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/96.sol:1:132:\n  |\n1 |  ... (address) {         address addr = address(value);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractF {\n    function translate(uint amount) public pure returns (address) {\n        address addr = address(amount);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/97.sol:1:136:\n  |\n1 |  ... (address) {         address addr = address(amount);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractG {\n    function modify(uint num) public pure returns (address) {\n        address output = address(num);\n        return output;\n    }\n    function unrelatedFunction4() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/98.sol:1:132:\n  |\n1 |  ... ddress) {         address output = address(num);         return output;     }      ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractH {\n    function convert(uint quantity) public pure returns (address) {\n        address converted = address(quantity);\n        return converted;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/99.sol:1:141:\n  |\n1 |  ... ess) {         address converted = address(quantity);         return converted;     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractI {\n    function transform(uint number) public pure returns (address) {\n        address transformed = address(number);\n        return transformed;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/100.sol:1:143:\n  |\n1 |  ... s) {         address transformed = address(number);         return transformed;     } ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractJ {\n    function alter(uint parameter) public pure returns (address) {\n        address changed = address(parameter);\n        return changed;\n    }\n    function unrelatedFunction5() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/101.sol:1:138:\n  |\n1 |  ... dress) {         address changed = address(parameter);         return changed;     }     ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractA {\n    function adjust(uint input) public pure returns (address) {\n        address addr = address(uint160(input));\n        return addr;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractB {\n    function generate(uint num) public pure returns (address) {\n        address output = address(uint160(num));\n        return output;\n    }\n    function unrelatedFunction1() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractC {\n    function deliver(uint data) public pure returns (address) {\n        address result = address(uint160(data));\n        return result;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractD {\n    function resolve(uint input) public pure returns (address) {\n        address addressVar = address(uint160(input));\n        return addressVar;\n    }\n    function unrelatedFunction2() public pure {}\n    function unrelatedFunction3() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractE {\n    function derive(uint value) public pure returns (address) {\n        address addr = address(uint160(value));\n        return addr;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractF {\n    function translate(uint amount) public pure returns (address) {\n        address addr = address(uint160(amount));\n        return addr;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractG {\n    function modify(uint num) public pure returns (address) {\n        address output = address(uint160(num));\n        return output;\n    }\n    function unrelatedFunction4() public pure {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractH {\n    function convert(uint quantity) public pure returns (address) {\n        address converted = address(uint160(quantity));\n        return converted;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractI {\n    function transform(uint number) public pure returns (address) {\n        address transformed = address(uint160(number));\n        return transformed;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractJ {\n    function alter(uint parameter) public pure returns (address) {\n        address changed = address(uint160(parameter));\n        return changed;\n    }\n    function unrelatedFunction5() public pure {}\n}"
      }
    }
  },
  {
    "Changes129": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Function call options can only be given once, i.e. <code>c.f{gas: 10000}{value: 1}()</code> is invalid and has to be changed to <code>c.f{gas: 10000, value: 1}()</code>.Combine <code>c.f{gas: 10000}{value: 1}()</code> to <code>c.f{gas: 10000, value: 1}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ExpenseTracker {\n    address payable public accountant;\n    function recordExpense() public {\n        accountant.call{gas: 3000}{value: 3 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/102.sol:1:135:\n  |\n1 |  ... n recordExpense() public {         accountant.call{gas: 3000}{value: 3 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract CharityFund {\n    address payable public donor;\n    function donate() public {\n        donor.call{gas: 4000}{value: 2 ether}(\"\");\n    }\n    function reportDonation() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/103.sol:1:120:\n  |\n1 |  ... function donate() public {         donor.call{gas: 4000}{value: 2 ether}(\"\");     }     function reportDona ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract PurchaseOrder {\n    address payable public supplier;\n    function orderItems() public {\n        supplier.call{gas: 2000}{value: 5 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/104.sol:1:129:\n  |\n1 |  ... tion orderItems() public {         supplier.call{gas: 2000}{value: 5 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract CashFlowManagement {\n    address payable public cashier;\n    function manageCashFlow() public {\n        cashier.call{gas: 5000}{value: 1 ether}(\"\");\n    }\n    function liquidityStatus() public pure returns (string memory) {\n        return \"Stable\";\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/105.sol:1:137:\n  |\n1 |  ...  manageCashFlow() public {         cashier.call{gas: 5000}{value: 1 ether}(\"\");     }     function liquidityS ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract FundingCampaign {\n    address payable public campaignTreasurer;\n    function startCampaign() public {\n        campaignTreasurer.call{gas: 4500}{value: 4 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/106.sol:1:143:\n  |\n1 |  ... n startCampaign() public {         campaignTreasurer.call{gas: 4500}{value: 4 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueService {\n    address payable public taxCollector;\n    function collectTax() public {\n        taxCollector.call{gas: 6000}{value: 2 ether}(\"\");\n    }\n    function revenueReport() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/107.sol:1:134:\n  |\n1 |  ... tion collectTax() public {         taxCollector.call{gas: 6000}{value: 2 ether}(\"\");     }     function revenueRep ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract SalaryDisbursement {\n    address payable public payroll;\n    function disburseSalary() public {\n        payroll.call{gas: 3500}{value: 3 ether}(\"\");\n    }\n    function updatePayroll() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/108.sol:1:137:\n  |\n1 |  ...  disburseSalary() public {         payroll.call{gas: 3500}{value: 3 ether}(\"\");     }     function updatePayr ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract EventOrganizer {\n    address payable public organizer;\n    function organizeEvent() public {\n        organizer.call{gas: 2500}{value: 1 ether}(\"\");\n    }\n    function eventSummary() public pure returns (string memory) {\n        return \"Event Successful\";\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/109.sol:1:134:\n  |\n1 |  ... n organizeEvent() public {         organizer.call{gas: 2500}{value: 1 ether}(\"\");     }     function eventSumma ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract InvestmentPool {\n    address payable public investor;\n    function poolFunds() public {\n        investor.call{gas: 7000}{value: 2 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/110.sol:1:129:\n  |\n1 |  ... ction poolFunds() public {         investor.call{gas: 7000}{value: 2 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract BudgetControl {\n    address payable public controller;\n    function controlBudget() public {\n        controller.call{gas: 8000}{value: 1 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/111.sol:1:134:\n  |\n1 |  ... n controlBudget() public {         controller.call{gas: 8000}{value: 1 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ExpenseTracker {\n    address payable public accountant;\n    function recordExpense() public {\n        accountant.call{gas: 3000, value: 3 ether}(\"\");\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract CharityFund {\n    address payable public donor;\n    function donate() public {\n        donor.call{gas: 4000, value: 2 ether}(\"\");\n    }\n    function reportDonation() public {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract PurchaseOrder {\n    address payable public supplier;\n    function orderItems() public {\n        supplier.call{gas: 2000, value: 5 ether}(\"\");\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract CashFlowManagement {\n    address payable public cashier;\n    function manageCashFlow() public {\n        cashier.call{gas: 5000, value: 1 ether}(\"\");\n    }\n    function liquidityStatus() public pure returns (string memory) {\n        return \"Stable\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract FundingCampaign {\n    address payable public campaignTreasurer;\n    function startCampaign() public {\n        campaignTreasurer.call{gas: 4500, value: 4 ether}(\"\");\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract RevenueService {\n    address payable public taxCollector;\n    function collectTax() public {\n        taxCollector.call{gas: 6000, value: 2 ether}(\"\");\n    }\n    function revenueReport() public {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract SalaryDisbursement {\n    address payable public payroll;\n    function disburseSalary() public {\n        payroll.call{gas: 3500, value: 3 ether}(\"\");\n    }\n    function updatePayroll() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract EventOrganizer {\n    address payable public organizer;\n    function organizeEvent() public {\n        organizer.call{gas: 2500, value: 1 ether}(\"\");\n    }\n    function eventSummary() public pure returns (string memory) {\n        return \"Event Successful\";\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract InvestmentPool {\n    address payable public investor;\n    function poolFunds() public {\n        investor.call{gas: 7000, value: 2 ether}(\"\");\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract BudgetControl {\n    address payable public controller;\n    function controlBudget() public {\n        controller.call{gas: 8000, value: 1 ether}(\"\");\n    }\n}"
      }
    }
  },
  {
    "Changes130": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The global functions <code>log0</code>, <code>log1</code>, <code>log2</code>, <code>log3</code> and <code>log4</code> have been removed.Use inline assembly as a replacement for <code>log0</code>, \u2026, <code>log4</code>.13.These are low-level functions that were largely unused. Their behavior can be accessed from inline assembly.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract AlertLogger {\n    function alertData(uint256 alertInfo) public {\n        bytes memory alertBytes = abi.encodePacked(alertInfo);\n        assembly {\n            log0(alertBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/112.sol:1:192:\n  |\n1 |  ... o);         assembly {             log0(alertBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract EventTracker {\n    function trackEvent(int256 eventValue) public {\n        bytes memory eventData = abi.encodePacked(eventValue);\n        assembly {\n            log3(eventData, eventValue, eventValue, eventValue)\n        }\n    }\n    function extraMethod() public pure returns (uint) { return 5; }\n}",
          "error message": "Error: Function expects 5 arguments but got 4.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/113.sol:1:194:\n  |\n1 |  ... e);         assembly {             log3(eventData, eventValue, eventValue, ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentLogger {\n    function logPayment(bytes32 paymentData) public {\n        assembly {\n            log4(paymentData, paymentData, paymentData, paymentData, paymentData)\n        }\n    }\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/114.sol:1:134:\n  |\n1 |  ... c {         assembly {             log4(paymentData, paymentData, paymentD ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract UsageLogger {\n    function logUsage(uint256 usage) public {\n        bytes memory usageBytes = abi.encodePacked(usage);\n        assembly {\n            log2(usageBytes, usage, usage)\n        }\n    }\n    function helperMethod() public pure {}\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/115.sol:1:183:\n  |\n1 |  ... e);         assembly {             log2(usageBytes, usage, usage)          ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract DetailTracker {\n    function trackDetail(uint256 detailAmount) public {\n        bytes memory detailBytes = abi.encodePacked(detailAmount);\n        assembly {\n            log1(detailBytes, detailAmount)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/116.sol:1:203:\n  |\n1 |  ... t);         assembly {             log1(detailBytes, detailAmount)         ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ProcessLogger {\n    function logProcess(uint256 processId) public {\n        bytes memory processBytes = abi.encodePacked(processId);\n        assembly {\n            log2(processBytes, processId, processId)\n        }\n    }\n    function unusedMethod() public pure {}\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/117.sol:1:197:\n  |\n1 |  ... d);         assembly {             log2(processBytes, processId, processId ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract FeedbackLogger {\n    function logFeedback(string memory feedback) public {\n        bytes memory feedbackBytes = bytes(feedback);\n        assembly {\n            log0(feedbackBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/118.sol:1:193:\n  |\n1 |  ... k);         assembly {             log0(feedbackBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract UpdateLogger {\n    function logUpdate(uint256 updateId) public {\n        bytes memory updateBytes = abi.encodePacked(updateId);\n        assembly {\n            log4(updateBytes, updateId, updateId, updateId, updateId)\n        }\n    }\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/119.sol:1:192:\n  |\n1 |  ... d);         assembly {             log4(updateBytes, updateId, updateId, u ...\n  |                                         ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueRecorder {\n    function recordValue(uint256 value) public {\n        bytes memory valueBytes = abi.encodePacked(value);\n        assembly {\n            log1(valueBytes, value)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/120.sol:1:188:\n  |\n1 |  ... e);         assembly {             log1(valueBytes, value)         }     } ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract NotificationLogger {\n    function logNotification(string memory notification) public {\n        bytes memory notificationBytes = bytes(notification);\n        assembly {\n            log2(notificationBytes, notificationBytes, notificationBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/121.sol:1:213:\n  |\n1 |  ... n);         assembly {             log2(notificationBytes, notificationByt ...\n  |                                         ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract AlertLogger {\n    event Alert(uint256 alertInfo);\n    function alertData(uint256 alertInfo) public {\n        emit Alert(alertInfo);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract EventTracker {\n    event TrackEvent(int256 eventValue);\n    function trackEvent(int256 eventValue) public {\n        emit TrackEvent(eventValue);\n    }\n    function extraMethod() public pure returns (uint) { return 5; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract PaymentLogger {\n    event Payment(bytes32 paymentData);\n    function logPayment(bytes32 paymentData) public {\n        emit Payment(paymentData);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract UsageLogger {\n    event Usage(uint256 usage);\n    function logUsage(uint256 usage) public {\n        emit Usage(usage);\n    }\n    function helperMethod() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract DetailTracker {\n    event Detail(uint256 detailAmount);\n    function trackDetail(uint256 detailAmount) public {\n        emit Detail(detailAmount);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ProcessLogger {\n    event Process(uint256 processId);\n    function logProcess(uint256 processId) public {\n        emit Process(processId);\n    }\n    function unusedMethod() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract FeedbackLogger {\n    event Feedback(string feedback);\n    function logFeedback(string memory feedback) public {\n        emit Feedback(feedback);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract UpdateLogger {\n    event Update(uint256 updateId);\n    function logUpdate(uint256 updateId) public {\n        emit Update(updateId);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ValueRecorder {\n    event Value(uint256 value);\n    function recordValue(uint256 value) public {\n        emit Value(value);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract NotificationLogger {\n    event Notification(string notification);\n    function logNotification(string memory notification) public {\n        emit Notification(notification);\n    }\n}"
      }
    }
  },
  {
    "Changes131": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Declarations with the name <code>this</code>, <code>super</code> and <code>_</code> are disallowed, with the exception of\npublic functions and events. The exception is to make it possible to declare interfaces of contracts\nimplemented in languages other than Solidity that do permit such function names.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractA {\n    uint256 public super;\n\n    function modifySuper(uint256 _value) public {\n        super = _value;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/122.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractA {     uint256 public super;      function modifySuper(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractB {\n    uint256 public this;\n\n    function updateThis(uint256 _value) public {\n        this = _value;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/123.sol:1:50:\n  |\n1 | pragma solidity^0.8.0;  contract ContractB {     uint256 public this;      function updateThis(uint256 _value) public {         this = _value;     } }\n  |                                                  ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractC {\n    bool public _;\n\n    function toggle_() public {\n        _ = !_;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/124.sol:1:50:\n  |\n1 | pragma solidity^0.8.0;  contract ContractC {     bool public _;      function toggle_() public {         _ = !_;     } }\n  |                                                  ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractD {\n    int256 public super;\n\n    function adjustSuper(int256 _value) public {\n        super = _value;\n    }\n\n    function extraMethod() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/125.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractD {     int256 public super;      function adjustSuper(int256  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractE {\n    string public this;\n\n    function setThis(string calldata _value) public {\n        this = _value;\n    }\n\n    function dummy() public pure returns (uint) {\n        return 1;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/126.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractE {     string public this;      function setThis(string call ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractF {\n    address public _;\n\n    function setAddress(address _address) public {\n        _ = _address;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/127.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractF {     address public _;      function setAddress(address  ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractG {\n    bytes32 public super;\n\n    function putSuper(bytes32 _value) public {\n        super = _value;\n    }\n\n    function anotherFunction() public pure returns (bytes32) {\n        return \"Sample\";\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/128.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractG {     bytes32 public super;      function putSuper(bytes32 _v ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractH {\n    uint256 public this;\n\n    function refreshThis(uint256 _value) public {\n        this = _value;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/129.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ContractH {     uint256 public this;      function refreshThis(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractI {\n    int public _;\n\n    function increment_() public {\n        _ += 1;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/130.sol:1:50:\n  |\n1 | pragma solidity^0.8.0;  contract ContractI {     int public _;      function increment_() public {         _ += 1;     } }\n  |                                                  ^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractJ {\n    bool public this;\n\n    function switchThis() public {\n        this = !this;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/131.sol:1:50:\n  |\n1 | pragma solidity^0.8.0;  contract ContractJ {     bool public this;      function switchThis() public {         this = !this;     } }\n  |                                                  ^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractA {\n    uint256 public value;\n\n    function modifyValue(uint256 _value) public {\n        value = _value;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractB {\n    uint256 public variable;\n\n    function updateVariable(uint256 _value) public {\n        variable = _value;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractC {\n    bool public state;\n\n    function toggleState() public {\n        state = !state;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractD {\n    int256 public value;\n\n    function adjustValue(int256 _value) public {\n        value = _value;\n    }\n\n    function extraMethod() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractE {\n    string public variable;\n\n    function setVariable(string calldata _value) public {\n        variable = _value;\n    }\n\n    function dummy() public pure returns (uint) {\n        return 1;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractF {\n    address public addressVariable;\n\n    function setAddressVariable(address _address) public {\n        addressVariable = _address;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractG {\n    bytes32 public value;\n\n    function putValue(bytes32 _value) public {\n        value = _value;\n    }\n\n    function anotherFunction() public pure returns (bytes32) {\n        return \"Sample\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractH {\n    uint256 public variable;\n\n    function refreshVariable(uint256 _value) public {\n        variable = _value;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractI {\n    int public value;\n\n    function incrementValue() public {\n        value += 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractJ {\n    bool public state;\n\n    function switchState() public {\n        state = !state;\n    }\n}"
      }
    }
  },
  {
    "Changes132": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Remove support for the <code>b</code>, <code>f</code>, and <code>v</code> escape sequences in code.\nThey can still be inserted via hexadecimal escapes, e.g. <code>x08</code>, <code>x0c</code>, and <code>x0b</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorCharOne {\n    string public missingChar = \"Missing character: \\b\";\n    function retrieveMissingChar() public view returns (string memory) {\n        return missingChar;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/132.sol:1:80:\n  |\n1 |  ...  {     string public missingChar = \"Missing character: \\b\";     function retrieveMissingChar ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorCharTwo {\n    string public feedError = \"Feed error: \\f\";\n    function fetchFeedError() public view returns (string memory) {\n        return feedError;\n    }\n    function additional() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/133.sol:1:78:\n  |\n1 |  ... wo {     string public feedError = \"Feed error: \\f\";     function fetchFeedError() pu ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorCharThree {\n    string public tabError = \"Tab error: \\v\";\n    function getTabError() public view returns (string memory) {\n        return tabError;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/134.sol:1:79:\n  |\n1 |  ... ree {     string public tabError = \"Tab error: \\v\";     function getTabError() publi ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract DataError {\n    string public dataBreak = \"Data break: \\b\";\n    function getDataBreak() public view returns (string memory) {\n        return dataBreak;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/135.sol:1:75:\n  |\n1 |  ... or {     string public dataBreak = \"Data break: \\b\";     function getDataBreak() publ ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract InfoError {\n    string public verticalError = \"Vertical error: \\v\";\n    function getVerticalError() public view returns (string memory) {\n        return verticalError;\n    }\n    function extraMethod() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/136.sol:1:79:\n  |\n1 |  ...      string public verticalError = \"Vertical error: \\v\";     function getVerticalError()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract CharError {\n    string public characterIssue = \"Character issue: \\f\";\n    function getCharacterIssue() public view returns (string memory) {\n        return characterIssue;\n    }\n    function randomFunction() public pure returns (uint) {\n        return 321;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/137.sol:1:80:\n  |\n1 |  ...     string public characterIssue = \"Character issue: \\f\";     function getCharacterIssue() ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract SoundError {\n    string public soundIssue = \"Sound issue: \\b\";\n    function getSoundIssue() public view returns (string memory) {\n        return soundIssue;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/138.sol:1:77:\n  |\n1 |  ... r {     string public soundIssue = \"Sound issue: \\b\";     function getSoundIssue() pub ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract TabIssue {\n    string public tabulationIssue = \"Tabulation issue: \\v\";\n    function getTabulationIssue() public view returns (string memory) {\n        return tabulationIssue;\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 789;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/139.sol:1:80:\n  |\n1 |  ...    string public tabulationIssue = \"Tabulation issue: \\v\";     function getTabulationIssue( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract FeedError {\n    string public lineFeedError = \"Line feed error: \\f\";\n    function getLineFeedError() public view returns (string memory) {\n        return lineFeedError;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/140.sol:1:79:\n  |\n1 |  ...      string public lineFeedError = \"Line feed error: \\f\";     function getLineFeedError()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract VisualError {\n    string public visualError = \"Visual error: \\b\";\n    function getVisualError() public view returns (string memory) {\n        return visualError;\n    }\n    function additionalFeature() public pure returns (string memory) {\n        return \"Feature\";\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/141.sol:1:79:\n  |\n1 |  ...  {     string public visualError = \"Visual error: \\b\";     function getVisualError() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ErrorCharOne {\n    string public missingChar = \"Missing character: \\x08\";\n    function retrieveMissingChar() public view returns (string memory) {\n        return missingChar;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ErrorCharTwo {\n    string public feedError = \"Feed error: \\x0c\";\n    function fetchFeedError() public view returns (string memory) {\n        return feedError;\n    }\n    function additional() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ErrorCharThree {\n    string public tabError = \"Tab error: \\x0b\";\n    function getTabError() public view returns (string memory) {\n        return tabError;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract DataError {\n    string public dataBreak = \"Data break: \\x08\";\n    function getDataBreak() public view returns (string memory) {\n        return dataBreak;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract InfoError {\n    string public verticalError = \"Vertical error: \\x0b\";\n    function getVerticalError() public view returns (string memory) {\n        return verticalError;\n    }\n    function extraMethod() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract CharError {\n    string public characterIssue = \"Character issue: \\x0c\";\n    function getCharacterIssue() public view returns (string memory) {\n        return characterIssue;\n    }\n    function randomFunction() public pure returns (uint) {\n        return 321;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract SoundError {\n    string public soundIssue = \"Sound issue: \\x08\";\n    function getSoundIssue() public view returns (string memory) {\n        return soundIssue;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract TabIssue {\n    string public tabulationIssue = \"Tabulation issue: \\x0b\";\n    function getTabulationIssue() public view returns (string memory) {\n        return tabulationIssue;\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 789;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract FeedError {\n    string public lineFeedError = \"Line feed error: \\x0c\";\n    function getLineFeedError() public view returns (string memory) {\n        return lineFeedError;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract VisualError {\n    string public visualError = \"Visual error: \\x08\";\n    function getVisualError() public view returns (string memory) {\n        return visualError;\n    }\n    function additionalFeature() public pure returns (string memory) {\n        return \"Feature\";\n    }\n}"
      }
    }
  },
  {
    "Changes133": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The global variables <code>tx.origin</code> and <code>msg.sender</code> have the type <code>address</code> instead of\n<code>address payable</code>. One can convert them into <code>address payable</code> by using an explicit\nconversion, i.e., <code>payable(tx.origin)</code> or <code>payable(msg.sender)</code>.This change was done since the compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible.Change <code>msg.sender.transfer(x)</code> to <code>payable(msg.sender).transfer(x)</code> or use a stored variable of <code>address payable</code> type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentDispatcher {\n    function dispatchPayment() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/142.sol:1:109:\n  |\n1 | pragma solidity^0.8.0; contract PaymentDispatcher {     function dispatchPayment() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                             ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract FeeDistributor {\n    function distributeFee() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function extraFeature() public pure returns (int) { return 2024; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/143.sol:1:104:\n  |\n1 |  ... buteFee() public payable {         msg.sender.transfer(msg.value);     }     function ext ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneySender {\n    function sendMoney() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function helperFunction() public pure returns (string memory) { return \"Extra\"; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/144.sol:1:97:\n  |\n1 |  ... ndMoney() public payable {         msg.sender.transfer(msg.value);     }     function hel ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ExpenseReimburser {\n    function reimburse() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/145.sol:1:103:\n  |\n1 | pragma solidity^0.8.0; contract ExpenseReimburser {     function reimburse() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                       ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueCollector {\n    function collectRevenue() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function additionalLogic() public pure returns (bool) { return false; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/146.sol:1:107:\n  |\n1 |  ... Revenue() public payable {         msg.sender.transfer(msg.value);     }     function add ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract WealthAllocator {\n    function allocateWealth() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/147.sol:1:106:\n  |\n1 | pragma solidity^0.8.0; contract WealthAllocator {     function allocateWealth() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                          ^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantIssuer {\n    function issueGrant() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/148.sol:1:98:\n  |\n1 | pragma solidity^0.8.0; contract GrantIssuer {     function issueGrant() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                  ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract CashoutProcessor {\n    function processCashout() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function unusedMethod() public pure {}\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/149.sol:1:107:\n  |\n1 |  ... Cashout() public payable {         msg.sender.transfer(msg.value);     }     function unu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract BenefitPayer {\n    function payBenefit() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/150.sol:1:99:\n  |\n1 | pragma solidity^0.8.0; contract BenefitPayer {     function payBenefit() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                   ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract RefundIssuer {\n    function issueRefund() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function someUtility() public pure returns (uint) { return 999; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/151.sol:1:100:\n  |\n1 |  ... eRefund() public payable {         msg.sender.transfer(msg.value);     }     function som ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract PaymentDispatcher {\n    function dispatchPayment() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract FeeDistributor {\n    function distributeFee() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function extraFeature() public pure returns (int) { return 2024; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract MoneySender {\n    function sendMoney() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function helperFunction() public pure returns (string memory) { return \"Extra\"; }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ExpenseReimburser {\n    function reimburse() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract RevenueCollector {\n    function collectRevenue() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function additionalLogic() public pure returns (bool) { return false; }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract WealthAllocator {\n    function allocateWealth() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract GrantIssuer {\n    function issueGrant() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract CashoutProcessor {\n    function processCashout() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function unusedMethod() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract BenefitPayer {\n    function payBenefit() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract RefundIssuer {\n    function issueRefund() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function someUtility() public pure returns (uint) { return 999; }\n}"
      }
    }
  },
  {
    "Changes134": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The <code>chainid</code> builtin in inline assembly is now considered <code>view</code> instead of <code>pure</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainProcessor {\n    function processChainID() public pure returns (uint256) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid\n        }\n        return chainID;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/152.sol:1:180:\n  |\n1 |  ...  assembly {             chainID := chainid         }         return chainID;  ...\n  |                                         ^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainData {\n    function accessChainData() public pure returns (uint256) {\n        uint256 data;\n        assembly {\n            data := chainid\n        }\n        return data;\n    }\n    function extraFuncA() public pure returns (uint256) { return 100; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/153.sol:1:170:\n  |\n1 |  ...     assembly {             data := chainid         }         return data;     ...\n  |                                         ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkIdentifier {\n    function getNetworkIdentifier() public pure returns (uint256) {\n        uint256 networkId;\n        assembly {\n            networkId := chainid\n        }\n        return networkId;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/154.sol:1:193:\n  |\n1 |  ... ssembly {             networkId := chainid         }         return networkId ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract BlockChainID {\n    function getBlockChainID() public pure returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid\n        }\n        return id;\n    }\n    function helperOne() public pure returns (uint256) { return 101; }\n    function helperTwo() public pure returns (uint256) { return 102; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/155.sol:1:169:\n  |\n1 |  ...       assembly {             id := chainid         }         return id;     } ...\n  |                                         ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainLink {\n    function linkToChain() public pure returns (uint256) {\n        uint256 link;\n        assembly {\n            link := chainid\n        }\n        return link;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/156.sol:1:166:\n  |\n1 |  ...     assembly {             link := chainid         }         return link;     ...\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainGather {\n    function gatherChainInfo() public pure returns (uint256) {\n        uint256 info;\n        assembly {\n            info := chainid\n        }\n        return info;\n    }\n    function unrelatedFunc() public pure returns (uint256) { return 42; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/157.sol:1:172:\n  |\n1 |  ...     assembly {             info := chainid         }         return info;     ...\n  |                                         ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkChain {\n    function fetchNetworkChain() public pure returns (uint256) {\n        uint256 networkChain;\n        assembly {\n            networkChain := chainid\n        }\n        return networkChain;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/158.sol:1:191:\n  |\n1 |  ... mbly {             networkChain := chainid         }         return networkCh ...\n  |                                         ^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract BlockchainRetriever {\n    function retrieveBlockchain() public pure returns (uint256) {\n        uint256 blockchain;\n        assembly {\n            blockchain := chainid\n        }\n        return blockchain;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/159.sol:1:195:\n  |\n1 |  ... sembly {             blockchain := chainid         }         return blockchai ...\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainReveal {\n    function revealChain() public pure returns (uint256) {\n        uint256 reveal;\n        assembly {\n            reveal := chainid\n        }\n        return reveal;\n    }\n    function additional() public pure returns (uint256) { return 777; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/160.sol:1:172:\n  |\n1 |  ...   assembly {             reveal := chainid         }         return reveal;   ...\n  |                                         ^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainDiscovery {\n    function discoverChain() public pure returns (uint256) {\n        uint256 discovery;\n        assembly {\n            discovery := chainid\n        }\n        return discovery;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/161.sol:1:183:\n  |\n1 |  ... ssembly {             discovery := chainid         }         return discovery ...\n  |                                         ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ChainProcessor {\n    function processChainID() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ChainData {\n    function accessChainData() public view returns (uint256) {\n        return block.chainid;\n    }\n    function extraFuncA() public pure returns (uint256) { return 100; }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract NetworkIdentifier {\n    function getNetworkIdentifier() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract BlockChainID {\n    function getBlockChainID() public view returns (uint256) {\n        return block.chainid;\n    }\n    function helperOne() public pure returns (uint256) { return 101; }\n    function helperTwo() public pure returns (uint256) { return 102; }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ChainLink {\n    function linkToChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ChainGather {\n    function gatherChainInfo() public view returns (uint256) {\n        return block.chainid;\n    }\n    function unrelatedFunc() public pure returns (uint256) { return 42; }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract NetworkChain {\n    function fetchNetworkChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract BlockchainRetriever {\n    function retrieveBlockchain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ChainReveal {\n    function revealChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function additional() public pure returns (uint256) { return 777; }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ChainDiscovery {\n    function discoverChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}"
      }
    }
  },
  {
    "Changes135": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Unary negation cannot be used on unsigned integers anymore, only on signed integers.Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. <code>type(uint256).max - x + 1</code>, while ensuring that <code>x</code> is not zero)",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract IntegerNegative {\n    function negate(uint p) public pure returns (uint) {\n        return -p;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/162.sol:1:123:\n  |\n1 | pragma solidity^0.8.0; contract IntegerNegative {     function negate(uint p) public pure returns (uint) {         return -p;     } }\n  |                                                                                                                           ^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract UnsignedError {\n    function error(uint q) public pure returns (uint) {\n        return -q;\n    }\n    function helperFunc() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/163.sol:1:120:\n  |\n1 |  ... re returns (uint) {         return -q;     }     function helperFunc() p ...\n  |                                         ^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueReversal {\n    function reverseValue(uint r) public pure returns (uint) {\n        return -r;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/164.sol:1:127:\n  |\n1 | pragma solidity^0.8.0; contract ValueReversal {     function reverseValue(uint r) public pure returns (uint) {         return -r;     } }\n  |                                                                                                                               ^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract SimpleMath {\n    function negate(uint s) public pure returns (uint) {\n        return -s;\n    }\n    function doExtra() public pure {}\n    function anotherExtra() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/165.sol:1:118:\n  |\n1 |  ... re returns (uint) {         return -s;     }     function doExtra() publ ...\n  |                                         ^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract CalculationError {\n    function makeError(uint t) public pure returns (uint) {\n        return -t;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/166.sol:1:127:\n  |\n1 | pragma solidity^0.8.0; contract CalculationError {     function makeError(uint t) public pure returns (uint) {         return -t;     } }\n  |                                                                                                                               ^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Inversion {\n    function invertValue(uint u) public pure returns (uint) {\n        return -u;\n    }\n    function anotherFunc() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/167.sol:1:122:\n  |\n1 |  ... re returns (uint) {         return -u;     }     function anotherFunc()  ...\n  |                                         ^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract SignFlip {\n    function flipSign(uint v) public pure returns (uint) {\n        return -v;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/168.sol:1:118:\n  |\n1 | pragma solidity^0.8.0; contract SignFlip {     function flipSign(uint v) public pure returns (uint) {         return -v;     } }\n  |                                                                                                                      ^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract NegativeOutput {\n    function outputNegative(uint w) public pure returns (uint) {\n        return -w;\n    }\n    function justAFunction() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/169.sol:1:130:\n  |\n1 |  ... re returns (uint) {         return -w;     }     function justAFunction( ...\n  |                                         ^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ZeroSubtract {\n    function subtractFromMax(uint x) public pure returns (uint) {\n        return -x;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/170.sol:1:129:\n  |\n1 | pragma solidity^0.8.0; contract ZeroSubtract {     function subtractFromMax(uint x) public pure returns (uint) {         return -x;     } }\n  |                                                                                                                                 ^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract DirectNegation {\n    function directlyNegate(uint y) public pure returns (uint) {\n        return -y;\n    }\n    function extraOne() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-test-error/171.sol:1:130:\n  |\n1 |  ... re returns (uint) {         return -y;     }     function extraOne() pub ...\n  |                                         ^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract IntegerNegative {\n    function negate(uint p) public pure returns (uint) {\n        return type(uint).max - p + 1;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract UnsignedError {\n    function error(uint q) public pure returns (uint) {\n        return type(uint).max - q + 1;\n    }\n    function helperFunc() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ValueReversal {\n    function reverseValue(uint r) public pure returns (uint) {\n        return type(uint).max - r + 1;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract SimpleMath {\n    function negate(uint s) public pure returns (uint) {\n        return type(uint).max - s + 1;\n    }\n    function doExtra() public pure {}\n    function anotherExtra() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract CalculationError {\n    function makeError(uint t) public pure returns (uint) {\n        return type(uint).max - t + 1;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Inversion {\n    function invertValue(uint u) public pure returns (uint) {\n        return type(uint).max - u + 1;\n    }\n    function anotherFunc() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract SignFlip {\n    function flipSign(uint v) public pure returns (uint) {\n        return type(uint).max - v + 1;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract NegativeOutput {\n    function outputNegative(uint w) public pure returns (uint) {\n        return type(uint).max - w + 1;\n    }\n    function justAFunction() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ZeroSubtract {\n    function subtractFromMax(uint x) public pure returns (uint) {\n        return type(uint).max - x + 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract DirectNegation {\n    function directlyNegate(uint y) public pure returns (uint) {\n        return type(uint).max - y + 1;\n    }\n    function extraOne() public pure {}\n}"
      }
    }
  },
  {
    "Changes136": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractEE {\n    byte itemEE;\n    function setItemEE(byte newValue) public {\n        itemEE = newValue;\n    }\n    function extraFunctionEE() public pure returns (string memory) {\n        return \"Extra EE\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/2.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractEE {     byte itemEE;     function setItemEE(byt ...\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractFF {\n    byte itemFF;\n    function modifyItemFF(byte newValue) public {\n        itemFF = newValue;\n    }\n    function randomFunctionFF() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/3.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractFF {     byte itemFF;     function modifyItemFF( ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractGG {\n    byte itemGG;\n    function updateItemGG(byte newValue) public {\n        itemGG = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/4.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractGG {     byte itemGG;     function updateItemGG(byte newValue) public {         itemGG = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractHH {\n    byte itemHH;\n    function changeItemHH(byte newValue) public {\n        itemHH = newValue;\n    }\n    function helperFunctionHH() public pure returns (int) {\n        return 256;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/5.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractHH {     byte itemHH;     function changeItemHH( ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractII {\n    byte itemII;\n    function adjustItemII(byte newValue) public {\n        itemII = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/6.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractII {     byte itemII;     function adjustItemII(byte newValue) public {         itemII = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractJJ {\n    byte itemJJ;\n    function setItemJJ(byte newValue) public {\n        itemJJ = newValue;\n    }\n    function extraFunctionJJ() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/7.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractJJ {     byte itemJJ;     function setItemJJ(byt ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractKK {\n    byte itemKK;\n    function deployItemKK(byte newValue) public {\n        itemKK = newValue;\n    }\n    function dummyFunctionKK() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/8.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractKK {     byte itemKK;     function deployItemKK( ...\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractLL {\n    byte itemLL;\n    function storeItemLL(byte newValue) public {\n        itemLL = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/9.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractLL {     byte itemLL;     function storeItemLL(byte newValue) public {         itemLL = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractMM {\n    byte itemMM;\n    function replaceItemMM(byte newValue) public {\n        itemMM = newValue;\n    }\n    function extraFunctionMM() public pure returns (int) {\n        return -123;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/10.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractMM {     byte itemMM;     function replaceItemMM ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractNN {\n    byte itemNN;\n    function refreshItemNN(byte newValue) public {\n        itemNN = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/11.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractNN {     byte itemNN;     function refreshItemNN(byte newValue) public {         itemNN = newValue;     } }\n  |                                                  ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractEE {\n    bytes1 itemEE;\n    function setItemEE(bytes1 newValue) public {\n        itemEE = newValue;\n    }\n    function extraFunctionEE() public pure returns (string memory) {\n        return \"Extra EE\";\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractFF {\n    bytes1 itemFF;\n    function modifyItemFF(bytes1 newValue) public {\n        itemFF = newValue;\n    }\n    function randomFunctionFF() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractGG {\n    bytes1 itemGG;\n    function updateItemGG(bytes1 newValue) public {\n        itemGG = newValue;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractHH {\n    bytes1 itemHH;\n    function changeItemHH(bytes1 newValue) public {\n        itemHH = newValue;\n    }\n    function helperFunctionHH() public pure returns (int) {\n        return 256;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractII {\n    bytes1 itemII;\n    function adjustItemII(bytes1 newValue) public {\n        itemII = newValue;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractJJ {\n    bytes1 itemJJ;\n    function setItemJJ(bytes1 newValue) public {\n        itemJJ = newValue;\n    }\n    function extraFunctionJJ() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractKK {\n    bytes1 itemKK;\n    function deployItemKK(bytes1 newValue) public {\n        itemKK = newValue;\n    }\n    function dummyFunctionKK() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractLL {\n    bytes1 itemLL;\n    function storeItemLL(bytes1 newValue) public {\n        itemLL = newValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractMM {\n    bytes1 itemMM;\n    function replaceItemMM(bytes1 newValue) public {\n        itemMM = newValue;\n    }\n    function extraFunctionMM() public pure returns (int) {\n        return -123;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractNN {\n    bytes1 itemNN;\n    function refreshItemNN(bytes1 newValue) public {\n        itemNN = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes137": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions from negative literals and literals larger than <code>type(uint160).max</code> to\n<code>address</code> are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyOne {\n    function convertNegativeThirtyOne() public pure returns (address) {\n        int neg = -31;\n        return address(uint160(neg));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/12.sol:1:172:\n  |\n1 |  ...  neg = -31;         return address(uint160(neg));     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyTwo {\n    function makeAddressNegative() public pure returns (address) {\n        int negative = -32;\n        return address(uint160(negative));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/13.sol:1:172:\n  |\n1 |  ... tive = -32;         return address(uint160(negative));     }     function extraMethod() ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyThree {\n    function negativeToAddressThirtyThree() public pure returns (address) {\n        int num = -33;\n        return address(uint160(num));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/14.sol:1:178:\n  |\n1 |  ...  num = -33;         return address(uint160(num));     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFour {\n    function addressFromNegThirtyFour() public pure returns (address) {\n        int numNeg = -34;\n        return address(uint160(numNeg));\n    }\n    function checkValue() public pure returns (uint) {\n        return 34;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/15.sol:1:176:\n  |\n1 |  ... mNeg = -34;         return address(uint160(numNeg));     }     function checkValue()  ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFive {\n    function convertNegToAddrThirtyFive() public pure returns (address) {\n        int negInt = -35;\n        return address(uint160(negInt));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/16.sol:1:178:\n  |\n1 |  ... gInt = -35;         return address(uint160(negInt));     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySix {\n    function castNegativeInteger() public pure returns (address) {\n        int negative = -36;\n        return address(uint160(negative));\n    }\n    function unrelatedFunction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/17.sol:1:172:\n  |\n1 |  ... tive = -36;         return address(uint160(negative));     }     function unrelatedFunc ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySeven {\n    function negativeToIntAddress() public pure returns (address) {\n        int badNumber = -37;\n        return address(uint160(badNumber));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/18.sol:1:176:\n  |\n1 |  ... mber = -37;         return address(uint160(badNumber));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyEight {\n    function castToAddressFromNeg() public pure returns (address) {\n        int negativeValue = -38;\n        return address(uint160(negativeValue));\n    }\n    function returnValue() public pure returns (int) {\n        return -38;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/19.sol:1:180:\n  |\n1 |  ... alue = -38;         return address(uint160(negativeValue));     }     function returnValue() ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyNine {\n    function negativeValueToAddress() public pure returns (address) {\n        int value = -39;\n        return address(uint160(value));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/20.sol:1:173:\n  |\n1 |  ... alue = -39;         return address(uint160(value));     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractForty {\n    function negativeToAddressConversion() public pure returns (address) {\n        int negativeForty = -40;\n        return address(uint160(negativeForty));\n    }\n    function simpleFunc() public pure returns (uint) {\n        return 40;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/21.sol:1:181:\n  |\n1 |  ... orty = -40;         return address(uint160(negativeForty));     }     function simpleFunc()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyOne {\n    function validOperation() public pure returns (uint) {\n        int neg = -31;\n        return uint(neg);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyTwo {\n    function makeAddressPositive() public pure returns (address) {\n        uint positive = 32;\n        return address(uint160(positive));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyThree {\n    function positiveToAddress() public pure returns (address) {\n        uint num = 33;\n        return address(uint160(num));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFour {\n    function addressFromPositive() public pure returns (address) {\n        uint numPos = 34;\n        return address(uint160(numPos));\n    }\n    function checkValue() public pure returns (uint) {\n        return 34;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFive {\n    function convertPosToAddr() public pure returns (address) {\n        uint posInt = 35;\n        return address(uint160(posInt));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySix {\n    function castPositiveInteger() public pure returns (address) {\n        uint positive = 36;\n        return address(uint160(positive));\n    }\n    function unrelatedFunction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySeven {\n    function positiveToIntAddress() public pure returns (address) {\n        uint goodNumber = 37;\n        return address(uint160(goodNumber));\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyEight {\n    function castToAddressFromPos() public pure returns (address) {\n        uint positiveValue = 38;\n        return address(uint160(positiveValue));\n    }\n    function returnValue() public pure returns (int) {\n        return -38;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyNine {\n    function positiveValueToAddress() public pure returns (address) {\n        uint value = 39;\n        return address(uint160(value));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractForty {\n    function positiveToAddressConversion() public pure returns (address) {\n        uint positiveForty = 40;\n        return address(uint160(positiveForty));\n    }\n    function simpleFunc() public pure returns (uint) {\n        return 40;\n    }\n}"
      }
    }
  },
  {
    "Changes138": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and an integer type <code>T</code> are only allowed if the literal\nlies between <code>type(T).min</code> and <code>type(T).max</code>. In particular, replace usages of <code>uint(-1)</code>\nwith <code>type(uint).max</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyOne {\n    function deriveCeiling() public pure returns (uint) {\n        uint ceiling = uint(-1);\n        return ceiling;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/22.sol:1:134:\n  |\n1 |  ... ns (uint) {         uint ceiling = uint(-1);         return ceiling;     } }\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyTwo {\n    function calculateMaxCap() public pure returns (uint) {\n        uint maxCap = uint(-1);\n        return maxCap;\n    }\n    function randomHelper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/23.sol:1:135:\n  |\n1 |  ... rns (uint) {         uint maxCap = uint(-1);         return maxCap;     }      ...\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyThree {\n    function establishLimit() public pure returns (uint) {\n        uint limit = uint(-1);\n        return limit;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/24.sol:1:135:\n  |\n1 |  ... urns (uint) {         uint limit = uint(-1);         return limit;     } }\n  |                                         ^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFour {\n    function reachMaximum() public pure returns (uint) {\n        uint maximumReach = uint(-1);\n        return maximumReach;\n    }\n    function extraFunctionFive() public pure returns (string memory) {\n        return \"Just a string\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/25.sol:1:139:\n  |\n1 |  ... int) {         uint maximumReach = uint(-1);         return maximumReach;      ...\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFive {\n    function pinpointCeiling() public pure returns (uint) {\n        uint ceilingPinpoint = uint(-1);\n        return ceilingPinpoint;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/26.sol:1:145:\n  |\n1 |  ... ) {         uint ceilingPinpoint = uint(-1);         return ceilingPinpoint;   ...\n  |                                         ^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySix {\n    function getExtremeValue() public pure returns (uint) {\n        uint extremeValue = uint(-1);\n        return extremeValue;\n    }\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 567;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/27.sol:1:141:\n  |\n1 |  ... int) {         uint extremeValue = uint(-1);         return extremeValue;      ...\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySeven {\n    function calculateBoundaryMax() public pure returns (uint) {\n        uint boundaryCalculation = uint(-1);\n        return boundaryCalculation;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/28.sol:1:155:\n  |\n1 |  ...         uint boundaryCalculation = uint(-1);         return boundaryCalculatio ...\n  |                                         ^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyEight {\n    function derivePeak() public pure returns (uint) {\n        uint peakDerivation = uint(-1);\n        return peakDerivation;\n    }\n    function extraFunctionSix() public pure returns (int) {\n        return -999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/29.sol:1:140:\n  |\n1 |  ... t) {         uint peakDerivation = uint(-1);         return peakDerivation;    ...\n  |                                         ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyNine {\n    function secureMaximum() public pure returns (uint) {\n        uint secureMax = uint(-1);\n        return secureMax;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/30.sol:1:137:\n  |\n1 |  ...  (uint) {         uint secureMax = uint(-1);         return secureMax;     } }\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleForty {\n    function identifyMaxValue() public pure returns (uint) {\n        uint maxValue = uint(-1);\n        return maxValue;\n    }\n    function unrelatedTwo() public pure returns (string memory) {\n        return \"Random text\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/31.sol:1:134:\n  |\n1 |  ... s (uint) {         uint maxValue = uint(-1);         return maxValue;     }    ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyOne {\n    function deriveCeiling() public pure returns (uint) {\n        uint ceiling = type(uint).max;\n        return ceiling;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyTwo {\n    function calculateMaxCap() public pure returns (uint) {\n        uint maxCap = type(uint).max;\n        return maxCap;\n    }\n    function randomHelper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyThree {\n    function establishLimit() public pure returns (uint) {\n        uint limit = type(uint).max;\n        return limit;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFour {\n    function reachMaximum() public pure returns (uint) {\n        uint maximumReach = type(uint).max;\n        return maximumReach;\n    }\n    function extraFunctionFive() public pure returns (string memory) {\n        return \"Just a string\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFive {\n    function pinpointCeiling() public pure returns (uint) {\n        uint ceilingPinpoint = type(uint).max;\n        return ceilingPinpoint;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySix {\n    function getExtremeValue() public pure returns (uint) {\n        uint extremeValue = type(uint).max;\n        return extremeValue;\n    }\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 567;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySeven {\n    function calculateBoundaryMax() public pure returns (uint) {\n        uint boundaryCalculation = type(uint).max;\n        return boundaryCalculation;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyEight {\n    function derivePeak() public pure returns (uint) {\n        uint peakDerivation = type(uint).max;\n        return peakDerivation;\n    }\n    function extraFunctionSix() public pure returns (int) {\n        return -999;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyNine {\n    function secureMaximum() public pure returns (uint) {\n        uint secureMax = type(uint).max;\n        return secureMax;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ExampleForty {\n    function identifyMaxValue() public pure returns (uint) {\n        uint maxValue = type(uint).max;\n        return maxValue;\n    }\n    function unrelatedTwo() public pure returns (string memory) {\n        return \"Random text\";\n    }\n}"
      }
    }
  },
  {
    "Changes139": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and enums are only allowed if the literal can\nrepresent a value in the enum.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    enum Speed { Slow, Fast }\n    Speed public carSpeed;\n    function setSpeed() public {\n        carSpeed = Speed(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example32.Speed\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/32.sol:1:155:\n  |\n1 |  ... peed() public {         carSpeed = Speed(3);     } }\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    enum Frequency { Never, Rarely, Often, Always }\n    Frequency public loginFrequency;\n    function setFrequency() public {\n        loginFrequency = Frequency(5);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example33.Frequency\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/33.sol:1:197:\n  |\n1 |  ...  public {         loginFrequency = Frequency(5);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    enum Status { Single, Married, Divorced }\n    Status public maritalStatus;\n    function updateStatus() public {\n        maritalStatus = Status(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example34.Status\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/34.sol:1:186:\n  |\n1 |  ... ) public {         maritalStatus = Status(4);     } }\n  |                                         ^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    enum Direction { Up, Down, Left, Right }\n    Direction public swipeDirection;\n    function swipe() public {\n        swipeDirection = Direction(5);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example35.Direction\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/35.sol:1:183:\n  |\n1 |  ...  public {         swipeDirection = Direction(5);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    enum Action { Buy, Sell, Hold }\n    Action public tradingAction;\n    function takeAction() public {\n        tradingAction = Action(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example36.Action\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/36.sol:1:174:\n  |\n1 |  ... ) public {         tradingAction = Action(4);     } }\n  |                                         ^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    enum Condition { Good, Fair, Poor }\n    Condition public itemCondition;\n    function setCondition() public {\n        itemCondition = Condition(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example37.Condition\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/37.sol:1:183:\n  |\n1 |  ... ) public {         itemCondition = Condition(4);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    enum Temperature { Cold, Warm, Hot }\n    Temperature public waterTemperature;\n    function setTemperature() public {\n        waterTemperature = Temperature(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example38.Temperature\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/38.sol:1:194:\n  |\n1 |  ... ublic {         waterTemperature = Temperature(4);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    enum Position { First, Second, Third }\n    Position public racePosition;\n    function setPosition() public {\n        racePosition = Position(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example39.Position\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/39.sol:1:182:\n  |\n1 |  ... () public {         racePosition = Position(4);     } }\n  |                                         ^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    enum Response { Yes, No }\n    Response public userResponse;\n    function setResponse() public {\n        userResponse = Response(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example40.Response\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/40.sol:1:169:\n  |\n1 |  ... () public {         userResponse = Response(3);     } }\n  |                                         ^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    enum Quality { High, Medium, Low }\n    Quality public productQuality;\n    function adjustQuality() public {\n        productQuality = Quality(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example41.Quality\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/41.sol:1:183:\n  |\n1 |  ...  public {         productQuality = Quality(4);     } }\n  |                                         ^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    enum Speed { Slow, Fast }\n    Speed public carSpeed;\n    function setSpeed() public {\n        carSpeed = Speed(1);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    enum Frequency { Never, Rarely, Often, Always }\n    Frequency public loginFrequency;\n    function setFrequency() public {\n        loginFrequency = Frequency(3);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    enum Status { Single, Married, Divorced }\n    Status public maritalStatus;\n    function updateStatus() public {\n        maritalStatus = Status(2);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    enum Direction { Up, Down, Left, Right }\n    Direction public swipeDirection;\n    function swipe() public {\n        swipeDirection = Direction(3);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    enum Action { Buy, Sell, Hold }\n    Action public tradingAction;\n    function takeAction() public {\n        tradingAction = Action(2);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    enum Condition { Good, Fair, Poor }\n    Condition public itemCondition;\n    function setCondition() public {\n        itemCondition = Condition(2);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    enum Temperature { Cold, Warm, Hot }\n    Temperature public waterTemperature;\n    function setTemperature() public {\n        waterTemperature = Temperature(2);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    enum Position { First, Second, Third }\n    Position public racePosition;\n    function setPosition() public {\n        racePosition = Position(2);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    enum Response { Yes, No }\n    Response public userResponse;\n    function setResponse() public {\n        userResponse = Response(1);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    enum Quality { High, Medium, Low }\n    Quality public productQuality;\n    function adjustQuality() public {\n        productQuality = Quality(2);\n    }\n}"
      }
    }
  },
  {
    "Changes140": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and <code>address</code> type (e.g. <code>address(literal)</code>) have the\ntype <code>address</code> instead of <code>address payable</code>. One can get a payable address type by using an\nexplicit conversion, i.e., <code>payable(literal)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    function issuePayments(address employee, uint256 salary) public {\n        address payable payrollAccount = address(0xFFF);\n        payrollAccount.transfer(salary);\n    }\n\n    function sumOfSquares(uint[] memory nums) public pure returns (uint total) {\n        total = 0;\n        for (uint i = 0; i < nums.length; i++) {\n            total += nums[i] * nums[i];\n        }\n        return total;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/42.sol:1:124:\n  |\n1 |  ... , uint256 salary) public {         address payable payrollAccount = address(0xFFF);         payrollAccount.transfer(s ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    function payDividends(address investor, uint256 dividends) public {\n        address payable investmentAccount = address(0x111);\n        investmentAccount.transfer(dividends);\n    }\n\n    function sumOfEvens(uint limit) public pure returns (uint sum) {\n        sum = 0;\n        for (uint i = 0; i <= limit; i += 2) {\n            sum += i;\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/43.sol:1:126:\n  |\n1 |  ... int256 dividends) public {         address payable investmentAccount = address(0x111);         investmentAccount.transfe ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    function clearDebt(address debtor, uint256 amount) public {\n        address payable debtAccount = address(0x222);\n        debtAccount.transfer(amount);\n    }\n\n    function powerOfTwo(uint n) public pure returns (uint) {\n        return 2**n;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/44.sol:1:118:\n  |\n1 |  ... , uint256 amount) public {         address payable debtAccount = address(0x222);         debtAccount.transfer(amou ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    function grantScholarship(address student, uint256 scholarship) public {\n        address payable schoolAccount = address(0x333);\n        schoolAccount.transfer(scholarship);\n    }\n\n    function isPrime(uint num) public pure returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/45.sol:1:131:\n  |\n1 |  ... t256 scholarship) public {         address payable schoolAccount = address(0x333);         schoolAccount.transfer(sc ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    function refundCustomer(address customer, uint256 refundAmount) public {\n        address payable refundAccount = address(0x444);\n        refundAccount.transfer(refundAmount);\n    }\n\n    function factorial(uint n) public pure returns (uint result) {\n        result = 1;\n        for (uint i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/46.sol:1:131:\n  |\n1 |  ... 256 refundAmount) public {         address payable refundAccount = address(0x444);         refundAccount.transfer(re ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    function payOutInsurance(address insured, uint256 claimAmount) public {\n        address payable insuranceAccount = address(0x555);\n        insuranceAccount.transfer(claimAmount);\n    }\n\n    function calculateModulus(uint a, uint b) public pure returns (uint) {\n        return a % b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/47.sol:1:130:\n  |\n1 |  ... t256 claimAmount) public {         address payable insuranceAccount = address(0x555);         insuranceAccount.transfer ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    function settleBill(address vendor, uint256 billAmount) public {\n        address payable vendorAccount = address(0x666);\n        vendorAccount.transfer(billAmount);\n    }\n\n    function countOddNumbers(uint limit) public pure returns (uint count) {\n        for (uint i = 1; i < limit; i += 2) {\n            count++;\n        }\n        return count;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/48.sol:1:123:\n  |\n1 |  ... nt256 billAmount) public {         address payable vendorAccount = address(0x666);         vendorAccount.transfer(bi ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    function payRoyalties(address author, uint256 royalties) public {\n        address payable royaltyAccount = address(0x777);\n        royaltyAccount.transfer(royalties);\n    }\n\n    function fibonacci(uint n) public pure returns (uint) {\n        if (n == 0) return 0;\n        else if (n == 1) return 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/49.sol:1:124:\n  |\n1 |  ... int256 royalties) public {         address payable royaltyAccount = address(0x777);         royaltyAccount.transfer(r ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    function distributeInterest(address accountHolder, uint256 interest) public {\n        address payable bankAccount = address(0x888);\n        bankAccount.transfer(interest);\n    }\n\n    function sumOfArray(uint[] memory array) public pure returns (uint sum) {\n        for (uint i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/50.sol:1:136:\n  |\n1 |  ... uint256 interest) public {         address payable bankAccount = address(0x888);         bankAccount.transfer(inte ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    function redeemPoints(address member, uint256 points) public {\n        address payable membershipAccount = address(0x999);\n        membershipAccount.transfer(points);\n    }\n\n    function generatePrimes(uint limit) public pure returns (uint[] memory primes) {\n        bool[] memory isPrime = new bool[](limit + 1);\n        for (uint i = 2; i <= limit; i++) isPrime[i] = true;\n        for (uint p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (uint j = p * p; j <= limit; j += p) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        uint count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) count++;\n        }\n        primes = new uint[](count);\n        count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) {\n                primes[count++] = i;\n            }\n        }\n        return primes;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/51.sol:1:121:\n  |\n1 |  ... , uint256 points) public {         address payable membershipAccount = address(0x999);         membershipAccount.transfe ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    function issuePayments(address employee, uint256 salary) public {\n        address payable payrollAccount = payable(employee);\n        payrollAccount.transfer(salary);\n    }\n\n    function sumOfSquares(uint[] memory nums) public pure returns (uint total) {\n        total = 0;\n        for (uint i = 0; i < nums.length; i++) {\n            total += nums[i] * nums[i];\n        }\n        return total;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    function payDividends(address investor, uint256 dividends) public {\n        address payable investmentAccount = payable(investor);\n        investmentAccount.transfer(dividends);\n    }\n\n    function sumOfEvens(uint limit) public pure returns (uint sum) {\n        sum = 0;\n        for (uint i = 0; i <= limit; i += 2) {\n            sum += i;\n        }\n        return sum;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    function clearDebt(address debtor, uint256 amount) public {\n        address payable debtAccount = payable(debtor);\n        debtAccount.transfer(amount);\n    }\n\n    function powerOfTwo(uint n) public pure returns (uint) {\n        return 2**n;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    function grantScholarship(address student, uint256 scholarship) public {\n        address payable schoolAccount = payable(student);\n        schoolAccount.transfer(scholarship);\n    }\n\n    function isPrime(uint num) public pure returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    function refundCustomer(address customer, uint256 refundAmount) public {\n        address payable refundAccount = payable(customer);\n        refundAccount.transfer(refundAmount);\n    }\n\n    function factorial(uint n) public pure returns (uint result) {\n        result = 1;\n        for (uint i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    function payOutInsurance(address insured, uint256 claimAmount) public {\n        address payable insuranceAccount = payable(insured);\n        insuranceAccount.transfer(claimAmount);\n    }\n\n    function calculateModulus(uint a, uint b) public pure returns (uint) {\n        return a % b;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    function settleBill(address vendor, uint256 billAmount) public {\n        address payable vendorAccount = payable(vendor);\n        vendorAccount.transfer(billAmount);\n    }\n\n    function countOddNumbers(uint limit) public pure returns (uint count) {\n        for (uint i = 1; i < limit; i += 2) {\n            count++;\n        }\n        return count;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    function payRoyalties(address author, uint256 royalties) public {\n        address payable royaltyAccount = payable(author);\n        royaltyAccount.transfer(royalties);\n    }\n\n    function fibonacci(uint n) public pure returns (uint) {\n        if (n == 0) return 0;\n        else if (n == 1) return 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    function distributeInterest(address accountHolder, uint256 interest) public {\n        address payable bankAccount = payable(accountHolder);\n        bankAccount.transfer(interest);\n    }\n\n    function sumOfArray(uint[] memory array) public pure returns (uint sum) {\n        for (uint i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    function redeemPoints(address member, uint256 points) public {\n        address payable membershipAccount = payable(member);\n        membershipAccount.transfer(points);\n    }\n\n    function generatePrimes(uint limit) public pure returns (uint[] memory primes) {\n        bool[] memory isPrime = new bool[](limit + 1);\n        for (uint i = 2; i <= limit; i++) isPrime[i] = true;\n        for (uint p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (uint j = p * p; j <= limit; j += p) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        uint count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) count++;\n        }\n        primes = new uint[](count);\n        count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) {\n                primes[count++] = i;\n            }\n        }\n        return primes;\n    }\n}"
      }
    }
  },
  {
    "Changes141": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/types.html#address-literals\"><span class=\"std std-ref\">Address literals</a> have the type <code>address</code> instead of <code>address\npayable</code>. They can be converted to <code>address payable</code> by using an explicit conversion, e.g.\n<code>payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract11 {\n    address payable public account11;\n    constructor() {\n        account11 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/52.sol:1:124:\n  |\n1 |  ... onstructor() {         account11 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract12 {\n    address payable public account12;\n    constructor() {\n        account12 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/53.sol:1:124:\n  |\n1 |  ... onstructor() {         account12 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract13 {\n    address payable public account13;\n    constructor() {\n        account13 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/54.sol:1:124:\n  |\n1 |  ... onstructor() {         account13 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract14 {\n    address payable public account14;\n    constructor() {\n        account14 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/55.sol:1:124:\n  |\n1 |  ... onstructor() {         account14 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract15 {\n    address payable public account15;\n    constructor() {\n        account15 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/56.sol:1:124:\n  |\n1 |  ... onstructor() {         account15 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract16 {\n    address payable public account16;\n    constructor() {\n        account16 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random6() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/57.sol:1:124:\n  |\n1 |  ... onstructor() {         account16 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random6() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract17 {\n    address payable public account17;\n    constructor() {\n        account17 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random7() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/58.sol:1:124:\n  |\n1 |  ... onstructor() {         account17 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random7() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract18 {\n    address payable public account18;\n    constructor() {\n        account18 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random8() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/59.sol:1:124:\n  |\n1 |  ... onstructor() {         account18 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random8() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract19 {\n    address payable public account19;\n    constructor() {\n        account19 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/60.sol:1:124:\n  |\n1 |  ... onstructor() {         account19 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract20 {\n    address payable public account20;\n    constructor() {\n        account20 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/61.sol:1:124:\n  |\n1 |  ... onstructor() {         account20 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Contract11 {\n    address payable public account11;\n    constructor() {\n        account11 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Contract12 {\n    address payable public account12;\n    constructor() {\n        account12 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Contract13 {\n    address payable public account13;\n    constructor() {\n        account13 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Contract14 {\n    address payable public account14;\n    constructor() {\n        account14 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Contract15 {\n    address payable public account15;\n    constructor() {\n        account15 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Contract16 {\n    address payable public account16;\n    constructor() {\n        account16 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random6() public {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Contract17 {\n    address payable public account17;\n    constructor() {\n        account17 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random7() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Contract18 {\n    address payable public account18;\n    constructor() {\n        account18 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random8() public {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Contract19 {\n    address payable public account19;\n    constructor() {\n        account19 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Contract20 {\n    address payable public account20;\n    constructor() {\n        account20 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}"
      }
    }
  },
  {
    "Changes142": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>address(uint)</code> and <code>uint(address)</code>: converting both type-category and width. Replace this by\n<code>address(uint160(uint))</code> and <code>uint(uint160(address))</code> respectively.Add intermediate explicit type conversions if required.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Reevaluate {\n    function reevaluateUintToAddress(uint ab) public pure returns (address) {\n        return address(ab);\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a function\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/62.sol:1:139:\n  |\n1 |  ... returns (address) {         return address(ab);     }     function randomFunction ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Reinterpret {\n    function reinterpretAddressToUint(address ac) public pure returns (uint) {\n        return uint(ac);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/63.sol:1:141:\n  |\n1 |  ... re returns (uint) {         return uint(ac);     } }\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Reorganize {\n    function reorganizeUintToAddress(uint ad) public pure returns (address) {\n        return address(ad);\n    }\n    function secondaryAction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/64.sol:1:139:\n  |\n1 |  ... returns (address) {         return address(ad);     }     function secondaryActio ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Reposition {\n    function repositionAddressToUint(address ae) public pure returns (uint) {\n        return uint(ae);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/65.sol:1:139:\n  |\n1 |  ... re returns (uint) {         return uint(ae);     } }\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Reconstruct {\n    function reconstructUintToAddress(uint af) public pure returns (address) {\n        return address(af);\n    }\n    function unusedMethod() public pure returns (int) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/66.sol:1:141:\n  |\n1 |  ... returns (address) {         return address(af);     }     function unusedMethod() ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Reintegrate {\n    function reintegrateAddressToUint(address ag) public pure returns (uint) {\n        return uint(ag);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/67.sol:1:141:\n  |\n1 |  ... re returns (uint) {         return uint(ag);     } }\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Redistribute {\n    function redistributeUintToAddress(uint ah) public pure returns (address) {\n        return address(ah);\n    }\n    function extraHelper() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/68.sol:1:143:\n  |\n1 |  ... returns (address) {         return address(ah);     }     function extraHelper()  ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Remodel {\n    function remodelAddressToUint(address ai) public pure returns (uint) {\n        return uint(ai);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/69.sol:1:133:\n  |\n1 | pragma solidity^0.8.0; contract Remodel {     function remodelAddressToUint(address ai) public pure returns (uint) {         return uint(ai);     } }\n  |                                                                                                                                     ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Revamp {\n    function revampUintToAddress(uint aj) public pure returns (address) {\n        return address(aj);\n    }\n    function optionalFunction() public pure returns (uint) {\n        return 256;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/70.sol:1:131:\n  |\n1 |  ... returns (address) {         return address(aj);     }     function optionalFuncti ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Retrofit {\n    function retrofitAddressToUint(address ak) public pure returns (uint) {\n        return uint(ak);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/71.sol:1:135:\n  |\n1 |  ... re returns (uint) {         return uint(ak);     } }\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Reevaluate {\n    function reevaluateUintToAddress(uint ab) public pure returns (address) {\n        return address(uint160(ab));\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a function\";\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Reinterpret {\n    function reinterpretAddressToUint(address ac) public pure returns (uint) {\n        return uint(uint160(ac));\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Reorganize {\n    function reorganizeUintToAddress(uint ad) public pure returns (address) {\n        return address(uint160(ad));\n    }\n    function secondaryAction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Reposition {\n    function repositionAddressToUint(address ae) public pure returns (uint) {\n        return uint(uint160(ae));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Reconstruct {\n    function reconstructUintToAddress(uint af) public pure returns (address) {\n        return address(uint160(af));\n    }\n    function unusedMethod() public pure returns (int) {\n        return 999;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Reintegrate {\n    function reintegrateAddressToUint(address ag) public pure returns (uint) {\n        return uint(uint160(ag));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Redistribute {\n    function redistributeUintToAddress(uint ah) public pure returns (address) {\n        return address(uint160(ah));\n    }\n    function extraHelper() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Remodel {\n    function remodelAddressToUint(address ai) public pure returns (uint) {\n        return uint(uint160(ai));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Revamp {\n    function revampUintToAddress(uint aj) public pure returns (address) {\n        return address(uint160(aj));\n    }\n    function optionalFunction() public pure returns (uint) {\n        return 256;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Retrofit {\n    function retrofitAddressToUint(address ak) public pure returns (uint) {\n        return uint(uint160(ak));\n    }\n}"
      }
    }
  },
  {
    "Changes143": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>payable(uint160)</code>, <code>payable(bytes20)</code> and <code>payable(integer-literal)</code>: converting both\ntype-category and state-mutability. Replace this by <code>payable(address(uint160))</code>,\n<code>payable(address(bytes20))</code> and <code>payable(address(integer-literal))</code> respectively. Note that\n<code>payable(0)</code> is valid and is an exception to the rule.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ProfitDistributor {\n    function distributeProfit(uint160 profit) public pure returns (address payable) {\n        return payable(profit);\n    }\n    function checkProfit() public pure returns (uint) {\n        return 1000;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/72.sol:1:154:\n  |\n1 |  ... (address payable) {         return payable(profit);     }     function checkProfit()  ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetRegistrar {\n    function registerAsset(uint160 asset) public pure returns (address payable) {\n        return payable(asset);\n    }\n    function isActiveRegistrar() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/73.sol:1:147:\n  |\n1 |  ... (address payable) {         return payable(asset);     }     function isActiveRegist ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract DebtManager {\n    function manageDebt(uint160 debt) public pure returns (address payable) {\n        return payable(debt);\n    }\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra Function\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/74.sol:1:140:\n  |\n1 |  ... (address payable) {         return payable(debt);     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract CashFlowProcessor {\n    function processCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(cashFlow);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/75.sol:1:155:\n  |\n1 |  ... (address payable) {         return payable(cashFlow);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract LiabilityHandler {\n    function handleLiability(uint160 liability) public pure returns (address payable) {\n        return payable(liability);\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/76.sol:1:155:\n  |\n1 |  ... (address payable) {         return payable(liability);     }     function extraData() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IncomeProcessor {\n    function processIncome(uint160 income) public pure returns (address payable) {\n        return payable(income);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/77.sol:1:149:\n  |\n1 |  ... (address payable) {         return payable(income);     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract TaxCollector {\n    function collectTax(uint160 taxAmount) public pure returns (address payable) {\n        return payable(taxAmount);\n    }\n    function getTaxRate() public pure returns (uint) {\n        return 15;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/78.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(taxAmount);     }     function getTaxRate() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract FundingController {\n    function controlFunding(uint160 funding) public pure returns (address payable) {\n        return payable(funding);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/79.sol:1:153:\n  |\n1 |  ... (address payable) {         return payable(funding);     } }\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneyHandler {\n    function handleMoney(uint160 money) public pure returns (address payable) {\n        return payable(money);\n    }\n    function checkBalance() public pure returns (int) {\n        return 1000;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/80.sol:1:143:\n  |\n1 |  ... (address payable) {         return payable(money);     }     function checkBalance() ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantAllocator {\n    function allocateGrant(uint160 grant) public pure returns (address payable) {\n        return payable(grant);\n    }\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/81.sol:1:147:\n  |\n1 |  ... (address payable) {         return payable(grant);     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ProfitDistributor {\n    function distributeProfit(uint160 profit) public pure returns (address payable) {\n        return payable(address(uint160(profit)));\n    }\n    function checkProfit() public pure returns (uint) {\n        return 1000;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract AssetRegistrar {\n    function registerAsset(uint160 asset) public pure returns (address payable) {\n        return payable(address(uint160(asset)));\n    }\n    function isActiveRegistrar() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract DebtManager {\n    function manageDebt(uint160 debt) public pure returns (address payable) {\n        return payable(address(uint160(debt)));\n    }\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra Function\";\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract CashFlowProcessor {\n    function processCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(address(uint160(cashFlow)));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract LiabilityHandler {\n    function handleLiability(uint160 liability) public pure returns (address payable) {\n        return payable(address(uint160(liability)));\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IncomeProcessor {\n    function processIncome(uint160 income) public pure returns (address payable) {\n        return payable(address(uint160(income)));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract TaxCollector {\n    function collectTax(uint160 taxAmount) public pure returns (address payable) {\n        return payable(address(uint160(taxAmount)));\n    }\n    function getTaxRate() public pure returns (uint) {\n        return 15;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract FundingController {\n    function controlFunding(uint160 funding) public pure returns (address payable) {\n        return payable(address(uint160(funding)));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract MoneyHandler {\n    function handleMoney(uint160 money) public pure returns (address payable) {\n        return payable(address(uint160(money)));\n    }\n    function checkBalance() public pure returns (int) {\n        return 1000;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract GrantAllocator {\n    function allocateGrant(uint160 grant) public pure returns (address payable) {\n        return payable(address(uint160(grant)));\n    }\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}"
      }
    }
  },
  {
    "Changes144": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>int80(bytes10)</code> and <code>bytes10(int80)</code>: converting both type-category and sign. Replace this by\n<code>int80(uint80(bytes10))</code> and <code>bytes10(uint80(int80)</code> respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterGamma {\n    function gammaConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function extraGammaFunction() public pure returns (uint256) {\n        return 255;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/82.sol:1:136:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function extraGammaFunc ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract DataReformer {\n    function reformData(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function randomGammaMethod() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/83.sol:1:132:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function randomGammaMet ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract TypeModifier {\n    function modifyType(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/84.sol:1:132:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract RapidConverter {\n    function rapidConversion(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function helperGamma() public pure returns (int) {\n        return 321;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/85.sol:1:139:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function helperGamma()  ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract BytesToIntegerConverter {\n    function bytesToInteger(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/86.sol:1:147:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IntegerToBytesConverter {\n    function integerToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/87.sol:1:147:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract EasyTransform {\n    function easyConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function additionalGammaMethod() public pure returns (string memory) {\n        return \"ExtraString\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/88.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function additionalGamm ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract BasicTypeModifier {\n    function basicConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/89.sol:1:139:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract DataTranscoder {\n    function transcodeData(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function extraGammaAction() public pure returns (uint) {\n        return 888;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/90.sol:1:137:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function extraGammaActi ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract DataTransmuter {\n    function transmuteData(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function dummyGammaValue() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/91.sol:1:137:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function dummyGammaValu ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ConverterGamma {\n    function gammaConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function extraGammaFunction() public pure returns (uint256) {\n        return 255;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract DataReformer {\n    function reformData(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function randomGammaMethod() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract TypeModifier {\n    function modifyType(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract RapidConverter {\n    function rapidConversion(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function helperGamma() public pure returns (int) {\n        return 321;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract BytesToIntegerConverter {\n    function bytesToInteger(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IntegerToBytesConverter {\n    function integerToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract EasyTransform {\n    function easyConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function additionalGammaMethod() public pure returns (string memory) {\n        return \"ExtraString\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract BasicTypeModifier {\n    function basicConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract DataTranscoder {\n    function transcodeData(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function extraGammaAction() public pure returns (uint) {\n        return 888;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract DataTransmuter {\n    function transmuteData(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function dummyGammaValue() public pure returns (bool) {\n        return false;\n    }\n}"
      }
    }
  },
  {
    "Changes145": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>Contract(uint)</code>: converting both type-category and width. Replace this by\n<code>Contract(address(uint160(uint)))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverOne {\n    function modify(uint index) public pure returns (address) {\n        address result = address(index);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/92.sol:1:136:\n  |\n1 |  ... ddress) {         address result = address(index);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverTwo {\n    function shift(uint data) public pure returns (address) {\n        address addr = address(data);\n        return addr;\n    }\n    function helperFunction() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/93.sol:1:132:\n  |\n1 |  ... (address) {         address addr = address(data);         return addr;     }     fu ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverThree {\n    function update(uint num) public pure returns (address) {\n        address addr = address(num);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/94.sol:1:134:\n  |\n1 |  ... (address) {         address addr = address(num);         return addr;     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverFour {\n    function calculate(uint input) public pure returns (address) {\n        address variable = address(input);\n        return variable;\n    }\n    function extraMethod() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/95.sol:1:142:\n  |\n1 |  ... ress) {         address variable = address(input);         return variable;     }    ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverFive {\n    function process(uint value) public pure returns (address) {\n        address addr = address(value);\n        return addr;\n    }\n    function anotherExtra() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/96.sol:1:136:\n  |\n1 |  ... (address) {         address addr = address(value);         return addr;     }     fu ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverSix {\n    function convert(uint data) public pure returns (address) {\n        address resultAddr = address(data);\n        return resultAddr;\n    }\n    function additionalMethod() public pure {}\n    function extraHelper() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/97.sol:1:140:\n  |\n1 |  ... ss) {         address resultAddr = address(data);         return resultAddr;     }  ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverSeven {\n    function transmit(uint amount) public pure returns (address) {\n        address result = address(amount);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/98.sol:1:141:\n  |\n1 |  ... ddress) {         address result = address(amount);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverEight {\n    function deliver(uint quantity) public pure returns (address) {\n        address output = address(quantity);\n        return output;\n    }\n    function unused() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/99.sol:1:142:\n  |\n1 |  ... ddress) {         address output = address(quantity);         return output;     }      ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverNine {\n    function fetch(uint number) public pure returns (address) {\n        address addr = address(number);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/100.sol:1:135:\n  |\n1 |  ... (address) {         address addr = address(number);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverTen {\n    function derive(uint param) public pure returns (address) {\n        address addressVar = address(param);\n        return addressVar;\n    }\n    function methodOne() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/101.sol:1:140:\n  |\n1 |  ... ss) {         address addressVar = address(param);         return addressVar;     }  ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ResolverOne {\n    function modify(uint index) public pure returns (address) {\n        address result = address(uint160(index));\n        return result;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ResolverTwo {\n    function shift(uint data) public pure returns (address) {\n        address addr = address(uint160(data));\n        return addr;\n    }\n    function helperFunction() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ResolverThree {\n    function update(uint num) public pure returns (address) {\n        address addr = address(uint160(num));\n        return addr;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ResolverFour {\n    function calculate(uint input) public pure returns (address) {\n        address variable = address(uint160(input));\n        return variable;\n    }\n    function extraMethod() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ResolverFive {\n    function process(uint value) public pure returns (address) {\n        address addr = address(uint160(value));\n        return addr;\n    }\n    function anotherExtra() public pure {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ResolverSix {\n    function convert(uint data) public pure returns (address) {\n        address resultAddr = address(uint160(data));\n        return resultAddr;\n    }\n    function additionalMethod() public pure {}\n    function extraHelper() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ResolverSeven {\n    function transmit(uint amount) public pure returns (address) {\n        address result = address(uint160(amount));\n        return result;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ResolverEight {\n    function deliver(uint quantity) public pure returns (address) {\n        address output = address(uint160(quantity));\n        return output;\n    }\n    function unused() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ResolverNine {\n    function fetch(uint number) public pure returns (address) {\n        address addr = address(uint160(number));\n        return addr;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ResolverTen {\n    function derive(uint param) public pure returns (address) {\n        address addressVar = address(uint160(param));\n        return addressVar;\n    }\n    function methodOne() public pure {}\n}"
      }
    }
  },
  {
    "Changes146": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Function call options can only be given once, i.e. <code>c.f{gas: 10000}{value: 1}()</code> is invalid and has to be changed to <code>c.f{gas: 10000, value: 1}()</code>.Combine <code>c.f{gas: 10000}{value: 1}()</code> to <code>c.f{gas: 10000, value: 1}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract FundingAllocation {\n    address payable public fundsAllocator;\n    function allocateFunds() public {\n        fundsAllocator.call{gas: 3000}{value: 2 ether}(\"\");\n    }\n    function validateAllocation() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/102.sol:1:142:\n  |\n1 |  ... n allocateFunds() public {         fundsAllocator.call{gas: 3000}{value: 2 ether}(\"\");     }     function validateAl ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract LoanIssuer {\n    address payable public issuer;\n    function issueLoan() public {\n        issuer.call{gas: 4000}{value: 5 ether}(\"\");\n    }\n    function recordIssuance() public {}\n    function loanSummary() public pure returns (string memory) {\n        return \"Loan Issued\";\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/103.sol:1:123:\n  |\n1 |  ... ction issueLoan() public {         issuer.call{gas: 4000}{value: 5 ether}(\"\");     }     function recordIssu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceManagement {\n    address payable public manager;\n    function manageResources() public {\n        manager.call{gas: 2500}{value: 1 ether}(\"\");\n    }\n    function reportStatus() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/104.sol:1:138:\n  |\n1 |  ... manageResources() public {         manager.call{gas: 2500}{value: 1 ether}(\"\");     }     function reportStat ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract InvestmentPortfolio {\n    address payable public portfolioManager;\n    function managePortfolio() public {\n        portfolioManager.call{gas: 5000}{value: 6 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/105.sol:1:148:\n  |\n1 |  ... managePortfolio() public {         portfolioManager.call{gas: 5000}{value: 6 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract DonationPlatform {\n    address payable public charity;\n    function sendDonation() public {\n        charity.call{gas: 3500}{value: 3 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/106.sol:1:133:\n  |\n1 |  ... on sendDonation() public {         charity.call{gas: 3500}{value: 3 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract RiskAssessment {\n    address payable public assessor;\n    function assessRisk() public {\n        assessor.call{gas: 5500}{value: 4 ether}(\"\");\n    }\n    function getRiskLevel() public pure returns (uint) {\n        return 5;\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/107.sol:1:130:\n  |\n1 |  ... tion assessRisk() public {         assessor.call{gas: 5500}{value: 4 ether}(\"\");     }     function getRiskLev ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract WealthDistribution {\n    address payable public distributor;\n    function distributeWealth() public {\n        distributor.call{gas: 6000}{value: 2.5 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/108.sol:1:143:\n  |\n1 |  ... istributeWealth() public {         distributor.call{gas: 6000}{value: 2.5 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract TalentFund {\n    address payable public talent;\n    function fundTalent() public {\n        talent.call{gas: 4500}{value: 1 ether}(\"\");\n    }\n    function monitorFunds() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/109.sol:1:124:\n  |\n1 |  ... tion fundTalent() public {         talent.call{gas: 4500}{value: 1 ether}(\"\");     }     function monitorFun ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    address payable public processor;\n    function processPayment() public {\n        processor.call{gas: 7000}{value: 5 ether}(\"\");\n    }\n    function finalizeProcess() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/110.sol:1:137:\n  |\n1 |  ...  processPayment() public {         processor.call{gas: 7000}{value: 5 ether}(\"\");     }     function finalizePr ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract EmergencyFund {\n    address payable public emergency;\n    function releaseFunds() public {\n        emergency.call{gas: 8000}{value: 7 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/111.sol:1:132:\n  |\n1 |  ... on releaseFunds() public {         emergency.call{gas: 8000}{value: 7 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract FundingAllocation {\n    address payable public fundsAllocator;\n    function allocateFunds() public {\n        fundsAllocator.call{gas: 3000, value: 2 ether}(\"\");\n    }\n    function validateAllocation() public {}\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract LoanIssuer {\n    address payable public issuer;\n    function issueLoan() public {\n        issuer.call{gas: 4000, value: 5 ether}(\"\");\n    }\n    function recordIssuance() public {}\n    function loanSummary() public pure returns (string memory) {\n        return \"Loan Issued\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ResourceManagement {\n    address payable public manager;\n    function manageResources() public {\n        manager.call{gas: 2500, value: 1 ether}(\"\");\n    }\n    function reportStatus() public {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract InvestmentPortfolio {\n    address payable public portfolioManager;\n    function managePortfolio() public {\n        portfolioManager.call{gas: 5000, value: 6 ether}(\"\");\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract DonationPlatform {\n    address payable public charity;\n    function sendDonation() public {\n        charity.call{gas: 3500, value: 3 ether}(\"\");\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract RiskAssessment {\n    address payable public assessor;\n    function assessRisk() public {\n        assessor.call{gas: 5500, value: 4 ether}(\"\");\n    }\n    function getRiskLevel() public pure returns (uint) {\n        return 5;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract WealthDistribution {\n    address payable public distributor;\n    function distributeWealth() public {\n        distributor.call{gas: 6000, value: 2.5 ether}(\"\");\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract TalentFund {\n    address payable public talent;\n    function fundTalent() public {\n        talent.call{gas: 4500, value: 1 ether}(\"\");\n    }\n    function monitorFunds() public {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    address payable public processor;\n    function processPayment() public {\n        processor.call{gas: 7000, value: 5 ether}(\"\");\n    }\n    function finalizeProcess() public {}\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract EmergencyFund {\n    address payable public emergency;\n    function releaseFunds() public {\n        emergency.call{gas: 8000, value: 7 ether}(\"\");\n    }\n}"
      }
    }
  }
]