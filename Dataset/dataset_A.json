[
  {
    "Changes1": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Functions can now only be overridden when they are either marked with the\n<code>virtual</code> keyword or defined in an interface. Functions without\nimplementation outside an interface have to be marked <code>virtual</code>.\nWhen overriding a function or modifier, the new keyword <code>override</code>\nmust be used. When overriding a function or modifier defined in multiple\nparallel bases, all bases must be listed in parentheses after the keyword\nlike so: <code>override(Base1, Base2)</code>.Add virtual to every non-interface function you intend to override.Add <code>virtual</code> to every non-interface function you intend to override. Add <code>virtual</code>to all functions without implementation outside interfaces. For single inheritance, add <code>override</code> to every overriding function. For multiple inheritance, add <code>override(A, B, ..)</code>,where you list all contracts that define the overridden function in the parentheses. When multiple bases define the same function, the inheriting contract must override all conflicting functions.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract A {\n    function foo() public pure returns (string memory) {\n        return \"A\";\n    }\n}\n\ncontract B is A {\n    function foo() public pure returns (string memory) {\n        return \"B\";\n    }\n}",
          "error message": ":1:146: TypeError: Overriding function is missing \"override\" specifier.\n ... A\";     } }  contract B is A {     function foo() public pure returns (string memory) {         return \"B\";     } }\n                                        ^----------------------------------------------------------------------------^\n:1:42: Overridden function is here:\n ...  solidity^0.6.0;  contract A {     function foo() public pure returns (string memory) {         return \"A\";     } }  contract B is A {     function  ...\n                                        ^----------------------------------------------------------------------------^\n:1:42: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ...  solidity^0.6.0;  contract A {     function foo() public pure returns (string memory) {         return \"A\";     } }  contract B is A {     function  ...\n                                        ^----------------------------------------------------------------------------^\n:1:146: Overriding function is here:\n ... A\";     } }  contract B is A {     function foo() public pure returns (string memory) {         return \"B\";     } }\n                                        ^----------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract X {\n    function bar() public pure returns (string memory) {\n        return \"X\";\n    }\n    \n    function baz() public pure returns (string memory) {\n        return \"Baz\";\n    }\n}\n\ncontract Y is X {\n    function bar() public pure returns (string memory) {\n        return \"Y\";\n    }\n}",
          "error message": ":1:236: TypeError: Overriding function is missing \"override\" specifier.\n ... z\";     } }  contract Y is X {     function bar() public pure returns (string memory) {         return \"Y\";     } }\n                                        ^----------------------------------------------------------------------------^\n:1:42: Overridden function is here:\n ...  solidity^0.6.0;  contract X {     function bar() public pure returns (string memory) {         return \"X\";     }          function baz() public pur ...\n                                        ^----------------------------------------------------------------------------^\n:1:42: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ...  solidity^0.6.0;  contract X {     function bar() public pure returns (string memory) {         return \"X\";     }          function baz() public pur ...\n                                        ^----------------------------------------------------------------------------^\n:1:236: Overriding function is here:\n ... z\";     } }  contract Y is X {     function bar() public pure returns (string memory) {         return \"Y\";     } }\n                                        ^----------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Parent {\n    function greetParent() public pure returns (string memory) {\n        return \"Hello Parent\";\n    }\n}\n\ncontract Child is Parent {\n    function greetParent() public pure returns (string memory) {\n        return \"Hello Child\";\n    }\n}",
          "error message": ":1:179: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Child is Parent {     function greetParent() public pure returns (string memory) {         return \"Hello Child\";     } }\n                                        ^----------------------------------------------------------------------------------------------^\n:1:47: Overridden function is here:\n ... dity^0.6.0;  contract Parent {     function greetParent() public pure returns (string memory) {         return \"Hello Parent\";     } }  contract Child is Parent {      ...\n                                        ^-----------------------------------------------------------------------------------------------^\n:1:47: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... dity^0.6.0;  contract Parent {     function greetParent() public pure returns (string memory) {         return \"Hello Parent\";     } }  contract Child is Parent {      ...\n                                        ^-----------------------------------------------------------------------------------------------^\n:1:179: Overriding function is here:\n ...  }  contract Child is Parent {     function greetParent() public pure returns (string memory) {         return \"Hello Child\";     } }\n                                        ^----------------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract M {\n    function sayM() public pure returns (string memory) {\n        return \"M\";\n    }\n    \n    function additionalFunction() public pure returns (uint) {\n        return 42;\n    }\n}\n\ncontract N is M {\n    function sayM() public pure returns (string memory) {\n        return \"N\";\n    }\n}",
          "error message": ":1:240: TypeError: Overriding function is missing \"override\" specifier.\n ... 42;     } }  contract N is M {     function sayM() public pure returns (string memory) {         return \"N\";     } }\n                                        ^-----------------------------------------------------------------------------^\n:1:42: Overridden function is here:\n ...  solidity^0.6.0;  contract M {     function sayM() public pure returns (string memory) {         return \"M\";     }          function additionalFuncti ...\n                                        ^-----------------------------------------------------------------------------^\n:1:42: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ...  solidity^0.6.0;  contract M {     function sayM() public pure returns (string memory) {         return \"M\";     }          function additionalFuncti ...\n                                        ^-----------------------------------------------------------------------------^\n:1:240: Overriding function is here:\n ... 42;     } }  contract N is M {     function sayM() public pure returns (string memory) {         return \"N\";     } }\n                                        ^-----------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Alpha {\n    function alphaFunction() public pure returns (string memory) {\n        return \"Alpha\";\n    }\n}\n\ncontract Beta is Alpha {\n    function alphaFunction() public pure returns (string memory) {\n        return \"Beta\";\n    }\n}",
          "error message": ":1:171: TypeError: Overriding function is missing \"override\" specifier.\n ...  } }  contract Beta is Alpha {     function alphaFunction() public pure returns (string memory) {         return \"Beta\";     } }\n                                        ^-----------------------------------------------------------------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Alpha {     function alphaFunction() public pure returns (string memory) {         return \"Alpha\";     } }  contract Beta is Alpha {     fu ...\n                                        ^------------------------------------------------------------------------------------------^\n:1:46: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... idity^0.6.0;  contract Alpha {     function alphaFunction() public pure returns (string memory) {         return \"Alpha\";     } }  contract Beta is Alpha {     fu ...\n                                        ^------------------------------------------------------------------------------------------^\n:1:171: Overriding function is here:\n ...  } }  contract Beta is Alpha {     function alphaFunction() public pure returns (string memory) {         return \"Beta\";     } }\n                                        ^-----------------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Base {\n    function getValue() public pure returns (uint) {\n        return 100;\n    }\n}\n\ncontract Derived is Base {\n    function getValue() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": ":1:154: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Derived is Base {     function getValue() public pure returns (uint) {         return 200;     } }\n                                        ^------------------------------------------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Base {     function getValue() public pure returns (uint) {         return 100;     } }  contract Derived is Base {      ...\n                                        ^------------------------------------------------------------------------^\n:1:45: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... lidity^0.6.0;  contract Base {     function getValue() public pure returns (uint) {         return 100;     } }  contract Derived is Base {      ...\n                                        ^------------------------------------------------------------------------^\n:1:154: Overriding function is here:\n ...  }  contract Derived is Base {     function getValue() public pure returns (uint) {         return 200;     } }\n                                        ^------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Super {\n    function message() public pure returns (string memory) {\n        return \"Super\";\n    }\n    \n    function anotherMessage() public pure returns (string memory) {\n        return \"Another\";\n    }\n}\n\ncontract Sub is Super {\n    function message() public pure returns (string memory) {\n        return \"Sub\";\n    }\n}",
          "error message": ":1:269: TypeError: Overriding function is missing \"override\" specifier.\n ...   } }  contract Sub is Super {     function message() public pure returns (string memory) {         return \"Sub\";     } }\n                                        ^----------------------------------------------------------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Super {     function message() public pure returns (string memory) {         return \"Super\";     }          function anotherMessage() ...\n                                        ^------------------------------------------------------------------------------------^\n:1:46: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... idity^0.6.0;  contract Super {     function message() public pure returns (string memory) {         return \"Super\";     }          function anotherMessage() ...\n                                        ^------------------------------------------------------------------------------------^\n:1:269: Overriding function is here:\n ...   } }  contract Sub is Super {     function message() public pure returns (string memory) {         return \"Sub\";     } }\n                                        ^----------------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract First {\n    function firstFunc() public pure returns (string memory) {\n        return \"First\";\n    }\n}\n\ncontract Second is First {\n    function firstFunc() public pure returns (string memory) {\n        return \"Second\";\n    }\n}",
          "error message": ":1:169: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Second is First {     function firstFunc() public pure returns (string memory) {         return \"Second\";     } }\n                                        ^---------------------------------------------------------------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract First {     function firstFunc() public pure returns (string memory) {         return \"First\";     } }  contract Second is First {      ...\n                                        ^--------------------------------------------------------------------------------------^\n:1:46: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... idity^0.6.0;  contract First {     function firstFunc() public pure returns (string memory) {         return \"First\";     } }  contract Second is First {      ...\n                                        ^--------------------------------------------------------------------------------------^\n:1:169: Overriding function is here:\n ...  }  contract Second is First {     function firstFunc() public pure returns (string memory) {         return \"Second\";     } }\n                                        ^---------------------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Original {\n    function originalMethod() public pure returns (string memory) {\n        return \"Original\";\n    }\n}\n\ncontract Duplicate is Original {\n    function originalMethod() public pure returns (string memory) {\n        return \"Duplicate\";\n    }\n}",
          "error message": ":1:186: TypeError: Overriding function is missing \"override\" specifier.\n ... ntract Duplicate is Original {     function originalMethod() public pure returns (string memory) {         return \"Duplicate\";     } }\n                                        ^-----------------------------------------------------------------------------------------------^\n:1:49: Overridden function is here:\n ... ty^0.6.0;  contract Original {     function originalMethod() public pure returns (string memory) {         return \"Original\";     } }  contract Duplicate is Original  ...\n                                        ^----------------------------------------------------------------------------------------------^\n:1:49: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... ty^0.6.0;  contract Original {     function originalMethod() public pure returns (string memory) {         return \"Original\";     } }  contract Duplicate is Original  ...\n                                        ^----------------------------------------------------------------------------------------------^\n:1:186: Overriding function is here:\n ... ntract Duplicate is Original {     function originalMethod() public pure returns (string memory) {         return \"Duplicate\";     } }\n                                        ^-----------------------------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract BaseClass {\n    function compute() public pure returns (uint) {\n        return 10;\n    }\n    \n    function extra() public pure returns (uint) {\n        return 20;\n    }\n}\n\ncontract DerivedClass is BaseClass {\n    function compute() public pure returns (uint) {\n        return 30;\n    }\n}",
          "error message": ":1:247: TypeError: Overriding function is missing \"override\" specifier.\n ... ct DerivedClass is BaseClass {     function compute() public pure returns (uint) {         return 30;     } }\n                                        ^----------------------------------------------------------------------^\n:1:50: Overridden function is here:\n ... y^0.6.0;  contract BaseClass {     function compute() public pure returns (uint) {         return 10;     }          function extra() public p ...\n                                        ^----------------------------------------------------------------------^\n:1:50: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... y^0.6.0;  contract BaseClass {     function compute() public pure returns (uint) {         return 10;     }          function extra() public p ...\n                                        ^----------------------------------------------------------------------^\n:1:247: Overriding function is here:\n ... ct DerivedClass is BaseClass {     function compute() public pure returns (uint) {         return 30;     } }\n                                        ^----------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract A {\n    function foo() public virtual pure returns (string memory) {\n        return \"A\";\n    }\n}\n\ncontract B is A {\n    function foo() public override pure returns (string memory) {\n        return \"B\";\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract X {\n    function bar() public virtual pure returns (string memory) {\n        return \"X\";\n    }\n    \n    function baz() public pure returns (string memory) {\n        return \"Baz\";\n    }\n}\n\ncontract Y is X {\n    function bar() public override pure returns (string memory) {\n        return \"Y\";\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Parent {\n    function greetParent() public virtual pure returns (string memory) {\n        return \"Hello Parent\";\n    }\n}\n\ncontract Child is Parent {\n    function greetParent() public override pure returns (string memory) {\n        return \"Hello Child\";\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract M {\n    function sayM() public virtual pure returns (string memory) {\n        return \"M\";\n    }\n    \n    function additionalFunction() public pure returns (uint) {\n        return 42;\n    }\n}\n\ncontract N is M {\n    function sayM() public override pure returns (string memory) {\n        return \"N\";\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Alpha {\n    function alphaFunction() public virtual pure returns (string memory) {\n        return \"Alpha\";\n    }\n}\n\ncontract Beta is Alpha {\n    function alphaFunction() public override pure returns (string memory) {\n        return \"Beta\";\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Base {\n    function getValue() public virtual pure returns (uint) {\n        return 100;\n    }\n}\n\ncontract Derived is Base {\n    function getValue() public override pure returns (uint) {\n        return 200;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Super {\n    function message() public virtual pure returns (string memory) {\n        return \"Super\";\n    }\n    \n    function anotherMessage() public pure returns (string memory) {\n        return \"Another\";\n    }\n}\n\ncontract Sub is Super {\n    function message() public override pure returns (string memory) {\n        return \"Sub\";\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract First {\n    function firstFunc() public virtual pure returns (string memory) {\n        return \"First\";\n    }\n}\n\ncontract Second is First {\n    function firstFunc() public override pure returns (string memory) {\n        return \"Second\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Original {\n    function originalMethod() public virtual pure returns (string memory) {\n        return \"Original\";\n    }\n}\n\ncontract Duplicate is Original {\n    function originalMethod() public override pure returns (string memory) {\n        return \"Duplicate\";\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract BaseClass {\n    function compute() public virtual pure returns (uint) {\n        return 10;\n    }\n    \n    function extra() public pure returns (uint) {\n        return 20;\n    }\n}\n\ncontract DerivedClass is BaseClass {\n    function compute() public override pure returns (uint) {\n        return 30;\n    }\n}"
      }
    }
  },
  {
    "Changes2": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Member-access to <code>length</code> of arrays is now always read-only, even for storage arrays. It is no\nlonger possible to resize storage arrays by assigning a new value to their length. Use <code>push()</code>,\n<code>push(value)</code> or <code>pop()</code> instead, or assign a full array, which will of course overwrite the existing content.\nThe reason behind this is to prevent storage collisions of gigantic\nstorage arrays.Change <code>uint length = array.push(value)</code> to <code>array.push(value);</code>. The new length can be accessed via <code>array.length</code>. ",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract TestContract1 {\n    uint[] public data;\n\n    function append(uint value) public {\n        data.push(value);\n    }\n\n    function adjustSize(uint newSize) public {\n        data.length = newSize;\n    }\n\n    function count() public view returns (uint) {\n        return data.length;\n    }\n}",
          "error message": ":1:204: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ize(uint newSize) public {         data.length = newSize;     }      function cou ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleContract2 {\n    uint[] public elements;\n\n    function insert(uint element) public {\n        elements.push(element);\n    }\n\n    function setArrayLength(uint newLength) public {\n        elements.length = newLength;\n    }\n\n    function getElementCount() public view returns (uint) {\n        return elements.length;\n    }\n\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a random function\";\n    }\n}",
          "error message": ":1:225: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         elements.length = newLength;     }      function g ...\n                                        ^-------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract SampleContract3 {\n    uint[] public numbersArray;\n\n    function addNumber(uint num) public {\n        numbersArray.push(num);\n    }\n\n    function resizeNumbers(uint newSize) public {\n        numbersArray.length = newSize;\n    }\n\n    function lengthOfNumbers() public view returns (uint) {\n        return numbersArray.length;\n    }\n}",
          "error message": ":1:224: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ers(uint newSize) public {         numbersArray.length = newSize;     }      function len ...\n                                        ^-----------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint[] public list;\n\n    function add(uint item) public {\n        list.push(item);\n    }\n\n    function modifyLength(uint length) public {\n        list.length = length;\n    }\n}",
          "error message": ":1:203: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         list.length = length;     } }\n                                        ^---------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractSample5 {\n    uint[] public queue;\n\n    function enqueue(uint item) public {\n        queue.push(item);\n    }\n\n    function setQueueSize(uint size) public {\n        queue.length = size;\n    }\n\n    function sizeOfQueue() public view returns (uint) {\n        return queue.length;\n    }\n}",
          "error message": ":1:206: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ueSize(uint size) public {         queue.length = size;     }      function sizeOf ...\n                                        ^----------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractTest6 {\n    uint[] public storageArray;\n\n    function addToStorage(uint value) public {\n        storageArray.push(value);\n    }\n\n    function changeLength(uint newLength) public {\n        storageArray.length = newLength;\n    }\n}",
          "error message": ":1:230: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         storageArray.length = newLength;     } }\n                                        ^-----------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ArrayHandling7 {\n    uint[] public dataList;\n\n    function pushData(uint data) public {\n        dataList.push(data);\n    }\n\n    function alterLength(uint length) public {\n        dataList.length = length;\n    }\n\n    function retrieveLength() public view returns (uint) {\n        return dataList.length;\n    }\n\n    function dummyFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:213: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         dataList.length = length;     }      function retr ...\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ResizeArray8 {\n    uint[] public bigArray;\n\n    function addEntry(uint entry) public {\n        bigArray.push(entry);\n    }\n\n    function updateArraySize(uint size) public {\n        bigArray.length = size;\n    }\n\n    function getArraySize() public view returns (uint) {\n        return bigArray.length;\n    }\n}",
          "error message": ":1:215: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... aySize(uint size) public {         bigArray.length = size;     }      function getArr ...\n                                        ^-------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract CustomContract9 {\n    uint[] public entries;\n\n    function addValue(uint val) public {\n        entries.push(val);\n    }\n\n    function adjustArrayLength(uint newLength) public {\n        entries.length = newLength;\n    }\n\n    function lengthOfEntries() public view returns (uint) {\n        return entries.length;\n    }\n\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:219: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         entries.length = newLength;     }      function l ...\n                                        ^------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract RandomContract10 {\n    uint[] public collection;\n\n    function pushValue(uint value) public {\n        collection.push(value);\n    }\n\n    function setCollectionLength(uint length) public {\n        collection.length = length;\n    }\n}",
          "error message": ":1:230: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         collection.length = length;     } }\n                                        ^---------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract TestContract1 {\n    uint[] public data;\n\n    function append(uint value) public {\n        data.push(value);\n    }\n\n    function adjustSize(uint newSize) public {\n        if (newSize > data.length) {\n            while (data.length < newSize) {\n                data.push(0);\n            }\n        } else {\n            while (data.length > newSize) {\n                data.pop();\n            }\n        }\n    }\n\n    function count() public view returns (uint) {\n        return data.length;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ExampleContract2 {\n    uint[] public elements;\n\n    function insert(uint element) public {\n        elements.push(element);\n    }\n\n    function setArrayLength(uint newLength) public {\n        if (newLength > elements.length) {\n            while (elements.length < newLength) {\n                elements.push(0);\n            }\n        } else {\n            while (elements.length > newLength) {\n                elements.pop();\n            }\n        }\n    }\n\n    function getElementCount() public view returns (uint) {\n        return elements.length;\n    }\n\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a random function\";\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract SampleContract3 {\n    uint[] public numbersArray;\n\n    function addNumber(uint num) public {\n        numbersArray.push(num);\n    }\n\n    function resizeNumbers(uint newSize) public {\n        if (newSize > numbersArray.length) {\n            while (numbersArray.length < newSize) {\n                numbersArray.push(0);\n            }\n        } else {\n            while (numbersArray.length > newSize) {\n                numbersArray.pop();\n            }\n        }\n    }\n\n    function lengthOfNumbers() public view returns (uint) {\n        return numbersArray.length;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint[] public list;\n\n    function add(uint item) public {\n        list.push(item);\n    }\n\n    function modifyLength(uint length) public {\n        if (length > list.length) {\n            while (list.length < length) {\n                list.push(0);\n            }\n        } else {\n            while (list.length > length) {\n                list.pop();\n            }\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ContractSample5 {\n    uint[] public queue;\n\n    function enqueue(uint item) public {\n        queue.push(item);\n    }\n\n    function setQueueSize(uint size) public {\n        if (size > queue.length) {\n            while (queue.length < size) {\n                queue.push(0);\n            }\n        } else {\n            while (queue.length > size) {\n                queue.pop();\n            }\n        }\n    }\n\n    function sizeOfQueue() public view returns (uint) {\n        return queue.length;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ContractTest6 {\n    uint[] public storageArray;\n\n    function addToStorage(uint value) public {\n        storageArray.push(value);\n    }\n\n    function changeLength(uint newLength) public {\n        if (newLength > storageArray.length) {\n            while (storageArray.length < newLength) {\n                storageArray.push(0);\n            }\n        } else {\n            while (storageArray.length > newLength) {\n                storageArray.pop();\n            }\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ArrayHandling7 {\n    uint[] public dataList;\n\n    function pushData(uint data) public {\n        dataList.push(data);\n    }\n\n    function alterLength(uint length) public {\n        if (length > dataList.length) {\n            while (dataList.length < length) {\n                dataList.push(0);\n            }\n        } else {\n            while (dataList.length > length) {\n                dataList.pop();\n            }\n        }\n    }\n\n    function retrieveLength() public view returns (uint) {\n        return dataList.length;\n    }\n\n    function dummyFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ResizeArray8 {\n    uint[] public bigArray;\n\n    function addEntry(uint entry) public {\n        bigArray.push(entry);\n    }\n\n    function updateArraySize(uint size) public {\n        if (size > bigArray.length) {\n            while (bigArray.length < size) {\n                bigArray.push(0);\n            }\n        } else {\n            while (bigArray.length > size) {\n                bigArray.pop();\n            }\n        }\n    }\n\n    function getArraySize() public view returns (uint) {\n        return bigArray.length;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract CustomContract9 {\n    uint[] public entries;\n\n    function addValue(uint val) public {\n        entries.push(val);\n    }\n\n    function adjustArrayLength(uint newLength) public {\n        if (newLength > entries.length) {\n            while (entries.length < newLength) {\n                entries.push(0);\n            }\n        } else {\n            while (entries.length > newLength) {\n                entries.pop();\n            }\n        }\n    }\n\n    function lengthOfEntries() public view returns (uint) {\n        return entries.length;\n    }\n\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract RandomContract10 {\n    uint[] public collection;\n\n    function pushValue(uint value) public {\n        collection.push(value);\n    }\n\n    function setCollectionLength(uint length) public {\n        if (length > collection.length) {\n            while (collection.length < length) {\n                collection.push(0);\n            }\n        } else {\n            while (collection.length > length) {\n                collection.pop();\n            }\n        }\n    }\n}"
      }
    }
  },
  {
    "Changes3": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The new keyword <code>abstract</code> can be used to mark contracts as abstract. It has to be used\nif a contract does not implement all its functions. Abstract contracts cannot be created using the <code>new</code> operator,\nand it is not possible to generate bytecode for them during compilation.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    function unimplementedFunction() public;\n    function implementedFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example1\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example1 {     function un ... (uint) {         return 42;     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example1 {     function unimplementedFunction() public;     function implementedFunction() ...\n                                        ^--------------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example1 {     function unimplementedFunction() public;     function implementedFunction() ...\n                                        ^--------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    function missingImplementation() public;\n    function additionalFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example2\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example2 {     function mi ... ool) {         return true;     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example2 {     function missingImplementation() public;     function additionalFunction1() ...\n                                        ^--------------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example2 {     function missingImplementation() public;     function additionalFunction1() ...\n                                        ^--------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    function undefinedBehavior() public;\n    function usefulFunction() public pure returns (string memory) {\n        return \"Completed\";\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example3\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example3 {     function un ...         return \"Completed\";     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example3 {     function undefinedBehavior() public;     function usefulFunction() publ ...\n                                        ^----------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example3 {     function undefinedBehavior() public;     function usefulFunction() publ ...\n                                        ^----------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    function unhandledCase() public;\n    function anotherFunction() public pure returns (address) {\n        return address(0);\n    }\n    function extraFunction() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example4\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example4 {     function un ...  (int) {         return -1;     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example4 {     function unhandledCase() public;     function anotherFunction() pub ...\n                                        ^------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example4 {     function unhandledCase() public;     function anotherFunction() pub ...\n                                        ^------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    function notImplementedYet() public;\n    function finishedFunction() public pure returns (bytes32) {\n        return keccak256(\"Hello\");\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example5\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example5 {     function no ...  return keccak256(\"Hello\");     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example5 {     function notImplementedYet() public;     function finishedFunction() pu ...\n                                        ^----------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example5 {     function notImplementedYet() public;     function finishedFunction() pu ...\n                                        ^----------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    function noCodeHere() public;\n    function compute() public pure returns (uint256) {\n        return 100;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example6\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example6 {     function noCodeHere() public;     function compute() public pure returns (uint256) {         return 100;     } }\n                        ^--------------------------------------------------------------------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example6 {     function noCodeHere() public;     function compute() public pure ...\n                                        ^---------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example6 {     function noCodeHere() public;     function compute() public pure ...\n                                        ^---------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    function actionNeeded() public;\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n    function extraHelper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example7\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example7 {     function ac ... ol) {         return false;     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example7 {     function actionNeeded() public;     function helperFunction() publ ...\n                                        ^-----------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example7 {     function actionNeeded() public;     function helperFunction() publ ...\n                                        ^-----------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    function needsImplementation() public;\n    function getData() public pure returns (bytes memory) {\n        return \"data\";\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example8\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example8 {     function ne ... y) {         return \"data\";     } }\n                        ^-------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example8 {     function needsImplementation() public;     function getData() public pure ...\n                                        ^------------------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example8 {     function needsImplementation() public;     function getData() public pure ...\n                                        ^------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    function toBeDone() public;\n    function anotherTask() public pure returns (uint8) {\n        return 255;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example9\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example9 {     function toBeDone() public;     function anotherTask() public pure returns (uint8) {         return 255;     } }\n                        ^--------------------------------------------------------------------------------------------------------------------------------------^\n:1:49: Missing implementation:\n ... ty^0.6.0;  contract Example9 {     function toBeDone() public;     function anotherTask() public  ...\n                                        ^-------------------------^\n:1:49: TypeError: Functions without implementation must be marked virtual.\n ... ty^0.6.0;  contract Example9 {     function toBeDone() public;     function anotherTask() public  ...\n                                        ^-------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    function pendingWork() public;\n    function process() public pure returns (uint16) {\n        return 1024;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example10\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example10 {     function pendingWork() public;     function process() public pure returns (uint16) {         return 1024;     } }\n                        ^----------------------------------------------------------------------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example10 {     function pendingWork() public;     function process() public pure ...\n                                        ^----------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example10 {     function pendingWork() public;     function process() public pure ...\n                                        ^----------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\nabstract contract Example1 {\n    function unimplementedFunction() public virtual;\n    function implementedFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\nabstract contract Example2 {\n    function missingImplementation() public virtual;\n    function additionalFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\nabstract contract Example3 {\n    function undefinedBehavior() public virtual;\n    function usefulFunction() public pure returns (string memory) {\n        return \"Completed\";\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\nabstract contract Example4 {\n    function unhandledCase() public virtual;\n    function anotherFunction() public pure returns (address) {\n        return address(0);\n    }\n    function extraFunction() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\nabstract contract Example5 {\n    function notImplementedYet() public virtual;\n    function finishedFunction() public pure returns (bytes32) {\n        return keccak256(\"Hello\");\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\nabstract contract Example6 {\n    function noCodeHere() public virtual;\n    function compute() public pure returns (uint256) {\n        return 100;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\nabstract contract Example7 {\n    function actionNeeded() public virtual;\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n    function extraHelper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\nabstract contract Example8 {\n    function needsImplementation() public virtual;\n    function getData() public pure returns (bytes memory) {\n        return \"data\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\nabstract contract Example9 {\n    function toBeDone() public virtual;\n    function anotherTask() public pure returns (uint8) {\n        return 255;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\nabstract contract Example10 {\n    function pendingWork() public virtual;\n    function process() public pure returns (uint16) {\n        return 1024;\n    }\n}"
      }
    }
  },
  {
    "Changes4": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Libraries have to implement all their functions, not only the internal ones.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary StringLibrary {\n    function internalConcat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n\n    function publicLength(string memory a) public pure returns (uint);\n}\n\ncontract TextProcessor {\n    using StringLibrary for string;\n\n    function combineStrings(string memory a, string memory b) public pure returns (string memory) {\n        return StringLibrary.internalConcat(a, b);\n    }\n}",
          "error message": ":1:209: TypeError: Library functions must be implemented if declared.\n ... bi.encodePacked(a, b));     }      function publicLength(string memory a) public pure returns (uint); }  contract TextProcessor {     us ...\n                                        ^----------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary MathOperations {\n    function internalSubtract(uint x, uint y) internal pure returns (uint) {\n        return x - y;\n    }\n\n    function publicDivide(uint x, uint y) public pure returns (uint);\n}\n\ncontract Arithmetic {\n    using MathOperations for uint;\n\n    function subtractNumbers(uint x, uint y) public pure returns (uint) {\n        return MathOperations.internalSubtract(x, y);\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:160: TypeError: Library functions must be implemented if declared.\n ... {         return x - y;     }      function publicDivide(uint x, uint y) public pure returns (uint); }  contract Arithmetic {     using ...\n                                        ^---------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary ArrayUtils {\n    function internalMax(uint[] memory array) internal pure returns (uint) {\n        uint max = array[0];\n        for (uint i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n\n    function publicMin(uint[] memory array) public pure returns (uint);\n}\n\ncontract ArrayProcessor {\n    using ArrayUtils for uint[];\n\n    function findMax(uint[] memory array) public pure returns (uint) {\n        return ArrayUtils.internalMax(array);\n    }\n\n    function dummyProcess() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": ":1:323: TypeError: Library functions must be implemented if declared.\n ...   }         return max;     }      function publicMin(uint[] memory array) public pure returns (uint); }  contract ArrayProcessor {     u ...\n                                        ^-----------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary TokenUtils {\n    function internalTransfer(address from, address to, uint amount) internal pure returns (bool) {\n        return true;\n    }\n\n    function publicBalance(address account) public view returns (uint);\n}\n\ncontract TokenManager {\n    using TokenUtils for address;\n\n    function transferTokens(address from, address to, uint amount) public pure returns (bool) {\n        return TokenUtils.internalTransfer(from, to, amount);\n    }\n}",
          "error message": ":1:178: TypeError: Library functions must be implemented if declared.\n ...  {         return true;     }      function publicBalance(address account) public view returns (uint); }  contract TokenManager {     usi ...\n                                        ^-----------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary HashingLib {\n    function internalHash(string memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(data));\n    }\n\n    function publicVerify(bytes32 hash, string memory data) public pure returns (bool);\n}\n\ncontract HashingContract {\n    using HashingLib for string;\n\n    function getHash(string memory data) public pure returns (bytes32) {\n        return HashingLib.internalHash(data);\n    }\n}",
          "error message": ":1:187: TypeError: Library functions must be implemented if declared.\n ... bi.encodePacked(data));     }      function publicVerify(bytes32 hash, string memory data) public pure returns (bool); }  contract HashingContract {      ...\n                                        ^---------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary FinancialLib {\n    function internalCalculateInterest(uint principal, uint rate) internal pure returns (uint) {\n        return (principal * rate) / 100;\n    }\n\n    function publicGetPrincipal() public pure returns (uint);\n}\n\ncontract FinancialContract {\n    using FinancialLib for uint;\n\n    function calculate(uint principal, uint rate) public pure returns (uint) {\n        return FinancialLib.internalCalculateInterest(principal, rate);\n    }\n}",
          "error message": ":1:197: TypeError: Library functions must be implemented if declared.\n ... rincipal * rate) / 100;     }      function publicGetPrincipal() public pure returns (uint); }  contract FinancialContract {    ...\n                                        ^-------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary CryptoLib {\n    function internalEncrypt(uint data) internal pure returns (uint) {\n        return data + 1;\n    }\n\n    function publicDecrypt(uint encryptedData) public pure returns (uint);\n}\n\ncontract CryptoContract {\n    using CryptoLib for uint;\n\n    function encryptData(uint data) public pure returns (uint) {\n        return CryptoLib.internalEncrypt(data);\n    }\n\n    function dummyFunction2() public pure returns (string memory) {\n        return \"dummy\";\n    }\n}",
          "error message": ":1:152: TypeError: Library functions must be implemented if declared.\n ...        return data + 1;     }      function publicDecrypt(uint encryptedData) public pure returns (uint); }  contract CryptoContract {     u ...\n                                        ^--------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary VotingLib {\n    function internalVote(uint proposalId) internal pure returns (bool) {\n        return true;\n    }\n\n    function publicResult(uint proposalId) public view returns (uint);\n}\n\ncontract VotingContract {\n    using VotingLib for uint;\n\n    function voteOnProposal(uint proposalId) public pure returns (bool) {\n        return VotingLib.internalVote(proposalId);\n    }\n\n    function getProposal() public view returns (string memory) {\n        return \"Proposal details\";\n    }\n}",
          "error message": ":1:151: TypeError: Library functions must be implemented if declared.\n ...  {         return true;     }      function publicResult(uint proposalId) public view returns (uint); }  contract VotingContract {     u ...\n                                        ^----------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary MappingLib {\n    function internalGetKey(bytes32 key) internal pure returns (uint) {\n        return uint(key);\n    }\n\n    function publicSetKey(bytes32 key, uint value) public pure returns (bool);\n}\n\ncontract MappingContract {\n    using MappingLib for bytes32;\n\n    function getKey(bytes32 key) public pure returns (uint) {\n        return MappingLib.internalGetKey(key);\n    }\n\n    function dummyFunction3() public pure returns (address) {\n        return address(0);\n    }\n}",
          "error message": ":1:155: TypeError: Library functions must be implemented if declared.\n ...       return uint(key);     }      function publicSetKey(bytes32 key, uint value) public pure returns (bool); }  contract MappingContract {      ...\n                                        ^------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary QueueLib {\n    function internalEnqueue(uint item) internal pure returns (uint) {\n        return item;\n    }\n\n    function publicDequeue() public pure returns (uint);\n}\n\ncontract QueueContract {\n    using QueueLib for uint;\n\n    function enqueueItem(uint item) public pure returns (uint) {\n        return QueueLib.internalEnqueue(item);\n    }\n}",
          "error message": ":1:147: TypeError: Library functions must be implemented if declared.\n ...  {         return item;     }      function publicDequeue() public pure returns (uint); }  contract QueueContract {     us ...\n                                        ^--------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\nlibrary StringLibrary {\n    function internalConcat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n\n    function publicLength(string memory a) public pure returns (uint) {\n        return bytes(a).length;\n    }\n}\n\ncontract TextProcessor {\n    using StringLibrary for string;\n\n    function combineStrings(string memory a, string memory b) public pure returns (string memory) {\n        return StringLibrary.internalConcat(a, b);\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\nlibrary MathOperations {\n    function internalSubtract(uint x, uint y) internal pure returns (uint) {\n        return x - y;\n    }\n\n    function publicDivide(uint x, uint y) public pure returns (uint) {\n        require(y != 0, \"Cannot divide by zero\");\n        return x / y;\n    }\n}\n\ncontract Arithmetic {\n    using MathOperations for uint;\n\n    function subtractNumbers(uint x, uint y) public pure returns (uint) {\n        return MathOperations.internalSubtract(x, y);\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\nlibrary ArrayUtils {\n    function internalMax(uint[] memory array) internal pure returns (uint) {\n        uint max = array[0];\n        for (uint i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n        return max;\n    }\n\n    function publicMin(uint[] memory array) public pure returns (uint) {\n        uint min = array[0];\n        for (uint i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n        return min;\n    }\n}\n\ncontract ArrayProcessor {\n    using ArrayUtils for uint[];\n\n    function findMax(uint[] memory array) public pure returns (uint) {\n        return ArrayUtils.internalMax(array);\n    }\n\n    function dummyProcess() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\nlibrary TokenUtils {\n    function internalTransfer(address from, address to, uint amount) internal pure returns (bool) {\n        return true;\n    }\n\n    function publicBalance(address account) public view returns (uint) {\n        return 1000;\n    }\n}\n\ncontract TokenManager {\n    using TokenUtils for address;\n\n    function transferTokens(address from, address to, uint amount) public pure returns (bool) {\n        return TokenUtils.internalTransfer(from, to, amount);\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\nlibrary HashingLib {\n    function internalHash(string memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(data));\n    }\n\n    function publicVerify(bytes32 hash, string memory data) public pure returns (bool) {\n        return hash == keccak256(abi.encodePacked(data));\n    }\n}\n\ncontract HashingContract {\n    using HashingLib for string;\n\n    function getHash(string memory data) public pure returns (bytes32) {\n        return HashingLib.internalHash(data);\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\nlibrary FinancialLib {\n    function internalCalculateInterest(uint principal, uint rate) internal pure returns (uint) {\n        return (principal * rate) / 100;\n    }\n\n    function publicGetPrincipal() public pure returns (uint) {\n        return 1000;\n    }\n}\n\ncontract FinancialContract {\n    using FinancialLib for uint;\n\n    function calculate(uint principal, uint rate) public pure returns (uint) {\n        return FinancialLib.internalCalculateInterest(principal, rate);\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\nlibrary CryptoLib {\n    function internalEncrypt(uint data) internal pure returns (uint) {\n        return data + 1;\n    }\n\n    function publicDecrypt(uint encryptedData) public pure returns (uint) {\n        return encryptedData - 1;\n    }\n}\n\ncontract CryptoContract {\n    using CryptoLib for uint;\n\n    function encryptData(uint data) public pure returns (uint) {\n        return CryptoLib.internalEncrypt(data);\n    }\n\n    function dummyFunction2() public pure returns (string memory) {\n        return \"dummy\";\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\nlibrary VotingLib {\n    function internalVote(uint proposalId) internal pure returns (bool) {\n        return true;\n    }\n\n    function publicResult(uint proposalId) public view returns (uint) {\n        return proposalId % 100;\n    }\n}\n\ncontract VotingContract {\n    using VotingLib for uint;\n\n    function voteOnProposal(uint proposalId) public pure returns (bool) {\n        return VotingLib.internalVote(proposalId);\n    }\n\n    function getProposal() public view returns (string memory) {\n        return \"Proposal details\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\nlibrary MappingLib {\n    function internalGetKey(bytes32 key) internal pure returns (uint) {\n        return uint(key);\n    }\n\n    function publicSetKey(bytes32 key, uint value) public pure returns (bool) {\n        return true;\n    }\n}\n\ncontract MappingContract {\n    using MappingLib for bytes32;\n\n    function getKey(bytes32 key) public pure returns (uint) {\n        return MappingLib.internalGetKey(key);\n    }\n\n    function dummyFunction3() public pure returns (address) {\n        return address(0);\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\nlibrary QueueLib {\n    function internalEnqueue(uint item) internal pure returns (uint) {\n        return item;\n    }\n\n    function publicDequeue() public pure returns (uint) {\n        return 0;\n    }\n}\n\ncontract QueueContract {\n    using QueueLib for uint;\n\n    function enqueueItem(uint item) public pure returns (uint) {\n        return QueueLib.internalEnqueue(item);\n    }\n}"
      }
    }
  },
  {
    "Changes5": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The names of variables declared in inline assembly may no longer end in <code>_slot</code> or <code>_offset</code>.Choose unique identifiers for variable declarations in inline assembly that do not conflict with declarations outside the inline assembly block.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractA {\n    uint256 public amount;\n\n    function setAmount(uint256 _value) public {\n        assembly {\n            let amount_slot := _value\n            sstore(amount_slot, _value)\n        }\n    }\n}",
          "error message": ":1:157: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let amount_slot := _value             sstore(amoun ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractB {\n    uint256 public balance;\n\n    function updateBalance(uint256 _newBalance) public {\n        assembly {\n            let balance_offset := _newBalance\n            sstore(balance_offset, _newBalance)\n        }\n    }\n}",
          "error message": ":1:167: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let balance_offset := _newBalance             sstore( ...\n                                        ^------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractC {\n    address public owner;\n\n    function setOwner(address _owner) public {\n        assembly {\n            let owner_slot := _owner\n            sstore(owner_slot, _owner)\n        }\n    }\n}",
          "error message": ":1:155: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let owner_slot := _owner             sstore(owner ...\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractD {\n    bytes32 public dataHash;\n\n    function storeDataHash(bytes32 _hash) public {\n        assembly {\n            let dataHash_slot := _hash\n            sstore(dataHash_slot, _hash)\n        }\n    }\n}",
          "error message": ":1:162: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let dataHash_slot := _hash             sstore(dataHa ...\n                                        ^-----------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractE {\n    uint256 public totalSupply;\n\n    function updateSupply(uint256 _supply) public {\n        assembly {\n            let supply_offset := _supply\n            sstore(supply_offset, _supply)\n        }\n    }\n\n}",
          "error message": ":1:166: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let supply_offset := _supply             sstore(supp ...\n                                        ^-----------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractF {\n    uint256 public value;\n\n    function modifyValue(uint256 _val) public {\n        assembly {\n            let value_slot := _val\n            sstore(value_slot, _val)\n        }\n    }\n}",
          "error message": ":1:156: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let value_slot := _val             sstore(value_s ...\n                                        ^--------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractG {\n    bool public isActive;\n\n    function setActive(bool _active) public {\n        assembly {\n            let active_flag_slot := _active\n            sstore(active_flag_slot, _active)\n        }\n    }\n\n}",
          "error message": ":1:154: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let active_flag_slot := _active             sstore(acti ...\n                                        ^--------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractH {\n    uint256 public count;\n\n    function setCount(uint256 _count) public {\n        assembly {\n            let count_offset := _count\n            sstore(count_offset, _count)\n        }\n    }\n}",
          "error message": ":1:155: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let count_offset := _count             sstore(count ...\n                                        ^----------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractI {\n    bytes32 public secret;\n\n    function saveSecret(bytes32 _secret) public {\n        assembly {\n            let secret_slot := _secret\n            sstore(secret_slot, _secret)\n        }\n    }\n}",
          "error message": ":1:159: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let secret_slot := _secret             sstore(secr ...\n                                        ^---------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractJ {\n    address public admin;\n\n    function assignAdmin(address _admin) public {\n        assembly {\n            let admin_offset := _admin\n            sstore(admin_offset, _admin)\n        }\n    }\n}",
          "error message": ":1:158: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let admin_offset := _admin             sstore(admin ...\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ContractA {\n    uint256 public amount;\n\n    function setAmount(uint256 _value) public {\n        assembly {\n            let amountLoc := _value\n            sstore(amountLoc, _value)\n        }\n    }\n\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ContractB {\n    uint256 public balance;\n\n    function updateBalance(uint256 _newBalance) public {\n        assembly {\n            let balanceLoc := _newBalance\n            sstore(balanceLoc, _newBalance)\n        }\n    }\n\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ContractC {\n    address public owner;\n\n    function setOwner(address _owner) public {\n        assembly {\n            let ownerLoc := _owner\n            sstore(ownerLoc, _owner)\n        }\n    }\n\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractD {\n    bytes32 public dataHash;\n\n    function storeDataHash(bytes32 _hash) public {\n        assembly {\n            let dataHashLoc := _hash\n            sstore(dataHashLoc, _hash)\n        }\n    }\n\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ContractE {\n    uint256 public totalSupply;\n\n    function updateSupply(uint256 _supply) public {\n        assembly {\n            let supplyLoc := _supply\n            sstore(supplyLoc, _supply)\n        }\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ContractF {\n    uint256 public value;\n\n    function modifyValue(uint256 _val) public {\n        assembly {\n            let valueLoc := _val\n            sstore(valueLoc, _val)\n        }\n    }\n\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ContractG {\n    bool public isActive;\n\n    function setActive(bool _active) public {\n        assembly {\n            let activeFlagLoc := _active\n            sstore(activeFlagLoc, _active)\n        }\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ContractH {\n    uint256 public count;\n\n    function setCount(uint256 _count) public {\n        assembly {\n            let countLoc := _count\n            sstore(countLoc, _count)\n        }\n    }\n\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ContractI {\n    bytes32 public secret;\n\n    function saveSecret(bytes32 _secret) public {\n        assembly {\n            let secretLoc := _secret\n            sstore(secretLoc, _secret)\n        }\n    }\n\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ContractJ {\n    address public admin;\n\n    function assignAdmin(address _admin) public {\n        assembly {\n            let adminLoc := _admin\n            sstore(adminLoc, _admin)\n        }\n    }\n\n}"
      }
    }
  },
  {
    "Changes6": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Variable declarations in inline assembly may no longer shadow any declaration outside the inline assembly block.\nIf the name contains a dot, its prefix up to the dot may not conflict with any declaration outside the inline\nassembly block.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    uint256 public amount = 50;\n\n    function calculate() public {\n        uint256 amount = 100;\n        assembly {\n            let amount := 200\n        }\n    }\n}",
          "error message": ":1:177: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let amount := 200         }     } }\n                                        ^----^\n:1:120: The shadowed declaration is here:\n ... ction calculate() public {         uint256 amount = 100;         assembly {          ...\n                                        ^------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    string public name = \"Alice\";\n\n    function changeName() public {\n        string memory name = \"Bob\";\n        assembly {\n            let name := \"Charlie\"\n        }\n    }\n}",
          "error message": ":1:186: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let name := \"Charlie\"         }     } }\n                                        ^--^\n:1:123: The shadowed declaration is here:\n ... tion changeName() public {         string memory name = \"Bob\";         assembly {        ...\n                                        ^----------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public owner;\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n        assembly {\n            let owner := newOwner\n        }\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
          "error message": ":1:182: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let owner := newOwner         }     }      f ...\n                                        ^---^\n:1:49: The shadowed declaration is here:\n ... ty^0.6.0;  contract Example3 {     address public owner;      function setOwner(address ne ...\n                                        ^------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    bool public isActive = true;\n\n    function toggle() public {\n        bool isActive = false;\n        assembly {\n            let isActive := 1\n        }\n    }\n}",
          "error message": ":1:176: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let isActive := 1         }     } }\n                                        ^------^\n:1:118: The shadowed declaration is here:\n ... function toggle() public {         bool isActive = false;         assembly {        ...\n                                        ^-----------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    uint256 public counter = 1;\n\n    function increment() public {\n        uint256 counter = 2;\n        assembly {\n            let counter := 3\n        }\n    }\n\n    function reset() public {\n        counter = 0;\n    }\n}",
          "error message": ":1:176: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let counter := 3         }     }      function ...\n                                        ^-----^\n:1:120: The shadowed declaration is here:\n ... ction increment() public {         uint256 counter = 2;         assembly {            ...\n                                        ^-------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    bytes32 public data = keccak256(\"Initial\");\n\n    function updateData() public {\n        bytes32 data = keccak256(\"Updated\");\n        assembly {\n            let data := keccak256(add(\"New\", 0x20), 0x20)\n        }\n    }\n}",
          "error message": ":1:209: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let data := keccak256(add(\"New\", 0x20), 0x2 ...\n                                        ^--^\n:1:137: The shadowed declaration is here:\n ... tion updateData() public {         bytes32 data = keccak256(\"Updated\");         as ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    uint256 public rate = 10;\n\n    function adjustRate() public {\n        uint256 rate = 15;\n        assembly {\n            let rate := 20\n        }\n    }\n\n    function getRate() public view returns (uint256) {\n        return rate;\n    }\n}",
          "error message": ":1:173: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let rate := 20         }     }      functio ...\n                                        ^--^\n:1:119: The shadowed declaration is here:\n ... tion adjustRate() public {         uint256 rate = 15;         assembly {           ...\n                                        ^----------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    int256 public balance = 100;\n\n    function setGreeting(string memory newGreeting) public {\n        string memory greeting = newGreeting;\n        assembly {\n            let greeting := \"Hi\"\n        }\n    }\n}",
          "error message": ":1:221: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let greeting := \"Hi\"         }     } }\n                                        ^------^\n:1:148: The shadowed declaration is here:\n ... mory newGreeting) public {         string memory greeting = newGreeting;         assembly {  ...\n                                        ^--------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    string public greeting = \"Hello\";\n\n    function setGreeting(string memory newGreeting) public {\n        string memory greeting = newGreeting;\n        assembly {\n            let greeting := \"Hi\"\n        }\n    }\n}",
          "error message": ":1:226: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let greeting := \"Hi\"         }     } }\n                                        ^------^\n:1:153: The shadowed declaration is here:\n ... mory newGreeting) public {         string memory greeting = newGreeting;         assembly {  ...\n                                        ^--------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    uint256 public totalSupply = 1000;\n\n    function adjustSupply() public {\n        uint256 totalSupply = 500;\n        assembly {\n            let totalSupply := 250\n        }\n    }\n\n    function dummyFunction1() public pure returns (uint256) {\n        return 1;\n    }\n\n    function dummyFunction2() public pure returns (uint256) {\n        return 2;\n    }\n}",
          "error message": ":1:193: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let totalSupply := 250         }     }      functi ...\n                                        ^---------^\n:1:131: The shadowed declaration is here:\n ... on adjustSupply() public {         uint256 totalSupply = 500;         assembly {          ...\n                                        ^-----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    uint256 public amount = 50;\n\n    function calculate() public {\n        uint256 amountLocal = 100;\n        assembly {\n            let amountAsm := 200\n        }\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    string public name = \"Alice\";\n\n    function changeName() public {\n        string memory nameLocal = \"Bob\";\n        assembly {\n            let nameAsm := \"Charlie\"\n        }\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public owner;\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n        assembly {\n            let ownerAsm := newOwner\n        }\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    bool public isActive = true;\n\n    function toggle() public {\n        bool isActiveLocal = false;\n        assembly {\n            let isActiveAsm := 1\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    uint256 public counter = 1;\n\n    function increment() public {\n        uint256 counterLocal = 2;\n        assembly {\n            let counterAsm := 3\n        }\n    }\n\n    function reset() public {\n        counter = 0;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    bytes32 public data = keccak256(\"Initial\");\n\n    function updateData() public {\n        bytes32 dataLocal = keccak256(\"Updated\");\n        assembly {\n            let dataAsm := keccak256(add(\"New\", 0x20), 0x20)\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    uint256 public rate = 10;\n\n    function adjustRate() public {\n        uint256 rateLocal = 15;\n        assembly {\n            let rateAsm := 20\n        }\n    }\n\n    function getRate() public view returns (uint256) {\n        return rate;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    int256 public balance = 100;\n\n    function setGreeting(string memory newGreeting) public {\n        string memory greetingLocal = newGreeting;\n        assembly {\n            let greetingAsm := \"Hi\"\n        }\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    string public greeting = \"Hello\";\n\n    function setGreeting(string memory newGreeting) public {\n        string memory greetingLocal = newGreeting;\n        assembly {\n            let greetingAsm := \"Hi\"\n        }\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    uint256 public totalSupply = 1000;\n\n    function adjustSupply() public {\n        uint256 totalSupplyLocal = 500;\n        assembly {\n            let totalSupplyAsm := 250\n        }\n    }\n\n    function dummyFunction1() public pure returns (uint256) {\n        return 1;\n    }\n\n    function dummyFunction2() public pure returns (uint256) {\n        return 2;\n    }\n}"
      }
    }
  },
  {
    "Changes7": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "In inline assembly, opcodes that do not take arguments are now represented as \u201cbuilt-in functions\u201d instead of standalone identifiers. So <code>gas</code> is now <code>gas()</code>.In inline assembly, add <code>()</code> to all opcodes that do not otherwise accept an argument.For example, change <code>pc</code> to <code>pc()</code>, and <code>gas</code> to <code>gas()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample1 {\n    uint256 public storedGas;\n\n    function executeAssembly() public {\n        assembly {\n            let g := gas\n            sstore(storedGas_slot, g)\n        }\n    }\n}",
          "error message": ":1:180: ParserError: Expected '(' but got identifier\n ...           let g := gas             sstore(storedGas_slot, g)         }     } ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample2 {\n    uint256 public lastPcValue;\n\n    function trackPC() public {\n        assembly {\n            let p := pc\n            sstore(lastPcValue_slot, p)\n        }\n    }\n}",
          "error message": ":1:173: ParserError: Expected '(' but got identifier\n ...            let p := pc             sstore(lastPcValue_slot, p)         }     ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample3 {\n    uint256 public finalGas;\n\n    function calculateGas() public {\n        assembly {\n            let gasLeft := gas\n            sstore(finalGas_slot, gasLeft)\n        }\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 123;\n    }\n}",
          "error message": ":1:182: ParserError: Expected '(' but got identifier\n ...     let gasLeft := gas             sstore(finalGas_slot, gasLeft)         }  ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint256 public codePosition;\n\n    function getPosition() public {\n        assembly {\n            let position := pc\n            sstore(codePosition_slot, position)\n        }\n    }\n}",
          "error message": ":1:185: ParserError: Expected '(' but got identifier\n ...     let position := pc             sstore(codePosition_slot, position)       ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample5 {\n    uint256 public gasValue;\n\n    function retrieveGas() public {\n        assembly {\n            let remainingGas := gas\n            sstore(gasValue_slot, remainingGas)\n        }\n    }\n\n    function additionalFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:186: ParserError: Expected '(' but got identifier\n ... et remainingGas := gas             sstore(gasValue_slot, remainingGas)       ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample6 {\n    uint256 public pcValue;\n\n    function storePC() public {\n        assembly {\n            let programCounter := pc\n            sstore(pcValue_slot, programCounter)\n        }\n    }\n}",
          "error message": ":1:182: ParserError: Expected '(' but got identifier\n ... t programCounter := pc             sstore(pcValue_slot, programCounter)      ...\n                                        ^----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample7 {\n    uint256 public gasLeft;\n\n    function checkGas() public {\n        assembly {\n            let remaining := gas\n            sstore(gasLeft_slot, remaining)\n        }\n    }\n}",
          "error message": ":1:179: ParserError: Expected '(' but got identifier\n ...   let remaining := gas             sstore(gasLeft_slot, remaining)         } ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample8 {\n    uint256 public currentPC;\n\n    function fetchPC() public {\n        assembly {\n            let current := pc\n            sstore(currentPC_slot, current)\n        }\n    }\n\n    function placeholderFunction() public pure returns (string memory) {\n        return \"test\";\n    }\n}",
          "error message": ":1:177: ParserError: Expected '(' but got identifier\n ...      let current := pc             sstore(currentPC_slot, current)         } ...\n                                        ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample9 {\n    uint256 public latestGas;\n\n    function measureGas() public {\n        assembly {\n            let gasNow := gas\n            sstore(latestGas_slot, gasNow)\n        }\n    }\n}",
          "error message": ":1:180: ParserError: Expected '(' but got identifier\n ...      let gasNow := gas             sstore(latestGas_slot, gasNow)         }  ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample10 {\n    uint256 public programCounter;\n\n    function pcValue() public {\n        assembly {\n            let pcCounter := pc\n            sstore(programCounter_slot, pcCounter)\n        }\n    }\n}",
          "error message": ":1:185: ParserError: Expected '(' but got identifier\n ...    let pcCounter := pc             sstore(programCounter_slot, pcCounter)    ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ContractExample1 {\n    uint256 public storedGas;\n\n    function executeAssembly() public {\n        assembly {\n            let g := gas()\n            sstore(storedGas_slot, g)\n        }\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ContractExample2 {\n    uint256 public lastPcValue;\n\n    function trackPC() public {\n        assembly {\n            let p := pc()\n            sstore(lastPcValue_slot, p)\n        }\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ContractExample3 {\n    uint256 public finalGas;\n\n    function calculateGas() public {\n        assembly {\n            let gasLeft := gas()\n            sstore(finalGas_slot, gasLeft)\n        }\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 123;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint256 public codePosition;\n\n    function getPosition() public {\n        assembly {\n            let position := pc()\n            sstore(codePosition_slot, position)\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ContractExample5 {\n    uint256 public gasValue;\n\n    function retrieveGas() public {\n        assembly {\n            let remainingGas := gas()\n            sstore(gasValue_slot, remainingGas)\n        }\n    }\n\n    function additionalFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ContractExample6 {\n    uint256 public pcValue;\n\n    function storePC() public {\n        assembly {\n            let programCounter := pc()\n            sstore(pcValue_slot, programCounter)\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ContractExample7 {\n    uint256 public gasLeft;\n\n    function checkGas() public {\n        assembly {\n            let remaining := gas()\n            sstore(gasLeft_slot, remaining)\n        }\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ContractExample8 {\n    uint256 public currentPC;\n\n    function fetchPC() public {\n        assembly {\n            let current := pc()\n            sstore(currentPC_slot, current)\n        }\n    }\n\n    function placeholderFunction() public pure returns (string memory) {\n        return \"test\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ContractExample9 {\n    uint256 public latestGas;\n\n    function measureGas() public {\n        assembly {\n            let gasNow := gas()\n            sstore(latestGas_slot, gasNow)\n        }\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ContractExample10 {\n    uint256 public programCounter;\n\n    function pcValue() public {\n        assembly {\n            let pcCounter := pc()\n            sstore(programCounter_slot, pcCounter)\n        }\n    }\n}"
      }
    }
  },
  {
    "Changes8": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "State variable shadowing is now disallowed.  A derived contract can only\ndeclare a state variable <code>x</code>, if there is no visible state variable with\nthe same name in any of its bases.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Alpha {\n    uint public alphaValue = 10;\n}\n\ncontract Beta is Alpha {\n    uint public alphaValue = 20;\n    \n    function getBetaValue() public view returns (uint) {\n        return alphaValue;\n    }\n}",
          "error message": ":1:107: DeclarationError: Identifier already declared.\n ... 0; }  contract Beta is Alpha {     uint public alphaValue = 20;          function getBetaValue()  ...\n                                        ^-------------------------^\n:1:46: The previous declaration is here:\n ... idity^0.6.0;  contract Alpha {     uint public alphaValue = 10; }  contract Beta is Alpha {     u ...\n                                        ^-------------------------^\n:1:107: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... 0; }  contract Beta is Alpha {     uint public alphaValue = 20;          function getBetaValue()  ...\n                                        ^-------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Alpha {     uint public alphaValue = 10; }  contract Beta is Alpha {     u ...\n                                        ^-------------------------^\n:1:46: TypeError: Cannot override public state variable.\n ... idity^0.6.0;  contract Alpha {     uint public alphaValue = 10; }  contract Beta is Alpha {     u ...\n                                        ^-------------------------^\n:1:107: Overriding public state variable is here:\n ... 0; }  contract Beta is Alpha {     uint public alphaValue = 20;          function getBetaValue()  ...\n                                        ^-------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Gamma {\n    string public name = \"Gamma\";\n}\n\ncontract Delta is Gamma {\n    string public name = \"Delta\";\n    \n    function getDeltaName() public view returns (string memory) {\n        return name;\n    }\n}",
          "error message": ":1:109: DeclarationError: Identifier already declared.\n ... ; }  contract Delta is Gamma {     string public name = \"Delta\";          function getDeltaName()  ...\n                                        ^--------------------------^\n:1:46: The previous declaration is here:\n ... idity^0.6.0;  contract Gamma {     string public name = \"Gamma\"; }  contract Delta is Gamma {      ...\n                                        ^--------------------------^\n:1:109: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ; }  contract Delta is Gamma {     string public name = \"Delta\";          function getDeltaName()  ...\n                                        ^--------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Gamma {     string public name = \"Gamma\"; }  contract Delta is Gamma {      ...\n                                        ^--------------------------^\n:1:46: TypeError: Cannot override public state variable.\n ... idity^0.6.0;  contract Gamma {     string public name = \"Gamma\"; }  contract Delta is Gamma {      ...\n                                        ^--------------------------^\n:1:109: Overriding public state variable is here:\n ... ; }  contract Delta is Gamma {     string public name = \"Delta\";          function getDeltaName()  ...\n                                        ^--------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract BaseA {\n    address public owner = msg.sender;\n}\n\ncontract DerivedA is BaseA {\n    address public owner = address(0);\n    \n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}",
          "error message": ":1:117: DeclarationError: Identifier already declared.\n ...   contract DerivedA is BaseA {     address public owner = address(0);          function getOwner() publ ...\n                                        ^-------------------------------^\n:1:46: The previous declaration is here:\n ... idity^0.6.0;  contract BaseA {     address public owner = msg.sender; }  contract DerivedA is BaseA {   ...\n                                        ^-------------------------------^\n:1:117: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract DerivedA is BaseA {     address public owner = address(0);          function getOwner() publ ...\n                                        ^-------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract BaseA {     address public owner = msg.sender; }  contract DerivedA is BaseA {   ...\n                                        ^-------------------------------^\n:1:46: TypeError: Cannot override public state variable.\n ... idity^0.6.0;  contract BaseA {     address public owner = msg.sender; }  contract DerivedA is BaseA {   ...\n                                        ^-------------------------------^\n:1:117: Overriding public state variable is here:\n ...   contract DerivedA is BaseA {     address public owner = address(0);          function getOwner() publ ...\n                                        ^-------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract BaseB {\n    uint public count = 1;\n}\n\ncontract DerivedB is BaseB {\n    uint public count = 2;\n    \n    function getCount() public view returns (uint) {\n        return count;\n    }\n}",
          "error message": ":1:105: DeclarationError: Identifier already declared.\n ...   contract DerivedB is BaseB {     uint public count = 2;          function getCount() publ ...\n                                        ^-------------------^\n:1:46: The previous declaration is here:\n ... idity^0.6.0;  contract BaseB {     uint public count = 1; }  contract DerivedB is BaseB {   ...\n                                        ^-------------------^\n:1:105: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract DerivedB is BaseB {     uint public count = 2;          function getCount() publ ...\n                                        ^-------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract BaseB {     uint public count = 1; }  contract DerivedB is BaseB {   ...\n                                        ^-------------------^\n:1:46: TypeError: Cannot override public state variable.\n ... idity^0.6.0;  contract BaseB {     uint public count = 1; }  contract DerivedB is BaseB {   ...\n                                        ^-------------------^\n:1:105: Overriding public state variable is here:\n ...   contract DerivedB is BaseB {     uint public count = 2;          function getCount() publ ...\n                                        ^-------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Parent1 {\n    bool public isActive = true;\n}\n\ncontract Child1 is Parent1 {\n    bool public isActive = false;\n    \n    function isChildActive() public view returns (bool) {\n        return isActive;\n    }\n}",
          "error message": ":1:113: DeclarationError: Identifier already declared.\n ...   contract Child1 is Parent1 {     bool public isActive = false;          function isChildActive() ...\n                                        ^--------------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Parent1 {     bool public isActive = true; }  contract Child1 is Parent1 {   ...\n                                        ^-------------------------^\n:1:113: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract Child1 is Parent1 {     bool public isActive = false;          function isChildActive() ...\n                                        ^--------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Parent1 {     bool public isActive = true; }  contract Child1 is Parent1 {   ...\n                                        ^-------------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Parent1 {     bool public isActive = true; }  contract Child1 is Parent1 {   ...\n                                        ^-------------------------^\n:1:113: Overriding public state variable is here:\n ...   contract Child1 is Parent1 {     bool public isActive = false;          function isChildActive() ...\n                                        ^--------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Main {\n    bytes32 public hash = keccak256(\"hello\");\n}\n\ncontract SubMain is Main {\n    bytes32 public hash = keccak256(\"world\");\n    \n    function getHash() public view returns (bytes32) {\n        return hash;\n    }\n}",
          "error message": ":1:121: DeclarationError: Identifier already declared.\n ...  }  contract SubMain is Main {     bytes32 public hash = keccak256(\"world\");          function getHash() publi ...\n                                        ^--------------------------------------^\n:1:45: The previous declaration is here:\n ... lidity^0.6.0;  contract Main {     bytes32 public hash = keccak256(\"hello\"); }  contract SubMain is Main {     ...\n                                        ^--------------------------------------^\n:1:121: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...  }  contract SubMain is Main {     bytes32 public hash = keccak256(\"world\");          function getHash() publi ...\n                                        ^--------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Main {     bytes32 public hash = keccak256(\"hello\"); }  contract SubMain is Main {     ...\n                                        ^--------------------------------------^\n:1:45: TypeError: Cannot override public state variable.\n ... lidity^0.6.0;  contract Main {     bytes32 public hash = keccak256(\"hello\"); }  contract SubMain is Main {     ...\n                                        ^--------------------------------------^\n:1:121: Overriding public state variable is here:\n ...  }  contract SubMain is Main {     bytes32 public hash = keccak256(\"world\");          function getHash() publi ...\n                                        ^--------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Parent2 {\n    int public temperature = 25;\n}\n\ncontract Child2 is Parent2 {\n    int public temperature = 30;\n    \n    function getTemperature() public view returns (int) {\n        return temperature;\n    }\n}",
          "error message": ":1:113: DeclarationError: Identifier already declared.\n ...   contract Child2 is Parent2 {     int public temperature = 30;          function getTemperature( ...\n                                        ^-------------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Parent2 {     int public temperature = 25; }  contract Child2 is Parent2 {   ...\n                                        ^-------------------------^\n:1:113: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract Child2 is Parent2 {     int public temperature = 30;          function getTemperature( ...\n                                        ^-------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Parent2 {     int public temperature = 25; }  contract Child2 is Parent2 {   ...\n                                        ^-------------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Parent2 {     int public temperature = 25; }  contract Child2 is Parent2 {   ...\n                                        ^-------------------------^\n:1:113: Overriding public state variable is here:\n ...   contract Child2 is Parent2 {     int public temperature = 30;          function getTemperature( ...\n                                        ^-------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Root {\n    uint8 public version = 1;\n}\n\ncontract Branch is Root {\n    uint8 public version = 2;\n    \n    function getVersion() public view returns (uint8) {\n        return version;\n    }\n}",
          "error message": ":1:104: DeclarationError: Identifier already declared.\n ... ; }  contract Branch is Root {     uint8 public version = 2;          function getVersion() pu ...\n                                        ^----------------------^\n:1:45: The previous declaration is here:\n ... lidity^0.6.0;  contract Root {     uint8 public version = 1; }  contract Branch is Root {      ...\n                                        ^----------------------^\n:1:104: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ; }  contract Branch is Root {     uint8 public version = 2;          function getVersion() pu ...\n                                        ^----------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Root {     uint8 public version = 1; }  contract Branch is Root {      ...\n                                        ^----------------------^\n:1:45: TypeError: Cannot override public state variable.\n ... lidity^0.6.0;  contract Root {     uint8 public version = 1; }  contract Branch is Root {      ...\n                                        ^----------------------^\n:1:104: Overriding public state variable is here:\n ... ; }  contract Branch is Root {     uint8 public version = 2;          function getVersion() pu ...\n                                        ^----------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Foundation {\n    uint public height = 100;\n}\n\ncontract Building is Foundation {\n    uint public height = 200;\n    \n    function getHeight() public view returns (uint) {\n        return height;\n    }\n}",
          "error message": ":1:118: DeclarationError: Identifier already declared.\n ... tract Building is Foundation {     uint public height = 200;          function getHeight() pub ...\n                                        ^----------------------^\n:1:51: The previous declaration is here:\n ... ^0.6.0;  contract Foundation {     uint public height = 100; }  contract Building is Foundatio ...\n                                        ^----------------------^\n:1:118: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... tract Building is Foundation {     uint public height = 200;          function getHeight() pub ...\n                                        ^----------------------^\n:1:51: Overridden function is here:\n ... ^0.6.0;  contract Foundation {     uint public height = 100; }  contract Building is Foundatio ...\n                                        ^----------------------^\n:1:51: TypeError: Cannot override public state variable.\n ... ^0.6.0;  contract Foundation {     uint public height = 100; }  contract Building is Foundatio ...\n                                        ^----------------------^\n:1:118: Overriding public state variable is here:\n ... tract Building is Foundation {     uint public height = 200;          function getHeight() pub ...\n                                        ^----------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Core {\n    string public coreName = \"CoreContract\";\n}\n\ncontract Extension is Core {\n    string public coreName = \"ExtensionContract\";\n    \n    function getCoreName() public view returns (string memory) {\n        return coreName;\n    }\n}",
          "error message": ":1:122: DeclarationError: Identifier already declared.\n ...   contract Extension is Core {     string public coreName = \"ExtensionContract\";          function getCoreName() p ...\n                                        ^------------------------------------------^\n:1:45: The previous declaration is here:\n ... lidity^0.6.0;  contract Core {     string public coreName = \"CoreContract\"; }  contract Extension is Core {   ...\n                                        ^-------------------------------------^\n:1:122: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...   contract Extension is Core {     string public coreName = \"ExtensionContract\";          function getCoreName() p ...\n                                        ^------------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Core {     string public coreName = \"CoreContract\"; }  contract Extension is Core {   ...\n                                        ^-------------------------------------^\n:1:45: TypeError: Cannot override public state variable.\n ... lidity^0.6.0;  contract Core {     string public coreName = \"CoreContract\"; }  contract Extension is Core {   ...\n                                        ^-------------------------------------^\n:1:122: Overriding public state variable is here:\n ...   contract Extension is Core {     string public coreName = \"ExtensionContract\";          function getCoreName() p ...\n                                        ^------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Alpha {\n    uint public alphaValue = 10;\n}\n\ncontract Beta is Alpha {\n    uint public betaValue = 20;\n    \n    function getBetaValue() public view returns (uint) {\n        return betaValue;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Gamma {\n    string public name = \"Gamma\";\n}\n\ncontract Delta is Gamma {\n    string public deltaName = \"Delta\";\n    \n    function getDeltaName() public view returns (string memory) {\n        return deltaName;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract BaseA {\n    address public owner = msg.sender;\n}\n\ncontract DerivedA is BaseA {\n    address public derivedOwner = address(0);\n    \n    function getOwner() public view returns (address) {\n        return derivedOwner;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract BaseB {\n    uint public count = 1;\n}\n\ncontract DerivedB is BaseB {\n    uint public derivedCount = 2;\n    \n    function getCount() public view returns (uint) {\n        return derivedCount;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Parent1 {\n    bool public isActive = true;\n}\n\ncontract Child1 is Parent1 {\n    bool public childIsActive = false;\n    \n    function isChildActive() public view returns (bool) {\n        return childIsActive;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Main {\n    bytes32 public hash = keccak256(\"hello\");\n}\n\ncontract SubMain is Main {\n    bytes32 public subHash = keccak256(\"world\");\n    \n    function getHash() public view returns (bytes32) {\n        return subHash;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Parent2 {\n    int public temperature = 25;\n}\n\ncontract Child2 is Parent2 {\n    int public childTemperature = 30;\n    \n    function getTemperature() public view returns (int) {\n        return childTemperature;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Root {\n    uint8 public version = 1;\n}\n\ncontract Branch is Root {\n    uint8 public branchVersion = 2;\n    \n    function getVersion() public view returns (uint8) {\n        return branchVersion;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Foundation {\n    uint public height = 100;\n}\n\ncontract Building is Foundation {\n    uint public buildingHeight = 200;\n    \n    function getHeight() public view returns (uint) {\n        return buildingHeight;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Core {\n    string public coreName = \"CoreContract\";\n}\n\ncontract Extension is Core {\n    string public extensionName = \"ExtensionContract\";\n    \n    function getCoreName() public view returns (string memory) {\n        return extensionName;\n    }\n}"
      }
    }
  },
  {
    "Changes9": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Conversions from external function types to <code>address</code> are now disallowed. Instead external\nfunction types have a member called <code>address</code>, similar to the existing <code>selector</code> member.Change <code>address(f)</code> to <code>f.address</code> for <code>f</code> being of external function type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    address public contractAddress;\n\n    function sampleFunction() external {\n    }\n\n    function setContractAddress() public {\n        address addr = address(this.sampleFunction);\n        contractAddress = addr;\n    }\n}",
          "error message": ":1:196: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         address addr = address(this.sampleFunction);         contractAddress = addr;   ...\n                                        ^--------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    address public storedAddress;\n\n    function externalCall() external {\n    }\n\n    function saveAddress() public {\n        storedAddress = address(this.externalCall);\n    }\n}",
          "error message": ":1:186: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ) public {         storedAddress = address(this.externalCall);     } }\n                                        ^------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public latestAddress;\n\n    function invokeExternal() external {\n    }\n\n    function updateAddress() public {\n        address addr = address(this.invokeExternal);\n        latestAddress = addr;\n    }\n\n    function additionalFunction() public {\n    }\n}",
          "error message": ":1:189: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         address addr = address(this.invokeExternal);         latestAddress = addr;     ...\n                                        ^--------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    address public callerAddress;\n\n    function someExternal() external {\n    }\n\n    function recordCaller() public {\n        callerAddress = address(this.someExternal);\n    }\n}",
          "error message": ":1:187: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ) public {         callerAddress = address(this.someExternal);     } }\n                                        ^------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    address public addrStored;\n\n    function extFunc() external {\n    }\n\n    function storeAddress() public {\n        addrStored = address(this.extFunc);\n    }\n}",
          "error message": ":1:176: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ss() public {         addrStored = address(this.extFunc);     } }\n                                        ^-------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    address public currentAddress;\n\n    function extFunctionality() external {\n    }\n\n    function logCurrentAddress() public {\n        currentAddress = address(this.extFunctionality);\n    }\n}",
          "error message": ":1:198: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ...  public {         currentAddress = address(this.extFunctionality);     } }\n                                        ^----------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    address public registeredAddress;\n\n    function someFunction() external {\n    }\n\n    function registerAddress() public {\n        registeredAddress = address(this.someFunction);\n    }\n\n    function randomFunction() public {\n    }\n}",
          "error message": ":1:198: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... blic {         registeredAddress = address(this.someFunction);     }      function randomFunctio ...\n                                        ^------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    address public savedAddress;\n\n    function extFuncLogic() external {\n    }\n\n    function saveExtAddress() public {\n        savedAddress = address(this.extFuncLogic);\n    }\n}",
          "error message": ":1:187: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         savedAddress = address(this.extFuncLogic);     } }\n                                        ^------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    address public retrievedAddress;\n\n    function extInvoke() external {\n    }\n\n    function retrieveAddress() public {\n        retrievedAddress = address(this.extInvoke);\n    }\n}",
          "error message": ":1:193: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ublic {         retrievedAddress = address(this.extInvoke);     } }\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address public functionAddress;\n\n    function externalExecutor() external {\n    }\n\n    function setFunctionAddress() public {\n        functionAddress = address(this.externalExecutor);\n    }\n}",
          "error message": ":1:202: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... public {         functionAddress = address(this.externalExecutor);     } }\n                                        ^----------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    address public contractAddress;\n    bytes4 public functionSelector;\n\n    function sampleFunction() external {\n    }\n\n    function setContractAddress() public {\n        contractAddress = address(this);\n        functionSelector = this.sampleFunction.selector;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    address public storedAddress;\n    bytes4 public functionSelector;\n\n    function externalCall() external {\n    }\n\n    function saveAddress() public {\n        storedAddress = address(this);\n        functionSelector = this.externalCall.selector;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public latestAddress;\n    bytes4 public functionSelector;\n\n    function invokeExternal() external {\n    }\n\n    function updateAddress() public {\n        latestAddress = address(this);\n        functionSelector = this.invokeExternal.selector;\n    }\n\n    function additionalFunction() public {\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    address public callerAddress;\n    bytes4 public functionSelector;\n\n    function someExternal() external {\n    }\n\n    function recordCaller() public {\n        callerAddress = address(this);\n        functionSelector = this.someExternal.selector;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    address public addrStored;\n    bytes4 public functionSelector;\n\n    function extFunc() external {\n    }\n\n    function storeAddress() public {\n        addrStored = address(this);\n        functionSelector = this.extFunc.selector;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    address public currentAddress;\n    bytes4 public functionSelector;\n\n    function extFunctionality() external {\n    }\n\n    function logCurrentAddress() public {\n        currentAddress = address(this);\n        functionSelector = this.extFunctionality.selector;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    address public registeredAddress;\n    bytes4 public functionSelector;\n\n    function someFunction() external {\n    }\n\n    function registerAddress() public {\n        registeredAddress = address(this);\n        functionSelector = this.someFunction.selector;\n    }\n\n    function randomFunction() public {\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    address public savedAddress;\n    bytes4 public functionSelector;\n\n    function extFuncLogic() external {\n    }\n\n    function saveExtAddress() public {\n        savedAddress = address(this);\n        functionSelector = this.extFuncLogic.selector;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    address public retrievedAddress;\n    bytes4 public functionSelector;\n\n    function extInvoke() external {\n    }\n\n    function retrieveAddress() public {\n        retrievedAddress = address(this);\n        functionSelector = this.extInvoke.selector;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address public functionAddress;\n    bytes4 public functionSelector;\n\n    function externalExecutor() external {\n    }\n\n    function setFunctionAddress() public {\n        functionAddress = address(this);\n        functionSelector = this.externalExecutor.selector;\n    }\n}"
      }
    }
  },
  {
    "Changes10": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The function <code>push(value)</code> for dynamic storage arrays does not return the new length anymore (it returns nothing).Change <code>uint length = array.push(value)</code> to <code>array.push(value);</code>. The new length can be accessed via <code>array.length</code>.Change <code>array.length++</code> to <code>array.push()</code> to increase, and use <code>pop()</code> to decrease the length of a storage array.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    uint[] public data;\n\n    function appendData(uint _value) public returns (uint) {\n        uint length = data.push(_value);\n        return length;\n    }\n}",
          "error message": ":1:139: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... e) public returns (uint) {         uint length = data.push(_value);         return length;     } }\n                                        ^-----------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    string[] public words;\n\n    function addWord(string memory _word) public returns (uint) {\n        uint newLength = words.push(_word);\n        return newLength;\n    }\n\n    function getWord(uint index) public view returns (string memory) {\n        return words[index];\n    }\n}",
          "error message": ":1:147: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... d) public returns (uint) {         uint newLength = words.push(_word);         return newLength;     }   ...\n                                        ^--------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address[] public addresses;\n\n    function addAddress(address _addr) public returns (uint) {\n        uint len = addresses.push(_addr);\n        return len;\n    }\n}",
          "error message": ":1:149: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... r) public returns (uint) {         uint len = addresses.push(_addr);         return len;     } }\n                                        ^------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    bytes32[] public hashes;\n\n    function pushHash(bytes32 _hash) public returns (uint) {\n        uint length = hashes.push(_hash);\n        return length;\n    }\n}",
          "error message": ":1:144: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... h) public returns (uint) {         uint length = hashes.push(_hash);         return length;     } }\n                                        ^------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    uint[] public numbers;\n\n    function insertNumber(uint _num) public returns (uint) {\n        uint len = numbers.push(_num);\n        return len;\n    }\n}",
          "error message": ":1:142: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... m) public returns (uint) {         uint len = numbers.push(_num);         return len;     } }\n                                        ^---------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    int[] public values;\n\n    function addValue(int _val) public returns (uint) {\n        uint length = values.push(_val);\n        return length;\n    }\n\n    function getValue(uint index) public view returns (int) {\n        return values[index];\n    }\n}",
          "error message": ":1:135: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... l) public returns (uint) {         uint length = values.push(_val);         return length;     }      ...\n                                        ^-----------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    bytes[] public blobs;\n\n    function addBlob(bytes memory _blob) public returns (uint) {\n        uint len = blobs.push(_blob);\n        return len;\n    }\n}",
          "error message": ":1:145: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... b) public returns (uint) {         uint len = blobs.push(_blob);         return len;     } }\n                                        ^--------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    uint[] public counts;\n\n    function incrementCount(uint _count) public returns (uint) {\n        uint newLength = counts.push(_count);\n        return newLength;\n    }\n}",
          "error message": ":1:145: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... t) public returns (uint) {         uint newLength = counts.push(_count);         return newLength;     } }\n                                        ^----------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    uint[] public elements;\n\n    function addElement(uint _element) public returns (uint) {\n        uint len = elements.push(_element);\n        return len;\n    }\n\n    function getElement(uint index) public view returns (uint) {\n        return elements[index];\n    }\n}",
          "error message": ":1:145: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... t) public returns (uint) {         uint len = elements.push(_element);         return len;     }      fu ...\n                                        ^--------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address[] public participants;\n\n    function addParticipant(address _participant) public returns (uint) {\n        uint newLength = participants.push(_participant);\n        return newLength;\n    }\n}",
          "error message": ":1:164: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... t) public returns (uint) {         uint newLength = participants.push(_participant);         return newLength;     } }\n                                        ^----------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    uint[] public data;\n\n    function appendData(uint _value) public returns (uint) {\n        data.push(_value);\n        return data.length;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    string[] public words;\n\n    function addWord(string memory _word) public returns (uint) {\n        words.push(_word);\n        return words.length;\n    }\n\n    function getWord(uint index) public view returns (string memory) {\n        return words[index];\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address[] public addresses;\n\n    function addAddress(address _addr) public returns (uint) {\n        addresses.push(_addr);\n        return addresses.length;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    bytes32[] public hashes;\n\n    function pushHash(bytes32 _hash) public returns (uint) {\n        hashes.push(_hash);\n        return hashes.length;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    uint[] public numbers;\n\n    function insertNumber(uint _num) public returns (uint) {\n        numbers.push(_num);\n        return numbers.length;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    int[] public values;\n\n    function addValue(int _val) public returns (uint) {\n        values.push(_val);\n        return values.length;\n    }\n\n    function getValue(uint index) public view returns (int) {\n        return values[index];\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    bytes[] public blobs;\n\n    function addBlob(bytes memory _blob) public returns (uint) {\n        blobs.push(_blob);\n        return blobs.length;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    uint[] public counts;\n\n    function incrementCount(uint _count) public returns (uint) {\n        counts.push(_count);\n        return counts.length;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    uint[] public elements;\n\n    function addElement(uint _element) public returns (uint) {\n        elements.push(_element);\n        return elements.length;\n    }\n\n    function getElement(uint index) public view returns (uint) {\n        return elements[index];\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address[] public participants;\n\n    function addParticipant(address _participant) public returns (uint) {\n        participants.push(_participant);\n        return participants.length;\n    }\n}"
      }
    }
  },
  {
    "Changes11": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The unnamed function commonly referred to as \u201cfallback function\u201d was split up into a new\nfallback function that is defined using the <code>fallback</code> keyword and a receive ether function\ndefined using the <code>receive</code> keyword.Replace <code>function () external [payable] { ... }</code> by either <code>receive() external payable { ... }</code>,<code>fallback() external [payable] { ... }</code> or both. Prefer using a <code>receive</code> function only, whenever possible.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    function () external payable {}\n\n    function randomFunction1(uint x) public pure returns (uint) {\n        return x * 2;\n    }\n}",
          "error message": ":1:78: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function randomFunction1(uin ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    function deposit() public payable {}\n\n    function () external {}\n\n    function randomFunction2() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:112: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... yable {}      function () external {}      function randomFunction2() p ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    function () external payable {}\n\n    function withdraw(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction3(address addr) public pure returns (address) {\n        return addr;\n    }\n}",
          "error message": ":1:78: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function withdraw(uint amoun ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    function () external {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction4() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... xample4 {     function () external {}      function getBalance() public ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    function () external payable {}\n\n    function balance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction5() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"data\"));\n    }\n}",
          "error message": ":1:78: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function balance() public vi ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    function receiveFunds() public payable {}\n\n    function () external {}\n\n    function randomFunction6(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
          "error message": ":1:117: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... yable {}      function () external {}      function randomFunction6(uin ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    function () external payable {}\n\n    function transferOwnership(address newOwner) public {}\n\n    function randomFunction7() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:78: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function transferOwnership(a ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    function depositEther() public payable {}\n\n    function () external payable {}\n\n    function getOwner() public view returns (address) {\n        return msg.sender;\n    }\n\n    function randomFunction8(uint x) public pure returns (uint) {\n        return x * x;\n    }\n}",
          "error message": ":1:125: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ...       function () external payable {}      function getOwner() public v ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    function () external {}\n\n    function withdrawFunds(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction9() public pure returns (string memory) {\n        return \"World\";\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... xample9 {     function () external {}      function withdrawFunds(uint  ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    function () external payable {}\n\n    function setOwner(address newOwner) public {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction10(bytes memory input) public pure returns (bytes memory) {\n        return input;\n    }\n}",
          "error message": ":1:79: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function setOwner(address ne ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    fallback() external payable {}\n\n    function randomFunction1(uint x) public pure returns (uint) {\n        return x * 2;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    function deposit() public payable {}\n\n    fallback() external {}\n\n    function randomFunction2() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    fallback() external payable {}\n\n    function withdraw(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction3(address addr) public pure returns (address) {\n        return addr;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    fallback() external {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction4() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    fallback() external payable {}\n\n    function balance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction5() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"data\"));\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    function receiveFunds() public payable {}\n\n    fallback() external {}\n\n    function randomFunction6(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    fallback() external payable {}\n\n    function transferOwnership(address newOwner) public {}\n\n    function randomFunction7() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    function depositEther() public payable {}\n\n    fallback() external payable {}\n\n    function getOwner() public view returns (address) {\n        return msg.sender;\n    }\n\n    function randomFunction8(uint x) public pure returns (uint) {\n        return x * x;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    fallback() external {}\n\n    function withdrawFunds(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction9() public pure returns (string memory) {\n        return \"World\";\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    fallback() external payable {}\n\n    function setOwner(address newOwner) public {}\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction10(bytes memory input) public pure returns (bytes memory) {\n        return input;\n    }\n}"
      }
    }
  },
  {
    "Changes12": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "If present, the receive ether function is called whenever the call data is empty (whether\nor not ether is received). This function is implicitly <code>payable</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract1 {\n    function() external {\n    }\n    \n    function getValue() public pure returns (uint) {\n        return 42;\n    }\n    \n    function randomFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract1 {     function() external {     }          function getValue() ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract2 {\n    function() external {\n    }\n    \n    function computeSum(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract2 {     function() external {     }          function computeSum ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract3 {\n    function() external {\n    }\n    \n    function calculate(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n    \n    function extraFunc() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract3 {     function() external {     }          function calculate( ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract4 {\n    function() external {\n    }\n    \n    function randomFunction() public pure returns (string memory) {\n        return \"Hello, Solidity!\";\n    }\n    \n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract4 {     function() external {     }          function randomFunc ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract5 {\n    function() external {\n    }\n    \n    function check(uint num) public pure returns (bool) {\n        return num > 10;\n    }\n    \n    function anotherCheck(uint num) public pure returns (bool) {\n        return num == 0;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract5 {     function() external {     }          function check(uint ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract6 {\n    function() external {\n    }\n    \n    function concatenate(string memory a, string memory b) public pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n    \n    function anotherFunction(uint num) public pure returns (uint) {\n        return num * 2;\n    }\n    \n    function auxiliaryFunc() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"test\"));\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract6 {     function() external {     }          function concatenat ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract7 {\n    function() external {\n    }\n    \n    function add(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n    \n    function auxiliaryFunc2() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract7 {     function() external {     }          function add(uint a ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract8 {\n    function() external {\n    }\n    \n    function greet() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n    \n    function combine(uint x, uint y) public pure returns (uint) {\n        return x + y;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract8 {     function() external {     }          function greet() pu ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract9 {\n    function() external {\n    }\n    \n    function isEven(uint number) public pure returns (bool) {\n        return number % 2 == 0;\n    }\n    \n    function randomOperation(uint a, uint b) public pure returns (uint) {\n        return a - b;\n    }\n    \n    function anotherCheck(uint a) public pure returns (bool) {\n        return a > 100;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract9 {     function() external {     }          function isEven(uin ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract10 {\n    function() external {\n    }\n    \n    function multiply(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function checkCondition(uint value) public pure returns (bool) {\n        return value > 1000;\n    }\n    \n    function dummyFunction() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": ":1:71: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ntract10 {     function() external {     }          function multiply(u ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Contract1 {\n    fallback() external payable {\n    }\n    \n    function getValue() public pure returns (uint) {\n        return 42;\n    }\n    \n    function randomFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Contract2 {\n    fallback() external payable {\n    }\n    \n    function computeSum(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Contract3 {\n    fallback() external payable {\n    }\n    \n    function calculate(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n    \n    function extraFunc() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Contract4 {\n    fallback() external payable {\n    }\n    \n    function randomFunction() public pure returns (string memory) {\n        return \"Hello, Solidity!\";\n    }\n    \n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Contract5 {\n    fallback() external payable {\n    }\n    \n    function check(uint num) public pure returns (bool) {\n        return num > 10;\n    }\n    \n    function anotherCheck(uint num) public pure returns (bool) {\n        return num == 0;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Contract6 {\n    fallback() external payable {\n    }\n    \n    function concatenate(string memory a, string memory b) public pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n    \n    function anotherFunction(uint num) public pure returns (uint) {\n        return num * 2;\n    }\n    \n    function auxiliaryFunc() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"test\"));\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Contract7 {\n    fallback() external payable {\n    }\n    \n    function add(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n    \n    function auxiliaryFunc2() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Contract8 {\n    fallback() external payable {\n    }\n    \n    function greet() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n    \n    function combine(uint x, uint y) public pure returns (uint) {\n        return x + y;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Contract9 {\n    fallback() external payable {\n    }\n    \n    function isEven(uint number) public pure returns (bool) {\n        return number % 2 == 0;\n    }\n    \n    function randomOperation(uint a, uint b) public pure returns (uint) {\n        return a - b;\n    }\n    \n    function anotherCheck(uint a) public pure returns (bool) {\n        return a > 100;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Contract10 {\n    fallback() external payable {\n    }\n    \n    function multiply(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function checkCondition(uint value) public pure returns (bool) {\n        return value > 1000;\n    }\n    \n    function dummyFunction() public pure returns (uint) {\n        return 123;\n    }\n}"
      }
    }
  },
  {
    "Changes13": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The new fallback function is called when no other function matches (if the receive ether\nfunction does not exist then this includes calls with empty call data).\nYou can make this function <code>payable</code> or not. If it is not <code>payable</code> then transactions\nnot matching any other function which send value will revert. You should only need to\nimplement the new fallback function if you are following an upgrade or proxy pattern.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleOne {\n    uint256 public total;\n\n    function() external {\n        total += 1;\n    }\n\n    function getTotal() public view returns (uint256) {\n        return total;\n    }\n}",
          "error message": ":1:98: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic total;      function() external {         total += 1;     }      fun ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleTwo {\n    address public owner;\n\n    function() external {\n        owner = msg.sender;\n    }\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n}",
          "error message": ":1:98: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic owner;      function() external {         owner = msg.sender;     }  ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleThree {\n    string public message = \"Hello World\";\n\n    function() external {\n        message = \"Fallback called\";\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n\n    function getMessage() public view returns (string memory) {\n        return message;\n    }\n}",
          "error message": ":1:117: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... o World\";      function() external {         message = \"Fallback called ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleFour {\n    uint public count;\n\n    function() external {\n        count++;\n    }\n\n    function resetCount() public {\n        count = 0;\n    }\n}",
          "error message": ":1:96: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic count;      function() external {         count++;     }      functi ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleFive {\n    bool public flag;\n\n    function() external {\n        flag = !flag;\n    }\n\n    function checkFlag() public view returns (bool) {\n        return flag;\n    }\n}",
          "error message": ":1:95: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... lic flag;      function() external {         flag = !flag;     }      f ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleSix {\n    bytes32 public data;\n\n    function() external {\n        data = keccak256(abi.encodePacked(msg.sender));\n    }\n\n    function getData() public view returns (bytes32) {\n        return data;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... lic data;      function() external {         data = keccak256(abi.encod ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleSeven {\n    uint public value;\n\n    function() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic value;      function() external {         value = 100;     }      fu ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleEight {\n    uint public value;\n\n    function() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic value;      function() external {         value = 100;     }      fu ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleNine {\n    string public status;\n\n    function() external {\n        status = \"Fallback activated\";\n    }\n\n    function getStatus() public view returns (string memory) {\n        return status;\n    }\n}",
          "error message": ":1:99: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... c status;      function() external {         status = \"Fallback activat ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleTen {\n    uint public counter;\n\n    function() external {\n        counter += 10;\n    }\n\n    function increment() public {\n        counter++;\n    }\n\n    function decrement() public {\n        counter--;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ...  counter;      function() external {         counter += 10;     }       ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ExampleOne {\n    uint256 public total;\n\n    fallback() external {\n        total += 1;\n    }\n\n    function getTotal() public view returns (uint256) {\n        return total;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ExampleTwo {\n    address public owner;\n\n    fallback() external {\n        owner = msg.sender;\n    }\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ExampleThree {\n    string public message = \"Hello World\";\n\n    fallback() external {\n        message = \"Fallback called\";\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n\n    function getMessage() public view returns (string memory) {\n        return message;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ExampleFour {\n    uint public count;\n\n    fallback() external {\n        count++;\n    }\n\n    function resetCount() public {\n        count = 0;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ExampleFive {\n    bool public flag;\n\n    fallback() external {\n        flag = !flag;\n    }\n\n    function checkFlag() public view returns (bool) {\n        return flag;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ExampleSix {\n    bytes32 public data;\n\n    fallback() external {\n        data = keccak256(abi.encodePacked(msg.sender));\n    }\n\n    function getData() public view returns (bytes32) {\n        return data;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ExampleSeven {\n    uint public value;\n\n    fallback() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ExampleEight {\n    uint public value;\n\n    fallback() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ExampleNine {\n    string public status;\n\n    fallback() external {\n        status = \"Fallback activated\";\n    }\n\n    function getStatus() public view returns (string memory) {\n        return status;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ExampleTen {\n    uint public counter;\n\n    fallback() external {\n        counter += 10;\n    }\n\n    function increment() public {\n        counter++;\n    }\n\n    function decrement() public {\n        counter--;\n    }\n}"
      }
    }
  },
  {
    "Changes14": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "In external function and contract creation calls, Ether and gas is now specified using a new syntax:\n<code>x.f{gas: 10000, value: 2 ether}(arg1, arg2)</code>.\nThe old syntax \u2013 <code>x.f.gas(10000).value(2 ether)(arg1, arg2)</code> \u2013 will cause an error.Change <code>x.f.value(...)()</code> to <code>x.f{value: ...}()</code>. Similarly <code>(new C).value(...)()</code> to <code>new C{value: ...}()</code> and <code>x.f.gas(...).value(...)()</code> to <code>x.f{gas: ..., value: ...}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    function actionK() external payable {\n    }\n}\n\ncontract Example11 {\n    ContractK contractK;\n\n    function triggerActionK() public {\n        contractK.actionK.value(0.3 ether)();\n    }\n\n    function miscellaneousFunction11() public pure returns(string memory) {\n        return \"Miscellaneous 11\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionK() public {         contractK.actionK.value(0.3 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    function actionL() external payable {\n    }\n}\n\ncontract Example12 {\n    ContractL contractL;\n\n    function triggerActionL() public {\n        contractL.actionL.value(0.2 ether)();\n    }\n\n    function miscellaneousFunction12() public pure returns(string memory) {\n        return \"Miscellaneous 12\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionL() public {         contractL.actionL.value(0.2 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    function actionM() external payable {\n    }\n}\n\ncontract Example13 {\n    ContractM contractM;\n\n    function triggerActionM() public {\n        contractM.actionM.value(1.5 ether)();\n    }\n\n    function miscellaneousFunction13() public pure returns(string memory) {\n        return \"Miscellaneous 13\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionM() public {         contractM.actionM.value(1.5 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    function actionN() external payable {\n    }\n}\n\ncontract Example14 {\n    ContractN contractN;\n\n    function triggerActionN() public {\n        contractN.actionN.value(0.05 ether)();\n    }\n\n    function miscellaneousFunction14() public pure returns(string memory) {\n        return \"Miscellaneous 14\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionN() public {         contractN.actionN.value(0.05 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    function actionO() external payable {\n    }\n}\n\ncontract Example15 {\n    ContractO contractO;\n\n    function triggerActionO() public {\n        contractO.actionO.value(2.5 ether)();\n    }\n\n    function miscellaneousFunction15() public pure returns(string memory) {\n        return \"Miscellaneous 15\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionO() public {         contractO.actionO.value(2.5 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    function actionP() external payable {\n    }\n}\n\ncontract Example16 {\n    ContractP contractP;\n\n    function triggerActionP() public {\n        contractP.actionP.value(0.4 ether)();\n    }\n\n    function miscellaneousFunction16() public pure returns(string memory) {\n        return \"Miscellaneous 16\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionP() public {         contractP.actionP.value(0.4 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    function actionQ() external payable {\n    }\n}\n\ncontract Example17 {\n    ContractQ contractQ;\n\n    function triggerActionQ() public {\n        contractQ.actionQ.value(3 ether)();\n    }\n\n    function miscellaneousFunction17() public pure returns(string memory) {\n        return \"Miscellaneous 17\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionQ() public {         contractQ.actionQ.value(3 ether)();     }      function mi ...\n                                        ^---------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    function actionR() external payable {\n    }\n}\n\ncontract Example18 {\n    ContractR contractR;\n\n    function triggerActionR() public {\n        contractR.actionR.value(0.75 ether)();\n    }\n\n    function miscellaneousFunction18() public pure returns(string memory) {\n        return \"Miscellaneous 18\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionR() public {         contractR.actionR.value(0.75 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    function actionS() external payable {\n    }\n}\n\ncontract Example19 {\n    ContractS contractS;\n\n    function triggerActionS() public {\n        contractS.actionS.value(1.25 ether)();\n    }\n\n    function miscellaneousFunction19() public pure returns(string memory) {\n        return \"Miscellaneous 19\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionS() public {         contractS.actionS.value(1.25 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    function actionT() external payable {\n    }\n}\n\ncontract Example20 {\n    ContractT contractT;\n\n    function triggerActionT() public {\n        contractT.actionT.value(0.125 ether)();\n    }\n\n    function miscellaneousFunction20() public pure returns(string memory) {\n        return \"Miscellaneous 20\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionT() public {         contractT.actionT.value(0.125 ether)();     }      functio ...\n                                        ^---------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    function actionK() external payable {\n    }\n}\n\ncontract Example11 {\n    ContractK contractK;\n\n    function triggerActionK() public {\n        contractK.actionK{value: 0.3 ether}();\n    }\n\n    function miscellaneousFunction11() public pure returns(string memory) {\n        return \"Miscellaneous 11\";\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    function actionL() external payable {\n    }\n}\n\ncontract Example12 {\n    ContractL contractL;\n\n    function triggerActionL() public {\n        contractL.actionL{value: 0.2 ether}();\n    }\n\n    function miscellaneousFunction12() public pure returns(string memory) {\n        return \"Miscellaneous 12\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    function actionM() external payable {\n    }\n}\n\ncontract Example13 {\n    ContractM contractM;\n\n    function triggerActionM() public {\n        contractM.actionM{value: 1.5 ether}();\n    }\n\n    function miscellaneousFunction13() public pure returns(string memory) {\n        return \"Miscellaneous 13\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    function actionN() external payable {\n    }\n}\n\ncontract Example14 {\n    ContractN contractN;\n\n    function triggerActionN() public {\n        contractN.actionN{value: 0.05 ether}();\n    }\n\n    function miscellaneousFunction14() public pure returns(string memory) {\n        return \"Miscellaneous 14\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    function actionO() external payable {\n    }\n}\n\ncontract Example15 {\n    ContractO contractO;\n\n    function triggerActionO() public {\n        contractO.actionO{value: 2.5 ether}();\n    }\n\n    function miscellaneousFunction15() public pure returns(string memory) {\n        return \"Miscellaneous 15\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    function actionP() external payable {\n    }\n}\n\ncontract Example16 {\n    ContractP contractP;\n\n    function triggerActionP() public {\n        contractP.actionP{value: 0.4 ether}();\n    }\n\n    function miscellaneousFunction16() public pure returns(string memory) {\n        return \"Miscellaneous 16\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    function actionQ() external payable {\n    }\n}\n\ncontract Example17 {\n    ContractQ contractQ;\n\n    function triggerActionQ() public {\n        contractQ.actionQ{value: 3 ether}();\n    }\n\n    function miscellaneousFunction17() public pure returns(string memory) {\n        return \"Miscellaneous 17\";\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    function actionR() external payable {\n    }\n}\n\ncontract Example18 {\n    ContractR contractR;\n\n    function triggerActionR() public {\n        contractR.actionR{value: 0.75 ether}();\n    }\n\n    function miscellaneousFunction18() public pure returns(string memory) {\n        return \"Miscellaneous 18\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    function actionS() external payable {\n    }\n}\n\ncontract Example19 {\n    ContractS contractS;\n\n    function triggerActionS() public {\n        contractS.actionS{value: 1.25 ether}();\n    }\n\n    function miscellaneousFunction19() public pure returns(string memory) {\n        return \"Miscellaneous 19\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    function actionT() external payable {\n    }\n}\n\ncontract Example20 {\n    ContractT contractT;\n\n    function triggerActionT() public {\n        contractT.actionT{value: 0.125 ether}();\n    }\n\n    function miscellaneousFunction20() public pure returns(string memory) {\n        return \"Miscellaneous 20\";\n    }\n}"
      }
    }
  },
  {
    "Changes15": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The global variable <code>now</code> is deprecated, <code>block.timestamp</code> should be used instead.\nThe single identifier <code>now</code> is too generic for a global variable and could give the impression\nthat it changes during transaction processing, whereas <code>block.timestamp</code> correctly\nreflects the fact that it is just a property of the block.Change <code>now</code> to <code>block.timestamp</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public lastCheckpoint;\n\n    function markCheckpoint() public {\n        lastCheckpoint = now;\n    }\n\n    uint public checkpointsMade;\n\n    function incrementCheckpoints() public {\n        checkpointsMade++;\n    }\n}",
          "error message": ":1:143: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ...  public {         lastCheckpoint = now;     }      uint public checkpoint ...\n                                        ^-^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public lastReset;\n\n    function reset() public {\n        lastReset = now;\n    }\n\n    uint public resetCount;\n\n    function incrementResetCount() public {\n        resetCount++;\n    }\n}",
          "error message": ":1:124: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... set() public {         lastReset = now;     }      uint public resetCount ...\n                                        ^-^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public lastEntry;\n\n    function logEntry() public {\n        lastEntry = now;\n    }\n\n    uint public entriesLogged;\n\n    function incrementEntriesLogged() public {\n        entriesLogged++;\n    }\n}",
          "error message": ":1:127: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... try() public {         lastEntry = now;     }      uint public entriesLog ...\n                                        ^-^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public lastSignIn;\n\n    function signIn() public {\n        lastSignIn = now;\n    }\n\n    uint public signInCount;\n\n    function incrementSignInCount() public {\n        signInCount++;\n    }\n}",
          "error message": ":1:127: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... In() public {         lastSignIn = now;     }      uint public signInCoun ...\n                                        ^-^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public lastRegistration;\n\n    function register() public {\n        lastRegistration = now;\n    }\n\n    uint public registrationCount;\n\n    function incrementRegistrationCount() public {\n        registrationCount++;\n    }\n}",
          "error message": ":1:141: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ublic {         lastRegistration = now;     }      uint public registrati ...\n                                        ^-^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public lastActivity;\n\n    function recordActivity() public {\n        lastActivity = now;\n    }\n\n    uint public activityCount;\n\n    function incrementActivityCount() public {\n        activityCount++;\n    }\n}",
          "error message": ":1:139: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastActivity = now;     }      uint public activityCo ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public lastPurchase;\n\n    function makePurchase() public {\n        lastPurchase = now;\n    }\n\n    uint public purchaseCount;\n\n    function incrementPurchaseCount() public {\n        purchaseCount++;\n    }\n}",
          "error message": ":1:137: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastPurchase = now;     }      uint public purchaseCo ...\n                                        ^-^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public lastDownload;\n\n    function download() public {\n        lastDownload = now;\n    }\n\n    uint public downloadCount;\n\n    function incrementDownloadCount() public {\n        downloadCount++;\n    }\n}",
          "error message": ":1:133: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastDownload = now;     }      uint public downloadCo ...\n                                        ^-^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public lastModification;\n\n    function modify() public {\n        lastModification = now;\n    }\n\n    uint public modificationsMade;\n\n    function incrementModifications() public {\n        modificationsMade++;\n    }\n}",
          "error message": ":1:139: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ublic {         lastModification = now;     }      uint public modificati ...\n                                        ^-^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public lastQuery;\n\n    function query() public {\n        lastQuery = now;\n    }\n\n    uint public queryCount;\n\n    function incrementQueryCount() public {\n        queryCount++;\n    }\n}",
          "error message": ":1:124: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ery() public {         lastQuery = now;     }      uint public queryCount ...\n                                        ^-^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public lastCheckpoint;\n\n    function markCheckpoint() public {\n        lastCheckpoint = block.timestamp;\n    }\n\n    uint public checkpointsMade;\n\n    function incrementCheckpoints() public {\n        checkpointsMade++;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public lastReset;\n\n    function reset() public {\n        lastReset = block.timestamp;\n    }\n\n    uint public resetCount;\n\n    function incrementResetCount() public {\n        resetCount++;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public lastEntry;\n\n    function logEntry() public {\n        lastEntry = block.timestamp;\n    }\n\n    uint public entriesLogged;\n\n    function incrementEntriesLogged() public {\n        entriesLogged++;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public lastSignIn;\n\n    function signIn() public {\n        lastSignIn = block.timestamp;\n    }\n\n    uint public signInCount;\n\n    function incrementSignInCount() public {\n        signInCount++;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public lastRegistration;\n\n    function register() public {\n        lastRegistration = block.timestamp;\n    }\n\n    uint public registrationCount;\n\n    function incrementRegistrationCount() public {\n        registrationCount++;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public lastActivity;\n\n    function recordActivity() public {\n        lastActivity = block.timestamp;\n    }\n\n    uint public activityCount;\n\n    function incrementActivityCount() public {\n        activityCount++;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public lastPurchase;\n\n    function makePurchase() public {\n        lastPurchase = block.timestamp;\n    }\n\n    uint public purchaseCount;\n\n    function incrementPurchaseCount() public {\n        purchaseCount++;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public lastDownload;\n\n    function download() public {\n        lastDownload = block.timestamp;\n    }\n\n    uint public downloadCount;\n\n    function incrementDownloadCount() public {\n        downloadCount++;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public lastModification;\n\n    function modify() public {\n        lastModification = block.timestamp;\n    }\n\n    uint public modificationsMade;\n\n    function incrementModifications() public {\n        modificationsMade++;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public lastQuery;\n\n    function query() public {\n        lastQuery = block.timestamp;\n    }\n\n    uint public queryCount;\n\n    function incrementQueryCount() public {\n        queryCount++;\n    }\n}"
      }
    }
  },
  {
    "Changes16": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "NatSpec comments on variables are only allowed for public state variables and not\nfor local or internal variables.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public length;\n\n    function setLength(uint256 _length) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localLength = _length;\n        length = localLength;\n    }\n\n    function getLength() public view returns (uint256) {\n        return length;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:528: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public width;\n\n    function setWidth(uint256 _width) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localWidth = _width;\n        width = localWidth;\n    }\n\n    function getWidth() public view returns (uint256) {\n        return width;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:632: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public height;\n\n    function setHeight(uint256 _height) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localHeight = _height;\n        height = localHeight;\n    }\n\n    function getHeight() public view returns (uint256) {\n        return height;\n    }\n}",
          "error message": ":1:421: ParserError: Function, variable, struct or modifier declaration expected.\n ... 6) {         return height;     } }\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public depth;\n\n    function setDepth(uint256 _depth) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localDepth = _depth;\n        depth = localDepth;\n    }\n\n    function getDepth() public view returns (uint256) {\n        return depth;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:519: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public radius;\n\n    function setRadius(uint256 _radius) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localRadius = _radius;\n        radius = localRadius;\n    }\n\n    function getRadius() public view returns (uint256) {\n        return radius;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
          "error message": ":1:531: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 1\";     } }\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public diameter;\n\n    function setDiameter(uint256 _diameter) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localDiameter = _diameter;\n        diameter = localDiameter;\n    }\n\n    function getDiameter() public view returns (uint256) {\n        return diameter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:659: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public volume;\n\n    function setVolume(uint256 _volume) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localVolume = _volume;\n        volume = localVolume;\n    }\n\n    function getVolume() public view returns (uint256) {\n        return volume;\n    }\n}",
          "error message": ":1:421: ParserError: Function, variable, struct or modifier declaration expected.\n ... 6) {         return volume;     } }\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public area;\n\n    function setArea(uint256 _area) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localArea = _area;\n        area = localArea;\n    }\n\n    function getArea() public view returns (uint256) {\n        return area;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:510: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public perimeter;\n\n    function setPerimeter(uint256 _perimeter) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localPerimeter = _perimeter;\n        perimeter = localPerimeter;\n    }\n\n    function getPerimeter() public view returns (uint256) {\n        return perimeter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
          "error message": ":1:558: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 1\";     } }\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public circumference;\n\n    function setCircumference(uint256 _circumference) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localCircumference = _circumference;\n        circumference = localCircumference;\n    }\n\n    function getCircumference() public view returns (uint256) {\n        return circumference;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:704: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ContractK {\n    uint256 public length;\n\n    function setLength(uint256 _length) public {\n        uint256 localLength = _length;\n        length = localLength;\n    }\n\n    function getLength() public view returns (uint256) {\n        return length;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract ContractL {\n    uint256 public width;\n\n    function setWidth(uint256 _width) public {\n        uint256 localWidth = _width;\n        width = localWidth;\n    }\n\n    function getWidth() public view returns (uint256) {\n        return width;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ContractM {\n    uint256 public height;\n\n    function setHeight(uint256 _height) public {\n        uint256 localHeight = _height;\n        height = localHeight;\n    }\n\n    function getHeight() public view returns (uint256) {\n        return height;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ContractN {\n    uint256 public depth;\n\n    function setDepth(uint256 _depth) public {\n        uint256 localDepth = _depth;\n        depth = localDepth;\n    }\n\n    function getDepth() public view returns (uint256) {\n        return depth;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ContractO {\n    uint256 public radius;\n\n    function setRadius(uint256 _radius) public {\n        uint256 localRadius = _radius;\n        radius = localRadius;\n    }\n\n    function getRadius() public view returns (uint256) {\n        return radius;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract ContractP {\n    uint256 public diameter;\n\n    function setDiameter(uint256 _diameter) public {\n        uint256 localDiameter = _diameter;\n        diameter = localDiameter;\n    }\n\n    function getDiameter() public view returns (uint256) {\n        return diameter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ContractQ {\n    uint256 public volume;\n\n    function setVolume(uint256 _volume) public {\n        uint256 localVolume = _volume;\n        volume = localVolume;\n    }\n\n    function getVolume() public view returns (uint256) {\n        return volume;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ContractR {\n    uint256 public area;\n\n    function setArea(uint256 _area) public {\n        uint256 localArea = _area;\n        area = localArea;\n    }\n\n    function getArea() public view returns (uint256) {\n        return area;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract ContractS {\n    uint256 public perimeter;\n\n    function setPerimeter(uint256 _perimeter) public {\n        uint256 localPerimeter = _perimeter;\n        perimeter = localPerimeter;\n    }\n\n    function getPerimeter() public view returns (uint256) {\n        return perimeter;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract ContractT {\n    uint256 public circumference;\n\n    function setCircumference(uint256 _circumference) public {\n        uint256 localCircumference = _circumference;\n        circumference = localCircumference;\n    }\n\n    function getCircumference() public view returns (uint256) {\n        return circumference;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}"
      }
    }
  },
  {
    "Changes17": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The token <code>gwei</code> is a keyword now (used to specify, e.g. <code>2 gwei</code> as a number)\nand cannot be used as an identifier.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public gwei;\n    uint public amount;\n\n    constructor(uint _amount) public {\n        gwei = 450;\n        amount = _amount;\n    }\n\n    function setGweiAmount(uint _gwei, uint _amount) public {\n        gwei = _gwei;\n        amount = _amount;\n    }\n\n    function getGweiAmount() public view returns (uint, uint) {\n        return (gwei, amount);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example11 {     uint public gwei;     uint public amount;      cons ...\n                                        ^--^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public gwei;\n    bool public isActive;\n\n    constructor() public {\n        gwei = 900;\n        isActive = true;\n    }\n\n    function toggleActive() public {\n        isActive = !isActive;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gwei, isActive);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example12 {     uint public gwei;     bool public isActive;      co ...\n                                        ^--^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public gwei;\n    uint public rate;\n\n    constructor(uint _rate) public {\n        gwei = 600;\n        rate = _rate;\n    }\n\n    function setGweiRate(uint _gwei, uint _rate) public {\n        gwei = _gwei;\n        rate = _rate;\n    }\n\n    function getGweiRate() public view returns (uint, uint) {\n        return (gwei, rate);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example13 {     uint public gwei;     uint public rate;      constr ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public gwei;\n\n    constructor() public {\n        gwei = 350;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGwei() public view returns (uint) {\n        return gwei;\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example14 {     uint public gwei;      constructor() public {       ...\n                                        ^--^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public gwei;\n    address public owner;\n\n    constructor(address _owner) public {\n        gwei = 250;\n        owner = _owner;\n    }\n\n    function setOwnerGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiOwner() public view returns (uint, address) {\n        return (gwei, owner);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example15 {     uint public gwei;     address public owner;      co ...\n                                        ^--^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public gwei;\n    string public description;\n\n    constructor(string memory _description) public {\n        gwei = 700;\n        description = _description;\n    }\n\n    function modifyGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiDescription() public view returns (uint, string memory) {\n        return (gwei, description);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example16 {     uint public gwei;     string public description;    ...\n                                        ^--^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public gwei;\n    bool public status;\n\n    constructor() public {\n        gwei = 80;\n        status = false;\n    }\n\n    function setGweiStatus(uint _gwei, bool _status) public {\n        gwei = _gwei;\n        status = _status;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gwei, status);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example17 {     uint public gwei;     bool public status;      cons ...\n                                        ^--^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public gwei;\n    uint public price;\n\n    constructor(uint _price) public {\n        gwei = 100;\n        price = _price;\n    }\n\n    function setGweiPrice(uint _gwei, uint _price) public {\n        gwei = _gwei;\n        price = _price;\n    }\n\n    function getGweiPrice() public view returns (uint, uint) {\n        return (gwei, price);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example18 {     uint public gwei;     uint public price;      const ...\n                                        ^--^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public gwei;\n    uint public count;\n\n    constructor() public {\n        gwei = 123;\n        count = 0;\n    }\n\n    function incrementCount() public {\n        count++;\n    }\n\n    function setGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiCount() public view returns (uint, uint) {\n        return (gwei, count);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example19 {     uint public gwei;     uint public count;      const ...\n                                        ^--^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public gwei;\n    string public info;\n\n    constructor(string memory _info) public {\n        gwei = 987;\n        info = _info;\n    }\n\n    function updateGweiInfo(uint _gwei, string memory _info) public {\n        gwei = _gwei;\n        info = _info;\n    }\n\n    function getGweiInfo() public view returns (uint, string memory) {\n        return (gwei, info);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example20 {     uint public gwei;     string public info;      cons ...\n                                        ^--^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public gweiValue;\n    uint public amount;\n\n    constructor(uint _amount) public {\n        gweiValue = 450;\n        amount = _amount;\n    }\n\n    function setGweiAmount(uint _gwei, uint _amount) public {\n        gweiValue = _gwei;\n        amount = _amount;\n    }\n\n    function getGweiAmount() public view returns (uint, uint) {\n        return (gweiValue, amount);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public gweiValue;\n    bool public isActive;\n\n    constructor() public {\n        gweiValue = 900;\n        isActive = true;\n    }\n\n    function toggleActive() public {\n        isActive = !isActive;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gweiValue, isActive);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public gweiValue;\n    uint public rate;\n\n    constructor(uint _rate) public {\n        gweiValue = 600;\n        rate = _rate;\n    }\n\n    function setGweiRate(uint _gwei, uint _rate) public {\n        gweiValue = _gwei;\n        rate = _rate;\n    }\n\n    function getGweiRate() public view returns (uint, uint) {\n        return (gweiValue, rate);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public gweiValue;\n\n    constructor() public {\n        gweiValue = 350;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGwei() public view returns (uint) {\n        return gweiValue;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public gweiValue;\n    address public owner;\n\n    constructor(address _owner) public {\n        gweiValue = 250;\n        owner = _owner;\n    }\n\n    function setOwnerGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiOwner() public view returns (uint, address) {\n        return (gweiValue, owner);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public gweiValue;\n    string public description;\n\n    constructor(string memory _description) public {\n        gweiValue = 700;\n        description = _description;\n    }\n\n    function modifyGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiDescription() public view returns (uint, string memory) {\n        return (gweiValue, description);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public gweiValue;\n    bool public status;\n\n    constructor() public {\n        gweiValue = 80;\n        status = false;\n    }\n\n    function setGweiStatus(uint _gwei, bool _status) public {\n        gweiValue = _gwei;\n        status = _status;\n    }\n\n    function getGweiStatus() public view returns (uint, bool) {\n        return (gweiValue, status);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public gweiValue;\n    uint public price;\n\n    constructor(uint _price) public {\n        gweiValue = 100;\n        price = _price;\n    }\n\n    function setGweiPrice(uint _gwei, uint _price) public {\n        gweiValue = _gwei;\n        price = _price;\n    }\n\n    function getGweiPrice() public view returns (uint, uint) {\n        return (gweiValue, price);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public gweiValue;\n    uint public count;\n\n    constructor() public {\n        gweiValue = 123;\n        count = 0;\n    }\n\n    function incrementCount() public {\n        count++;\n    }\n\n    function setGwei(uint _gwei) public {\n        gweiValue = _gwei;\n    }\n\n    function getGweiCount() public view returns (uint, uint) {\n        return (gweiValue, count);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public gweiValue;\n    string public info;\n\n    constructor(string memory _info) public {\n        gweiValue = 987;\n        info = _info;\n    }\n\n    function updateGweiInfo(uint _gwei, string memory _info) public {\n        gweiValue = _gwei;\n        info = _info;\n    }\n\n    function getGweiInfo() public view returns (uint, string memory) {\n        return (gweiValue, info);\n    }\n}"
      }
    }
  },
  {
    "Changes18": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Disallow <code>.</code> in user-defined function and variable names in inline assembly.\nIt is still valid if you use Solidity in Yul-only mode.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint256 public finalOutput;\n\n    function compute() public {\n        uint256 x = 17;\n        uint256 y = 27;\n        uint256 res;\n\n        assembly {\n            function sumValues(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let result.val := sumValues(x, y)\n\n            res := result.val\n        }\n\n        finalOutput = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 123;\n    }\n}",
          "error message": ":1:314: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let result.val := sumValues(x, y)              re ...\n                                        ^--------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint256 public finalResult;\n\n    function calculate() public {\n        uint256 m = 21;\n        uint256 n = 15;\n        uint256 res;\n\n        assembly {\n            function sumNumbers(a, b) -> totalSum {\n                totalSum := add(a, b)\n            }\n\n            let total.result := sumNumbers(m, n)\n\n            res := total.result\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:323: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let total.result := sumNumbers(m, n)              r ...\n                                        ^----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint256 public output;\n\n    function execute() public {\n        uint256 p = 19;\n        uint256 q = 23;\n        uint256 res;\n\n        assembly {\n            function addValues(c, d) -> sum {\n                sum := add(c, d)\n            }\n\n            let var.sum := addValues(p, q)\n\n            res := var.sum\n        }\n\n        output = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Test\";\n    }\n\n    function unrelatedFunction2() public pure returns (uint256) {\n        return 456;\n    }\n}",
          "error message": ":1:305: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  d)             }              let var.sum := addValues(p, q)              re ...\n                                        ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint256 public resultValue;\n\n    function computeResult() public {\n        uint256 w = 11;\n        uint256 z = 18;\n        uint256 res;\n\n        assembly {\n            function calculateSum(e, f) -> finalSum {\n                finalSum := add(e, f)\n            }\n\n            let res.total := calculateSum(w, z)\n\n            res := res.total\n        }\n\n        resultValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}",
          "error message": ":1:329: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  f)             }              let res.total := calculateSum(w, z)              ...\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint256 public finalOutcome;\n\n    function perform() public {\n        uint256 a = 14;\n        uint256 b = 16;\n        uint256 res;\n\n        assembly {\n            function computeTotal(x, y) -> totalSum {\n                totalSum := add(x, y)\n            }\n\n            let total.value := computeTotal(a, b)\n\n            res := total.value\n        }\n\n        finalOutcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 789;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:324: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  y)             }              let total.value := computeTotal(a, b)              ...\n                                        ^---------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint256 public result;\n\n    function calculate() public {\n        uint256 x = 13;\n        uint256 y = 14;\n        uint256 res;\n\n        assembly {\n            function addNumbers(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let calc.sum := addNumbers(x, y)\n\n            res := calc.sum\n        }\n\n        result = res;\n    }\n}",
          "error message": ":1:308: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let calc.sum := addNumbers(x, y)              r ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint256 public finalValue;\n\n    function runCalculation() public {\n        uint256 p = 10;\n        uint256 q = 30;\n        uint256 res;\n\n        assembly {\n            function getTotal(m, n) -> totalSum {\n                totalSum := add(m, n)\n            }\n\n            let sum.result := getTotal(p, q)\n\n            res := sum.result\n        }\n\n        finalValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
          "error message": ":1:325: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  n)             }              let sum.result := getTotal(p, q)              res ...\n                                        ^--------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint256 public outputValue;\n\n    function executeCalculation() public {\n        uint256 g = 12;\n        uint256 h = 24;\n        uint256 res;\n\n        assembly {\n            function findSum(i, j) -> sumResult {\n                sumResult := add(i, j)\n            }\n\n            let result.sum := findSum(g, h)\n\n            res := result.sum\n        }\n\n        outputValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 111;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:331: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  j)             }              let result.sum := findSum(g, h)              res  ...\n                                        ^--------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint256 public outcome;\n\n    function performCalculation() public {\n        uint256 w = 25;\n        uint256 z = 5;\n        uint256 res;\n\n        assembly {\n            function computeSum(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let total.result := computeSum(w, z)\n\n            res := total.result\n        }\n\n        outcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:321: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let total.result := computeSum(w, z)              r ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint256 public finalResult;\n\n    function calculateTotal() public {\n        uint256 x = 8;\n        uint256 y = 22;\n        uint256 res;\n\n        assembly {\n            function calculate(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let result.sum := calculate(x, y)\n\n            res := result.sum\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 888;\n    }\n\n    function unrelatedFunction2() public pure returns (string memory) {\n        return \"World\";\n    }\n}",
          "error message": ":1:316: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let result.sum := calculate(x, y)              re ...\n                                        ^--------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint256 public finalOutput;\n\n    function compute() public {\n        uint256 x = 17;\n        uint256 y = 27;\n        uint256 res;\n\n        assembly {\n            function sumValues(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let resultVal := sumValues(x, y)\n\n            res := resultVal\n        }\n\n        finalOutput = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 123;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint256 public finalResult;\n\n    function calculate() public {\n        uint256 m = 21;\n        uint256 n = 15;\n        uint256 res;\n\n        assembly {\n            function sumNumbers(a, b) -> totalSum {\n                totalSum := add(a, b)\n            }\n\n            let totalResult := sumNumbers(m, n)\n\n            res := totalResult\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint256 public output;\n\n    function execute() public {\n        uint256 p = 19;\n        uint256 q = 23;\n        uint256 res;\n\n        assembly {\n            function addValues(c, d) -> sum {\n                sum := add(c, d)\n            }\n\n            let varSum := addValues(p, q)\n\n            res := varSum\n        }\n\n        output = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Test\";\n    }\n\n    function unrelatedFunction2() public pure returns (uint256) {\n        return 456;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint256 public resultValue;\n\n    function computeResult() public {\n        uint256 w = 11;\n        uint256 z = 18;\n        uint256 res;\n\n        assembly {\n            function calculateSum(e, f) -> finalSum {\n                finalSum := add(e, f)\n            }\n\n            let resTotal := calculateSum(w, z)\n\n            res := resTotal\n        }\n\n        resultValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint256 public finalOutcome;\n\n    function perform() public {\n        uint256 a = 14;\n        uint256 b = 16;\n        uint256 res;\n\n        assembly {\n            function computeTotal(x, y) -> totalSum {\n                totalSum := add(x, y)\n            }\n\n            let totalValue := computeTotal(a, b)\n\n            res := totalValue\n        }\n\n        finalOutcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 789;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint256 public result;\n\n    function calculate() public {\n        uint256 x = 13;\n        uint256 y = 14;\n        uint256 res;\n\n        assembly {\n            function addNumbers(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let calcSum := addNumbers(x, y)\n\n            res := calcSum\n        }\n\n        result = res;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint256 public finalValue;\n\n    function runCalculation() public {\n        uint256 p = 10;\n        uint256 q = 30;\n        uint256 res;\n\n        assembly {\n            function getTotal(m, n) -> totalSum {\n                totalSum := add(m, n)\n            }\n\n            let sumResult := getTotal(p, q)\n\n            res := sumResult\n        }\n\n        finalValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint256 public outputValue;\n\n    function executeCalculation() public {\n        uint256 g = 12;\n        uint256 h = 24;\n        uint256 res;\n\n        assembly {\n            function findSum(i, j) -> sumResult {\n                sumResult := add(i, j)\n            }\n\n            let resultSum := findSum(g, h)\n\n            res := resultSum\n        }\n\n        outputValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 111;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint256 public outcome;\n\n    function performCalculation() public {\n        uint256 w = 25;\n        uint256 z = 5;\n        uint256 res;\n\n        assembly {\n            function computeSum(a, b) -> total {\n                total := add(a, b)\n            }\n\n            let totalResult := computeSum(w, z)\n\n            res := totalResult\n        }\n\n        outcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint256 public finalResult;\n\n    function calculateTotal() public {\n        uint256 x = 8;\n        uint256 y = 22;\n        uint256 res;\n\n        assembly {\n            function calculate(a, b) -> sum {\n                sum := add(a, b)\n            }\n\n            let resultSum := calculate(x, y)\n\n            res := resultSum\n        }\n\n        finalResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 888;\n    }\n\n    function unrelatedFunction2() public pure returns (string memory) {\n        return \"World\";\n    }\n}"
      }
    }
  },
  {
    "Changes19": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Slot and offset of storage pointer variable <code>x</code> are accessed via <code>x.slot</code>\nand <code>x.offset</code> instead of <code>x_slot</code> and <code>x_offset</code>.Change <code>_slot</code> and <code>_offset</code> suffixes in inline assembly to <code>.slot</code> and <code>.offset</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Customer {\n        uint id;\n    }\n\n    Customer public customer;\n\n    constructor() public {\n        customer.id = 123;\n    }\n\n    function getCustomerPointer() public view returns (uint slot, uint offset) {\n        uint customerSlot;\n        uint customerOffset;\n        assembly {\n            customerSlot := customer_slot\n            customerOffset := customer_offset\n        }\n        return (customerSlot, customerOffset);\n    }\n}",
          "error message": ":1:368: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... mbly {             customerSlot := customer_slot             customerOffset := cust ...\n                                        ^-----------^\n:1:412: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... slot             customerOffset := customer_offset         }         return (customer ...\n                                        ^-------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Ticket {\n        uint number;\n    }\n\n    Ticket public ticket;\n\n    constructor() public {\n        ticket.number = 456;\n    }\n\n    function fetchTicketPointer() public view returns (uint slot, uint offset) {\n        uint ticketSlot;\n        uint ticketOffset;\n        assembly {\n            ticketSlot := ticket_slot\n            ticketOffset := ticket_offset\n        }\n        return (ticketSlot, ticketOffset);\n    }\n}",
          "error message": ":1:362: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             ticketSlot := ticket_slot             ticketOffset := ticket ...\n                                        ^---------^\n:1:402: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... t_slot             ticketOffset := ticket_offset         }         return (ticketSl ...\n                                        ^-----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Box {\n        uint size;\n    }\n\n    Box public box;\n\n    constructor() public {\n        box.size = 789;\n    }\n\n    function retrieveBoxPointer() public view returns (uint slot, uint offset) {\n        uint boxSlot;\n        uint boxOffset;\n        assembly {\n            boxSlot := box_slot\n            boxOffset := box_offset\n        }\n        return (boxSlot, boxOffset);\n    }\n\n    function dummyFunctionOne() public pure returns (uint) {\n        return 1;\n    }\n}",
          "error message": ":1:337: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  assembly {             boxSlot := box_slot             boxOffset := box_offse ...\n                                        ^------^\n:1:371: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  box_slot             boxOffset := box_offset         }         return (boxSlot, ...\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Car {\n        uint speed;\n    }\n\n    Car public car;\n\n    constructor() public {\n        car.speed = 200;\n    }\n\n    function getCarPointer() public view returns (uint slot, uint offset) {\n        uint carSlot;\n        uint carOffset;\n        assembly {\n            carSlot := car_slot\n            carOffset := car_offset\n        }\n        return (carSlot, carOffset);\n    }\n}",
          "error message": ":1:334: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  assembly {             carSlot := car_slot             carOffset := car_offse ...\n                                        ^------^\n:1:368: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ...  car_slot             carOffset := car_offset         }         return (carSlot, ...\n                                        ^--------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Book {\n        uint pages;\n    }\n\n    Book public book;\n\n    constructor() public {\n        book.pages = 300;\n    }\n\n    function fetchBookPointer() public view returns (uint slot, uint offset) {\n        uint bookSlot;\n        uint bookOffset;\n        assembly {\n            bookSlot := book_slot\n            bookOffset := book_offset\n        }\n        return (bookSlot, bookOffset);\n    }\n\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 2;\n    }\n\n    function extraDummyFunctionTwo() public pure returns (uint) {\n        return 3;\n    }\n}",
          "error message": ":1:344: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             bookSlot := book_slot             bookOffset := book_off ...\n                                        ^-------^\n:1:380: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ook_slot             bookOffset := book_offset         }         return (bookSlot ...\n                                        ^---------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Movie {\n        uint duration;\n    }\n\n    Movie public movie;\n\n    constructor() public {\n        movie.duration = 120;\n    }\n\n    function getMoviePointer() public view returns (uint slot, uint offset) {\n        uint movieSlot;\n        uint movieOffset;\n        assembly {\n            movieSlot := movie_slot\n            movieOffset := movie_offset\n        }\n        return (movieSlot, movieOffset);\n    }\n}",
          "error message": ":1:356: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             movieSlot := movie_slot             movieOffset := movie_o ...\n                                        ^--------^\n:1:394: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ie_slot             movieOffset := movie_offset         }         return (movieSlo ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Laptop {\n        uint ram;\n    }\n\n    Laptop public laptop;\n\n    constructor() public {\n        laptop.ram = 16;\n    }\n\n    function retrieveLaptopPointer() public view returns (uint slot, uint offset) {\n        uint laptopSlot;\n        uint laptopOffset;\n        assembly {\n            laptopSlot := laptop_slot\n            laptopOffset := laptop_offset\n        }\n        return (laptopSlot, laptopOffset);\n    }\n}",
          "error message": ":1:358: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             laptopSlot := laptop_slot             laptopOffset := laptop ...\n                                        ^---------^\n:1:398: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... p_slot             laptopOffset := laptop_offset         }         return (laptopSl ...\n                                        ^-----------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Phone {\n        uint storage;\n    }\n\n    Phone public phone;\n\n    constructor() public {\n        phone.storage = 64;\n    }\n\n    function getPhonePointer() public view returns (uint slot, uint offset) {\n        uint phoneSlot;\n        uint phoneOffset;\n        assembly {\n            phoneSlot := phone_slot\n            phoneOffset := phone_offset\n        }\n        return (phoneSlot, phoneOffset);\n    }\n}",
          "error message": ":1:78: ParserError: Expected identifier but got 'storage'\n ...  {     struct Phone {         uint storage;     }      Phone public phone;    ...\n                                        ^-----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Chair {\n        uint legs;\n    }\n\n    Chair public chair;\n\n    constructor() public {\n        chair.legs = 4;\n    }\n\n    function fetchChairPointer() public view returns (uint slot, uint offset) {\n        uint chairSlot;\n        uint chairOffset;\n        assembly {\n            chairSlot := chair_slot\n            chairOffset := chair_offset\n        }\n        return (chairSlot, chairOffset);\n    }\n\n    function extraFunctionOne() public pure returns (string memory) {\n        return \"extra1\";\n    }\n}",
          "error message": ":1:348: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             chairSlot := chair_slot             chairOffset := chair_o ...\n                                        ^--------^\n:1:386: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ir_slot             chairOffset := chair_offset         }         return (chairSlo ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct House {\n        uint rooms;\n    }\n\n    House public house;\n\n    constructor() public {\n        house.rooms = 5;\n    }\n\n    function retrieveHousePointer() public view returns (uint slot, uint offset) {\n        uint houseSlot;\n        uint houseOffset;\n        assembly {\n            houseSlot := house_slot\n            houseOffset := house_offset\n        }\n        return (houseSlot, houseOffset);\n    }\n\n    function extraFunctionTwo() public pure returns (string memory) {\n        return \"extra2\";\n    }\n}",
          "error message": ":1:353: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             houseSlot := house_slot             houseOffset := house_o ...\n                                        ^--------^\n:1:391: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... se_slot             houseOffset := house_offset         }         return (houseSlo ...\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Customer {\n        uint id;\n    }\n\n    Customer public customer;\n\n    constructor() public {\n        customer.id = 123;\n    }\n\n    function getCustomerPointer() public view returns (uint slot, uint offset) {\n        uint customerSlot;\n        uint customerOffset;\n        assembly {\n            customerSlot := customer.slot\n            customerOffset := customer.offset\n        }\n        return (customerSlot, customerOffset);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Ticket {\n        uint number;\n    }\n\n    Ticket public ticket;\n\n    constructor() public {\n        ticket.number = 456;\n    }\n\n    function fetchTicketPointer() public view returns (uint slot, uint offset) {\n        uint ticketSlot;\n        uint ticketOffset;\n        assembly {\n            ticketSlot := ticket.slot\n            ticketOffset := ticket.offset\n        }\n        return (ticketSlot, ticketOffset);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Box {\n        uint size;\n    }\n\n    Box public box;\n\n    constructor() public {\n        box.size = 789;\n    }\n\n    function retrieveBoxPointer() public view returns (uint slot, uint offset) {\n        uint boxSlot;\n        uint boxOffset;\n        assembly {\n            boxSlot := box.slot\n            boxOffset := box.offset\n        }\n        return (boxSlot, boxOffset);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Car {\n        uint speed;\n    }\n\n    Car public car;\n\n    constructor() public {\n        car.speed = 200;\n    }\n\n    function getCarPointer() public view returns (uint slot, uint offset) {\n        uint carSlot;\n        uint carOffset;\n        assembly {\n            carSlot := car.slot\n            carOffset := car.offset\n        }\n        return (carSlot, carOffset);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Book {\n        uint pages;\n    }\n\n    Book public book;\n\n    constructor() public {\n        book.pages = 300;\n    }\n\n    function fetchBookPointer() public view returns (uint slot, uint offset) {\n        uint bookSlot;\n        uint bookOffset;\n        assembly {\n            bookSlot := book.slot\n            bookOffset := book.offset\n        }\n        return (bookSlot, bookOffset);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Movie {\n        uint duration;\n    }\n\n    Movie public movie;\n\n    constructor() public {\n        movie.duration = 120;\n    }\n\n    function getMoviePointer() public view returns (uint slot, uint offset) {\n        uint movieSlot;\n        uint movieOffset;\n        assembly {\n            movieSlot := movie.slot\n            movieOffset := movie.offset\n        }\n        return (movieSlot, movieOffset);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Laptop {\n        uint ram;\n    }\n\n    Laptop public laptop;\n\n    constructor() public {\n        laptop.ram = 16;\n    }\n\n    function retrieveLaptopPointer() public view returns (uint slot, uint offset) {\n        uint laptopSlot;\n        uint laptopOffset;\n        assembly {\n            laptopSlot := laptop.slot\n            laptopOffset := laptop.offset\n        }\n        return (laptopSlot, laptopOffset);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Phone {\n        uint storage;\n    }\n\n    Phone public phone;\n\n    constructor() public {\n        phone.storage = 64;\n    }\n\n    function getPhonePointer() public view returns (uint slot, uint offset) {\n        uint phoneSlot;\n        uint phoneOffset;\n        assembly {\n            phoneSlot := phone.slot\n            phoneOffset := phone.offset\n        }\n        return (phoneSlot, phoneOffset);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Chair {\n        uint legs;\n    }\n\n    Chair public chair;\n\n    constructor() public {\n        chair.legs = 4;\n    }\n\n    function fetchChairPointer() public view returns (uint slot, uint offset) {\n        uint chairSlot;\n        uint chairOffset;\n        assembly {\n            chairSlot := chair.slot\n            chairOffset := chair.offset\n        }\n        return (chairSlot, chairOffset);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct House {\n        uint rooms;\n    }\n\n    House public house;\n\n    constructor() public {\n        house.rooms = 5;\n    }\n\n    function retrieveHousePointer() public view returns (uint slot, uint offset) {\n        uint houseSlot;\n        uint houseOffset;\n        assembly {\n            houseSlot := house.slot\n            houseOffset := house.offset\n        }\n        return (houseSlot, houseOffset);\n    }\n}"
      }
    }
  },
  {
    "Changes20": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "If a struct or array contains a mapping, it can only be used in storage.\nPreviously, mapping members were silently skipped in memory, which\nis confusing and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct11 {\n    struct ExampleStruct {\n        uint256 data;\n        mapping(address => uint256) balances;\n    }\n    \n    ExampleStruct[] public examples;\n\n    function createStruct(uint256 _data) public {\n        ExampleStruct memory newExample;\n        newExample.data = _data;\n        examples.push(newExample);\n    }\n\n    function setBalance(uint256 index, address user, uint256 amount) public {\n        examples[index].balances[user] = amount;\n    }\n\n    function getBalance(uint256 index, address user) public view returns (uint256) {\n        return examples[index].balances[user];\n    }\n\n    function dummyFuncA() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:256: TypeError: Type struct MappingInStruct11.ExampleStruct is only valid in storage because it contains a (nested) mapping.\n ... ct(uint256 _data) public {         ExampleStruct memory newExample;         newExample.data = _data;  ...\n                                        ^-----------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct12 {\n    struct InfoStruct {\n        uint256 id;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _id) public {\n        InfoStruct memory newInfo;\n        newInfo.id = _id;\n        infos.push(newInfo);\n    }\n\n    function updateHoldings(uint256 index, address user, uint256 value) public {\n        infos[index].holdings[user] = value;\n    }\n\n    function fetchHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n\n    function dummyFuncB() public pure returns (string memory) {\n        return \"DummyB\";\n    }\n\n    function dummyFuncC() public pure returns (uint256) {\n        return 256;\n    }\n}",
          "error message": ":1:238: TypeError: Type struct MappingInStruct12.InfoStruct is only valid in storage because it contains a (nested) mapping.\n ... Info(uint256 _id) public {         InfoStruct memory newInfo;         newInfo.id = _id;         ...\n                                        ^-----------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct13 {\n    struct RecordStruct {\n        uint256 identifier;\n        mapping(address => uint256) funds;\n    }\n    \n    RecordStruct[] public records;\n\n    function addRecord(uint256 _identifier) public {\n        RecordStruct memory newRecord;\n        newRecord.identifier = _identifier;\n        records.push(newRecord);\n    }\n\n    function modifyFunds(uint256 index, address user, uint256 amount) public {\n        records[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return records[index].funds[user];\n    }\n}",
          "error message": ":1:259: TypeError: Type struct MappingInStruct13.RecordStruct is only valid in storage because it contains a (nested) mapping.\n ... t256 _identifier) public {         RecordStruct memory newRecord;         newRecord.identifier = _i ...\n                                        ^---------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct14 {\n    struct AssetStruct {\n        uint256 assetId;\n        mapping(address => uint256) userBalances;\n    }\n    \n    AssetStruct[] public assets;\n\n    function registerAsset(uint256 _assetId) public {\n        AssetStruct memory newAsset;\n        newAsset.assetId = _assetId;\n        assets.push(newAsset);\n    }\n\n    function setAssetBalance(uint256 index, address user, uint256 amount) public {\n        assets[index].userBalances[user] = amount;\n    }\n\n    function getAssetBalance(uint256 index, address user) public view returns (uint256) {\n        return assets[index].userBalances[user];\n    }\n\n    function dummyFuncD() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:261: TypeError: Type struct MappingInStruct14.AssetStruct is only valid in storage because it contains a (nested) mapping.\n ... uint256 _assetId) public {         AssetStruct memory newAsset;         newAsset.assetId = _asset ...\n                                        ^-------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct15 {\n    struct ExampleData {\n        uint256 key;\n        mapping(address => uint256) accounts;\n    }\n    \n    ExampleData[] public dataCollection;\n\n    function addExample(uint256 _key) public {\n        ExampleData memory newExample;\n        newExample.key = _key;\n        dataCollection.push(newExample);\n    }\n\n    function setAccount(uint256 index, address user, uint256 value) public {\n        dataCollection[index].accounts[user] = value;\n    }\n\n    function getAccount(uint256 index, address user) public view returns (uint256) {\n        return dataCollection[index].accounts[user];\n    }\n\n    function dummyFuncE() public pure returns (uint256) {\n        return 1000;\n    }\n}",
          "error message": ":1:254: TypeError: Type struct MappingInStruct15.ExampleData is only valid in storage because it contains a (nested) mapping.\n ... ple(uint256 _key) public {         ExampleData memory newExample;         newExample.key = _key;    ...\n                                        ^---------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct16 {\n    struct CustomStruct {\n        uint256 id;\n        mapping(address => uint256) balances;\n    }\n    \n    CustomStruct[] public customStructs;\n\n    function createCustomStruct(uint256 _id) public {\n        CustomStruct memory newStruct;\n        newStruct.id = _id;\n        customStructs.push(newStruct);\n    }\n\n    function updateBalance(uint256 index, address user, uint256 amount) public {\n        customStructs[index].balances[user] = amount;\n    }\n\n    function viewBalance(uint256 index, address user) public view returns (uint256) {\n        return customStructs[index].balances[user];\n    }\n}",
          "error message": ":1:261: TypeError: Type struct MappingInStruct16.CustomStruct is only valid in storage because it contains a (nested) mapping.\n ... ruct(uint256 _id) public {         CustomStruct memory newStruct;         newStruct.id = _id;       ...\n                                        ^---------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct17 {\n    struct HolderStruct {\n        uint256 value;\n        mapping(address => uint256) funds;\n    }\n    \n    HolderStruct[] public holders;\n\n    function addHolder(uint256 _value) public {\n        HolderStruct memory newHolder;\n        newHolder.value = _value;\n        holders.push(newHolder);\n    }\n\n    function changeFunds(uint256 index, address user, uint256 amount) public {\n        holders[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return holders[index].funds[user];\n    }\n\n    function dummyFuncF() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": ":1:249: TypeError: Type struct MappingInStruct17.HolderStruct is only valid in storage because it contains a (nested) mapping.\n ... r(uint256 _value) public {         HolderStruct memory newHolder;         newHolder.value = _value; ...\n                                        ^---------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct18 {\n    struct DataStruct {\n        uint256 number;\n        mapping(address => uint256) userBalances;\n    }\n    \n    DataStruct[] public dataEntries;\n\n    function addData(uint256 _number) public {\n        DataStruct memory newData;\n        newData.number = _number;\n        dataEntries.push(newData);\n    }\n\n    function setUserBalance(uint256 index, address user, uint256 value) public {\n        dataEntries[index].userBalances[user] = value;\n    }\n\n    function getUserBalance(uint256 index, address user) public view returns (uint256) {\n        return dataEntries[index].userBalances[user];\n    }\n}",
          "error message": ":1:256: TypeError: Type struct MappingInStruct18.DataStruct is only valid in storage because it contains a (nested) mapping.\n ... (uint256 _number) public {         DataStruct memory newData;         newData.number = _number; ...\n                                        ^-----------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct19 {\n    struct ItemStruct {\n        uint256 id;\n        mapping(address => uint256) allocations;\n    }\n    \n    ItemStruct[] public items;\n\n    function createItem(uint256 _id) public {\n        ItemStruct memory newItem;\n        newItem.id = _id;\n        items.push(newItem);\n    }\n\n    function updateAllocation(uint256 index, address user, uint256 amount) public {\n        items[index].allocations[user] = amount;\n    }\n\n    function getAllocation(uint256 index, address user) public view returns (uint256) {\n        return items[index].allocations[user];\n    }\n\n    function dummyFuncG() public pure returns (uint256) {\n        return 99;\n    }\n}",
          "error message": ":1:244: TypeError: Type struct MappingInStruct19.ItemStruct is only valid in storage because it contains a (nested) mapping.\n ... Item(uint256 _id) public {         ItemStruct memory newItem;         newItem.id = _id;         ...\n                                        ^-----------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct20 {\n    struct InfoStruct {\n        uint256 value;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _value) public {\n        InfoStruct memory newInfo;\n        newInfo.value = _value;\n        infos.push(newInfo);\n    }\n\n    function setHoldings(uint256 index, address user, uint256 amount) public {\n        infos[index].holdings[user] = amount;\n    }\n\n    function getHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n\n    function dummyFuncH() public pure returns (bool) {\n        return true;\n    }\n\n    function dummyFuncI() public pure returns (string memory) {\n        return \"Example\";\n    }\n}",
          "error message": ":1:244: TypeError: Type struct MappingInStruct20.InfoStruct is only valid in storage because it contains a (nested) mapping.\n ... o(uint256 _value) public {         InfoStruct memory newInfo;         newInfo.value = _value;   ...\n                                        ^-----------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct11 {\n    struct ExampleStruct {\n        uint256 data;\n        mapping(address => uint256) balances;\n    }\n    \n    ExampleStruct[] public examples;\n\n    function createStruct(uint256 _data) public {\n        ExampleStruct storage newExample = examples.push();\n        newExample.data = _data;\n    }\n\n    function setBalance(uint256 index, address user, uint256 amount) public {\n        examples[index].balances[user] = amount;\n    }\n\n    function getBalance(uint256 index, address user) public view returns (uint256) {\n        return examples[index].balances[user];\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct12 {\n    struct InfoStruct {\n        uint256 id;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _id) public {\n        InfoStruct storage newInfo = infos.push();\n        newInfo.id = _id;\n    }\n\n    function updateHoldings(uint256 index, address user, uint256 value) public {\n        infos[index].holdings[user] = value;\n    }\n\n    function fetchHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct13 {\n    struct RecordStruct {\n        uint256 identifier;\n        mapping(address => uint256) funds;\n    }\n    \n    RecordStruct[] public records;\n\n    function addRecord(uint256 _identifier) public {\n        RecordStruct storage newRecord = records.push();\n        newRecord.identifier = _identifier;\n    }\n\n    function modifyFunds(uint256 index, address user, uint256 amount) public {\n        records[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return records[index].funds[user];\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct14 {\n    struct AssetStruct {\n        uint256 assetId;\n        mapping(address => uint256) userBalances;\n    }\n    \n    AssetStruct[] public assets;\n\n    function registerAsset(uint256 _assetId) public {\n        AssetStruct storage newAsset = assets.push();\n        newAsset.assetId = _assetId;\n    }\n\n    function setAssetBalance(uint256 index, address user, uint256 amount) public {\n        assets[index].userBalances[user] = amount;\n    }\n\n    function getAssetBalance(uint256 index, address user) public view returns (uint256) {\n        return assets[index].userBalances[user];\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct15 {\n    struct ExampleData {\n        uint256 key;\n        mapping(address => uint256) accounts;\n    }\n    \n    ExampleData[] public dataCollection;\n\n    function addExample(uint256 _key) public {\n        ExampleData storage newExample = dataCollection.push();\n        newExample.key = _key;\n    }\n\n    function setAccount(uint256 index, address user, uint256 value) public {\n        dataCollection[index].accounts[user] = value;\n    }\n\n    function getAccount(uint256 index, address user) public view returns (uint256) {\n        return dataCollection[index].accounts[user];\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct16 {\n    struct CustomStruct {\n        uint256 id;\n        mapping(address => uint256) balances;\n    }\n    \n    CustomStruct[] public customStructs;\n\n    function createCustomStruct(uint256 _id) public {\n        CustomStruct storage newStruct = customStructs.push();\n        newStruct.id = _id;\n    }\n\n    function updateBalance(uint256 index, address user, uint256 amount) public {\n        customStructs[index].balances[user] = amount;\n    }\n\n    function viewBalance(uint256 index, address user) public view returns (uint256) {\n        return customStructs[index].balances[user];\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct17 {\n    struct HolderStruct {\n        uint256 value;\n        mapping(address => uint256) funds;\n    }\n    \n    HolderStruct[] public holders;\n\n    function addHolder(uint256 _value) public {\n        HolderStruct storage newHolder = holders.push();\n        newHolder.value = _value;\n    }\n\n    function changeFunds(uint256 index, address user, uint256 amount) public {\n        holders[index].funds[user] = amount;\n    }\n\n    function getFunds(uint256 index, address user) public view returns (uint256) {\n        return holders[index].funds[user];\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct18 {\n    struct DataStruct {\n        uint256 number;\n        mapping(address => uint256) userBalances;\n    }\n    \n    DataStruct[] public dataEntries;\n\n    function addData(uint256 _number) public {\n        DataStruct storage newData = dataEntries.push();\n        newData.number = _number;\n    }\n\n    function setUserBalance(uint256 index, address user, uint256 value) public {\n        dataEntries[index].userBalances[user] = value;\n    }\n\n    function getUserBalance(uint256 index, address user) public view returns (uint256) {\n        return dataEntries[index].userBalances[user];\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct19 {\n    struct ItemStruct {\n        uint256 id;\n        mapping(address => uint256) allocations;\n    }\n    \n    ItemStruct[] public items;\n\n    function createItem(uint256 _id) public {\n        ItemStruct storage newItem = items.push();\n        newItem.id = _id;\n    }\n\n    function updateAllocation(uint256 index, address user, uint256 amount) public {\n        items[index].allocations[user] = amount;\n    }\n\n    function getAllocation(uint256 index, address user) public view returns (uint256) {\n        return items[index].allocations[user];\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct20 {\n    struct InfoStruct {\n        uint256 value;\n        mapping(address => uint256) holdings;\n    }\n    \n    InfoStruct[] public infos;\n\n    function addInfo(uint256 _value) public {\n        InfoStruct storage newInfo = infos.push();\n        newInfo.value = _value;\n    }\n\n    function setHoldings(uint256 index, address user, uint256 amount) public {\n        infos[index].holdings[user] = amount;\n    }\n\n    function getHoldings(uint256 index, address user) public view returns (uint256) {\n        return infos[index].holdings[user];\n    }\n}"
      }
    }
  },
  {
    "Changes21": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Assignments to structs or arrays in storage does not work if they contain\nmappings.\nPreviously, mappings were silently skipped during the copy operation, which\nis misleading and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Dataset {\n        mapping(address => uint) data;\n        uint total;\n    }\n\n    Dataset dataset1;\n    Dataset dataset2;\n\n    function addData(address _addr, uint _value) public {\n        dataset1.data[_addr] = _value;\n        dataset1.total += _value;\n    }\n\n    function cloneDataset() public {\n        dataset2 = dataset1;\n    }\n\n    function getTotal() public view returns (uint) {\n        return dataset2.total;\n    }\n}",
          "error message": ":1:361: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on cloneDataset() public {         dataset2 = dataset1;     }      function ge ...\n                                        ^------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Holder {\n        mapping(address => uint) items;\n        uint itemCount;\n    }\n\n    Holder holder1;\n    Holder holder2;\n\n    function addItem(address _addr, uint _item) public {\n        holder1.items[_addr] = _item;\n        holder1.itemCount += _item;\n    }\n\n    function duplicateHolder() public {\n        holder2 = holder1;\n    }\n\n    function getItemCount() public view returns (uint) {\n        return holder2.itemCount;\n    }\n\n    function anotherFunc() public pure returns (string memory) {\n        return \"Another\";\n    }\n}",
          "error message": ":1:364: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... duplicateHolder() public {         holder2 = holder1;     }      function get ...\n                                        ^-----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint entryCount;\n    }\n\n    Log log1;\n    Log log2;\n\n    function addEntry(address _addr, uint _entry) public {\n        log1.entries[_addr] = _entry;\n        log1.entryCount += _entry;\n    }\n\n    function copyLog() public {\n        log2 = log1;\n    }\n\n    function getEntryCount() public view returns (uint) {\n        return log2.entryCount;\n    }\n\n    function extraFunc() public pure returns (bool) {\n        return true;\n    }\n\n    function yetAnotherFunc() public pure returns (uint) {\n        return 101;\n    }\n}",
          "error message": ":1:345: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... unction copyLog() public {         log2 = log1;     }      function getEnt ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Table {\n        mapping(address => uint) values;\n        uint valueCount;\n    }\n\n    Table table1;\n    Table table2;\n\n    function setValue(address _addr, uint _value) public {\n        table1.values[_addr] = _value;\n        table1.valueCount += _value;\n    }\n\n    function cloneTable() public {\n        table2 = table1;\n    }\n\n    function getValueCount() public view returns (uint) {\n        return table2.valueCount;\n    }\n}",
          "error message": ":1:360: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... tion cloneTable() public {         table2 = table1;     }      function getV ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Registry {\n        mapping(address => uint) records;\n        uint recordTotal;\n    }\n\n    Registry registry1;\n    Registry registry2;\n\n    function addRecord(address _addr, uint _record) public {\n        registry1.records[_addr] = _record;\n        registry1.recordTotal += _record;\n    }\n\n    function copyRegistry() public {\n        registry2 = registry1;\n    }\n\n    function getRecordTotal() public view returns (uint) {\n        return registry2.recordTotal;\n    }\n\n    function func1() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:391: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on copyRegistry() public {         registry2 = registry1;     }      function g ...\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Database {\n        mapping(address => uint) entries;\n        uint entrySum;\n    }\n\n    Database db1;\n    Database db2;\n\n    function addEntry(address _addr, uint _entry) public {\n        db1.entries[_addr] = _entry;\n        db1.entrySum += _entry;\n    }\n\n    function replicateDatabase() public {\n        db2 = db1;\n    }\n\n    function getEntrySum() public view returns (uint) {\n        return db2.entrySum;\n    }\n}",
          "error message": ":1:362: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... plicateDatabase() public {         db2 = db1;     }      function getEntr ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Storage {\n        mapping(address => uint) tokens;\n        uint tokenTotal;\n    }\n\n    Storage storage1;\n    Storage storage2;\n\n    function addToken(address _addr, uint _token) public {\n        storage1.tokens[_addr] = _token;\n        storage1.tokenTotal += _token;\n    }\n\n    function copyStorage() public {\n        storage2 = storage1;\n    }\n\n    function getTokenTotal() public view returns (uint) {\n        return storage2.tokenTotal;\n    }\n\n    function dummy() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": ":1:375: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... ion copyStorage() public {         storage2 = storage1;     }      function ge ...\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Archive {\n        mapping(address => uint) files;\n        uint fileCount;\n    }\n\n    Archive archive1;\n    Archive archive2;\n\n    function addFile(address _addr, uint _file) public {\n        archive1.files[_addr] = _file;\n        archive1.fileCount += _file;\n    }\n\n    function cloneArchive() public {\n        archive2 = archive1;\n    }\n\n    function getFileCount() public view returns (uint) {\n        return archive2.fileCount;\n    }\n}",
          "error message": ":1:368: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on cloneArchive() public {         archive2 = archive1;     }      function ge ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Network {\n        mapping(address => uint) nodes;\n        uint nodeCount;\n    }\n\n    Network network1;\n    Network network2;\n\n    function addNode(address _addr, uint _node) public {\n        network1.nodes[_addr] = _node;\n        network1.nodeCount += _node;\n    }\n\n    function duplicateNetwork() public {\n        network2 = network1;\n    }\n\n    function getNodeCount() public view returns (uint) {\n        return network2.nodeCount;\n    }\n\n    function dummyFunc() public pure returns (string memory) {\n        return \"Node\";\n    }\n\n    function anotherDummyFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:372: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... uplicateNetwork() public {         network2 = network1;     }      function ge ...\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Cache {\n        mapping(address => uint) items;\n        uint itemTotal;\n    }\n\n    Cache cache1;\n    Cache cache2;\n\n    function addItem(address _addr, uint _item) public {\n        cache1.items[_addr] = _item;\n        cache1.itemTotal += _item;\n    }\n\n    function replicateCache() public {\n        cache2 = cache1;\n    }\n\n    function getItemTotal() public view returns (uint) {\n        return cache2.itemTotal;\n    }\n}",
          "error message": ":1:356: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ...  replicateCache() public {         cache2 = cache1;     }      function getI ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    struct Dataset {\n        mapping(address => uint) data;\n        uint total;\n    }\n    Dataset dataset1;\n    Dataset dataset2;\n    function addData(address _addr, uint _value) public {\n        dataset1.data[_addr] = _value;\n        dataset1.total += _value;\n    }\n    function cloneDataset() public {\n        dataset2.total = dataset1.total;\n    }\n    function getTotal() public view returns (uint) {\n        return dataset2.total;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    struct Holder {\n        mapping(address => uint) items;\n        uint itemCount;\n    }\n    Holder holder1;\n    Holder holder2;\n    function addItem(address _addr, uint _item) public {\n        holder1.items[_addr] = _item;\n        holder1.itemCount += _item;\n    }\n    function duplicateHolder() public {\n        holder2.itemCount = holder1.itemCount;\n    }\n    function getItemCount() public view returns (uint) {\n        return holder2.itemCount;\n    }\n    function anotherFunc() public pure returns (string memory) {\n        return \"Another\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint entryCount;\n    }\n    Log log1;\n    Log log2;\n    function addEntry(address _addr, uint _entry) public {\n        log1.entries[_addr] = _entry;\n        log1.entryCount += _entry;\n    }\n    function copyLog() public {\n        log2.entryCount = log1.entryCount;\n    }\n    function getEntryCount() public view returns (uint) {\n        return log2.entryCount;\n    }\n    function extraFunc() public pure returns (bool) {\n        return true;\n    }\n    function yetAnotherFunc() public pure returns (uint) {\n        return 101;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    struct Table {\n        mapping(address => uint) values;\n        uint valueCount;\n    }\n    Table table1;\n    Table table2;\n    function setValue(address _addr, uint _value) public {\n        table1.values[_addr] = _value;\n        table1.valueCount += _value;\n    }\n    function cloneTable() public {\n        table2.valueCount = table1.valueCount;\n    }\n    function getValueCount() public view returns (uint) {\n        return table2.valueCount;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    struct Registry {\n        mapping(address => uint) records;\n        uint recordTotal;\n    }\n    Registry registry1;\n    Registry registry2;\n    function addRecord(address _addr, uint _record) public {\n        registry1.records[_addr] = _record;\n        registry1.recordTotal += _record;\n    }\n    function copyRegistry() public {\n        registry2.recordTotal = registry1.recordTotal;\n    }\n    function getRecordTotal() public view returns (uint) {\n        return registry2.recordTotal;\n    }\n    function func1() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    struct Database {\n        mapping(address => uint) entries;\n        uint entrySum;\n    }\n    Database db1;\n    Database db2;\n    function addEntry(address _addr, uint _entry) public {\n        db1.entries[_addr] = _entry;\n        db1.entrySum += _entry;\n    }\n    function replicateDatabase() public {\n        db2.entrySum = db1.entrySum;\n    }\n    function getEntrySum() public view returns (uint) {\n        return db2.entrySum;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    struct Storage {\n        mapping(address => uint) tokens;\n        uint tokenTotal;\n    }\n    Storage storage1;\n    Storage storage2;\n    function addToken(address _addr, uint _token) public {\n        storage1.tokens[_addr] = _token;\n        storage1.tokenTotal += _token;\n    }\n    function copyStorage() public {\n        storage2.tokenTotal = storage1.tokenTotal;\n    }\n    function getTokenTotal() public view returns (uint) {\n        return storage2.tokenTotal;\n    }\n    function dummy() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    struct Archive {\n        mapping(address => uint) files;\n        uint fileCount;\n    }\n    Archive archive1;\n    Archive archive2;\n    function addFile(address _addr, uint _file) public {\n        archive1.files[_addr] = _file;\n        archive1.fileCount += _file;\n    }\n    function cloneArchive() public {\n        archive2.fileCount = archive1.fileCount;\n    }\n    function getFileCount() public view returns (uint) {\n        return archive2.fileCount;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    struct Network {\n        mapping(address => uint) nodes;\n        uint nodeCount;\n    }\n    Network network1;\n    Network network2;\n    function addNode(address _addr, uint _node) public {\n        network1.nodes[_addr] = _node;\n        network1.nodeCount += _node;\n    }\n    function duplicateNetwork() public {\n        network2.nodeCount = network1.nodeCount;\n    }\n    function getNodeCount() public view returns (uint) {\n        return network2.nodeCount;\n    }\n    function dummyFunc() public pure returns (string memory) {\n        return \"Node\";\n    }\n    function anotherDummyFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    struct Cache {\n        mapping(address => uint) items;\n        uint itemTotal;\n    }\n    Cache cache1;\n    Cache cache2;\n    function addItem(address _addr, uint _item) public {\n        cache1.items[_addr] = _item;\n        cache1.itemTotal += _item;\n    }\n    function replicateCache() public {\n        cache2.itemTotal = cache1.itemTotal;\n    }\n    function getItemTotal() public view returns (uint) {\n        return cache2.itemTotal;\n    }\n}"
      }
    }
  },
  {
    "Changes22": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Multiple events with the same name and parameter types in the same\ninheritance hierarchy are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function submitReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n}\n\ncontract DerivedContract11 is BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function fileReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n\n    function nonRelatedFunction() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Non-related\"));\n    }\n\n    function anotherNonRelatedFunction() public pure returns (uint256) {\n        return 789;\n    }\n}",
          "error message": ":1:251: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract11 is BaseContract11 {     event ReportEvent(uint256 indexed reportId);      function fileReport(uint256 _ ...\n                                        ^------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0; contract BaseContract11 {     event ReportEvent(uint256 indexed reportId);      function submitReport(uint256 ...\n                                        ^------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function function12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n}\n\ncontract DerivedContract12 is BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function derivedFunction12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n\n    function helperFunction12() public pure returns (uint256) {\n        return 120;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract12 is BaseContract12 {     event Event12(uint256 indexed id12);      function derivedFunction12(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract12 {     event Event12(uint256 indexed id12);      function function12(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function function13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n}\n\ncontract DerivedContract13 is BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function derivedFunction13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n\n    function additionalFunction13() public pure returns (bool) {\n        return true;\n    }\n\n    function anotherFunction13() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract13 is BaseContract13 {     event Event13(uint256 indexed id13);      function derivedFunction13(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract13 {     event Event13(uint256 indexed id13);      function function13(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function function14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n}\n\ncontract DerivedContract14 is BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function derivedFunction14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n\n    function unrelatedFunction14() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Unrelated\"));\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract14 is BaseContract14 {     event Event14(uint256 indexed id14);      function derivedFunction14(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract14 {     event Event14(uint256 indexed id14);      function function14(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function function15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n}\n\ncontract DerivedContract15 is BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function derivedFunction15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n\n    function extraFunction15() public pure returns (uint256) {\n        return 150;\n    }\n\n    function anotherExtraFunction15() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract15 is BaseContract15 {     event Event15(uint256 indexed id15);      function derivedFunction15(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract15 {     event Event15(uint256 indexed id15);      function function15(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function function16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}\n\ncontract DerivedContract16 is BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function derivedFunction16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract16 is BaseContract16 {     event Event16(uint256 indexed id16);      function derivedFunction16(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract16 {     event Event16(uint256 indexed id16);      function function16(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function function17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n\n    function unrelatedFunction17() public pure returns (int256) {\n        return -17;\n    }\n}\n\ncontract DerivedContract17 is BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function derivedFunction17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n}",
          "error message": ":1:323: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract17 is BaseContract17 {     event Event17(uint256 indexed id17);      function derivedFunction17(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract17 {     event Event17(uint256 indexed id17);      function function17(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function function18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n}\n\ncontract DerivedContract18 is BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function derivedFunction18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n\n    function anotherUnrelatedFunction18() public pure returns (address) {\n        return address(this);\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract18 is BaseContract18 {     event Event18(uint256 indexed id18);      function derivedFunction18(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract18 {     event Event18(uint256 indexed id18);      function function18(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function function19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n}\n\ncontract DerivedContract19 is BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function derivedFunction19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n\n    function nonRelatedFunction19() public pure returns (uint256) {\n        return 190;\n    }\n}",
          "error message": ":1:230: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract19 is BaseContract19 {     event Event19(uint256 indexed id19);      function derivedFunction19(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract19 {     event Event19(uint256 indexed id19);      function function19(uint256 _ ...\n                                        ^----------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function function20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n\n    function unrelatedFunction20() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}\n\ncontract DerivedContract20 is BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function derivedFunction20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n}",
          "error message": ":1:338: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract20 is BaseContract20 {     event Event20(uint256 indexed id20);      function derivedFunction20(ui ...\n                                        ^----------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract20 {     event Event20(uint256 indexed id20);      function function20(uint256 _ ...\n                                        ^----------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract BaseContract11 {\n    event ReportEvent(uint256 indexed reportId);\n\n    function submitReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n}\n\ncontract DerivedContract11 is BaseContract11 {\n    function fileReport(uint256 _reportId) public {\n        emit ReportEvent(_reportId);\n    }\n\n    function nonRelatedFunction() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Non-related\"));\n    }\n\n    function anotherNonRelatedFunction() public pure returns (uint256) {\n        return 789;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract BaseContract12 {\n    event Event12(uint256 indexed id12);\n\n    function function12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n}\n\ncontract DerivedContract12 is BaseContract12 {\n    function derivedFunction12(uint256 _id12) public {\n        emit Event12(_id12);\n    }\n\n    function helperFunction12() public pure returns (uint256) {\n        return 120;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract BaseContract13 {\n    event Event13(uint256 indexed id13);\n\n    function function13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n}\n\ncontract DerivedContract13 is BaseContract13 {\n    function derivedFunction13(uint256 _id13) public {\n        emit Event13(_id13);\n    }\n\n    function additionalFunction13() public pure returns (bool) {\n        return true;\n    }\n\n    function anotherFunction13() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract BaseContract14 {\n    event Event14(uint256 indexed id14);\n\n    function function14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n}\n\ncontract DerivedContract14 is BaseContract14 {\n    function derivedFunction14(uint256 _id14) public {\n        emit Event14(_id14);\n    }\n\n    function unrelatedFunction14() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Unrelated\"));\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract BaseContract15 {\n    event Event15(uint256 indexed id15);\n\n    function function15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n}\n\ncontract DerivedContract15 is BaseContract15 {\n    function derivedFunction15(uint256 _id15) public {\n        emit Event15(_id15);\n    }\n\n    function extraFunction15() public pure returns (uint256) {\n        return 150;\n    }\n\n    function anotherExtraFunction15() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract BaseContract16 {\n    event Event16(uint256 indexed id16);\n\n    function function16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}\n\ncontract DerivedContract16 is BaseContract16 {\n    function derivedFunction16(uint256 _id16) public {\n        emit Event16(_id16);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract BaseContract17 {\n    event Event17(uint256 indexed id17);\n\n    function function17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n\n    function unrelatedFunction17() public pure returns (int256) {\n        return -17;\n    }\n}\n\ncontract DerivedContract17 is BaseContract17 {\n    function derivedFunction17(uint256 _id17) public {\n        emit Event17(_id17);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract BaseContract18 {\n    event Event18(uint256 indexed id18);\n\n    function function18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n}\n\ncontract DerivedContract18 is BaseContract18 {\n    function derivedFunction18(uint256 _id18) public {\n        emit Event18(_id18);\n    }\n\n    function anotherUnrelatedFunction18() public pure returns (address) {\n        return address(this);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract BaseContract19 {\n    event Event19(uint256 indexed id19);\n\n    function function19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n}\n\ncontract DerivedContract19 is BaseContract19 {\n    function derivedFunction19(uint256 _id19) public {\n        emit Event19(_id19);\n    }\n\n    function nonRelatedFunction19() public pure returns (uint256) {\n        return 190;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract BaseContract20 {\n    event Event20(uint256 indexed id20);\n\n    function function20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n\n    function unrelatedFunction20() public pure returns (string memory) {\n        return \"Unrelated\";\n    }\n}\n\ncontract DerivedContract20 is BaseContract20 {\n    function derivedFunction20(uint256 _id20) public {\n        emit Event20(_id20);\n    }\n}"
      }
    }
  },
  {
    "Changes23": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "<code>using A for B</code> only affects the contract it is mentioned in.\nPreviously, the effect was inherited. Now, you have to repeat the <code>using</code>\nstatement in all derived contracts that make use of the feature.Repeat the <code>using A for B</code> statements in all derived contracts if needed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Operations {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Operations: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract A {\n    using Operations for uint;\n\n    uint public aValue;\n\n    function setAValue(uint _value) public {\n        aValue = _value;\n    }\n\n    function subtractAValue(uint _value) public {\n        aValue = aValue.subtract(_value);\n    }\n}\n\ncontract B is A {\n    uint public bValue;\n\n    function setBValue(uint _value) public {\n        bValue = _value;\n    }\n\n    function subtractBValue(uint _value) public {\n        bValue = bValue.subtract(_value);\n    }\n}",
          "error message": ":1:642: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ...  _value) public {         bValue = bValue.subtract(_value);     } }\n                                        ^-------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Calculate {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"Calculate: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract X {\n    using Calculate for uint;\n\n    uint public xValue;\n\n    function setXValue(uint _value) public {\n        xValue = _value;\n    }\n\n    function multiplyXValue(uint _value) public {\n        xValue = xValue.multiply(_value);\n    }\n}\n\ncontract Y is X {\n    uint public yValue;\n\n    function setYValue(uint _value) public {\n        yValue = _value;\n    }\n\n    function multiplyYValue(uint _value) public {\n        yValue = yValue.multiply(_value);\n    }\n}",
          "error message": ":1:666: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ...  _value) public {         yValue = yValue.multiply(_value);     } }\n                                        ^-------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary CalcLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"CalcLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract Master {\n    using CalcLib for uint;\n\n    uint public masterValue;\n\n    function setMasterValue(uint _value) public {\n        masterValue = _value;\n    }\n\n    function addMasterValue(uint _value) public {\n        masterValue = masterValue.add(_value);\n    }\n}\n\ncontract Slave is Master {\n    uint public slaveValue;\n\n    function setSlaveValue(uint _value) public {\n        slaveValue = _value;\n    }\n\n    function addSlaveValue(uint _value) public {\n        slaveValue = slaveValue.add(_value);\n    }\n}",
          "error message": ":1:694: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         slaveValue = slaveValue.add(_value);     } }\n                                        ^------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary NumberLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"NumberLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Origin {\n    using NumberLib for uint;\n\n    uint public originValue;\n\n    function setOriginValue(uint _value) public {\n        originValue = _value;\n    }\n\n    function subtractOriginValue(uint _value) public {\n        originValue = originValue.subtract(_value);\n    }\n}\n\ncontract Copy is Origin {\n    uint public copyValue;\n\n    function setCopyValue(uint _value) public {\n        copyValue = _value;\n    }\n\n    function subtractCopyValue(uint _value) public {\n        copyValue = copyValue.subtract(_value);\n    }\n}",
          "error message": ":1:697: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         copyValue = copyValue.subtract(_value);     } }\n                                        ^----------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary MyLibrary {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"MyLibrary: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Prime {\n    using MyLibrary for uint;\n\n    uint public primeValue;\n\n    function setPrimeValue(uint _value) public {\n        primeValue = _value;\n    }\n\n    function multiplyPrimeValue(uint _value) public {\n        primeValue = primeValue.multiply(_value);\n    }\n}\n\ncontract Secondary is Prime {\n    uint public secondaryValue;\n\n    function setSecondaryValue(uint _value) public {\n        secondaryValue = _value;\n    }\n\n    function multiplySecondaryValue(uint _value) public {\n        secondaryValue = secondaryValue.multiply(_value);\n    }\n}",
          "error message": ":1:746: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ...  public {         secondaryValue = secondaryValue.multiply(_value);     } }\n                                        ^---------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary UtilsLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"UtilsLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Initial {\n    using UtilsLib for uint;\n\n    uint public initialValue;\n\n    function setInitialValue(uint _value) public {\n        initialValue = _value;\n    }\n\n    function divideInitialValue(uint _value) public {\n        initialValue = initialValue.divide(_value);\n    }\n}\n\ncontract Final is Initial {\n    uint public finalValue;\n\n    function setFinalValue(uint _value) public {\n        finalValue = _value;\n    }\n\n    function divideFinalValue(uint _value) public {\n        finalValue = finalValue.divide(_value);\n    }\n}",
          "error message": ":1:695: TypeError: Member \"divide\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         finalValue = finalValue.divide(_value);     } }\n                                        ^---------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary ExtraLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ExtraLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract First {\n    using ExtraLib for uint;\n\n    uint public firstValue;\n\n    function setFirstValue(uint _value) public {\n        firstValue = _value;\n    }\n\n    function addFirstValue(uint _value) public {\n        firstValue = firstValue.add(_value);\n    }\n}\n\ncontract Second is First {\n    uint public secondValue;\n\n    function setSecondValue(uint _value) public {\n        secondValue = _value;\n    }\n\n    function addSecondValue(uint _value) public {\n        secondValue = secondValue.add(_value);\n    }\n}",
          "error message": ":1:695: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         secondValue = secondValue.add(_value);     } }\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary OperationLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"OperationLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Root {\n    using OperationLib for uint;\n\n    uint public rootValue;\n\n    function setRootValue(uint _value) public {\n        rootValue = _value;\n    }\n\n    function subtractRootValue(uint _value) public {\n        rootValue = rootValue.subtract(_value);\n    }\n}\n\ncontract Branch is Root {\n    uint public branchValue;\n\n    function setBranchValue(uint _value) public {\n        branchValue = _value;\n    }\n\n    function subtractBranchValue(uint _value) public {\n        branchValue = branchValue.subtract(_value);\n    }\n}",
          "error message": ":1:702: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         branchValue = branchValue.subtract(_value);     } }\n                                        ^------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary CalculationLib {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"CalculationLib: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Main {\n    using CalculationLib for uint;\n\n    uint public mainValue;\n\n    function setMainValue(uint _value) public {\n        mainValue = _value;\n    }\n\n    function multiplyMainValue(uint _value) public {\n        mainValue = mainValue.multiply(_value);\n    }\n}\n\ncontract Side is Main {\n    uint public sideValue;\n\n    function setSideValue(uint _value) public {\n        sideValue = _value;\n    }\n\n    function multiplySideValue(uint _value) public {\n        sideValue = sideValue.multiply(_value);\n    }\n}",
          "error message": ":1:723: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         sideValue = sideValue.multiply(_value);     } }\n                                        ^----------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary HelperLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"HelperLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Alpha {\n    using HelperLib for uint;\n\n    uint public alphaValue;\n\n    function setAlphaValue(uint _value) public {\n        alphaValue = _value;\n    }\n\n    function divideAlphaValue(uint _value) public {\n        alphaValue = alphaValue.divide(_value);\n    }\n}\n\ncontract Beta is Alpha {\n    uint public betaValue;\n\n    function setBetaValue(uint _value) public {\n        betaValue = _value;\n    }\n\n    function divideBetaValue(uint _value) public {\n        betaValue = betaValue.divide(_value);\n    }\n}",
          "error message": ":1:676: TypeError: Member \"divide\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         betaValue = betaValue.divide(_value);     } }\n                                        ^--------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary Operations {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Operations: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract A {\n    using Operations for uint;\n    uint public aValue;\n    function setAValue(uint _value) public {\n        aValue = _value;\n    }\n    function subtractAValue(uint _value) public {\n        aValue = aValue.subtract(_value);\n    }\n}\n\ncontract B is A {\n    using Operations for uint;\n    uint public bValue;\n    function setBValue(uint _value) public {\n        bValue = _value;\n    }\n    function subtractBValue(uint _value) public {\n        bValue = bValue.subtract(_value);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary Calculate {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"Calculate: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract X {\n    using Calculate for uint;\n    uint public xValue;\n    function setXValue(uint _value) public {\n        xValue = _value;\n    }\n    function multiplyXValue(uint _value) public {\n        xValue = xValue.multiply(_value);\n    }\n}\n\ncontract Y is X {\n    using Calculate for uint;\n    uint public yValue;\n    function setYValue(uint _value) public {\n        yValue = _value;\n    }\n    function multiplyYValue(uint _value) public {\n        yValue = yValue.multiply(_value);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary CalcLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"CalcLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract Master {\n    using CalcLib for uint;\n    uint public masterValue;\n    function setMasterValue(uint _value) public {\n        masterValue = _value;\n    }\n    function addMasterValue(uint _value) public {\n        masterValue = masterValue.add(_value);\n    }\n}\n\ncontract Slave is Master {\n    using CalcLib for uint;\n    uint public slaveValue;\n    function setSlaveValue(uint _value) public {\n        slaveValue = _value;\n    }\n    function addSlaveValue(uint _value) public {\n        slaveValue = slaveValue.add(_value);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary NumberLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"NumberLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Origin {\n    using NumberLib for uint;\n    uint public originValue;\n    function setOriginValue(uint _value) public {\n        originValue = _value;\n    }\n    function subtractOriginValue(uint _value) public {\n        originValue = originValue.subtract(_value);\n    }\n}\n\ncontract Copy is Origin {\n    using NumberLib for uint;\n    uint public copyValue;\n    function setCopyValue(uint _value) public {\n        copyValue = _value;\n    }\n    function subtractCopyValue(uint _value) public {\n        copyValue = copyValue.subtract(_value);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary MyLibrary {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"MyLibrary: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Prime {\n    using MyLibrary for uint;\n    uint public primeValue;\n    function setPrimeValue(uint _value) public {\n        primeValue = _value;\n    }\n    function multiplyPrimeValue(uint _value) public {\n        primeValue = primeValue.multiply(_value);\n    }\n}\n\ncontract Secondary is Prime {\n    using MyLibrary for uint;\n    uint public secondaryValue;\n    function setSecondaryValue(uint _value) public {\n        secondaryValue = _value;\n    }\n    function multiplySecondaryValue(uint _value) public {\n        secondaryValue = secondaryValue.multiply(_value);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary UtilsLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"UtilsLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Initial {\n    using UtilsLib for uint;\n    uint public initialValue;\n    function setInitialValue(uint _value) public {\n        initialValue = _value;\n    }\n    function divideInitialValue(uint _value) public {\n        initialValue = initialValue.divide(_value);\n    }\n}\n\ncontract Final is Initial {\n    using UtilsLib for uint;\n    uint public finalValue;\n    function setFinalValue(uint _value) public {\n        finalValue = _value;\n    }\n    function divideFinalValue(uint _value) public {\n        finalValue = finalValue.divide(_value);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary ExtraLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ExtraLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract First {\n    using ExtraLib for uint;\n    uint public firstValue;\n    function setFirstValue(uint _value) public {\n        firstValue = _value;\n    }\n    function addFirstValue(uint _value) public {\n        firstValue = firstValue.add(_value);\n    }\n}\n\ncontract Second is First {\n    using ExtraLib for uint;\n    uint public secondValue;\n    function setSecondValue(uint _value) public {\n        secondValue = _value;\n    }\n    function addSecondValue(uint _value) public {\n        secondValue = secondValue.add(_value);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary OperationLib {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"OperationLib: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract Root {\n    using OperationLib for uint;\n    uint public rootValue;\n    function setRootValue(uint _value) public {\n        rootValue = _value;\n    }\n    function subtractRootValue(uint _value) public {\n        rootValue = rootValue.subtract(_value);\n    }\n}\n\ncontract Branch is Root {\n    using OperationLib for uint;\n    uint public branchValue;\n    function setBranchValue(uint _value) public {\n        branchValue = _value;\n    }\n    function subtractBranchValue(uint _value) public {\n        branchValue = branchValue.subtract(_value);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary CalculationLib {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"CalculationLib: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Main {\n    using CalculationLib for uint;\n    uint public mainValue;\n    function setMainValue(uint _value) public {\n        mainValue = _value;\n    }\n    function multiplyMainValue(uint _value) public {\n        mainValue = mainValue.multiply(_value);\n    }\n}\n\ncontract Side is Main {\n    using CalculationLib for uint;\n    uint public sideValue;\n    function setSideValue(uint _value) public {\n        sideValue = _value;\n    }\n    function multiplySideValue(uint _value) public {\n        sideValue = sideValue.multiply(_value);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary HelperLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"HelperLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Alpha {\n    using HelperLib for uint;\n    uint public alphaValue;\n    function setAlphaValue(uint _value) public {\n        alphaValue = _value;\n    }\n    function divideAlphaValue(uint _value) public {\n        alphaValue = alphaValue.divide(_value);\n    }\n}\n\ncontract Beta is Alpha {\n    using HelperLib for uint;\n    uint public betaValue;\n    function setBetaValue(uint _value) public {\n        betaValue = _value;\n    }\n    function divideBetaValue(uint _value) public {\n        betaValue = betaValue.divide(_value);\n    }\n}"
      }
    }
  },
  {
    "Changes24": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Shifts by signed types are disallowed.\nPreviously, shifts by negative amounts were allowed, but reverted at runtime.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    int public output;\n\n    function shiftLeft(int x, int y) public {\n        output = x << y;\n    }\n}",
          "error message": ":1:133: TypeError: Operator << not compatible with types int256 and int256\npragma solidity^0.7.0;  contract Example11 {     int public output;      function shiftLeft(int x, int y) public {         output = x << y;     } }\n                                                                                                                                    ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    int public shiftResult;\n\n    function performRightShift(int a, int b) public {\n        shiftResult = a >> b;\n    }\n\n    function dummyFunction2() public pure returns (int) {\n        return 50;\n    }\n}",
          "error message": ":1:151: TypeError: Operator >> not compatible with types int256 and int256\n ...  b) public {         shiftResult = a >> b;     }      function dummyFunction ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    int public shifted;\n\n    function leftShift(int x, int y) public {\n        shifted = x << y;\n    }\n}",
          "error message": ":1:135: TypeError: Operator << not compatible with types int256 and int256\npragma solidity^0.7.0;  contract Example13 {     int public shifted;      function leftShift(int x, int y) public {         shifted = x << y;     } }\n                                                                                                                                      ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    int public resultShift;\n\n    function rightShift(int number, int shiftBy) public {\n        resultShift = number >> shiftBy;\n    }\n\n    function additionalFunction1() public pure returns (int) {\n        return 99;\n    }\n}",
          "error message": ":1:155: TypeError: Operator >> not compatible with types int256 and int256\n ... By) public {         resultShift = number >> shiftBy;     }      function additionalFun ...\n                                        ^---------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    int public finalShift;\n\n    function shiftLeftBy(int input, int shiftAmount) public {\n        finalShift = input << shiftAmount;\n    }\n\n    function anotherDummyFunction() public pure returns (int) {\n        return 15;\n    }\n\n    function extraFunction() public pure returns (int) {\n        return 200;\n    }\n}",
          "error message": ":1:157: TypeError: Operator << not compatible with types int256 and int256\n ... unt) public {         finalShift = input << shiftAmount;     }      function anotherDummyF ...\n                                        ^------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    int public shiftedValue;\n\n    function shiftOperation(int base, int offset) public {\n        shiftedValue = base << offset;\n    }\n}",
          "error message": ":1:158: TypeError: Operator << not compatible with types int256 and int256\n ... t) public {         shiftedValue = base << offset;     } }\n                                        ^------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    int public result;\n\n    function performShift(int x, int y) public {\n        result = x << y;\n    }\n\n    function auxiliaryFunction() public pure returns (int) {\n        return 3;\n    }\n}",
          "error message": ":1:136: TypeError: Operator << not compatible with types int256 and int256\n ... , int y) public {         result = x << y;     }      function auxiliaryFunc ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    int public shiftOutcome;\n\n    function leftShift(int a, int b) public {\n        shiftOutcome = a << b;\n    }\n}",
          "error message": ":1:145: TypeError: Operator << not compatible with types int256 and int256\n ... b) public {         shiftOutcome = a << b;     } }\n                                        ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    int public data;\n\n    function shiftLeftBy(int number, int shiftBy) public {\n        data = number << shiftBy;\n    }\n\n    function unusedFunction() public pure returns (int) {\n        return -5;\n    }\n}",
          "error message": ":1:142: TypeError: Operator << not compatible with types int256 and int256\n ... t shiftBy) public {         data = number << shiftBy;     }      function unusedFunctio ...\n                                        ^---------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    int public shiftedResult;\n\n    function rightShiftOperation(int num, int shiftAmount) public {\n        shiftedResult = num >> shiftAmount;\n    }\n\n    function extraFunction1() public pure returns (int) {\n        return 101;\n    }\n}",
          "error message": ":1:169: TypeError: Operator >> not compatible with types int256 and int256\n ... ) public {         shiftedResult = num >> shiftAmount;     }      function extraFunction ...\n                                        ^----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    int public output;\n\n    function shiftLeft(int x, uint y) public {\n        output = x << y;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    int public shiftResult;\n\n    function performRightShift(int a, uint b) public {\n        shiftResult = a >> b;\n    }\n\n    function dummyFunction2() public pure returns (int) {\n        return 50;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    int public shifted;\n\n    function leftShift(int x, uint y) public {\n        shifted = x << y;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    int public resultShift;\n\n    function rightShift(int number, uint shiftBy) public {\n        resultShift = number >> shiftBy;\n    }\n\n    function additionalFunction1() public pure returns (int) {\n        return 99;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    int public finalShift;\n\n    function shiftLeftBy(int input, uint shiftAmount) public {\n        finalShift = input << shiftAmount;\n    }\n\n    function anotherDummyFunction() public pure returns (int) {\n        return 15;\n    }\n\n    function extraFunction() public pure returns (int) {\n        return 200;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    int public shiftedValue;\n\n    function shiftOperation(int base, uint offset) public {\n        shiftedValue = base << offset;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    int public result;\n\n    function performShift(int x, uint y) public {\n        result = x << y;\n    }\n\n    function auxiliaryFunction() public pure returns (int) {\n        return 3;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    int public shiftOutcome;\n\n    function leftShift(int a, uint b) public {\n        shiftOutcome = a << b;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    int public data;\n\n    function shiftLeftBy(int number, uint shiftBy) public {\n        data = number << shiftBy;\n    }\n\n    function unusedFunction() public pure returns (int) {\n        return -5;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    int public shiftedResult;\n\n    function rightShiftOperation(int num, uint shiftAmount) public {\n        shiftedResult = num >> shiftAmount;\n    }\n\n    function extraFunction1() public pure returns (int) {\n        return 101;\n    }\n}"
      }
    }
  },
  {
    "Changes25": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The <code>finney</code> and <code>szabo</code> denominations are removed.\nThey are rarely used and do not make the actual amount readily visible. Instead, explicit\nvalues like <code>1e20</code> or the very common <code>gwei</code> can be used.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public feeInFinney = 3 finney;\n\n    function payFee() public payable {\n        require(msg.value >= feeInFinney, \"Fee is 3 finney\");\n    }\n\n    function getFee() public view returns (uint) {\n        return feeInFinney;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": ":1:78: ParserError: Expected ';' but got identifier\n ...  {     uint public feeInFinney = 3 finney;      function payFee() public pay ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public donationInSzabo = 25 szabo;\n\n    function donate() public payable {\n        require(msg.value >= donationInSzabo, \"Minimum donation is 25 szabo\");\n    }\n\n    function getDonation() public view returns (uint) {\n        return donationInSzabo;\n    }\n\n    function anotherFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:83: ParserError: Expected ';' but got identifier\n ...   uint public donationInSzabo = 25 szabo;      function donate() public pay ...\n                                        ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public valueInFinney = 5 finney;\n\n    function setValue(uint newValue) public {\n        valueInFinney = newValue * 1 finney;\n    }\n\n    function getValue() public view returns (uint) {\n        return valueInFinney;\n    }\n\n    function randomFunc() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
          "error message": ":1:80: ParserError: Expected ';' but got identifier\n ...      uint public valueInFinney = 5 finney;      function setValue(uint newVa ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public minSzabo = 30 szabo;\n\n    function deposit() public payable {\n        require(msg.value >= minSzabo, \"Must deposit at least 30 szabo\");\n    }\n\n    function getMin() public view returns (uint) {\n        return minSzabo;\n    }\n}",
          "error message": ":1:76: ParserError: Expected ';' but got identifier\n ... 14 {     uint public minSzabo = 30 szabo;      function deposit() public pa ...\n                                        ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public maxFinney = 50 finney;\n\n    function setMax(uint newMax) public {\n        maxFinney = newMax * 1 finney;\n    }\n\n    function getMax() public view returns (uint) {\n        return maxFinney;\n    }\n}",
          "error message": ":1:77: ParserError: Expected ';' but got identifier\n ... 5 {     uint public maxFinney = 50 finney;      function setMax(uint newMax) ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public requiredSzabo = 75 szabo;\n\n    function sendFunds() public payable {\n        require(msg.value >= requiredSzabo, \"Need at least 75 szabo\");\n    }\n\n    function getRequired() public view returns (uint) {\n        return requiredSzabo;\n    }\n\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:81: ParserError: Expected ';' but got identifier\n ...     uint public requiredSzabo = 75 szabo;      function sendFunds() public  ...\n                                        ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public feeFinney = 4 finney;\n\n    function pay() public payable {\n        require(msg.value >= feeFinney, \"Fee is 4 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return feeFinney;\n    }\n\n    function additionalFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": ":1:76: ParserError: Expected ';' but got identifier\n ... 17 {     uint public feeFinney = 4 finney;      function pay() public payabl ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public amountSzabo = 40 szabo;\n\n    function contribute() public payable {\n        require(msg.value >= amountSzabo, \"Contribution must be at least 40 szabo\");\n    }\n\n    function getAmount() public view returns (uint) {\n        return amountSzabo;\n    }\n}",
          "error message": ":1:79: ParserError: Expected ';' but got identifier\n ... {     uint public amountSzabo = 40 szabo;      function contribute() public ...\n                                        ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public rateFinney = 6 finney;\n\n    function invest() public payable {\n        require(msg.value >= rateFinney, \"Investment rate is 6 finney\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rateFinney;\n    }\n\n    function someFunction() public pure returns (string memory) {\n        return \"some\";\n    }\n}",
          "error message": ":1:77: ParserError: Expected ';' but got identifier\n ... 9 {     uint public rateFinney = 6 finney;      function invest() public pay ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public thresholdSzabo = 100 szabo;\n\n    function setThreshold(uint newThreshold) public {\n        thresholdSzabo = newThreshold * 1 szabo;\n    }\n\n    function getThreshold() public view returns (uint) {\n        return thresholdSzabo;\n    }\n}",
          "error message": ":1:83: ParserError: Expected ';' but got identifier\n ...   uint public thresholdSzabo = 100 szabo;      function setThreshold(uint n ...\n                                        ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public feeInWei = 3e15;\n\n    function payFee() public payable {\n        require(msg.value >= feeInWei, \"Fee is 3 finney equivalent in wei\");\n    }\n\n    function getFee() public view returns (uint) {\n        return feeInWei;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public donationInWei = 25e12;\n\n    function donate() public payable {\n        require(msg.value >= donationInWei, \"Minimum donation is 25 szabo equivalent in wei\");\n    }\n\n    function getDonation() public view returns (uint) {\n        return donationInWei;\n    }\n\n    function anotherFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public valueInWei = 5e15;\n\n    function setValue(uint newValue) public {\n        valueInWei = newValue * 1e15;\n    }\n\n    function getValue() public view returns (uint) {\n        return valueInWei;\n    }\n\n    function randomFunc() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public minWei = 30e12;\n\n    function deposit() public payable {\n        require(msg.value >= minWei, \"Must deposit at least 30 szabo equivalent in wei\");\n    }\n\n    function getMin() public view returns (uint) {\n        return minWei;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public maxWei = 50e15;\n\n    function setMax(uint newMax) public {\n        maxWei = newMax * 1e15;\n    }\n\n    function getMax() public view returns (uint) {\n        return maxWei;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public requiredWei = 75e12;\n\n    function sendFunds() public payable {\n        require(msg.value >= requiredWei, \"Need at least 75 szabo equivalent in wei\");\n    }\n\n    function getRequired() public view returns (uint) {\n        return requiredWei;\n    }\n\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public feeWei = 4e15;\n\n    function pay() public payable {\n        require(msg.value >= feeWei, \"Fee is 4 finney equivalent in wei\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return feeWei;\n    }\n\n    function additionalFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public amountWei = 40e12;\n\n    function contribute() public payable {\n        require(msg.value >= amountWei, \"Contribution must be at least 40 szabo equivalent in wei\");\n    }\n\n    function getAmount() public view returns (uint) {\n        return amountWei;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public rateWei = 6e15;\n\n    function invest() public payable {\n        require(msg.value >= rateWei, \"Investment rate is 6 finney equivalent in wei\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rateWei;\n    }\n\n    function someFunction() public pure returns (string memory) {\n        return \"some\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public thresholdWei = 100e12;\n\n    function setThreshold(uint newThreshold) public {\n        thresholdWei = newThreshold * 1e12;\n    }\n\n    function getThreshold() public view returns (uint) {\n        return thresholdWei;\n    }\n}"
      }
    }
  },
  {
    "Changes26": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Functions can now only be overridden when they are either marked with the\n<code>virtual</code> keyword or defined in an interface. Functions without\nimplementation outside an interface have to be marked <code>virtual</code>.\nWhen overriding a function or modifier, the new keyword <code>override</code>\nmust be used. When overriding a function or modifier defined in multiple\nparallel bases, all bases must be listed in parentheses after the keyword\nlike so: <code>override(Base1, Base2)</code>.Add virtual to every non-interface function you intend to override.Add <code>virtual</code> to every non-interface function you intend to override. Add <code>virtual</code>to all functions without implementation outside interfaces. For single inheritance, add <code>override</code> to every overriding function. For multiple inheritance, add <code>override(A, B, ..)</code>,where you list all contracts that define the overridden function in the parentheses. When multiple bases define the same function, the inheriting contract must override all conflicting functions.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Vehicle {\n    function speed() public pure returns (uint) {\n        return 100;\n    }\n}\n\ncontract Car is Vehicle {\n    function speed() public pure returns (uint) {\n        return 150;\n    }\n}",
          "error message": ":1:153: TypeError: Overriding function is missing \"override\" specifier.\n ... } }  contract Car is Vehicle {     function speed() public pure returns (uint) {         return 150;     } }\n                                        ^---------------------------------------------------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Vehicle {     function speed() public pure returns (uint) {         return 100;     } }  contract Car is Vehicle {     f ...\n                                        ^---------------------------------------------------------------------^\n:1:48: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... ity^0.6.0;  contract Vehicle {     function speed() public pure returns (uint) {         return 100;     } }  contract Car is Vehicle {     f ...\n                                        ^---------------------------------------------------------------------^\n:1:153: Overriding function is here:\n ... } }  contract Car is Vehicle {     function speed() public pure returns (uint) {         return 150;     } }\n                                        ^---------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Animal {\n    function sound() public pure returns (string memory) {\n        return \"Roar\";\n    }\n    \n    function move() public pure returns (string memory) {\n        return \"Running\";\n    }\n}\n\ncontract Dog is Animal {\n    function sound() public pure returns (string memory) {\n        return \"Bark\";\n    }\n}",
          "error message": ":1:258: TypeError: Overriding function is missing \"override\" specifier.\n ...  } }  contract Dog is Animal {     function sound() public pure returns (string memory) {         return \"Bark\";     } }\n                                        ^---------------------------------------------------------------------------------^\n:1:47: Overridden function is here:\n ... dity^0.6.0;  contract Animal {     function sound() public pure returns (string memory) {         return \"Roar\";     }          function move() public pu ...\n                                        ^---------------------------------------------------------------------------------^\n:1:47: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... dity^0.6.0;  contract Animal {     function sound() public pure returns (string memory) {         return \"Roar\";     }          function move() public pu ...\n                                        ^---------------------------------------------------------------------------------^\n:1:258: Overriding function is here:\n ...  } }  contract Dog is Animal {     function sound() public pure returns (string memory) {         return \"Bark\";     } }\n                                        ^---------------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Tree {\n    function typeOfTree() public pure returns (string memory) {\n        return \"Oak\";\n    }\n}\n\ncontract Pine is Tree {\n    function typeOfTree() public pure returns (string memory) {\n        return \"Pine\";\n    }\n}",
          "error message": ":1:164: TypeError: Overriding function is missing \"override\" specifier.\n ...   } }  contract Pine is Tree {     function typeOfTree() public pure returns (string memory) {         return \"Pine\";     } }\n                                        ^--------------------------------------------------------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Tree {     function typeOfTree() public pure returns (string memory) {         return \"Oak\";     } }  contract Pine is Tree {     fun ...\n                                        ^-------------------------------------------------------------------------------------^\n:1:45: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... lidity^0.6.0;  contract Tree {     function typeOfTree() public pure returns (string memory) {         return \"Oak\";     } }  contract Pine is Tree {     fun ...\n                                        ^-------------------------------------------------------------------------------------^\n:1:164: Overriding function is here:\n ...   } }  contract Pine is Tree {     function typeOfTree() public pure returns (string memory) {         return \"Pine\";     } }\n                                        ^--------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Calculator {\n    function add(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}\n\ncontract AdvancedCalculator is Calculator {\n    function add(uint a, uint b) public pure returns (uint) {\n        return a + b + 1;\n    }\n}",
          "error message": ":1:188: TypeError: Overriding function is missing \"override\" specifier.\n ... ncedCalculator is Calculator {     function add(uint a, uint b) public pure returns (uint) {         return a + b + 1;     } }\n                                        ^---------------------------------------------------------------------------------------^\n:1:51: Overridden function is here:\n ... ^0.6.0;  contract Calculator {     function add(uint a, uint b) public pure returns (uint) {         return a + b;     } }  contract AdvancedCalculator is  ...\n                                        ^-----------------------------------------------------------------------------------^\n:1:51: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... ^0.6.0;  contract Calculator {     function add(uint a, uint b) public pure returns (uint) {         return a + b;     } }  contract AdvancedCalculator is  ...\n                                        ^-----------------------------------------------------------------------------------^\n:1:188: Overriding function is here:\n ... ncedCalculator is Calculator {     function add(uint a, uint b) public pure returns (uint) {         return a + b + 1;     } }\n                                        ^---------------------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Appliance {\n    function powerOn() public pure returns (string memory) {\n        return \"On\";\n    }\n}\n\ncontract WashingMachine is Appliance {\n    function powerOn() public pure returns (string memory) {\n        return \"Washing Machine On\";\n    }\n}",
          "error message": ":1:180: TypeError: Overriding function is missing \"override\" specifier.\n ...  WashingMachine is Appliance {     function powerOn() public pure returns (string memory) {         return \"Washing Machine On\";     } }\n                                        ^-------------------------------------------------------------------------------------------------^\n:1:50: Overridden function is here:\n ... y^0.6.0;  contract Appliance {     function powerOn() public pure returns (string memory) {         return \"On\";     } }  contract WashingMachine is Appl ...\n                                        ^---------------------------------------------------------------------------------^\n:1:50: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... y^0.6.0;  contract Appliance {     function powerOn() public pure returns (string memory) {         return \"On\";     } }  contract WashingMachine is Appl ...\n                                        ^---------------------------------------------------------------------------------^\n:1:180: Overriding function is here:\n ...  WashingMachine is Appliance {     function powerOn() public pure returns (string memory) {         return \"Washing Machine On\";     } }\n                                        ^-------------------------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Gadget {\n    function status() public pure returns (string memory) {\n        return \"Active\";\n    }\n    \n    function batteryLevel() public pure returns (uint) {\n        return 80;\n    }\n}\n\ncontract Smartphone is Gadget {\n    function status() public pure returns (string memory) {\n        return \"Smartphone Active\";\n    }\n}",
          "error message": ":1:260: TypeError: Overriding function is missing \"override\" specifier.\n ... ontract Smartphone is Gadget {     function status() public pure returns (string memory) {         return \"Smartphone Active\";     } }\n                                        ^-----------------------------------------------------------------------------------------------^\n:1:47: Overridden function is here:\n ... dity^0.6.0;  contract Gadget {     function status() public pure returns (string memory) {         return \"Active\";     }          function batteryLevel() p ...\n                                        ^------------------------------------------------------------------------------------^\n:1:47: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... dity^0.6.0;  contract Gadget {     function status() public pure returns (string memory) {         return \"Active\";     }          function batteryLevel() p ...\n                                        ^------------------------------------------------------------------------------------^\n:1:260: Overriding function is here:\n ... ontract Smartphone is Gadget {     function status() public pure returns (string memory) {         return \"Smartphone Active\";     } }\n                                        ^-----------------------------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Plant {\n    function growthStage() public pure returns (string memory) {\n        return \"Seedling\";\n    }\n}\n\ncontract Flower is Plant {\n    function growthStage() public pure returns (string memory) {\n        return \"Blooming\";\n    }\n}",
          "error message": ":1:174: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Flower is Plant {     function growthStage() public pure returns (string memory) {         return \"Blooming\";     } }\n                                        ^-------------------------------------------------------------------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Plant {     function growthStage() public pure returns (string memory) {         return \"Seedling\";     } }  contract Flower is Plant {      ...\n                                        ^-------------------------------------------------------------------------------------------^\n:1:46: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... idity^0.6.0;  contract Plant {     function growthStage() public pure returns (string memory) {         return \"Seedling\";     } }  contract Flower is Plant {      ...\n                                        ^-------------------------------------------------------------------------------------------^\n:1:174: Overriding function is here:\n ...  }  contract Flower is Plant {     function growthStage() public pure returns (string memory) {         return \"Blooming\";     } }\n                                        ^-------------------------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Device {\n    function operationMode() public pure returns (string memory) {\n        return \"Manual\";\n    }\n}\n\ncontract Robot is Device {\n    function operationMode() public pure returns (string memory) {\n        return \"Automatic\";\n    }\n}",
          "error message": ":1:175: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Robot is Device {     function operationMode() public pure returns (string memory) {         return \"Automatic\";     } }\n                                        ^----------------------------------------------------------------------------------------------^\n:1:47: Overridden function is here:\n ... dity^0.6.0;  contract Device {     function operationMode() public pure returns (string memory) {         return \"Manual\";     } }  contract Robot is Device {      ...\n                                        ^-------------------------------------------------------------------------------------------^\n:1:47: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... dity^0.6.0;  contract Device {     function operationMode() public pure returns (string memory) {         return \"Manual\";     } }  contract Robot is Device {      ...\n                                        ^-------------------------------------------------------------------------------------------^\n:1:175: Overriding function is here:\n ...  }  contract Robot is Device {     function operationMode() public pure returns (string memory) {         return \"Automatic\";     } }\n                                        ^----------------------------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Book {\n    function title() public pure returns (string memory) {\n        return \"Unknown Title\";\n    }\n    \n    function author() public pure returns (string memory) {\n        return \"Unknown Author\";\n    }\n}\n\ncontract Novel is Book {\n    function title() public pure returns (string memory) {\n        return \"Famous Novel\";\n    }\n}",
          "error message": ":1:274: TypeError: Overriding function is missing \"override\" specifier.\n ...  } }  contract Novel is Book {     function title() public pure returns (string memory) {         return \"Famous Novel\";     } }\n                                        ^-----------------------------------------------------------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Book {     function title() public pure returns (string memory) {         return \"Unknown Title\";     }          function author() public  ...\n                                        ^------------------------------------------------------------------------------------------^\n:1:45: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... lidity^0.6.0;  contract Book {     function title() public pure returns (string memory) {         return \"Unknown Title\";     }          function author() public  ...\n                                        ^------------------------------------------------------------------------------------------^\n:1:274: Overriding function is here:\n ...  } }  contract Novel is Book {     function title() public pure returns (string memory) {         return \"Famous Novel\";     } }\n                                        ^-----------------------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Shape {\n    function area() public pure returns (uint) {\n        return 0;\n    }\n}\n\ncontract Circle is Shape {\n    function area() public pure returns (uint) {\n        return 314;\n    }\n}",
          "error message": ":1:149: TypeError: Overriding function is missing \"override\" specifier.\n ...  }  contract Circle is Shape {     function area() public pure returns (uint) {         return 314;     } }\n                                        ^--------------------------------------------------------------------^\n:1:46: Overridden function is here:\n ... idity^0.6.0;  contract Shape {     function area() public pure returns (uint) {         return 0;     } }  contract Circle is Shape {      ...\n                                        ^------------------------------------------------------------------^\n:1:46: TypeError: Trying to override non-virtual function. Did you forget to add \"virtual\"?\n ... idity^0.6.0;  contract Shape {     function area() public pure returns (uint) {         return 0;     } }  contract Circle is Shape {      ...\n                                        ^------------------------------------------------------------------^\n:1:149: Overriding function is here:\n ...  }  contract Circle is Shape {     function area() public pure returns (uint) {         return 314;     } }\n                                        ^--------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Vehicle {\n    function speed() public virtual pure returns (uint) {\n        return 100;\n    }\n}\n\ncontract Car is Vehicle {\n    function speed() public override pure returns (uint) {\n        return 150;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Animal {\n    function sound() public virtual pure returns (string memory) {\n        return \"Roar\";\n    }\n    \n    function move() public pure returns (string memory) {\n        return \"Running\";\n    }\n}\n\ncontract Dog is Animal {\n    function sound() public override pure returns (string memory) {\n        return \"Bark\";\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Tree {\n    function typeOfTree() public virtual pure returns (string memory) {\n        return \"Oak\";\n    }\n}\n\ncontract Pine is Tree {\n    function typeOfTree() public override pure returns (string memory) {\n        return \"Pine\";\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Calculator {\n    function add(uint a, uint b) public virtual pure returns (uint) {\n        return a + b;\n    }\n}\n\ncontract AdvancedCalculator is Calculator {\n    function add(uint a, uint b) public override pure returns (uint) {\n        return a + b + 1;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Appliance {\n    function powerOn() public virtual pure returns (string memory) {\n        return \"On\";\n    }\n}\n\ncontract WashingMachine is Appliance {\n    function powerOn() public override pure returns (string memory) {\n        return \"Washing Machine On\";\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Gadget {\n    function status() public virtual pure returns (string memory) {\n        return \"Active\";\n    }\n    \n    function batteryLevel() public pure returns (uint) {\n        return 80;\n    }\n}\n\ncontract Smartphone is Gadget {\n    function status() public override pure returns (string memory) {\n        return \"Smartphone Active\";\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Plant {\n    function growthStage() public virtual pure returns (string memory) {\n        return \"Seedling\";\n    }\n}\n\ncontract Flower is Plant {\n    function growthStage() public override pure returns (string memory) {\n        return \"Blooming\";\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Device {\n    function operationMode() public virtual pure returns (string memory) {\n        return \"Manual\";\n    }\n}\n\ncontract Robot is Device {\n    function operationMode() public override pure returns (string memory) {\n        return \"Automatic\";\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Book {\n    function title() public virtual pure returns (string memory) {\n        return \"Unknown Title\";\n    }\n    \n    function author() public pure returns (string memory) {\n        return \"Unknown Author\";\n    }\n}\n\ncontract Novel is Book {\n    function title() public override pure returns (string memory) {\n        return \"Famous Novel\";\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Shape {\n    function area() public virtual pure returns (uint) {\n        return 0;\n    }\n}\n\ncontract Circle is Shape {\n    function area() public override pure returns (uint) {\n        return 314;\n    }\n}"
      }
    }
  },
  {
    "Changes27": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Member-access to <code>length</code> of arrays is now always read-only, even for storage arrays. It is no\nlonger possible to resize storage arrays by assigning a new value to their length. Use <code>push()</code>,\n<code>push(value)</code> or <code>pop()</code> instead, or assign a full array, which will of course overwrite the existing content.\nThe reason behind this is to prevent storage collisions of gigantic\nstorage arrays.Change <code>uint length = array.push(value)</code> to <code>array.push(value);</code>. The new length can be accessed via <code>array.length</code>. ",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract MyContract1 {\n    uint[] public values;\n\n    function addValue(uint val) public {\n        values.push(val);\n    }\n\n    function modifyArrayLength(uint newLength) public {\n        values.length = newLength;\n    }\n\n    function getValueCount() public view returns (uint) {\n        return values.length;\n    }\n}",
          "error message": ":1:213: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         values.length = newLength;     }      function g ...\n                                        ^-----------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ArrayContract2 {\n    uint[] public items;\n\n    function appendItem(uint item) public {\n        items.push(item);\n    }\n\n    function changeArrayLength(uint length) public {\n        items.length = length;\n    }\n\n    function getItemCount() public view returns (uint) {\n        return items.length;\n    }\n}",
          "error message": ":1:215: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         items.length = length;     }      function getI ...\n                                        ^----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract TestArray3 {\n    uint[] public records;\n\n    function addRecord(uint record) public {\n        records.push(record);\n    }\n\n    function resizeRecords(uint newSize) public {\n        records.length = newSize;\n    }\n\n    function numberOfRecords() public view returns (uint) {\n        return records.length;\n    }\n}",
          "error message": ":1:215: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... rds(uint newSize) public {         records.length = newSize;     }      function num ...\n                                        ^------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint[] public storageList;\n\n    function pushToStorage(uint val) public {\n        storageList.push(val);\n    }\n\n    function setStorageLength(uint newLength) public {\n        storageList.length = newLength;\n    }\n}",
          "error message": ":1:232: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         storageList.length = newLength;     } }\n                                        ^----------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleArray5 {\n    uint[] public myArray;\n\n    function addEntryToMyArray(uint entry) public {\n        myArray.push(entry);\n    }\n\n    function changeMyArrayLength(uint length) public {\n        myArray.length = length;\n    }\n\n    function getArraySize() public view returns (uint) {\n        return myArray.length;\n    }\n}",
          "error message": ":1:229: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         myArray.length = length;     }      function getA ...\n                                        ^------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract DynamicArray6 {\n    uint[] public dynamicList;\n\n    function addDynamicEntry(uint entry) public {\n        dynamicList.push(entry);\n    }\n\n    function modifyDynamicListLength(uint newLength) public {\n        dynamicList.length = newLength;\n    }\n\n    function dynamicListSize() public view returns (uint) {\n        return dynamicList.length;\n    }\n}",
          "error message": ":1:242: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         dynamicList.length = newLength;     }      function d ...\n                                        ^----------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ResizableArray7 {\n    uint[] public dataStore;\n\n    function insertData(uint data) public {\n        dataStore.push(data);\n    }\n\n    function adjustDataStoreLength(uint newLength) public {\n        dataStore.length = newLength;\n    }\n\n    function getDataStoreSize() public view returns (uint) {\n        return dataStore.length;\n    }\n\n    function randomExtraFunction() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": ":1:231: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... h(uint newLength) public {         dataStore.length = newLength;     }      function g ...\n                                        ^--------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ListContract8 {\n    uint[] public valueList;\n\n    function addValueToList(uint value) public {\n        valueList.push(value);\n    }\n\n    function setListLength(uint length) public {\n        valueList.length = length;\n    }\n\n    function getListSize() public view returns (uint) {\n        return valueList.length;\n    }\n}",
          "error message": ":1:224: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         valueList.length = length;     }      function getL ...\n                                        ^--------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract AdjustableArray9 {\n    uint[] public arrayValues;\n\n    function insertValue(uint value) public {\n        arrayValues.push(value);\n    }\n\n    function changeArraySize(uint size) public {\n        arrayValues.length = size;\n    }\n\n    function arraySize() public view returns (uint) {\n        return arrayValues.length;\n    }\n\n    function anotherFunction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:228: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... aySize(uint size) public {         arrayValues.length = size;     }      function arrayS ...\n                                        ^----------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract CollectionContract10 {\n    uint[] public collection;\n\n    function addItem(uint item) public {\n        collection.push(item);\n    }\n\n    function adjustCollectionLength(uint length) public {\n        collection.length = length;\n    }\n}",
          "error message": ":1:233: TypeError: Member \"length\" is read-only and cannot be used to resize arrays.\n ... ngth(uint length) public {         collection.length = length;     } }\n                                        ^---------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract MyContract1 {\n    uint[] public values;\n\n    function addValue(uint val) public {\n        values.push(val);\n    }\n\n    function modifyArrayLength(uint newLength) public {\n        if (newLength < values.length) {\n            while (values.length > newLength) {\n                values.pop();\n            }\n        } else {\n            for (uint i = values.length; i < newLength; i++) {\n                values.push(0);\n            }\n        }\n    }\n\n    function getValueCount() public view returns (uint) {\n        return values.length;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ArrayContract2 {\n    uint[] public items;\n\n    function appendItem(uint item) public {\n        items.push(item);\n    }\n\n    function changeArrayLength(uint length) public {\n        if (length < items.length) {\n            while (items.length > length) {\n                items.pop();\n            }\n        } else {\n            for (uint i = items.length; i < length; i++) {\n                items.push(0);\n            }\n        }\n    }\n\n    function getItemCount() public view returns (uint) {\n        return items.length;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract TestArray3 {\n    uint[] public records;\n\n    function addRecord(uint record) public {\n        records.push(record);\n    }\n\n    function resizeRecords(uint newSize) public {\n        if (newSize < records.length) {\n            while (records.length > newSize) {\n                records.pop();\n            }\n        } else {\n            for (uint i = records.length; i < newSize; i++) {\n                records.push(0);\n            }\n        }\n    }\n\n    function numberOfRecords() public view returns (uint) {\n        return records.length;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractExample4 {\n    uint[] public storageList;\n\n    function pushToStorage(uint val) public {\n        storageList.push(val);\n    }\n\n    function setStorageLength(uint newLength) public {\n        if (newLength < storageList.length) {\n            while (storageList.length > newLength) {\n                storageList.pop();\n            }\n        } else {\n            for (uint i = storageList.length; i < newLength; i++) {\n                storageList.push(0);\n            }\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ExampleArray5 {\n    uint[] public myArray;\n\n    function addEntryToMyArray(uint entry) public {\n        myArray.push(entry);\n    }\n\n    function changeMyArrayLength(uint length) public {\n        if (length < myArray.length) {\n            while (myArray.length > length) {\n                myArray.pop();\n            }\n        } else {\n            for (uint i = myArray.length; i < length; i++) {\n                myArray.push(0);\n            }\n        }\n    }\n\n    function getArraySize() public view returns (uint) {\n        return myArray.length;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract DynamicArray6 {\n    uint[] public dynamicList;\n\n    function addDynamicEntry(uint entry) public {\n        dynamicList.push(entry);\n    }\n\n    function modifyDynamicListLength(uint newLength) public {\n        if (newLength < dynamicList.length) {\n            while (dynamicList.length > newLength) {\n                dynamicList.pop();\n            }\n        } else {\n            for (uint i = dynamicList.length; i < newLength; i++) {\n                dynamicList.push(0);\n            }\n        }\n    }\n\n    function dynamicListSize() public view returns (uint) {\n        return dynamicList.length;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ResizableArray7 {\n    uint[] public dataStore;\n\n    function insertData(uint data) public {\n        dataStore.push(data);\n    }\n\n    function adjustDataStoreLength(uint newLength) public {\n        if (newLength < dataStore.length) {\n            while (dataStore.length > newLength) {\n                dataStore.pop();\n            }\n        } else {\n            for (uint i = dataStore.length; i < newLength; i++) {\n                dataStore.push(0);\n            }\n        }\n    }\n\n    function getDataStoreSize() public view returns (uint) {\n        return dataStore.length;\n    }\n\n    function randomExtraFunction() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ListContract8 {\n    uint[] public valueList;\n\n    function addValueToList(uint value) public {\n        valueList.push(value);\n    }\n\n    function setListLength(uint length) public {\n        if (length < valueList.length) {\n            while (valueList.length > length) {\n                valueList.pop();\n            }\n        } else {\n            for (uint i = valueList.length; i < length; i++) {\n                valueList.push(0);\n            }\n        }\n    }\n\n    function getListSize() public view returns (uint) {\n        return valueList.length;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract AdjustableArray9 {\n    uint[] public arrayValues;\n\n    function insertValue(uint value) public {\n        arrayValues.push(value);\n    }\n\n    function changeArraySize(uint size) public {\n        if (size < arrayValues.length) {\n            while (arrayValues.length > size) {\n                arrayValues.pop();\n            }\n        } else {\n            for (uint i = arrayValues.length; i < size; i++) {\n                arrayValues.push(0);\n            }\n        }\n    }\n\n    function arraySize() public view returns (uint) {\n        return arrayValues.length;\n    }\n\n    function anotherFunction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract CollectionContract10 {\n    uint[] public collection;\n\n    function addItem(uint item) public {\n        collection.push(item);\n    }\n\n    function adjustCollectionLength(uint length) public {\n        if (length < collection.length) {\n            while (collection.length > length) {\n                collection.pop();\n            }\n        } else {\n            for (uint i = collection.length; i < length; i++) {\n                collection.push(0);\n            }\n        }\n    }\n}"
      }
    }
  },
  {
    "Changes28": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The new keyword <code>abstract</code> can be used to mark contracts as abstract. It has to be used\nif a contract does not implement all its functions. Abstract contracts cannot be created using the <code>new</code> operator,\nand it is not possible to generate bytecode for them during compilation.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example11 {\n    function futureWork() public;\n    function execute() public pure returns (uint256) {\n        return 500;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example11\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example11 {     function futureWork() public;     function execute() public pure returns (uint256) {         return 500;     } }\n                        ^---------------------------------------------------------------------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example11 {     function futureWork() public;     function execute() public pure ...\n                                        ^---------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example11 {     function futureWork() public;     function execute() public pure ...\n                                        ^---------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example12 {\n    function unfinishedTask() public;\n    function retrieveData() public pure returns (string memory) {\n        return \"Data Retrieved\";\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example12\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example12 {     function u ...    return \"Data Retrieved\";     } }\n                        ^-------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example12 {     function unfinishedTask() public;     function retrieveData() public ...\n                                        ^-------------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example12 {     function unfinishedTask() public;     function retrieveData() public ...\n                                        ^-------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example13 {\n    function taskIncomplete() public;\n    function performAction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example13\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example13 {     function taskIncomplete() public;     function performAction() public pure returns (bool) {         return true;     } }\n                        ^-----------------------------------------------------------------------------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example13 {     function taskIncomplete() public;     function performAction() publi ...\n                                        ^-------------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example13 {     function taskIncomplete() public;     function performAction() publi ...\n                                        ^-------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example14 {\n    function pendingFunction() public;\n    function calculate() public pure returns (int256) {\n        return -100;\n    }\n    function getDetails() public pure returns (string memory) {\n        return \"Details\";\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example14\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example14 {     function p ... {         return \"Details\";     } }\n                        ^-------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example14 {     function pendingFunction() public;     function calculate() public pu ...\n                                        ^--------------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example14 {     function pendingFunction() public;     function calculate() public pu ...\n                                        ^--------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example15 {\n    function deferredTask() public;\n    function fetchResults() public pure returns (bytes32) {\n        return keccak256(\"Result\");\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example15\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example15 {     function d ... return keccak256(\"Result\");     } }\n                        ^-------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example15 {     function deferredTask() public;     function fetchResults() public ...\n                                        ^-----------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example15 {     function deferredTask() public;     function fetchResults() public ...\n                                        ^-----------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example16 {\n    function placeholderFunction() public;\n    function determineValue() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example16\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example16 {     function placeholderFunction() public;     function determineValue() public pure returns (uint) {         return 123;     } }\n                        ^----------------------------------------------------------------------------------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example16 {     function placeholderFunction() public;     function determineValue() publ ...\n                                        ^------------------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example16 {     function placeholderFunction() public;     function determineValue() publ ...\n                                        ^------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example17 {\n    function toBeCompleted() public;\n    function getValue() public pure returns (uint16) {\n        return 256;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example17\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example17 {     function toBeCompleted() public;     function getValue() public pure returns (uint16) {         return 256;     } }\n                        ^------------------------------------------------------------------------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example17 {     function toBeCompleted() public;     function getValue() public pur ...\n                                        ^------------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example17 {     function toBeCompleted() public;     function getValue() public pur ...\n                                        ^------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example18 {\n    function incompleteStep() public;\n    function calculateSum() public pure returns (int) {\n        return 10 + 20;\n}\n    function additionalStep() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example18\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example18 {     function i ... ol) {         return false;     } }\n                        ^-------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example18 {     function incompleteStep() public;     function calculateSum() public ...\n                                        ^-------------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example18 {     function incompleteStep() public;     function calculateSum() public ...\n                                        ^-------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example19 {\n    function unfinalizedFunction() public;\n    function calculateSum() public pure returns (int) {\n        return 10 + 20;\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example19\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example19 {     function u ... ) {         return 10 + 20;     } }\n                        ^-------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example19 {     function unfinalizedFunction() public;     function calculateSum() public ...\n                                        ^------------------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example19 {     function unfinalizedFunction() public;     function calculateSum() public ...\n                                        ^------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example20 {\n    function unfinishedProcess() public;\n    function finalize() public pure returns (string memory) {\n        return \"Finalized\";\n    }\n}",
          "error message": ":1:25: TypeError: Contract \"Example20\" should be marked as abstract.\npragma solidity^0.6.0;  contract Example20 {     function u ...         return \"Finalized\";     } }\n                        ^-------------------------------------------------------------------------^\n:1:50: Missing implementation:\n ... y^0.6.0;  contract Example20 {     function unfinishedProcess() public;     function finalize() public pur ...\n                                        ^----------------------------------^\n:1:50: TypeError: Functions without implementation must be marked virtual.\n ... y^0.6.0;  contract Example20 {     function unfinishedProcess() public;     function finalize() public pur ...\n                                        ^----------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\nabstract contract Example11 {\n    function futureWork() public virtual;\n    function execute() public pure returns (uint256) {\n        return 500;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\nabstract contract Example12 {\n    function unfinishedTask() public virtual;\n    function retrieveData() public pure returns (string memory) {\n        return \"Data Retrieved\";\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\nabstract contract Example13 {\n    function taskIncomplete() public virtual;\n    function performAction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\nabstract contract Example14 {\n    function pendingFunction() public virtual;\n    function calculate() public pure returns (int256) {\n        return -100;\n    }\n    function getDetails() public pure returns (string memory) {\n        return \"Details\";\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\nabstract contract Example15 {\n    function deferredTask() public virtual;\n    function fetchResults() public pure returns (bytes32) {\n        return keccak256(\"Result\");\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\nabstract contract Example16 {\n    function placeholderFunction() public virtual;\n    function determineValue() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\nabstract contract Example17 {\n    function toBeCompleted() public virtual;\n    function getValue() public pure returns (uint16) {\n        return 256;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\nabstract contract Example18 {\n    function incompleteStep() public virtual;\n    function calculateSum() public pure returns (int) {\n        return 10 + 20;\n}\n    function additionalStep() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\nabstract contract Example19 {\n    function unfinalizedFunction() public virtual;\n    function calculateSum() public pure returns (int) {\n        return 10 + 20;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\nabstract contract Example20 {\n    function unfinishedProcess() public virtual;\n    function finalize() public pure returns (string memory) {\n        return \"Finalized\";\n    }\n}"
      }
    }
  },
  {
    "Changes29": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Libraries have to implement all their functions, not only the internal ones.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary SafeMathLib {\n    function internalAdd(uint a, uint b) internal pure returns (uint) {\n        require(a + b >= a, \"Addition overflow\");\n        return a + b;\n    }\n\n    function publicSubtract(uint a, uint b) public pure returns (uint);\n}\n\ncontract SafeMathUsage {\n    using SafeMathLib for uint;\n\n    function addSafe(uint a, uint b) public pure returns (uint) {\n        return SafeMathLib.internalAdd(a, b);\n    }\n\n    function dummyOperation() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:202: TypeError: Library functions must be implemented if declared.\n ... ;         return a + b;     }      function publicSubtract(uint a, uint b) public pure returns (uint); }  contract SafeMathUsage {     us ...\n                                        ^-----------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary DateTimeLib {\n    function internalGetYear(uint timestamp) internal pure returns (uint) {\n        return (timestamp / 31556926) + 1970;\n    }\n\n    function publicGetMonth(uint timestamp) public pure returns (uint);\n}\n\ncontract DateTimeContract {\n    using DateTimeLib for uint;\n\n    function getYear(uint timestamp) public pure returns (uint) {\n        return DateTimeLib.internalGetYear(timestamp);\n    }\n\n    function getCurrentYear() public view returns (uint) {\n        return DateTimeLib.internalGetYear(now);\n    }\n}",
          "error message": ":1:180: TypeError: Library functions must be implemented if declared.\n ... amp / 31556926) + 1970;     }      function publicGetMonth(uint timestamp) public pure returns (uint); }  contract DateTimeContract {     ...\n                                        ^-----------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary ConversionLib {\n    function internalToUint256(bytes32 data) internal pure returns (uint256) {\n        return uint256(data);\n    }\n\n    function publicToAddress(bytes32 data) public pure returns (address);\n}\n\ncontract ConversionContract {\n    using ConversionLib for bytes32;\n\n    function convertToUint256(bytes32 data) public pure returns (uint256) {\n        return ConversionLib.internalToUint256(data);\n    }\n\n    function dummyConversion() public pure returns (bytes32) {\n        return bytes32(0);\n    }\n}",
          "error message": ":1:169: TypeError: Library functions must be implemented if declared.\n ...   return uint256(data);     }      function publicToAddress(bytes32 data) public pure returns (address); }  contract ConversionContract {   ...\n                                        ^-------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary ListLib {\n    function internalPush(uint[] storage list, uint item) internal {\n        list.push(item);\n    }\n\n    function publicPop(uint[] storage list) public returns (uint);\n}\n\ncontract ListContract {\n    using ListLib for uint[];\n\n    uint[] private list;\n\n    function addItem(uint item) public {\n        list.internalPush(item);\n    }\n\n    function dummyListFunction() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": ":1:148: TypeError: Library functions must be implemented if declared.\n ...        list.push(item);     }      function publicPop(uint[] storage list) public returns (uint); }  contract ListContract {     usi ...\n                                        ^------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary AuthLib {\n    function internalIsAdmin(address user) internal view returns (bool) {\n        return user == address(0);\n    }\n\n    function publicIsAuthorized(address user) public view returns (bool);\n}\n\ncontract AuthContract {\n    using AuthLib for address;\n\n    function checkAdmin(address user) public view returns (bool) {\n        return user.internalIsAdmin();\n    }\n\n    function dummyAuthCheck() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:163: TypeError: Library functions must be implemented if declared.\n ... urn user == address(0);     }      function publicIsAuthorized(address user) public view returns (bool); }  contract AuthContract {     usi ...\n                                        ^-------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary RandomLib {\n    function internalRandom(uint seed) internal pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(seed)));\n    }\n\n    function publicRandomRange(uint seed, uint min, uint max) public pure returns (uint);\n}\n\ncontract RandomContract {\n    using RandomLib for uint;\n\n    function getRandomNumber(uint seed) public pure returns (uint) {\n        return RandomLib.internalRandom(seed);\n    }\n}",
          "error message": ":1:182: TypeError: Library functions must be implemented if declared.\n ... i.encodePacked(seed)));     }      function publicRandomRange(uint seed, uint min, uint max) public pure returns (uint); }  contract RandomContract {     u ...\n                                        ^-----------------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary SortLib {\n    function internalSort(uint[] memory arr) internal pure returns (uint[] memory) {\n        for (uint i = 0; i < arr.length; i++) {\n            for (uint j = i + 1; j < arr.length; j++) {\n                if (arr[i] > arr[j]) {\n                    (arr[i], arr[j]) = (arr[j], arr[i]);\n                }\n            }\n        }\n        return arr;\n    }\n\n    function publicFindMin(uint[] memory arr) public pure returns (uint);\n}\n\ncontract SortContract {\n    using SortLib for uint[];\n\n    function sortArray(uint[] memory arr) public pure returns (uint[] memory) {\n        return arr.internalSort();\n    }\n}",
          "error message": ":1:401: TypeError: Library functions must be implemented if declared.\n ...   }         return arr;     }      function publicFindMin(uint[] memory arr) public pure returns (uint); }  contract SortContract {     usi ...\n                                        ^-------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary LoanLib {\n    function internalCalculateEMI(uint principal, uint rate, uint time) internal pure returns (uint) {\n        return (principal * rate * time) / 100;\n    }\n\n    function publicLoanEligibility(uint income, uint age) public pure returns (bool);\n}\n\ncontract LoanContract {\n    using LoanLib for uint;\n\n    function calculateEMI(uint principal, uint rate, uint time) public pure returns (uint) {\n        return LoanLib.internalCalculateEMI(principal, rate, time);\n    }\n}",
          "error message": ":1:205: TypeError: Library functions must be implemented if declared.\n ... l * rate * time) / 100;     }      function publicLoanEligibility(uint income, uint age) public pure returns (bool); }  contract LoanContract {     usi ...\n                                        ^-------------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary MathLib {\n    function internalPower(uint base, uint exp) internal pure returns (uint) {\n        uint result = 1;\n        for (uint i = 0; i < exp; i++) {\n            result *= base;\n        }\n        return result;\n    }\n\n    function publicFactorial(uint number) public pure returns (uint);\n}\n\ncontract MathContract {\n    using MathLib for uint;\n\n    function calculatePower(uint base, uint exp) public pure returns (uint) {\n        return MathLib.internalPower(base, exp);\n    }\n}",
          "error message": ":1:260: TypeError: Library functions must be implemented if declared.\n ...          return result;     }      function publicFactorial(uint number) public pure returns (uint); }  contract MathContract {     usi ...\n                                        ^---------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\nlibrary VotingHelperLib {\n    function internalCountVotes(uint[] memory votes) internal pure returns (uint) {\n        uint totalVotes = 0;\n        for (uint i = 0; i < votes.length; i++) {\n            totalVotes += votes[i];\n        }\n        return totalVotes;\n    }\n\n    function publicAnnounceWinner(uint[] memory votes) public pure returns (uint);\n}\n\ncontract VotingHelperContract {\n    using VotingHelperLib for uint[];\n\n    function getTotalVotes(uint[] memory votes) public pure returns (uint) {\n        return VotingHelperLib.internalCountVotes(votes);\n    }\n\n    function dummyVoteFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:298: TypeError: Library functions must be implemented if declared.\n ...      return totalVotes;     }      function publicAnnounceWinner(uint[] memory votes) public pure returns (uint); }  contract VotingHelperContract { ...\n                                        ^----------------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\nlibrary SafeMathLib {\n    function internalAdd(uint a, uint b) internal pure returns (uint) {\n        require(a + b >= a, \"Addition overflow\");\n        return a + b;\n    }\n\n    function publicSubtract(uint a, uint b) public pure returns (uint) {\n        require(a >= b, \"Subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract SafeMathUsage {\n    using SafeMathLib for uint;\n\n    function addSafe(uint a, uint b) public pure returns (uint) {\n        return SafeMathLib.internalAdd(a, b);\n    }\n\n    function dummyOperation() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\nlibrary DateTimeLib {\n    function internalGetYear(uint timestamp) internal pure returns (uint) {\n        return (timestamp / 31556926) + 1970;\n    }\n\n    function publicGetMonth(uint timestamp) public pure returns (uint) {\n        return (timestamp / 2629743) % 12 + 1;\n    }\n}\n\ncontract DateTimeContract {\n    using DateTimeLib for uint;\n\n    function getYear(uint timestamp) public pure returns (uint) {\n        return DateTimeLib.internalGetYear(timestamp);\n    }\n\n    function getCurrentYear() public view returns (uint) {\n        return DateTimeLib.internalGetYear(now);\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\nlibrary ConversionLib {\n    function internalToUint256(bytes32 data) internal pure returns (uint256) {\n        return uint256(data);\n    }\n\n    function publicToAddress(bytes32 data) public pure returns (address) {\n        return address(uint160(uint256(data)));\n    }\n}\n\ncontract ConversionContract {\n    using ConversionLib for bytes32;\n\n    function convertToUint256(bytes32 data) public pure returns (uint256) {\n        return ConversionLib.internalToUint256(data);\n    }\n\n    function dummyConversion() public pure returns (bytes32) {\n        return bytes32(0);\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\nlibrary ListLib {\n    function internalPush(uint[] storage list, uint item) internal {\n        list.push(item);\n    }\n\n    function publicPop(uint[] storage list) public returns (uint) {\n        require(list.length > 0, \"List is empty\");\n        uint item = list[list.length - 1];\n        list.pop();\n        return item;\n    }\n}\n\ncontract ListContract {\n    using ListLib for uint[];\n\n    uint[] private list;\n\n    function addItem(uint item) public {\n        list.internalPush(item);\n    }\n\n    function dummyListFunction() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\nlibrary AuthLib {\n    function internalIsAdmin(address user) internal view returns (bool) {\n        return user == address(0);\n    }\n\n    function publicIsAuthorized(address user) public view returns (bool) {\n        return user != address(0);\n    }\n}\n\ncontract AuthContract {\n    using AuthLib for address;\n\n    function checkAdmin(address user) public view returns (bool) {\n        return user.internalIsAdmin();\n    }\n\n    function dummyAuthCheck() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\nlibrary RandomLib {\n    function internalRandom(uint seed) internal pure returns (uint) {\n        return uint(keccak256(abi.encodePacked(seed)));\n    }\n\n    function publicRandomRange(uint seed, uint min, uint max) public pure returns (uint) {\n        require(max > min, \"Invalid range\");\n        return min + (internalRandom(seed) % (max - min + 1));\n    }\n}\n\ncontract RandomContract {\n    using RandomLib for uint;\n\n    function getRandomNumber(uint seed) public pure returns (uint) {\n        return RandomLib.internalRandom(seed);\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\nlibrary SortLib {\n    function internalSort(uint[] memory arr) internal pure returns (uint[] memory) {\n        for (uint i = 0; i < arr.length; i++) {\n            for (uint j = i + 1; j < arr.length; j++) {\n                if (arr[i] > arr[j]) {\n                    (arr[i], arr[j]) = (arr[j], arr[i]);\n                }\n            }\n        }\n        return arr;\n    }\n\n    function publicFindMin(uint[] memory arr) public pure returns (uint) {\n        require(arr.length > 0, \"Array is empty\");\n        uint min = arr[0];\n        for (uint i = 1; i < arr.length; i++) {\n            if (arr[i] < min) {\n                min = arr[i];\n            }\n        }\n        return min;\n    }\n}\n\ncontract SortContract {\n    using SortLib for uint[];\n\n    function sortArray(uint[] memory arr) public pure returns (uint[] memory) {\n        return arr.internalSort();\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\nlibrary LoanLib {\n    function internalCalculateEMI(uint principal, uint rate, uint time) internal pure returns (uint) {\n        return (principal * rate * time) / 100;\n    }\n\n    function publicLoanEligibility(uint income, uint age) public pure returns (bool) {\n        return income > 50000 && age < 60;\n    }\n}\n\ncontract LoanContract {\n    using LoanLib for uint;\n\n    function calculateEMI(uint principal, uint rate, uint time) public pure returns (uint) {\n        return LoanLib.internalCalculateEMI(principal, rate, time);\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\nlibrary MathLib {\n    function internalPower(uint base, uint exp) internal pure returns (uint) {\n        uint result = 1;\n        for (uint i = 0; i < exp; i++) {\n            result *= base;\n        }\n        return result;\n    }\n\n    function publicFactorial(uint number) public pure returns (uint) {\n        require(number > 0, \"Number must be greater than zero\");\n        uint result = 1;\n        for (uint i = 2; i <= number; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}\n\ncontract MathContract {\n    using MathLib for uint;\n\n    function calculatePower(uint base, uint exp) public pure returns (uint) {\n        return MathLib.internalPower(base, exp);\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\nlibrary VotingHelperLib {\n    function internalCountVotes(uint[] memory votes) internal pure returns (uint) {\n        uint totalVotes = 0;\n        for (uint i = 0; i < votes.length; i++) {\n            totalVotes += votes[i];\n        }\n        return totalVotes;\n    }\n\n    function publicAnnounceWinner(uint[] memory votes) public pure returns (uint) {\n        require(votes.length > 0, \"No votes cast\");\n        uint maxVotes = votes[0];\n        uint winnerIndex = 0;\n        for (uint i = 1; i < votes.length; i++) {\n            if (votes[i] > maxVotes) {\n                maxVotes = votes[i];\n                winnerIndex = i;\n            }\n        }\n        return winnerIndex;\n    }\n}\n\ncontract VotingHelperContract {\n    using VotingHelperLib for uint[];\n\n    function getTotalVotes(uint[] memory votes) public pure returns (uint) {\n        return VotingHelperLib.internalCountVotes(votes);\n    }\n\n    function dummyVoteFunction() public pure returns (bool) {\n        return true;\n    }\n}"
      }
    }
  },
  {
    "Changes30": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The names of variables declared in inline assembly may no longer end in <code>_slot</code> or <code>_offset</code>.Choose unique identifiers for variable declarations in inline assembly that do not conflict with declarations outside the inline assembly block.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractK {\n    uint256 public totalAmount;\n\n    function setTotalAmount(uint256 _value) public {\n        assembly {\n            let totalAmount_slot := _value\n            sstore(totalAmount_slot, _value)\n        }\n    }\n}",
          "error message": ":1:167: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let totalAmount_slot := _value             sstore(total ...\n                                        ^--------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractL {\n    uint256 public reserveBalance;\n\n    function updateReserve(uint256 _newReserve) public {\n        assembly {\n            let reserve_offset := _newReserve\n            sstore(reserve_offset, _newReserve)\n        }\n    }\n}",
          "error message": ":1:174: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let reserve_offset := _newReserve             sstore( ...\n                                        ^------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractM {\n    address public mainOwner;\n\n    function assignOwner(address _owner) public {\n        assembly {\n            let mainOwner_slot := _owner\n            sstore(mainOwner_slot, _owner)\n        }\n    }\n}",
          "error message": ":1:162: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let mainOwner_slot := _owner             sstore(mainO ...\n                                        ^------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractN {\n    bytes32 public hashValue;\n\n    function storeHash(bytes32 _hash) public {\n        assembly {\n            let hashValue_slot := _hash\n            sstore(hashValue_slot, _hash)\n        }\n    }\n}",
          "error message": ":1:159: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let hashValue_slot := _hash             sstore(hashVa ...\n                                        ^------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractO {\n    uint256 public totalSupply;\n\n    function changeSupply(uint256 _supply) public {\n        assembly {\n            let totalSupply_offset := _supply\n            sstore(totalSupply_offset, _supply)\n        }\n    }\n}",
          "error message": ":1:166: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let totalSupply_offset := _supply             sstore(tota ...\n                                        ^----------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractP {\n    uint256 public storedValue;\n\n    function setStoredValue(uint256 _val) public {\n        assembly {\n            let storedValue_slot := _val\n            sstore(storedValue_slot, _val)\n        }\n    }\n}",
          "error message": ":1:165: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let storedValue_slot := _val             sstore(storedV ...\n                                        ^--------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractQ {\n    bool public isAvailable;\n\n    function setAvailability(bool _status) public {\n        assembly {\n            let availability_slot := _status\n            sstore(availability_slot, _status)\n        }\n    }\n}",
          "error message": ":1:163: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let availability_slot := _status             sstore(avai ...\n                                        ^---------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractR {\n    uint256 public itemCount;\n\n    function updateItemCount(uint256 _count) public {\n        assembly {\n            let itemCount_offset := _count\n            sstore(itemCount_offset, _count)\n        }\n    }\n}",
          "error message": ":1:166: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let itemCount_offset := _count             sstore(itemC ...\n                                        ^--------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractS {\n    bytes32 public secretCode;\n\n    function saveCode(bytes32 _code) public {\n        assembly {\n            let secretCode_slot := _code\n            sstore(secretCode_slot, _code)\n        }\n    }\n}",
          "error message": ":1:159: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let secretCode_slot := _code             sstore(secret ...\n                                        ^-------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractT {\n    address public mainAdmin;\n\n    function setAdmin(address _admin) public {\n        assembly {\n            let admin_offset := _admin\n            sstore(admin_offset, _admin)\n        }\n    }\n}",
          "error message": ":1:159: DeclarationError: In variable declarations _slot and _offset can not be used as a suffix.\n ...         assembly {             let admin_offset := _admin             sstore(admin ...\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ContractK {\n    uint256 public totalAmount;\n\n    function setTotalAmount(uint256 _value) public {\n        assembly {\n            let totalAmountLoc := _value\n            sstore(totalAmountLoc, _value)\n        }\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ContractL {\n    uint256 public reserveBalance;\n\n    function updateReserve(uint256 _newReserve) public {\n        assembly {\n            let reserveLoc := _newReserve\n            sstore(reserveLoc, _newReserve)\n        }\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ContractM {\n    address public mainOwner;\n\n    function assignOwner(address _owner) public {\n        assembly {\n            let mainOwnerLoc := _owner\n            sstore(mainOwnerLoc, _owner)\n        }\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractN {\n    bytes32 public hashValue;\n\n    function storeHash(bytes32 _hash) public {\n        assembly {\n            let hashValueLoc := _hash\n            sstore(hashValueLoc, _hash)\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ContractO {\n    uint256 public totalSupply;\n\n    function changeSupply(uint256 _supply) public {\n        assembly {\n            let totalSupplyLoc := _supply\n            sstore(totalSupplyLoc, _supply)\n        }\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ContractP {\n    uint256 public storedValue;\n\n    function setStoredValue(uint256 _val) public {\n        assembly {\n            let storedValueLoc := _val\n            sstore(storedValueLoc, _val)\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ContractQ {\n    bool public isAvailable;\n\n    function setAvailability(bool _status) public {\n        assembly {\n            let availabilityLoc := _status\n            sstore(availabilityLoc, _status)\n        }\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ContractR {\n    uint256 public itemCount;\n\n    function updateItemCount(uint256 _count) public {\n        assembly {\n            let itemCountLoc := _count\n            sstore(itemCountLoc, _count)\n        }\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ContractS {\n    bytes32 public secretCode;\n\n    function saveCode(bytes32 _code) public {\n        assembly {\n            let secretCodeLoc := _code\n            sstore(secretCodeLoc, _code)\n        }\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ContractT {\n    address public mainAdmin;\n\n    function setAdmin(address _admin) public {\n        assembly {\n            let adminLoc := _admin\n            sstore(adminLoc, _admin)\n        }\n    }\n}"
      }
    }
  },
  {
    "Changes31": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Variable declarations in inline assembly may no longer shadow any declaration outside the inline assembly block.\nIf the name contains a dot, its prefix up to the dot may not conflict with any declaration outside the inline\nassembly block.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example11 {\n    uint256 public supply = 100;\n\n    function updateSupply() public {\n        uint256 supply = 200;\n        assembly {\n            let supply := 300\n        }\n    }\n}",
          "error message": ":1:182: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let supply := 300         }     } }\n                                        ^----^\n:1:125: The shadowed declaration is here:\n ... on updateSupply() public {         uint256 supply = 200;         assembly {          ...\n                                        ^------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example12 {\n    string public title = \"Initial Title\";\n\n    function setTitle(string memory newTitle) public {\n        string memory title = newTitle;\n        assembly {\n            let title := \"New Title\"\n        }\n    }\n}",
          "error message": ":1:220: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let title := \"New Title\"         }     } }\n                                        ^---^\n:1:153: The shadowed declaration is here:\n ...  memory newTitle) public {         string memory title = newTitle;         assembly {     ...\n                                        ^-----------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example13 {\n    uint256 public fee = 5;\n\n    function adjustFee() public {\n        uint256 fee = 10;\n        assembly {\n            let fee := 15\n        }\n    }\n\n    function dummyFunction() public pure returns (string memory) {\n        return \"dummy\";\n    }\n}",
          "error message": ":1:170: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let fee := 15         }     }      functio ...\n                                        ^-^\n:1:117: The shadowed declaration is here:\n ... ction adjustFee() public {         uint256 fee = 10;         assembly {           ...\n                                        ^---------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example14 {\n    bytes32 public identifier = keccak256(\"ID\");\n\n    function changeIdentifier() public {\n        bytes32 identifier = keccak256(\"NewID\");\n        assembly {\n            let identifier := keccak256(add(\"AltID\", 0x20), 0x20)\n        }\n    }\n}",
          "error message": ":1:221: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let identifier := keccak256(add(\"AltID\", 0x20), 0 ...\n                                        ^--------^\n:1:145: The shadowed declaration is here:\n ... hangeIdentifier() public {         bytes32 identifier = keccak256(\"NewID\");         asse ...\n                                        ^----------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example15 {\n    address public userAddress;\n\n    function setUserAddress(address addr) public {\n        userAddress = addr;\n        assembly {\n            let userAddress := addr\n        }\n    }\n\n    function anotherFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:193: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let userAddress := addr         }     }      funct ...\n                                        ^---------^\n:1:50: The shadowed declaration is here:\n ... y^0.6.0;  contract Example15 {     address public userAddress;      function setUserAddress(addr ...\n                                        ^------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example16 {\n    bool public status = false;\n\n    function flipStatus() public {\n        bool status = true;\n        assembly {\n            let status := 0\n        }\n    }\n}",
          "error message": ":1:177: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let status := 0         }     } }\n                                        ^----^\n:1:122: The shadowed declaration is here:\n ... tion flipStatus() public {         bool status = true;         assembly {         ...\n                                        ^---------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example17 {\n    int256 public total = 50;\n\n    function modifyTotal(int256 value) public {\n        int256 total = value;\n        assembly {\n            let total := 100\n        }\n    }\n\n    function getTotal() public view returns (int256) {\n        return total;\n    }\n}",
          "error message": ":1:190: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let total := 100         }     }      functi ...\n                                        ^---^\n:1:133: The shadowed declaration is here:\n ... tal(int256 value) public {         int256 total = value;         assembly {        ...\n                                        ^----------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example18 {\n    string public description = \"Default\";\n\n    function updateDescription() public {\n        string memory description = \"Updated\";\n        assembly {\n            let description := \"Final\"\n        }\n    }\n}",
          "error message": ":1:214: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let description := \"Final\"         }     } }\n                                        ^---------^\n:1:140: The shadowed declaration is here:\n ... dateDescription() public {         string memory description = \"Updated\";         assembly {    ...\n                                        ^-----------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example19 {\n    uint256 public limit = 1000;\n\n    function changeLimit() public {\n        uint256 limit = 500;\n        assembly {\n            let limit := 250\n        }\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return limit;\n    }\n}",
          "error message": ":1:180: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let limit := 250         }     }      functi ...\n                                        ^---^\n:1:124: The shadowed declaration is here:\n ... ion changeLimit() public {         uint256 limit = 500;         assembly {          ...\n                                        ^-----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example20 {\n    string public version = \"v1.0\";\n\n    function upgradeVersion() public {\n        string memory version = \"v2.0\";\n        assembly {\n            let version := \"v3.0\"\n        }\n    }\n}",
          "error message": ":1:197: DeclarationError: This declaration shadows a declaration outside the inline assembly block.\n ...         assembly {             let version := \"v3.0\"         }     } }\n                                        ^-----^\n:1:130: The shadowed declaration is here:\n ...  upgradeVersion() public {         string memory version = \"v2.0\";         assembly {       ...\n                                        ^-------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example11 {\n    uint256 public supply = 100;\n\n    function updateSupply() public {\n        uint256 supply = 200;\n        assembly {\n            let localSupply := 300\n        }\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example12 {\n    string public title = \"Initial Title\";\n\n    function setTitle(string memory newTitle) public {\n        string memory title = newTitle;\n        assembly {\n            let localTitle := \"New Title\"\n        }\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example13 {\n    uint256 public fee = 5;\n\n    function adjustFee() public {\n        uint256 fee = 10;\n        assembly {\n            let localFee := 15\n        }\n    }\n\n    function dummyFunction() public pure returns (string memory) {\n        return \"dummy\";\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example14 {\n    bytes32 public identifier = keccak256(\"ID\");\n\n    function changeIdentifier() public {\n        bytes32 identifier = keccak256(\"NewID\");\n        assembly {\n            let localIdentifier := keccak256(add(\"AltID\", 0x20), 0x20)\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example15 {\n    address public userAddress;\n\n    function setUserAddress(address addr) public {\n        userAddress = addr;\n        assembly {\n            let localUserAddress := addr\n        }\n    }\n\n    function anotherFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example16 {\n    bool public status = false;\n\n    function flipStatus() public {\n        bool status = true;\n        assembly {\n            let localStatus := 0\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example17 {\n    int256 public total = 50;\n\n    function modifyTotal(int256 value) public {\n        int256 total = value;\n        assembly {\n            let localTotal := 100\n        }\n    }\n\n    function getTotal() public view returns (int256) {\n        return total;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example18 {\n    string public description = \"Default\";\n\n    function updateDescription() public {\n        string memory description = \"Updated\";\n        assembly {\n            let localDescription := \"Final\"\n        }\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example19 {\n    uint256 public limit = 1000;\n\n    function changeLimit() public {\n        uint256 limit = 500;\n        assembly {\n            let localLimit := 250\n        }\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return limit;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example20 {\n    string public version = \"v1.0\";\n\n    function upgradeVersion() public {\n        string memory version = \"v2.0\";\n        assembly {\n            let localVersion := \"v3.0\"\n        }\n    }\n}"
      }
    }
  },
  {
    "Changes32": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "In inline assembly, opcodes that do not take arguments are now represented as \u201cbuilt-in functions\u201d instead of standalone identifiers. So <code>gas</code> is now <code>gas()</code>.In inline assembly, add <code>()</code> to all opcodes that do not otherwise accept an argument.For example, change <code>pc</code> to <code>pc()</code>, and <code>gas</code> to <code>gas()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample11 {\n    uint256 public gasRemaining;\n\n    function computeGas() public {\n        assembly {\n            let gasLeft := gas\n            sstore(gasRemaining_slot, gasLeft)\n        }\n    }\n}",
          "error message": ":1:185: ParserError: Expected '(' but got identifier\n ...     let gasLeft := gas             sstore(gasRemaining_slot, gasLeft)        ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample12 {\n    uint256 public executionCounter;\n\n    function getPC() public {\n        assembly {\n            let counter := pc\n            sstore(executionCounter_slot, counter)\n        }\n    }\n}",
          "error message": ":1:183: ParserError: Expected '(' but got identifier\n ...      let counter := pc             sstore(executionCounter_slot, counter)    ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample13 {\n    uint256 public availableGas;\n\n    function checkRemainingGas() public {\n        assembly {\n            let remainingGas := gas\n            sstore(availableGas_slot, remainingGas)\n        }\n    }\n}",
          "error message": ":1:197: ParserError: Expected '(' but got identifier\n ... et remainingGas := gas             sstore(availableGas_slot, remainingGas)   ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample14 {\n    uint256 public pcRegister;\n\n    function capturePC() public {\n        assembly {\n            let pcReg := pc\n            sstore(pcRegister_slot, pcReg)\n        }\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 456;\n    }\n}",
          "error message": ":1:179: ParserError: Expected '(' but got identifier\n ...        let pcReg := pc             sstore(pcRegister_slot, pcReg)         }  ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample15 {\n    uint256 public gasBalance;\n\n    function retrieveRemainingGas() public {\n        assembly {\n            let gasRem := gas\n            sstore(gasBalance_slot, gasRem)\n        }\n    }\n}",
          "error message": ":1:192: ParserError: Expected '(' but got identifier\n ...      let gasRem := gas             sstore(gasBalance_slot, gasRem)         } ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample16 {\n    uint256 public instructionCounter;\n\n    function trackInstructionPC() public {\n        assembly {\n            let instCounter := pc\n            sstore(instructionCounter_slot, instCounter)\n        }\n    }\n}",
          "error message": ":1:202: ParserError: Expected '(' but got identifier\n ...  let instCounter := pc             sstore(instructionCounter_slot, instCount ...\n                                        ^----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample17 {\n    uint256 public gasState;\n\n    function computeGasState() public {\n        assembly {\n            let gasAvailable := gas\n            sstore(gasState_slot, gasAvailable)\n        }\n    }\n\n    function dummyFunctionTwo() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:191: ParserError: Expected '(' but got identifier\n ... et gasAvailable := gas             sstore(gasState_slot, gasAvailable)       ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample18 {\n    uint256 public currentCounter;\n\n    function storePCValue() public {\n        assembly {\n            let currPC := pc\n            sstore(currentCounter_slot, currPC)\n        }\n    }\n}",
          "error message": ":1:187: ParserError: Expected '(' but got identifier\n ...       let currPC := pc             sstore(currentCounter_slot, currPC)       ...\n                                        ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample19 {\n    uint256 public gasSnapshot;\n\n    function snapshotGas() public {\n        assembly {\n            let snapshot := gas\n            sstore(gasSnapshot_slot, snapshot)\n        }\n    }\n}",
          "error message": ":1:186: ParserError: Expected '(' but got identifier\n ...    let snapshot := gas             sstore(gasSnapshot_slot, snapshot)        ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ContractExample20 {\n    uint256 public executionPosition;\n\n    function logPC() public {\n        assembly {\n            let execPos := pc\n            sstore(executionPosition_slot, execPos)\n        }\n    }\n}",
          "error message": ":1:184: ParserError: Expected '(' but got identifier\n ...      let execPos := pc             sstore(executionPosition_slot, execPos)   ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ContractExample11 {\n    uint256 public gasRemaining;\n\n    function computeGas() public {\n        assembly {\n            let gasLeft := gas()\n            sstore(gasRemaining_slot, gasLeft)\n        }\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ContractExample12 {\n    uint256 public executionCounter;\n\n    function getPC() public {\n        assembly {\n            let counter := pc()\n            sstore(executionCounter_slot, counter)\n        }\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ContractExample13 {\n    uint256 public availableGas;\n\n    function checkRemainingGas() public {\n        assembly {\n            let remainingGas := gas()\n            sstore(availableGas_slot, remainingGas)\n        }\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ContractExample14 {\n    uint256 public pcRegister;\n\n    function capturePC() public {\n        assembly {\n            let pcReg := pc()\n            sstore(pcRegister_slot, pcReg)\n        }\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 456;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ContractExample15 {\n    uint256 public gasBalance;\n\n    function retrieveRemainingGas() public {\n        assembly {\n            let gasRem := gas()\n            sstore(gasBalance_slot, gasRem)\n        }\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ContractExample16 {\n    uint256 public instructionCounter;\n\n    function trackInstructionPC() public {\n        assembly {\n            let instCounter := pc()\n            sstore(instructionCounter_slot, instCounter)\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ContractExample17 {\n    uint256 public gasState;\n\n    function computeGasState() public {\n        assembly {\n            let gasAvailable := gas()\n            sstore(gasState_slot, gasAvailable)\n        }\n    }\n\n    function dummyFunctionTwo() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ContractExample18 {\n    uint256 public currentCounter;\n\n    function storePCValue() public {\n        assembly {\n            let currPC := pc()\n            sstore(currentCounter_slot, currPC)\n        }\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ContractExample19 {\n    uint256 public gasSnapshot;\n\n    function snapshotGas() public {\n        assembly {\n            let snapshot := gas()\n            sstore(gasSnapshot_slot, snapshot)\n        }\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ContractExample20 {\n    uint256 public executionPosition;\n\n    function logPC() public {\n        assembly {\n            let execPos := pc()\n            sstore(executionPosition_slot, execPos)\n        }\n    }\n}"
      }
    }
  },
  {
    "Changes33": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "State variable shadowing is now disallowed.  A derived contract can only\ndeclare a state variable <code>x</code>, if there is no visible state variable with\nthe same name in any of its bases.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Primary {\n    uint256 public data = 50;\n}\n\ncontract Secondary is Primary {\n    uint256 public data = 75;\n    \n    function getData() public view returns (uint256) {\n        return data;\n    }\n}",
          "error message": ":1:113: DeclarationError: Identifier already declared.\n ... ontract Secondary is Primary {     uint256 public data = 75;          function getData() publi ...\n                                        ^----------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Primary {     uint256 public data = 50; }  contract Secondary is Primary  ...\n                                        ^----------------------^\n:1:113: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ontract Secondary is Primary {     uint256 public data = 75;          function getData() publi ...\n                                        ^----------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Primary {     uint256 public data = 50; }  contract Secondary is Primary  ...\n                                        ^----------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Primary {     uint256 public data = 50; }  contract Secondary is Primary  ...\n                                        ^----------------------^\n:1:113: Overriding public state variable is here:\n ... ontract Secondary is Primary {     uint256 public data = 75;          function getData() publi ...\n                                        ^----------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Vehicle {\n    string public model = \"Sedan\";\n}\n\ncontract Car is Vehicle {\n    string public model = \"SUV\";\n    \n    function getModel() public view returns (string memory) {\n        return model;\n    }\n}",
          "error message": ":1:112: DeclarationError: Identifier already declared.\n ... ; }  contract Car is Vehicle {     string public model = \"SUV\";          function getModel() publ ...\n                                        ^-------------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Vehicle {     string public model = \"Sedan\"; }  contract Car is Vehicle {      ...\n                                        ^---------------------------^\n:1:112: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ; }  contract Car is Vehicle {     string public model = \"SUV\";          function getModel() publ ...\n                                        ^-------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Vehicle {     string public model = \"Sedan\"; }  contract Car is Vehicle {      ...\n                                        ^---------------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Vehicle {     string public model = \"Sedan\"; }  contract Car is Vehicle {      ...\n                                        ^---------------------------^\n:1:112: Overriding public state variable is here:\n ... ; }  contract Car is Vehicle {     string public model = \"SUV\";          function getModel() publ ...\n                                        ^-------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Account {\n    address public owner = msg.sender;\n}\n\ncontract UserAccount is Account {\n    address public owner = address(0x123);\n    \n    function getOwnerAddress() public view returns (address) {\n        return owner;\n    }\n}",
          "error message": ":1:124: DeclarationError: Identifier already declared.\n ... tract UserAccount is Account {     address public owner = address(0x123);          function getOwnerAddress ...\n                                        ^-----------------------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Account {     address public owner = msg.sender; }  contract UserAccount is Accoun ...\n                                        ^-------------------------------^\n:1:124: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... tract UserAccount is Account {     address public owner = address(0x123);          function getOwnerAddress ...\n                                        ^-----------------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Account {     address public owner = msg.sender; }  contract UserAccount is Accoun ...\n                                        ^-------------------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Account {     address public owner = msg.sender; }  contract UserAccount is Accoun ...\n                                        ^-------------------------------^\n:1:124: Overriding public state variable is here:\n ... tract UserAccount is Account {     address public owner = address(0x123);          function getOwnerAddress ...\n                                        ^-----------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Storage {\n    uint256 public amount = 500;\n}\n\ncontract Warehouse is Storage {\n    uint256 public amount = 1000;\n    \n    function getAmount() public view returns (uint256) {\n        return amount;\n    }\n}",
          "error message": ":1:116: DeclarationError: Identifier already declared.\n ... ontract Warehouse is Storage {     uint256 public amount = 1000;          function getAmount() pub ...\n                                        ^--------------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Storage {     uint256 public amount = 500; }  contract Warehouse is Storage  ...\n                                        ^-------------------------^\n:1:116: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ontract Warehouse is Storage {     uint256 public amount = 1000;          function getAmount() pub ...\n                                        ^--------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Storage {     uint256 public amount = 500; }  contract Warehouse is Storage  ...\n                                        ^-------------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Storage {     uint256 public amount = 500; }  contract Warehouse is Storage  ...\n                                        ^-------------------------^\n:1:116: Overriding public state variable is here:\n ... ontract Warehouse is Storage {     uint256 public amount = 1000;          function getAmount() pub ...\n                                        ^--------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Employee {\n    string public position = \"Manager\";\n}\n\ncontract Executive is Employee {\n    string public position = \"Director\";\n    \n    function getPosition() public view returns (string memory) {\n        return position;\n    }\n}",
          "error message": ":1:125: DeclarationError: Identifier already declared.\n ... ntract Executive is Employee {     string public position = \"Director\";          function getPosition() p ...\n                                        ^---------------------------------^\n:1:49: The previous declaration is here:\n ... ty^0.6.0;  contract Employee {     string public position = \"Manager\"; }  contract Executive is Employee ...\n                                        ^--------------------------------^\n:1:125: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ntract Executive is Employee {     string public position = \"Director\";          function getPosition() p ...\n                                        ^---------------------------------^\n:1:49: Overridden function is here:\n ... ty^0.6.0;  contract Employee {     string public position = \"Manager\"; }  contract Executive is Employee ...\n                                        ^--------------------------------^\n:1:49: TypeError: Cannot override public state variable.\n ... ty^0.6.0;  contract Employee {     string public position = \"Manager\"; }  contract Executive is Employee ...\n                                        ^--------------------------------^\n:1:125: Overriding public state variable is here:\n ... ntract Executive is Employee {     string public position = \"Director\";          function getPosition() p ...\n                                        ^---------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Info {\n    bytes32 public dataHash = keccak256(\"Solidity\");\n}\n\ncontract Detail is Info {\n    bytes32 public dataHash = keccak256(\"Blockchain\");\n    \n    function getDataHash() public view returns (bytes32) {\n        return dataHash;\n    }\n}",
          "error message": ":1:127: DeclarationError: Identifier already declared.\n ... ; }  contract Detail is Info {     bytes32 public dataHash = keccak256(\"Blockchain\");          function getDataHash() p ...\n                                        ^-----------------------------------------------^\n:1:45: The previous declaration is here:\n ... lidity^0.6.0;  contract Info {     bytes32 public dataHash = keccak256(\"Solidity\"); }  contract Detail is Info {      ...\n                                        ^---------------------------------------------^\n:1:127: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ; }  contract Detail is Info {     bytes32 public dataHash = keccak256(\"Blockchain\");          function getDataHash() p ...\n                                        ^-----------------------------------------------^\n:1:45: Overridden function is here:\n ... lidity^0.6.0;  contract Info {     bytes32 public dataHash = keccak256(\"Solidity\"); }  contract Detail is Info {      ...\n                                        ^---------------------------------------------^\n:1:45: TypeError: Cannot override public state variable.\n ... lidity^0.6.0;  contract Info {     bytes32 public dataHash = keccak256(\"Solidity\"); }  contract Detail is Info {      ...\n                                        ^---------------------------------------------^\n:1:127: Overriding public state variable is here:\n ... ; }  contract Detail is Info {     bytes32 public dataHash = keccak256(\"Blockchain\");          function getDataHash() p ...\n                                        ^-----------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Weather {\n    int public temperature = 20;\n}\n\ncontract Climate is Weather {\n    int public temperature = 25;\n    \n    function getTemperature() public view returns (int) {\n        return temperature;\n    }\n}",
          "error message": ":1:114: DeclarationError: Identifier already declared.\n ...  contract Climate is Weather {     int public temperature = 25;          function getTemperature( ...\n                                        ^-------------------------^\n:1:48: The previous declaration is here:\n ... ity^0.6.0;  contract Weather {     int public temperature = 20; }  contract Climate is Weather {  ...\n                                        ^-------------------------^\n:1:114: TypeError: Overriding public state variable is missing \"override\" specifier.\n ...  contract Climate is Weather {     int public temperature = 25;          function getTemperature( ...\n                                        ^-------------------------^\n:1:48: Overridden function is here:\n ... ity^0.6.0;  contract Weather {     int public temperature = 20; }  contract Climate is Weather {  ...\n                                        ^-------------------------^\n:1:48: TypeError: Cannot override public state variable.\n ... ity^0.6.0;  contract Weather {     int public temperature = 20; }  contract Climate is Weather {  ...\n                                        ^-------------------------^\n:1:114: Overriding public state variable is here:\n ...  contract Climate is Weather {     int public temperature = 25;          function getTemperature( ...\n                                        ^-------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Version1 {\n    uint public release = 100;\n}\n\ncontract Version2 is Version1 {\n    uint public release = 200;\n    \n    function getRelease() public view returns (uint) {\n        return release;\n    }\n}",
          "error message": ":1:115: DeclarationError: Identifier already declared.\n ... ontract Version2 is Version1 {     uint public release = 200;          function getRelease() pu ...\n                                        ^-----------------------^\n:1:49: The previous declaration is here:\n ... ty^0.6.0;  contract Version1 {     uint public release = 100; }  contract Version2 is Version1  ...\n                                        ^-----------------------^\n:1:115: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ontract Version2 is Version1 {     uint public release = 200;          function getRelease() pu ...\n                                        ^-----------------------^\n:1:49: Overridden function is here:\n ... ty^0.6.0;  contract Version1 {     uint public release = 100; }  contract Version2 is Version1  ...\n                                        ^-----------------------^\n:1:49: TypeError: Cannot override public state variable.\n ... ty^0.6.0;  contract Version1 {     uint public release = 100; }  contract Version2 is Version1  ...\n                                        ^-----------------------^\n:1:115: Overriding public state variable is here:\n ... ontract Version2 is Version1 {     uint public release = 200;          function getRelease() pu ...\n                                        ^-----------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract HeightTracker {\n    uint public height = 180;\n}\n\ncontract Altitude is HeightTracker {\n    uint public height = 220;\n    \n    function getHeight() public view returns (uint) {\n        return height;\n    }\n}",
          "error message": ":1:124: DeclarationError: Identifier already declared.\n ... ct Altitude is HeightTracker {     uint public height = 220;          function getHeight() pub ...\n                                        ^----------------------^\n:1:54: The previous declaration is here:\n ... 6.0;  contract HeightTracker {     uint public height = 180; }  contract Altitude is HeightTra ...\n                                        ^----------------------^\n:1:124: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ct Altitude is HeightTracker {     uint public height = 220;          function getHeight() pub ...\n                                        ^----------------------^\n:1:54: Overridden function is here:\n ... 6.0;  contract HeightTracker {     uint public height = 180; }  contract Altitude is HeightTra ...\n                                        ^----------------------^\n:1:54: TypeError: Cannot override public state variable.\n ... 6.0;  contract HeightTracker {     uint public height = 180; }  contract Altitude is HeightTra ...\n                                        ^----------------------^\n:1:124: Overriding public state variable is here:\n ... ct Altitude is HeightTracker {     uint public height = 220;          function getHeight() pub ...\n                                        ^----------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract BaseContract {\n    string public baseName = \"ContractBase\";\n}\n\ncontract DerivedContract is BaseContract {\n    string public baseName = \"DerivedBase\";\n    \n    function getBaseName() public view returns (string memory) {\n        return baseName;\n    }\n}",
          "error message": ":1:144: DeclarationError: Identifier already declared.\n ... ivedContract is BaseContract {     string public baseName = \"DerivedBase\";          function getBaseName() p ...\n                                        ^------------------------------------^\n:1:53: The previous declaration is here:\n ... .6.0;  contract BaseContract {     string public baseName = \"ContractBase\"; }  contract DerivedContract is Ba ...\n                                        ^-------------------------------------^\n:1:144: TypeError: Overriding public state variable is missing \"override\" specifier.\n ... ivedContract is BaseContract {     string public baseName = \"DerivedBase\";          function getBaseName() p ...\n                                        ^------------------------------------^\n:1:53: Overridden function is here:\n ... .6.0;  contract BaseContract {     string public baseName = \"ContractBase\"; }  contract DerivedContract is Ba ...\n                                        ^-------------------------------------^\n:1:53: TypeError: Cannot override public state variable.\n ... .6.0;  contract BaseContract {     string public baseName = \"ContractBase\"; }  contract DerivedContract is Ba ...\n                                        ^-------------------------------------^\n:1:144: Overriding public state variable is here:\n ... ivedContract is BaseContract {     string public baseName = \"DerivedBase\";          function getBaseName() p ...\n                                        ^------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Primary {\n    uint256 public data = 50;\n}\n\ncontract Secondary is Primary {\n    uint256 public secondaryData = 75;\n    \n    function getData() public view returns (uint256) {\n        return secondaryData;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Vehicle {\n    string public model = \"Sedan\";\n}\n\ncontract Car is Vehicle {\n    string public carModel = \"SUV\";\n    \n    function getModel() public view returns (string memory) {\n        return carModel;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Account {\n    address public owner = msg.sender;\n}\n\ncontract UserAccount is Account {\n    address public userOwner = address(0x123);\n    \n    function getOwnerAddress() public view returns (address) {\n        return userOwner;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Storage {\n    uint256 public amount = 500;\n}\n\ncontract Warehouse is Storage {\n    uint256 public warehouseAmount = 1000;\n    \n    function getAmount() public view returns (uint256) {\n        return warehouseAmount;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Employee {\n    string public position = \"Manager\";\n}\n\ncontract Executive is Employee {\n    string public executivePosition = \"Director\";\n    \n    function getPosition() public view returns (string memory) {\n        return executivePosition;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Info {\n    bytes32 public dataHash = keccak256(\"Solidity\");\n}\n\ncontract Detail is Info {\n    bytes32 public detailDataHash = keccak256(\"Blockchain\");\n    \n    function getDataHash() public view returns (bytes32) {\n        return detailDataHash;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Weather {\n    int public temperature = 20;\n}\n\ncontract Climate is Weather {\n    int public climateTemperature = 25;\n    \n    function getTemperature() public view returns (int) {\n        return climateTemperature;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Version1 {\n    uint public release = 100;\n}\n\ncontract Version2 is Version1 {\n    uint public releaseVersion2 = 200;\n    \n    function getRelease() public view returns (uint) {\n        return releaseVersion2;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract HeightTracker {\n    uint public height = 180;\n}\n\ncontract Altitude is HeightTracker {\n    uint public altitudeHeight = 220;\n    \n    function getHeight() public view returns (uint) {\n        return altitudeHeight;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract BaseContract {\n    string public baseName = \"ContractBase\";\n}\n\ncontract DerivedContract is BaseContract {\n    string public derivedName = \"DerivedBase\";\n    \n    function getBaseName() public view returns (string memory) {\n        return derivedName;\n    }\n}"
      }
    }
  },
  {
    "Changes34": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "Conversions from external function types to <code>address</code> are now disallowed. Instead external\nfunction types have a member called <code>address</code>, similar to the existing <code>selector</code> member.Change <code>address(f)</code> to <code>f.address</code> for <code>f</code> being of external function type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    address public contractAddress;\n\n    function sampleFunction() external {\n    }\n\n    function setContractAddress() public {\n        address addr = address(this.sampleFunction);\n        contractAddress = addr;\n    }\n}",
          "error message": ":1:196: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         address addr = address(this.sampleFunction);         contractAddress = addr;   ...\n                                        ^--------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    address public storedAddress;\n\n    function externalCall() external {\n    }\n\n    function saveAddress() public {\n        storedAddress = address(this.externalCall);\n    }\n}",
          "error message": ":1:186: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ) public {         storedAddress = address(this.externalCall);     } }\n                                        ^------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public latestAddress;\n\n    function invokeExternal() external {\n    }\n\n    function updateAddress() public {\n        address addr = address(this.invokeExternal);\n        latestAddress = addr;\n    }\n\n    function additionalFunction() public {\n    }\n}",
          "error message": ":1:189: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         address addr = address(this.invokeExternal);         latestAddress = addr;     ...\n                                        ^--------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    address public callerAddress;\n\n    function someExternal() external {\n    }\n\n    function recordCaller() public {\n        callerAddress = address(this.someExternal);\n    }\n}",
          "error message": ":1:187: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ) public {         callerAddress = address(this.someExternal);     } }\n                                        ^------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    address public addrStored;\n\n    function extFunc() external {\n    }\n\n    function storeAddress() public {\n        addrStored = address(this.extFunc);\n    }\n}",
          "error message": ":1:176: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ss() public {         addrStored = address(this.extFunc);     } }\n                                        ^-------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    address public currentAddress;\n\n    function extFunctionality() external {\n    }\n\n    function logCurrentAddress() public {\n        currentAddress = address(this.extFunctionality);\n    }\n}",
          "error message": ":1:198: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ...  public {         currentAddress = address(this.extFunctionality);     } }\n                                        ^----------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    address public registeredAddress;\n\n    function someFunction() external {\n    }\n\n    function registerAddress() public {\n        registeredAddress = address(this.someFunction);\n    }\n\n    function randomFunction() public {\n    }\n}",
          "error message": ":1:198: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... blic {         registeredAddress = address(this.someFunction);     }      function randomFunctio ...\n                                        ^------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    address public savedAddress;\n\n    function extFuncLogic() external {\n    }\n\n    function saveExtAddress() public {\n        savedAddress = address(this.extFuncLogic);\n    }\n}",
          "error message": ":1:187: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... () public {         savedAddress = address(this.extFuncLogic);     } }\n                                        ^------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    address public retrievedAddress;\n\n    function extInvoke() external {\n    }\n\n    function retrieveAddress() public {\n        retrievedAddress = address(this.extInvoke);\n    }\n}",
          "error message": ":1:193: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... ublic {         retrievedAddress = address(this.extInvoke);     } }\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address public functionAddress;\n\n    function externalExecutor() external {\n    }\n\n    function setFunctionAddress() public {\n        functionAddress = address(this.externalExecutor);\n    }\n}",
          "error message": ":1:202: TypeError: Explicit type conversion not allowed from \"function () external\" to \"address\". To obtain the address of the contract of the function, you can use the .address member of the function.\n ... public {         functionAddress = address(this.externalExecutor);     } }\n                                        ^----------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example1 {\n    address public contractAddress;\n    bytes4 public functionSelector;\n\n    function sampleFunction() external {\n    }\n\n    function setContractAddress() public {\n        contractAddress = address(this);\n        functionSelector = this.sampleFunction.selector;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example2 {\n    address public storedAddress;\n    bytes4 public functionSelector;\n\n    function externalCall() external {\n    }\n\n    function saveAddress() public {\n        storedAddress = address(this);\n        functionSelector = this.externalCall.selector;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example3 {\n    address public latestAddress;\n    bytes4 public functionSelector;\n\n    function invokeExternal() external {\n    }\n\n    function updateAddress() public {\n        latestAddress = address(this);\n        functionSelector = this.invokeExternal.selector;\n    }\n\n    function additionalFunction() public {\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example4 {\n    address public callerAddress;\n    bytes4 public functionSelector;\n\n    function someExternal() external {\n    }\n\n    function recordCaller() public {\n        callerAddress = address(this);\n        functionSelector = this.someExternal.selector;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example5 {\n    address public addrStored;\n    bytes4 public functionSelector;\n\n    function extFunc() external {\n    }\n\n    function storeAddress() public {\n        addrStored = address(this);\n        functionSelector = this.extFunc.selector;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example6 {\n    address public currentAddress;\n    bytes4 public functionSelector;\n\n    function extFunctionality() external {\n    }\n\n    function logCurrentAddress() public {\n        currentAddress = address(this);\n        functionSelector = this.extFunctionality.selector;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example7 {\n    address public registeredAddress;\n    bytes4 public functionSelector;\n\n    function someFunction() external {\n    }\n\n    function registerAddress() public {\n        registeredAddress = address(this);\n        functionSelector = this.someFunction.selector;\n    }\n\n    function randomFunction() public {\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example8 {\n    address public savedAddress;\n    bytes4 public functionSelector;\n\n    function extFuncLogic() external {\n    }\n\n    function saveExtAddress() public {\n        savedAddress = address(this);\n        functionSelector = this.extFuncLogic.selector;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example9 {\n    address public retrievedAddress;\n    bytes4 public functionSelector;\n\n    function extInvoke() external {\n    }\n\n    function retrieveAddress() public {\n        retrievedAddress = address(this);\n        functionSelector = this.extInvoke.selector;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example10 {\n    address public functionAddress;\n    bytes4 public functionSelector;\n\n    function externalExecutor() external {\n    }\n\n    function setFunctionAddress() public {\n        functionAddress = address(this);\n        functionSelector = this.externalExecutor.selector;\n    }\n}"
      }
    }
  },
  {
    "Changes35": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The function <code>push(value)</code> for dynamic storage arrays does not return the new length anymore (it returns nothing).Change <code>uint length = array.push(value)</code> to <code>array.push(value);</code>. The new length can be accessed via <code>array.length</code>.Change <code>array.length++</code> to <code>array.push()</code> to increase, and use <code>pop()</code> to decrease the length of a storage array.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example11 {\n    uint[] public list;\n\n    function addItem(uint _item) public returns (uint) {\n        uint length = list.push(_item);\n        return length;\n    }\n}",
          "error message": ":1:136: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... m) public returns (uint) {         uint length = list.push(_item);         return length;     } }\n                                        ^----------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example12 {\n    bytes32[] public identifiers;\n\n    function addIdentifier(bytes32 _id) public returns (uint) {\n        uint newLength = identifiers.push(_id);\n        return newLength;\n    }\n\n    function getIdentifier(uint index) public view returns (bytes32) {\n        return identifiers[index];\n    }\n}",
          "error message": ":1:153: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... d) public returns (uint) {         uint newLength = identifiers.push(_id);         return newLength;     }   ...\n                                        ^------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example13 {\n    uint[] public queue;\n\n    function enqueue(uint _val) public returns (uint) {\n        uint len = queue.push(_val);\n        return len;\n    }\n}",
          "error message": ":1:136: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... l) public returns (uint) {         uint len = queue.push(_val);         return len;     } }\n                                        ^-------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example14 {\n    int[] public scores;\n\n    function addScore(int _score) public returns (uint) {\n        uint length = scores.push(_score);\n        return length;\n    }\n}",
          "error message": ":1:138: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... e) public returns (uint) {         uint length = scores.push(_score);         return length;     } }\n                                        ^-------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example15 {\n    address[] public users;\n\n    function registerUser(address _user) public returns (uint) {\n        uint len = users.push(_user);\n        return len;\n    }\n\n    function getUser(uint index) public view returns (address) {\n        return users[index];\n    }\n}",
          "error message": ":1:148: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... r) public returns (uint) {         uint len = users.push(_user);         return len;     }      fu ...\n                                        ^--------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example16 {\n    bytes[] public dataChunks;\n\n    function addChunk(bytes memory _chunk) public returns (uint) {\n        uint newLength = dataChunks.push(_chunk);\n        return newLength;\n    }\n}",
          "error message": ":1:153: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... k) public returns (uint) {         uint newLength = dataChunks.push(_chunk);         return newLength;     } }\n                                        ^--------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example17 {\n    string[] public names;\n\n    function addName(string memory _name) public returns (uint) {\n        uint len = names.push(_name);\n        return len;\n    }\n\n    function getName(uint index) public view returns (string memory) {\n        return names[index];\n    }\n}",
          "error message": ":1:148: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... e) public returns (uint) {         uint len = names.push(_name);         return len;     }      fu ...\n                                        ^--------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example18 {\n    uint[] public registry;\n\n    function register(uint _entry) public returns (uint) {\n        uint length = registry.push(_entry);\n        return length;\n    }\n}",
          "error message": ":1:142: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... y) public returns (uint) {         uint length = registry.push(_entry);         return length;     } }\n                                        ^---------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example19 {\n    int[] public temperatures;\n\n    function recordTemperature(int _temp) public returns (uint) {\n        uint newLength = temperatures.push(_temp);\n        return newLength;\n    }\n}",
          "error message": ":1:152: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... p) public returns (uint) {         uint newLength = temperatures.push(_temp);         return newLength;     } }\n                                        ^---------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example20 {\n    bytes32[] public signatures;\n\n    function addSignature(bytes32 _sig) public returns (uint) {\n        uint len = signatures.push(_sig);\n        return len;\n    }\n}",
          "error message": ":1:152: TypeError: Different number of components on the left hand side (1) than on the right hand side (0).\n ... g) public returns (uint) {         uint len = signatures.push(_sig);         return len;     } }\n                                        ^------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example11 {\n    uint[] public list;\n\n    function addItem(uint _item) public {\n        list.push(_item);\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example12 {\n    bytes32[] public identifiers;\n\n    function addIdentifier(bytes32 _id) public {\n        identifiers.push(_id);\n    }\n\n    function getIdentifier(uint index) public view returns (bytes32) {\n        return identifiers[index];\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example13 {\n    uint[] public queue;\n\n    function enqueue(uint _val) public {\n        queue.push(_val);\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example14 {\n    int[] public scores;\n\n    function addScore(int _score) public {\n        scores.push(_score);\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example15 {\n    address[] public users;\n\n    function registerUser(address _user) public {\n        users.push(_user);\n    }\n\n    function getUser(uint index) public view returns (address) {\n        return users[index];\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example16 {\n    bytes[] public dataChunks;\n\n    function addChunk(bytes memory _chunk) public {\n        dataChunks.push(_chunk);\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example17 {\n    string[] public names;\n\n    function addName(string memory _name) public {\n        names.push(_name);\n    }\n\n    function getName(uint index) public view returns (string memory) {\n        return names[index];\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example18 {\n    uint[] public registry;\n\n    function register(uint _entry) public {\n        registry.push(_entry);\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example19 {\n    int[] public temperatures;\n\n    function recordTemperature(int _temp) public {\n        temperatures.push(_temp);\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example20 {\n    bytes32[] public signatures;\n\n    function addSignature(bytes32 _sig) public {\n        signatures.push(_sig);\n    }\n}"
      }
    }
  },
  {
    "Changes36": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The unnamed function commonly referred to as \u201cfallback function\u201d was split up into a new\nfallback function that is defined using the <code>fallback</code> keyword and a receive ether function\ndefined using the <code>receive</code> keyword.Replace <code>function () external [payable] { ... }</code> by either <code>receive() external payable { ... }</code>,<code>fallback() external [payable] { ... }</code> or both. Prefer using a <code>receive</code> function only, whenever possible.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example11 {\n    function () external payable {}\n\n    function randomFunction11(uint y) public pure returns (uint) {\n        return y + 3;\n    }\n}",
          "error message": ":1:79: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function randomFunction11(ui ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example12 {\n    function () external {}\n\n    function sendEther() public payable {}\n\n    function randomFunction12() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:71: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ample12 {     function () external {}      function sendEther() public  ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example13 {\n    function () external payable {}\n\n    function transferFunds(address payable recipient, uint amount) public {\n        recipient.transfer(amount);\n    }\n\n    function randomFunction13(bytes32 input) public pure returns (bytes32) {\n        return input;\n    }\n}",
          "error message": ":1:79: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function transferFunds(addre ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example14 {\n    function () external {}\n\n    function checkBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction14() public pure returns (string memory) {\n        return \"Test\";\n    }\n}",
          "error message": ":1:71: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ample14 {     function () external {}      function checkBalance() publ ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example15 {\n    function () external payable {}\n\n    function deposit() public payable {}\n\n    function randomFunction15() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": ":1:79: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function deposit() public pa ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example16 {\n    function () external {}\n\n    function processPayment() public payable {}\n\n    function randomFunction16() public pure returns (uint) {\n        return 5;\n    }\n}",
          "error message": ":1:71: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ample16 {     function () external {}      function processPayment() pu ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example17 {\n    function () external payable {}\n\n    function updateOwner(address newOwner) public {}\n}",
          "error message": ":1:79: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\npragma solidity^0.6.0;  contract Example17 {     function () external payable {}      function updateOwner(address newOwner) public {} }\n                                                                              ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example18 {\n    function () external {}\n\n    function claimFunds() public {}\n\n    function randomFunction18(uint x) public pure returns (uint) {\n        return x + 1;\n    }\n}",
          "error message": ":1:71: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ample18 {     function () external {}      function claimFunds() public ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example19 {\n    function () external payable {}\n\n    function refund(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction19(uint z) public pure returns (uint) {\n        return z * 3;\n    }\n}",
          "error message": ":1:79: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... {     function () external payable {}      function refund(uint amount) ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Example20 {\n    function () external {}\n\n    function setReceiver(address payable receiver) public {}\n\n    function randomFunction20(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
          "error message": ":1:71: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ample20 {     function () external {}      function setReceiver(address ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Example11 {\n    fallback() external payable {}\n\n    function randomFunction11(uint y) public pure returns (uint) {\n        return y + 3;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Example12 {\n    fallback() external {}\n\n    function sendEther() public payable {}\n\n    function randomFunction12() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Example13 {\n    receive() external payable {}\n\n    function transferFunds(address payable recipient, uint amount) public {\n        recipient.transfer(amount);\n    }\n\n    function randomFunction13(bytes32 input) public pure returns (bytes32) {\n        return input;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Example14 {\n    fallback() external {}\n\n    function checkBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function randomFunction14() public pure returns (string memory) {\n        return \"Test\";\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Example15 {\n    receive() external payable {}\n\n    function deposit() public payable {}\n\n    function randomFunction15() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Example16 {\n    fallback() external {}\n\n    function processPayment() public payable {}\n\n    function randomFunction16() public pure returns (uint) {\n        return 5;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Example17 {\n    receive() external payable {}\n\n    function updateOwner(address newOwner) public {}\n\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Example18 {\n    fallback() external {}\n\n    function claimFunds() public {}\n\n    function randomFunction18(uint x) public pure returns (uint) {\n        return x + 1;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Example19 {\n    receive() external payable {}\n\n    function refund(uint amount) public {\n        msg.sender.transfer(amount);\n    }\n\n    function randomFunction19(uint z) public pure returns (uint) {\n        return z * 3;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Example20 {\n    fallback() external {}\n\n    function setReceiver(address payable receiver) public {}\n\n    function randomFunction20(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}"
      }
    }
  },
  {
    "Changes37": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "If present, the receive ether function is called whenever the call data is empty (whether\nor not ether is received). This function is implicitly <code>payable</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract1 {\n    function() external {\n    }\n    \n    function getValue() public pure returns (uint) {\n        return 42;\n    }\n    \n    function randomFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract1 {     function() external {     }          function getValue() ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract2 {\n    function() external {\n    }\n    \n    function computeSum(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract2 {     function() external {     }          function computeSum ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract3 {\n    function() external {\n    }\n    \n    function calculate(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n    \n    function extraFunc() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract3 {     function() external {     }          function calculate( ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract4 {\n    function() external {\n    }\n    \n    function randomFunction() public pure returns (string memory) {\n        return \"Hello, Solidity!\";\n    }\n    \n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract4 {     function() external {     }          function randomFunc ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract5 {\n    function() external {\n    }\n    \n    function check(uint num) public pure returns (bool) {\n        return num > 10;\n    }\n    \n    function anotherCheck(uint num) public pure returns (bool) {\n        return num == 0;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract5 {     function() external {     }          function check(uint ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract6 {\n    function() external {\n    }\n    \n    function concatenate(string memory a, string memory b) public pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n    \n    function anotherFunction(uint num) public pure returns (uint) {\n        return num * 2;\n    }\n    \n    function auxiliaryFunc() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"test\"));\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract6 {     function() external {     }          function concatenat ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract7 {\n    function() external {\n    }\n    \n    function add(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n    \n    function auxiliaryFunc2() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract7 {     function() external {     }          function add(uint a ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract8 {\n    function() external {\n    }\n    \n    function greet() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n    \n    function combine(uint x, uint y) public pure returns (uint) {\n        return x + y;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract8 {     function() external {     }          function greet() pu ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract9 {\n    function() external {\n    }\n    \n    function isEven(uint number) public pure returns (bool) {\n        return number % 2 == 0;\n    }\n    \n    function randomOperation(uint a, uint b) public pure returns (uint) {\n        return a - b;\n    }\n    \n    function anotherCheck(uint a) public pure returns (bool) {\n        return a > 100;\n    }\n}",
          "error message": ":1:70: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ontract9 {     function() external {     }          function isEven(uin ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract Contract10 {\n    function() external {\n    }\n    \n    function multiply(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function checkCondition(uint value) public pure returns (bool) {\n        return value > 1000;\n    }\n    \n    function dummyFunction() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": ":1:71: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ntract10 {     function() external {     }          function multiply(u ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract Contract1 {\n    fallback() external payable {\n    }\n    \n    function getValue() public pure returns (uint) {\n        return 42;\n    }\n    \n    function randomFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract Contract2 {\n    fallback() external payable {\n    }\n    \n    function computeSum(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract Contract3 {\n    fallback() external payable {\n    }\n    \n    function calculate(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n    \n    function extraFunc() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract Contract4 {\n    fallback() external payable {\n    }\n    \n    function randomFunction() public pure returns (string memory) {\n        return \"Hello, Solidity!\";\n    }\n    \n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract Contract5 {\n    fallback() external payable {\n    }\n    \n    function check(uint num) public pure returns (bool) {\n        return num > 10;\n    }\n    \n    function anotherCheck(uint num) public pure returns (bool) {\n        return num == 0;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract Contract6 {\n    fallback() external payable {\n    }\n    \n    function concatenate(string memory a, string memory b) public pure returns (string memory) {\n        return string(abi.encodePacked(a, b));\n    }\n    \n    function anotherFunction(uint num) public pure returns (uint) {\n        return num * 2;\n    }\n    \n    function auxiliaryFunc() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"test\"));\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract Contract7 {\n    fallback() external payable {\n    }\n    \n    function add(uint a, uint b) public pure returns (uint) {\n        return a + b;\n    }\n    \n    function auxiliaryFunc2() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract Contract8 {\n    fallback() external payable {\n    }\n    \n    function greet() public pure returns (string memory) {\n        return \"Welcome!\";\n    }\n    \n    function combine(uint x, uint y) public pure returns (uint) {\n        return x + y;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract Contract9 {\n    fallback() external payable {\n    }\n    \n    function isEven(uint number) public pure returns (bool) {\n        return number % 2 == 0;\n    }\n    \n    function randomOperation(uint a, uint b) public pure returns (uint) {\n        return a - b;\n    }\n    \n    function anotherCheck(uint a) public pure returns (bool) {\n        return a > 100;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract Contract10 {\n    fallback() external payable {\n    }\n    \n    function multiply(uint x, uint y) public pure returns (uint) {\n        return x * y;\n    }\n    \n    function checkCondition(uint value) public pure returns (bool) {\n        return value > 1000;\n    }\n    \n    function dummyFunction() public pure returns (uint) {\n        return 123;\n    }\n}"
      }
    }
  },
  {
    "Changes38": {
      "Version Migration": "0.5->0.6",
      "Knowledge": "The new fallback function is called when no other function matches (if the receive ether\nfunction does not exist then this includes calls with empty call data).\nYou can make this function <code>payable</code> or not. If it is not <code>payable</code> then transactions\nnot matching any other function which send value will revert. You should only need to\nimplement the new fallback function if you are following an upgrade or proxy pattern.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleOne {\n    uint256 public total;\n\n    function() external {\n        total += 1;\n    }\n\n    function getTotal() public view returns (uint256) {\n        return total;\n    }\n}",
          "error message": ":1:98: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic total;      function() external {         total += 1;     }      fun ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleTwo {\n    address public owner;\n\n    function() external {\n        owner = msg.sender;\n    }\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n}",
          "error message": ":1:98: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic owner;      function() external {         owner = msg.sender;     }  ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleThree {\n    string public message = \"Hello World\";\n\n    function() external {\n        message = \"Fallback called\";\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n\n    function getMessage() public view returns (string memory) {\n        return message;\n    }\n}",
          "error message": ":1:117: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... o World\";      function() external {         message = \"Fallback called ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleFour {\n    uint public count;\n\n    function() external {\n        count++;\n    }\n\n    function resetCount() public {\n        count = 0;\n    }\n}",
          "error message": ":1:96: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic count;      function() external {         count++;     }      functi ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleFive {\n    bool public flag;\n\n    function() external {\n        flag = !flag;\n    }\n\n    function checkFlag() public view returns (bool) {\n        return flag;\n    }\n}",
          "error message": ":1:95: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... lic flag;      function() external {         flag = !flag;     }      f ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleSix {\n    bytes32 public data;\n\n    function() external {\n        data = keccak256(abi.encodePacked(msg.sender));\n    }\n\n    function getData() public view returns (bytes32) {\n        return data;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... lic data;      function() external {         data = keccak256(abi.encod ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleSeven {\n    uint public value;\n\n    function() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic value;      function() external {         value = 100;     }      fu ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleEight {\n    uint public value;\n\n    function() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... ic value;      function() external {         value = 100;     }      fu ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleNine {\n    string public status;\n\n    function() external {\n        status = \"Fallback activated\";\n    }\n\n    function getStatus() public view returns (string memory) {\n        return status;\n    }\n}",
          "error message": ":1:99: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ... c status;      function() external {         status = \"Fallback activat ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.6.0;\n\ncontract ExampleTen {\n    uint public counter;\n\n    function() external {\n        counter += 10;\n    }\n\n    function increment() public {\n        counter++;\n    }\n\n    function decrement() public {\n        counter--;\n    }\n}",
          "error message": ":1:97: ParserError: Expected a state variable declaration. If you intended this as a fallback function or a function to handle plain ether transactions, use the \"fallback\" keyword or the \"ether\" keyword instead.\n ...  counter;      function() external {         counter += 10;     }       ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.6.0;\n\ncontract ExampleOne {\n    uint256 public total;\n\n    fallback() external {\n        total += 1;\n    }\n\n    function getTotal() public view returns (uint256) {\n        return total;\n    }\n}",
        "Example2": "pragma solidity ^0.6.0;\n\ncontract ExampleTwo {\n    address public owner;\n\n    fallback() external {\n        owner = msg.sender;\n    }\n\n    function setOwner(address newOwner) public {\n        owner = newOwner;\n    }\n}",
        "Example3": "pragma solidity ^0.6.0;\n\ncontract ExampleThree {\n    string public message = \"Hello World\";\n\n    fallback() external {\n        message = \"Fallback called\";\n    }\n\n    function setMessage(string memory newMessage) public {\n        message = newMessage;\n    }\n\n    function getMessage() public view returns (string memory) {\n        return message;\n    }\n}",
        "Example4": "pragma solidity ^0.6.0;\n\ncontract ExampleFour {\n    uint public count;\n\n    fallback() external {\n        count++;\n    }\n\n    function resetCount() public {\n        count = 0;\n    }\n}",
        "Example5": "pragma solidity ^0.6.0;\n\ncontract ExampleFive {\n    bool public flag;\n\n    fallback() external {\n        flag = !flag;\n    }\n\n    function checkFlag() public view returns (bool) {\n        return flag;\n    }\n}",
        "Example6": "pragma solidity ^0.6.0;\n\ncontract ExampleSix {\n    bytes32 public data;\n\n    fallback() external {\n        data = keccak256(abi.encodePacked(msg.sender));\n    }\n\n    function getData() public view returns (bytes32) {\n        return data;\n    }\n}",
        "Example7": "pragma solidity ^0.6.0;\n\ncontract ExampleSeven {\n    uint public value;\n\n    fallback() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
        "Example8": "pragma solidity ^0.6.0;\n\ncontract ExampleEight {\n    uint public value;\n\n    fallback() external {\n        value = 100;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
        "Example9": "pragma solidity ^0.6.0;\n\ncontract ExampleNine {\n    string public status;\n\n    fallback() external {\n        status = \"Fallback activated\";\n    }\n\n    function getStatus() public view returns (string memory) {\n        return status;\n    }\n}",
        "Example10": "pragma solidity ^0.6.0;\n\ncontract ExampleTen {\n    uint public counter;\n\n    fallback() external {\n        counter += 10;\n    }\n\n    function increment() public {\n        counter++;\n    }\n\n    function decrement() public {\n        counter--;\n    }\n}"
      }
    }
  },
  {
    "Changes39": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "In external function and contract creation calls, Ether and gas is now specified using a new syntax:\n<code>x.f{gas: 10000, value: 2 ether}(arg1, arg2)</code>.\nThe old syntax \u2013 <code>x.f.gas(10000).value(2 ether)(arg1, arg2)</code> \u2013 will cause an error.Change <code>x.f.value(...)()</code> to <code>x.f{value: ...}()</code>. Similarly <code>(new C).value(...)()</code> to <code>new C{value: ...}()</code> and <code>x.f.gas(...).value(...)()</code> to <code>x.f{gas: ..., value: ...}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractA {\n    function actionA() external payable {\n    }\n}\n\ncontract Example1 {\n    ContractA contractA;\n\n    function triggerActionA() public {\n        contractA.actionA.value(0.5 ether)();\n    }\n\n    function exampleFunction1() public pure returns(string memory) {\n        return \"Example 1\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionA() public {         contractA.actionA.value(0.5 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractB {\n    function actionB() external payable {\n    }\n}\n\ncontract Example2 {\n    ContractB contractB;\n\n    function triggerActionB() public {\n        contractB.actionB.value(0.25 ether)();\n    }\n\n    function exampleFunction2() public pure returns(string memory) {\n        return \"Example 2\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionB() public {         contractB.actionB.value(0.25 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractC {\n    function actionC() external payable {\n    }\n}\n\ncontract Example3 {\n    ContractC contractC;\n\n    function triggerActionC() public {\n        contractC.actionC.value(0.1 ether)();\n    }\n\n    function exampleFunction3() public pure returns(string memory) {\n        return \"Example 3\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionC() public {         contractC.actionC.value(0.1 ether)();     }      function  ...\n                                        ^---------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractD {\n    function actionD() external payable {\n    }\n}\n\ncontract Example4 {\n    ContractD contractD;\n\n    function triggerActionD() public {\n        contractD.actionD.value(2 ether)();\n    }\n\n    function exampleFunction4() public pure returns(string memory) {\n        return \"Example 4\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionD() public {         contractD.actionD.value(2 ether)();     }      function ex ...\n                                        ^---------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractE {\n    function actionE() external payable {\n    }\n}\n\ncontract Example5 {\n    ContractE contractE;\n\n    function triggerActionE() public {\n        contractE.actionE.value(1 ether)();\n    }\n\n    function exampleFunction5() public pure returns(string memory) {\n        return \"Example 5\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionE() public {         contractE.actionE.value(1 ether)();     }      function ex ...\n                                        ^---------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractF {\n    function actionF() external payable {\n    }\n}\n\ncontract Example6 {\n    ContractF contractF;\n\n    function triggerActionF() public {\n        contractF.actionF.value(3 ether)();\n    }\n\n    function exampleFunction6() public pure returns(string memory) {\n        return \"Example 6\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionF() public {         contractF.actionF.value(3 ether)();     }      function ex ...\n                                        ^---------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractG {\n    function actionG() external payable {\n    }\n}\n\ncontract Example7 {\n    ContractG contractG;\n\n    function triggerActionG() public {\n        contractG.actionG.value(0.75 ether)();\n    }\n\n    function exampleFunction7() public pure returns(string memory) {\n        return \"Example 7\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionG() public {         contractG.actionG.value(0.75 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractH {\n    function actionH() external payable {\n    }\n}\n\ncontract Example8 {\n    ContractH contractH;\n\n    function triggerActionH() public {\n        contractH.actionH.value(5 ether)();\n    }\n\n    function exampleFunction8() public pure returns(string memory) {\n        return \"Example 8\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionH() public {         contractH.actionH.value(5 ether)();     }      function ex ...\n                                        ^---------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractI {\n    function actionI() external payable {\n    }\n}\n\ncontract Example9 {\n    ContractI contractI;\n\n    function triggerActionI() public {\n        contractI.actionI.value(0.01 ether)();\n    }\n\n    function exampleFunction9() public pure returns(string memory) {\n        return \"Example 9\";\n    }\n}",
          "error message": ":1:190: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionI() public {         contractI.actionI.value(0.01 ether)();     }      function ...\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractJ {\n    function actionJ() external payable {\n    }\n}\n\ncontract Example10 {\n    ContractJ contractJ;\n\n    function triggerActionJ() public {\n        contractJ.actionJ.value(0.5 ether)();\n    }\n\n    function exampleFunction10() public pure returns(string memory) {\n        return \"Example 10\";\n    }\n}",
          "error message": ":1:191: TypeError: Using \".value(...)\" is deprecated. Use \"{value: ...}\" instead.\n ...  triggerActionJ() public {         contractJ.actionJ.value(0.5 ether)();     }      function  ...\n                                        ^---------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ContractA {\n    function actionA() external payable {\n    }\n}\n\ncontract Example1 {\n    ContractA contractA;\n\n    function triggerActionA() public {\n        contractA.actionA{value: 0.5 ether}();\n    }\n\n    function exampleFunction1() public pure returns(string memory) {\n        return \"Example 1\";\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract ContractB {\n    function actionB() external payable {\n    }\n}\n\ncontract Example2 {\n    ContractB contractB;\n\n    function triggerActionB() public {\n        contractB.actionB{value: 0.25 ether}();\n    }\n\n    function exampleFunction2() public pure returns(string memory) {\n        return \"Example 2\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ContractC {\n    function actionC() external payable {\n    }\n}\n\ncontract Example3 {\n    ContractC contractC;\n\n    function triggerActionC() public {\n        contractC.actionC{value: 0.1 ether}();\n    }\n\n    function exampleFunction3() public pure returns(string memory) {\n        return \"Example 3\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract ContractD {\n    function actionD() external payable {\n    }\n}\n\ncontract Example4 {\n    ContractD contractD;\n\n    function triggerActionD() public {\n        contractD.actionD{value: 2 ether}();\n    }\n\n    function exampleFunction4() public pure returns(string memory) {\n        return \"Example 4\";\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract ContractE {\n    function actionE() external payable {\n    }\n}\n\ncontract Example5 {\n    ContractE contractE;\n\n    function triggerActionE() public {\n        contractE.actionE{value: 1 ether}();\n    }\n\n    function exampleFunction5() public pure returns(string memory) {\n        return \"Example 5\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract ContractF {\n    function actionF() external payable {\n    }\n}\n\ncontract Example6 {\n    ContractF contractF;\n\n    function triggerActionF() public {\n        contractF.actionF{value: 3 ether}();\n    }\n\n    function exampleFunction6() public pure returns(string memory) {\n        return \"Example 6\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ContractG {\n    function actionG() external payable {\n    }\n}\n\ncontract Example7 {\n    ContractG contractG;\n\n    function triggerActionG() public {\n        contractG.actionG{value: 0.75 ether}();\n    }\n\n    function exampleFunction7() public pure returns(string memory) {\n        return \"Example 7\";\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ContractH {\n    function actionH() external payable {\n    }\n}\n\ncontract Example8 {\n    ContractH contractH;\n\n    function triggerActionH() public {\n        contractH.actionH{value: 5 ether}();\n    }\n\n    function exampleFunction8() public pure returns(string memory) {\n        return \"Example 8\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract ContractI {\n    function actionI() external payable {\n    }\n}\n\ncontract Example9 {\n    ContractI contractI;\n\n    function triggerActionI() public {\n        contractI.actionI{value: 0.01 ether}();\n    }\n\n    function exampleFunction9() public pure returns(string memory) {\n        return \"Example 9\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract ContractJ {\n    function actionJ() external payable {\n    }\n}\n\ncontract Example10 {\n    ContractJ contractJ;\n\n    function triggerActionJ() public {\n        contractJ.actionJ{value: 0.5 ether}();\n    }\n\n    function exampleFunction10() public pure returns(string memory) {\n        return \"Example 10\";\n    }\n}"
      }
    }
  },
  {
    "Changes40": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The global variable <code>now</code> is deprecated, <code>block.timestamp</code> should be used instead.\nThe single identifier <code>now</code> is too generic for a global variable and could give the impression\nthat it changes during transaction processing, whereas <code>block.timestamp</code> correctly\nreflects the fact that it is just a property of the block.Change <code>now</code> to <code>block.timestamp</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public timeMark;\n\n    function setTimeMark() public {\n        timeMark = now;\n    }\n\n    uint public data;\n\n    function setData(uint newData) public {\n        data = newData;\n    }\n}",
          "error message": ":1:127: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... Mark() public {         timeMark = now;     }      uint public data;      ...\n                                        ^-^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public lastInteraction;\n\n    function setLastInteraction() public {\n        lastInteraction = now;\n    }\n\n    uint public count;\n\n    function incrementCount() public {\n        count += 1;\n    }\n}",
          "error message": ":1:148: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... public {         lastInteraction = now;     }      uint public count;     ...\n                                        ^-^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public lastPayment;\n\n    function recordPayment() public {\n        lastPayment = now;\n    }\n\n    uint public balance;\n\n    function deposit(uint amount) public {\n        balance += amount;\n    }\n}",
          "error message": ":1:135: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... t() public {         lastPayment = now;     }      uint public balance;   ...\n                                        ^-^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public creationTime;\n\n    function setCreationTime() public {\n        creationTime = now;\n    }\n\n    string public note;\n\n    function setNote(string memory newNote) public {\n        note = newNote;\n    }\n}",
          "error message": ":1:139: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         creationTime = now;     }      string public note;    ...\n                                        ^-^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public lastVoteTime;\n\n    function vote() public {\n        lastVoteTime = now;\n    }\n\n    uint public votes;\n\n    function countVote() public {\n        votes += 1;\n    }\n}",
          "error message": ":1:128: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... () public {         lastVoteTime = now;     }      uint public votes;     ...\n                                        ^-^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public lastAccess;\n\n    function access() public {\n        lastAccess = now;\n    }\n\n    uint public accessCount;\n\n    function recordAccess() public {\n        accessCount++;\n    }\n}",
          "error message": ":1:126: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ss() public {         lastAccess = now;     }      uint public accessCoun ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public lastUpdate;\n\n    function update() public {\n        lastUpdate = now;\n    }\n\n    uint public updateCount;\n\n    function incrementUpdate() public {\n        updateCount++;\n    }\n}",
          "error message": ":1:126: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... te() public {         lastUpdate = now;     }      uint public updateCoun ...\n                                        ^-^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public lastChange;\n\n    function change() public {\n        lastChange = now;\n    }\n\n    uint public changeFrequency;\n\n    function recordChange() public {\n        changeFrequency++;\n    }\n}",
          "error message": ":1:126: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ge() public {         lastChange = now;     }      uint public changeFreq ...\n                                        ^-^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public lastActionTimestamp;\n\n    function performAction() public {\n        lastActionTimestamp = now;\n    }\n\n    uint public actionCounter;\n\n    function incrementActionCounter() public {\n        actionCounter++;\n    }\n}",
          "error message": ":1:151: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ic {         lastActionTimestamp = now;     }      uint public actionCoun ...\n                                        ^-^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public lastEventTime;\n\n    function triggerEvent() public {\n        lastEventTime = now;\n    }\n\n    uint public eventCount;\n\n    function increaseEventCount() public {\n        eventCount++;\n    }\n}",
          "error message": ":1:139: TypeError: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ) public {         lastEventTime = now;     }      uint public eventCount ...\n                                        ^-^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public timeMark;\n\n    function setTimeMark() public {\n        timeMark = block.timestamp;\n    }\n\n    uint public data;\n\n    function setData(uint newData) public {\n        data = newData;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public lastInteraction;\n\n    function setLastInteraction() public {\n        lastInteraction = block.timestamp;\n    }\n\n    uint public count;\n\n    function incrementCount() public {\n        count += 1;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public lastPayment;\n\n    function recordPayment() public {\n        lastPayment = block.timestamp;\n    }\n\n    uint public balance;\n\n    function deposit(uint amount) public {\n        balance += amount;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public creationTime;\n\n    function setCreationTime() public {\n        creationTime = block.timestamp;\n    }\n\n    string public note;\n\n    function setNote(string memory newNote) public {\n        note = newNote;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public lastVoteTime;\n\n    function vote() public {\n        lastVoteTime = block.timestamp;\n    }\n\n    uint public votes;\n\n    function countVote() public {\n        votes += 1;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public lastAccess;\n\n    function access() public {\n        lastAccess = block.timestamp;\n    }\n\n    uint public accessCount;\n\n    function recordAccess() public {\n        accessCount++;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public lastUpdate;\n\n    function update() public {\n        lastUpdate = block.timestamp;\n    }\n\n    uint public updateCount;\n\n    function incrementUpdate() public {\n        updateCount++;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public lastChange;\n\n    function change() public {\n        lastChange = block.timestamp;\n    }\n\n    uint public changeFrequency;\n\n    function recordChange() public {\n        changeFrequency++;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public lastActionTimestamp;\n\n    function performAction() public {\n        lastActionTimestamp = block.timestamp;\n    }\n\n    uint public actionCounter;\n\n    function incrementActionCounter() public {\n        actionCounter++;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public lastEventTime;\n\n    function triggerEvent() public {\n        lastEventTime = block.timestamp;\n    }\n\n    uint public eventCount;\n\n    function increaseEventCount() public {\n        eventCount++;\n    }\n}"
      }
    }
  },
  {
    "Changes41": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "NatSpec comments on variables are only allowed for public state variables and not\nfor local or internal variables.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MyContract {\n    /// @notice This is a public state variable with NatSpec comment\n    /// @dev It stores a number\n    uint256 public myNumber;\n\n    function setNumber(uint256 _number) public {\n        /// @notice This is a NatSpec comment on a local variable\n        /// @dev This is not allowed in Solidity 0.7 and later\n        uint256 localNumber = _number;\n        myNumber = localNumber;\n    }\n\n    function getNumber() public view returns (uint256) {\n        return myNumber;\n    }\n}",
          "error message": ":1:523: ParserError: Function, variable, struct or modifier declaration expected.\n ...  {         return myNumber;     } }\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractB {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public data;\n\n    function modifyData(uint256 _data) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 internalData = _data;\n        data = internalData;\n    }\n\n    function retrieveData() public view returns (uint256) {\n        return data;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
          "error message": ":1:526: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 1\";     } }\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractC {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public num;\n\n    function setNum(uint256 _num) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localNum = _num;\n        num = localNum;\n    }\n\n    function getNum() public view returns (uint256) {\n        return num;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:614: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractD {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public count;\n\n    function setCount(uint256 _count) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localCount = _count;\n        count = localCount;\n    }\n\n    function getCount() public view returns (uint256) {\n        return count;\n    }\n}",
          "error message": ":1:412: ParserError: Function, variable, struct or modifier declaration expected.\n ... 56) {         return count;     } }\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractE {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public amount;\n\n    function setAmount(uint256 _amount) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localAmount = _amount;\n        amount = localAmount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return amount;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
          "error message": ":1:528: ParserError: Function, variable, struct or modifier declaration expected.\n ...    return \"Extra function\";     } }\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractF {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public total;\n\n    function updateTotal(uint256 _total) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 internalTotal = _total;\n        total = internalTotal;\n    }\n\n    function fetchTotal() public view returns (uint256) {\n        return total;\n    }\n}",
          "error message": ":1:423: ParserError: Function, variable, struct or modifier declaration expected.\n ... 56) {         return total;     } }\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractG {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public balance;\n\n    function setBalance(uint256 _balance) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localBalance = _balance;\n        balance = localBalance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n}",
          "error message": ":1:430: ParserError: Function, variable, struct or modifier declaration expected.\n ... ) {         return balance;     } }\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractH {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public points;\n\n    function updatePoints(uint256 _points) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localPoints = _points;\n        points = localPoints;\n    }\n\n    function getPoints() public view returns (uint256) {\n        return points;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
          "error message": ":1:534: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 1\";     } }\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractI {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public score;\n\n    function setScore(uint256 _score) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localScore = _score;\n        score = localScore;\n    }\n\n    function getScore() public view returns (uint256) {\n        return score;\n    }\n}",
          "error message": ":1:412: ParserError: Function, variable, struct or modifier declaration expected.\n ... 56) {         return score;     } }\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ContractJ {\n    /// @notice This is a public state variable with NatSpec comment\n    uint256 public index;\n\n    function updateIndex(uint256 _index) public {\n        /// @notice This is a NatSpec comment on a local variable\n        uint256 localIndex = _index;\n        index = localIndex;\n    }\n\n    function getIndex() public view returns (uint256) {\n        return index;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
          "error message": ":1:632: ParserError: Function, variable, struct or modifier declaration expected.\n ...  return \"Extra function 2\";     } }\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract MyContract {\n    uint256 public myNumber;\n\n    function setNumber(uint256 _number) public {\n        uint256 localNumber = _number;\n        myNumber = localNumber;\n    }\n\n    function getNumber() public view returns (uint256) {\n        return myNumber;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract ContractB {\n    uint256 public data;\n\n    function modifyData(uint256 _data) public {\n        uint256 internalData = _data;\n        data = internalData;\n    }\n\n    function retrieveData() public view returns (uint256) {\n        return data;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract ContractC {\n    uint256 public num;\n\n    function setNum(uint256 _num) public {\n        uint256 localNum = _num;\n        num = localNum;\n    }\n\n    function getNum() public view returns (uint256) {\n        return num;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract ContractD {\n    uint256 public count;\n\n    function setCount(uint256 _count) public {\n        uint256 localCount = _count;\n        count = localCount;\n    }\n\n    function getCount() public view returns (uint256) {\n        return count;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract ContractE {\n    uint256 public amount;\n\n    function setAmount(uint256 _amount) public {\n        uint256 localAmount = _amount;\n        amount = localAmount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return amount;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract ContractF {\n    uint256 public total;\n\n    function updateTotal(uint256 _total) public {\n        uint256 internalTotal = _total;\n        total = internalTotal;\n    }\n\n    function fetchTotal() public view returns (uint256) {\n        return total;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract ContractG {\n    uint256 public balance;\n\n    function setBalance(uint256 _balance) public {\n        uint256 localBalance = _balance;\n        balance = localBalance;\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balance;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract ContractH {\n    uint256 public points;\n\n    function updatePoints(uint256 _points) public {\n        uint256 localPoints = _points;\n        points = localPoints;\n    }\n\n    function getPoints() public view returns (uint256) {\n        return points;\n    }\n\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra function 1\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract ContractI {\n    uint256 public score;\n\n    function setScore(uint256 _score) public {\n        uint256 localScore = _score;\n        score = localScore;\n    }\n\n    function getScore() public view returns (uint256) {\n        return score;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract ContractJ {\n    uint256 public index;\n\n    function updateIndex(uint256 _index) public {\n        uint256 localIndex = _index;\n        index = localIndex;\n    }\n\n    function getIndex() public view returns (uint256) {\n        return index;\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra function\";\n    }\n\n    function extraFunction2() public pure returns (string memory) {\n        return \"Extra function 2\";\n    }\n}"
      }
    }
  },
  {
    "Changes42": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The token <code>gwei</code> is a keyword now (used to specify, e.g. <code>2 gwei</code> as a number)\nand cannot be used as an identifier.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public gwei;\n\n    constructor() public {\n        gwei = 500;\n    }\n\n    function updateGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function retrieveGwei() public view returns (uint) {\n        return gwei;\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example1 {     uint public gwei;      constructor() public {       ...\n                                        ^--^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public gwei;\n    uint public value;\n\n    constructor(uint initialValue) public {\n        gwei = initialValue;\n        value = 0;\n    }\n\n    function setGweiValue(uint _gwei, uint _value) public {\n        gwei = _gwei;\n        value = _value;\n    }\n\n    function getValues() public view returns (uint, uint) {\n        return (gwei, value);\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example2 {     uint public gwei;     uint public value;      const ...\n                                        ^--^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public gwei;\n\n    constructor(uint _initialGwei) public {\n        gwei = _initialGwei;\n    }\n\n    function changeGwei(uint _newGwei) public {\n        gwei = _newGwei;\n    }\n\n    function fetchGwei() public view returns (uint) {\n        return gwei;\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example3 {     uint public gwei;      constructor(uint _initialGwe ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public gwei;\n    string public name;\n\n    constructor(string memory _name) public {\n        gwei = 200;\n        name = _name;\n    }\n\n    function modifyGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiAndName() public view returns (uint, string memory) {\n        return (gwei, name);\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example4 {     uint public gwei;     string public name;      cons ...\n                                        ^--^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public gwei;\n    address public owner;\n\n    constructor() public {\n        gwei = 150;\n        owner = msg.sender;\n    }\n\n    function adjustGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function retrieveOwnerGwei() public view returns (address, uint) {\n        return (owner, gwei);\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example5 {     uint public gwei;     address public owner;      co ...\n                                        ^--^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public gwei;\n    bool public active;\n\n    constructor(bool _active) public {\n        gwei = 75;\n        active = _active;\n    }\n\n    function setActiveGwei(uint _gwei, bool _active) public {\n        gwei = _gwei;\n        active = _active;\n    }\n\n    function getStatus() public view returns (uint, bool) {\n        return (gwei, active);\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example6 {     uint public gwei;     bool public active;      cons ...\n                                        ^--^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public gwei;\n    uint public rate;\n\n    constructor(uint _rate) public {\n        gwei = 300;\n        rate = _rate;\n    }\n\n    function configureGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiAndRate() public view returns (uint, uint) {\n        return (gwei, rate);\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example7 {     uint public gwei;     uint public rate;      constr ...\n                                        ^--^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public gwei;\n\n    constructor() public {\n        gwei = 800;\n    }\n\n    function alterGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function viewGwei() public view returns (uint) {\n        return gwei;\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example8 {     uint public gwei;      constructor() public {       ...\n                                        ^--^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public gwei;\n    uint public balance;\n\n    constructor(uint _initialBalance) public {\n        gwei = 1000;\n        balance = _initialBalance;\n    }\n\n    function setGweiBalance(uint _gwei, uint _balance) public {\n        gwei = _gwei;\n        balance = _balance;\n    }\n\n    function getGweiBalance() public view returns (uint, uint) {\n        return (gwei, balance);\n    }\n}",
          "error message": ":1:61: ParserError: Expected identifier but got 'gwei'\n ... ontract Example9 {     uint public gwei;     uint public balance;      con ...\n                                        ^--^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public gwei;\n    address public owner;\n\n    constructor(address _owner) public {\n        gwei = 250;\n        owner = _owner;\n    }\n\n    function updateOwnerGwei(uint _gwei) public {\n        gwei = _gwei;\n    }\n\n    function getGweiOwner() public view returns (uint, address) {\n        return (gwei, owner);\n    }\n}",
          "error message": ":1:62: ParserError: Expected identifier but got 'gwei'\n ... ntract Example10 {     uint public gwei;     address public owner;      co ...\n                                        ^--^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public gweiValue;\n\n    constructor() public {\n        gweiValue = 500;\n    }\n\n    function updateGwei(uint _gweiValue) public {\n        gweiValue = _gweiValue;\n    }\n\n    function retrieveGwei() public view returns (uint) {\n        return gweiValue;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public gweiValue;\n    uint public value;\n\n    constructor(uint initialValue) public {\n        gweiValue = initialValue;\n        value = 0;\n    }\n\n    function setGweiValue(uint _gweiValue, uint _value) public {\n        gweiValue = _gweiValue;\n        value = _value;\n    }\n\n    function getValues() public view returns (uint, uint) {\n        return (gweiValue, value);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public gweiValue;\n\n    constructor(uint _initialGweiValue) public {\n        gweiValue = _initialGweiValue;\n    }\n\n    function changeGwei(uint _newGweiValue) public {\n        gweiValue = _newGweiValue;\n    }\n\n    function fetchGwei() public view returns (uint) {\n        return gweiValue;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public gweiValue;\n    string public name;\n\n    constructor(string memory _name) public {\n        gweiValue = 200;\n        name = _name;\n    }\n\n    function modifyGwei(uint _gweiValue) public {\n        gweiValue = _gweiValue;\n    }\n\n    function getGweiAndName() public view returns (uint, string memory) {\n        return (gweiValue, name);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public gweiValue;\n    address public owner;\n\n    constructor() public {\n        gweiValue = 150;\n        owner = msg.sender;\n    }\n\n    function adjustGwei(uint _gweiValue) public {\n        gweiValue = _gweiValue;\n    }\n\n    function retrieveOwnerGwei() public view returns (address, uint) {\n        return (owner, gweiValue);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public gweiValue;\n    bool public active;\n\n    constructor(bool _active) public {\n        gweiValue = 75;\n        active = _active;\n    }\n\n    function setActiveGwei(uint _gweiValue, bool _active) public {\n        gweiValue = _gweiValue;\n        active = _active;\n    }\n\n    function getStatus() public view returns (uint, bool) {\n        return (gweiValue, active);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public gweiValue;\n    uint public rate;\n\n    constructor(uint _rate) public {\n        gweiValue = 300;\n        rate = _rate;\n    }\n\n    function configureGwei(uint _gweiValue) public {\n        gweiValue = _gweiValue;\n    }\n\n    function getGweiAndRate() public view returns (uint, uint) {\n        return (gweiValue, rate);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public gweiValue;\n\n    constructor() public {\n        gweiValue = 800;\n    }\n\n    function alterGwei(uint _gweiValue) public {\n        gweiValue = _gweiValue;\n    }\n\n    function viewGwei() public view returns (uint) {\n        return gweiValue;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public gweiValue;\n    uint public balance;\n\n    constructor(uint _initialBalance) public {\n        gweiValue = 1000;\n        balance = _initialBalance;\n    }\n\n    function setGweiBalance(uint _gweiValue, uint _balance) public {\n        gweiValue = _gweiValue;\n        balance = _balance;\n    }\n\n    function getGweiBalance() public view returns (uint, uint) {\n        return (gweiValue, balance);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public gweiValue;\n    address public owner;\n\n    constructor(address _owner) public {\n        gweiValue = 250;\n        owner = _owner;\n    }\n\n    function updateOwnerGwei(uint _gweiValue) public {\n        gweiValue = _gweiValue;\n    }\n\n    function getGweiOwner() public view returns (uint, address) {\n        return (gweiValue, owner);\n    }\n}"
      }
    }
  },
  {
    "Changes43": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Disallow <code>.</code> in user-defined function and variable names in inline assembly.\nIt is still valid if you use Solidity in Yul-only mode.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint256 public result;\n\n    function compute() public {\n        uint256 a = 15;\n        uint256 b = 25;\n        uint256 res;\n\n        assembly {\n            function sumValues(x, y) -> total {\n                total := add(x, y)\n            }\n\n            let total.val := sumValues(a, b)\n\n            res := total.val\n        }\n\n        result = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Unrelated function 1\";\n    }\n}",
          "error message": ":1:308: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  y)             }              let total.val := sumValues(a, b)              re ...\n                                        ^-------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint256 public outcome;\n\n    function execute() public {\n        uint256 m = 5;\n        uint256 n = 30;\n        uint256 res;\n\n        assembly {\n            function addNums(u, v) -> result {\n                result := add(u, v)\n            }\n\n            let temp.result := addNums(m, n)\n\n            res := temp.result\n        }\n\n        outcome = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 42;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:308: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  v)             }              let temp.result := addNums(m, n)              res  ...\n                                        ^---------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint256 public value;\n\n    function calculateResult() public {\n        uint256 p = 12;\n        uint256 q = 18;\n        uint256 res;\n\n        assembly {\n            function getSum(j, k) -> summation {\n                summation := add(j, k)\n            }\n\n            let res.value := getSum(p, q)\n\n            res := res.value\n        }\n\n        value = res;\n    }\n}",
          "error message": ":1:320: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  k)             }              let res.value := getSum(p, q)              res : ...\n                                        ^-------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint256 public output;\n\n    function perform() public {\n        uint256 x = 8;\n        uint256 y = 22;\n        uint256 res;\n\n        assembly {\n            function computeSum(e, f) -> totalSum {\n                totalSum := add(e, f)\n            }\n\n            let var.total := computeSum(x, y)\n\n            res := var.total\n        }\n\n        output = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"This is an unrelated function\";\n    }\n}",
          "error message": ":1:314: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  f)             }              let var.total := computeSum(x, y)              r ...\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint256 public resultValue;\n\n    function process() public {\n        uint256 g = 9;\n        uint256 h = 11;\n        uint256 res;\n\n        assembly {\n            function calcSum(m, n) -> sumResult {\n                sumResult := add(m, n)\n            }\n\n            let res.calc := calcSum(g, h)\n\n            res := res.calc\n        }\n\n        resultValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 100;\n    }\n\n    function unrelatedFunction2() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:318: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  n)             }              let res.calc := calcSum(g, h)              res  ...\n                                        ^------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint256 public finalResult;\n\n    function calculateSum() public {\n        uint256 a = 7;\n        uint256 b = 14;\n        uint256 res;\n\n        assembly {\n            function sumNumbers(c, d) -> finalSum {\n                finalSum := add(c, d)\n            }\n\n            let final.val := sumNumbers(a, b)\n\n            res := final.val\n        }\n\n        finalResult = res;\n    }\n}",
          "error message": ":1:324: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  d)             }              let final.val := sumNumbers(a, b)              r ...\n                                        ^-------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint256 public calcResult;\n\n    function run() public {\n        uint256 x = 6;\n        uint256 y = 19;\n        uint256 res;\n\n        assembly {\n            function addValues(p, q) -> finalResult {\n                finalResult := add(p, q)\n            }\n\n            let result.val := addValues(x, y)\n\n            res := result.val\n        }\n\n        calcResult = res;\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Another unrelated function\";\n    }\n}",
          "error message": ":1:319: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  q)             }              let result.val := addValues(x, y)              re ...\n                                        ^--------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint256 public outputValue;\n\n    function executeCalc() public {\n        uint256 w = 20;\n        uint256 z = 10;\n        uint256 res;\n\n        assembly {\n            function findSum(i, j) -> resultSum {\n                resultSum := add(i, j)\n            }\n\n            let output.sum := findSum(w, z)\n\n            res := output.sum\n        }\n\n        outputValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (uint256) {\n        return 777;\n    }\n}",
          "error message": ":1:323: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  j)             }              let output.sum := findSum(w, z)              res  ...\n                                        ^--------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint256 public finalValue;\n\n    function start() public {\n        uint256 m = 11;\n        uint256 n = 13;\n        uint256 res;\n\n        assembly {\n            function sumTotal(a, b) -> totalValue {\n                totalValue := add(a, b)\n            }\n\n            let sum.total := sumTotal(m, n)\n\n            res := sum.total\n        }\n\n        finalValue = res;\n    }\n\n    function unrelatedFunction1() public pure returns (bool) {\n        return true;\n    }\n\n    function unrelatedFunction2() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}",
          "error message": ":1:319: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let sum.total := sumTotal(m, n)              res ...\n                                        ^-------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint256 public resultOutput;\n\n    function operate() public {\n        uint256 p = 9;\n        uint256 q = 21;\n        uint256 res;\n\n        assembly {\n            function calculate(a, b) -> totalResult {\n                totalResult := add(a, b)\n            }\n\n            let calc.result := calculate(p, q)\n\n            res := calc.result\n        }\n\n        resultOutput = res;\n    }\n}",
          "error message": ":1:326: DeclarationError: User-defined identifiers in inline assembly cannot contain '.'.\n ...  b)             }              let calc.result := calculate(p, q)              re ...\n                                        ^---------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint256 public result;\n\n    function compute() public {\n        uint256 a = 15;\n        uint256 b = 25;\n        uint256 res;\n\n        assembly {\n            function sumValues(x, y) -> total {\n                total := add(x, y)\n            }\n\n            let totalVal := sumValues(a, b)\n\n            res := totalVal\n        }\n\n        result = res;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint256 public outcome;\n\n    function execute() public {\n        uint256 m = 5;\n        uint256 n = 30;\n        uint256 res;\n\n        assembly {\n            function addNums(u, v) -> result {\n                result := add(u, v)\n            }\n\n            let tempResult := addNums(m, n)\n\n            res := tempResult\n        }\n\n        outcome = res;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint256 public value;\n\n    function calculateResult() public {\n        uint256 p = 12;\n        uint256 q = 18;\n        uint256 res;\n\n        assembly {\n            function getSum(j, k) -> summation {\n                summation := add(j, k)\n            }\n\n            let resValue := getSum(p, q)\n\n            res := resValue\n        }\n\n        value = res;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint256 public output;\n\n    function perform() public {\n        uint256 x = 8;\n        uint256 y = 22;\n        uint256 res;\n\n        assembly {\n            function computeSum(e, f) -> totalSum {\n                totalSum := add(e, f)\n            }\n\n            let varTotal := computeSum(x, y)\n\n            res := varTotal\n        }\n\n        output = res;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint256 public resultValue;\n\n    function process() public {\n        uint256 g = 9;\n        uint256 h = 11;\n        uint256 res;\n\n        assembly {\n            function calcSum(m, n) -> sumResult {\n                sumResult := add(m, n)\n            }\n\n            let resCalc := calcSum(g, h)\n\n            res := resCalc\n        }\n\n        resultValue = res;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint256 public finalResult;\n\n    function calculateSum() public {\n        uint256 a = 7;\n        uint256 b = 14;\n        uint256 res;\n\n        assembly {\n            function sumNumbers(c, d) -> finalSum {\n                finalSum := add(c, d)\n            }\n\n            let finalVal := sumNumbers(a, b)\n\n            res := finalVal\n        }\n\n        finalResult = res;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint256 public calcResult;\n\n    function run() public {\n        uint256 x = 6;\n        uint256 y = 19;\n        uint256 res;\n\n        assembly {\n            function addValues(p, q) -> finalResult {\n                finalResult := add(p, q)\n            }\n\n            let resultVal := addValues(x, y)\n\n            res := resultVal\n        }\n\n        calcResult = res;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint256 public outputValue;\n\n    function executeCalc() public {\n        uint256 w = 20;\n        uint256 z = 10;\n        uint256 res;\n\n        assembly {\n            function findSum(i, j) -> resultSum {\n                resultSum := add(i, j)\n            }\n\n            let outputSum := findSum(w, z)\n\n            res := outputSum\n        }\n\n        outputValue = res;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint256 public finalValue;\n\n    function start() public {\n        uint256 m = 11;\n        uint256 n = 13;\n        uint256 res;\n\n        assembly {\n            function sumTotal(a, b) -> totalValue {\n                totalValue := add(a, b)\n            }\n\n            let sumTotal := sumTotal(m, n)\n\n            res := sumTotal\n        }\n\n        finalValue = res;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint256 public resultOutput;\n\n    function operate() public {\n        uint256 p = 9;\n        uint256 q = 21;\n        uint256 res;\n\n        assembly {\n            function calculate(a, b) -> totalResult {\n                totalResult := add(a, b)\n            }\n\n            let calcResult := calculate(p, q)\n\n            res := calcResult\n        }\n\n        resultOutput = res;\n    }\n}"
      }
    }
  },
  {
    "Changes44": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Slot and offset of storage pointer variable <code>x</code> are accessed via <code>x.slot</code>\nand <code>x.offset</code> instead of <code>x_slot</code> and <code>x_offset</code>.Change <code>_slot</code> and <code>_offset</code> suffixes in inline assembly to <code>.slot</code> and <code>.offset</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Item {\n        uint count;\n    }\n\n    Item public item;\n\n    constructor() public {\n        item.count = 100;\n    }\n\n    function getItemPointer() public view returns (uint slot, uint offset) {\n        uint itemSlot;\n        uint itemOffset;\n        assembly {\n            itemSlot := item_slot\n            itemOffset := item_offset\n        }\n        return (itemSlot, itemOffset);\n    }\n}",
          "error message": ":1:341: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             itemSlot := item_slot             itemOffset := item_off ...\n                                        ^-------^\n:1:377: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... tem_slot             itemOffset := item_offset         }         return (itemSlot ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Record {\n        uint number;\n    }\n\n    Record public record;\n\n    constructor() public {\n        record.number = 42;\n    }\n\n    function fetchRecordPointer() public view returns (uint slot, uint offset) {\n        uint recordSlot;\n        uint recordOffset;\n        assembly {\n            recordSlot := record_slot\n            recordOffset := record_offset\n        }\n        return (recordSlot, recordOffset);\n    }\n}",
          "error message": ":1:360: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             recordSlot := record_slot             recordOffset := record ...\n                                        ^---------^\n:1:400: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... d_slot             recordOffset := record_offset         }         return (recordSl ...\n                                        ^-----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Profile {\n        uint age;\n    }\n\n    Profile public profile;\n\n    constructor() public {\n        profile.age = 25;\n    }\n\n    function retrieveProfilePointer() public view returns (uint slot, uint offset) {\n        uint profileSlot;\n        uint profileOffset;\n        assembly {\n            profileSlot := profile_slot\n            profileOffset := profile_offset\n        }\n        return (profileSlot, profileOffset);\n    }\n\n    function dummyFunction() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": ":1:365: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             profileSlot := profile_slot             profileOffset := profi ...\n                                        ^----------^\n:1:407: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... _slot             profileOffset := profile_offset         }         return (profileS ...\n                                        ^------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Account {\n        uint balance;\n    }\n\n    Account public account;\n\n    constructor() public {\n        account.balance = 1000;\n    }\n\n    function getAccountPointer() public view returns (uint slot, uint offset) {\n        uint accountSlot;\n        uint accountOffset;\n        assembly {\n            accountSlot := account_slot\n            accountOffset := account_offset\n        }\n        return (accountSlot, accountOffset);\n    }\n}",
          "error message": ":1:370: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             accountSlot := account_slot             accountOffset := accou ...\n                                        ^----------^\n:1:412: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... _slot             accountOffset := account_offset         }         return (accountS ...\n                                        ^------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Product {\n        uint price;\n    }\n\n    Product public product;\n\n    constructor() public {\n        product.price = 50;\n    }\n\n    function fetchProductPointer() public view returns (uint slot, uint offset) {\n        uint productSlot;\n        uint productOffset;\n        assembly {\n            productSlot := product_slot\n            productOffset := product_offset\n        }\n        return (productSlot, productOffset);\n    }\n\n    function anotherDummyFunction() public pure returns (uint) {\n        return 1;\n    }\n\n    function extraDummyFunction() public pure returns (uint) {\n        return 2;\n    }\n}",
          "error message": ":1:366: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             productSlot := product_slot             productOffset := produ ...\n                                        ^----------^\n:1:408: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... _slot             productOffset := product_offset         }         return (productS ...\n                                        ^------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Document {\n        uint id;\n    }\n\n    Document public document;\n\n    constructor() public {\n        document.id = 7;\n    }\n\n    function getDocumentPointer() public view returns (uint slot, uint offset) {\n        uint documentSlot;\n        uint documentOffset;\n        assembly {\n            documentSlot := document_slot\n            documentOffset := document_offset\n        }\n        return (documentSlot, documentOffset);\n    }\n}",
          "error message": ":1:365: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... mbly {             documentSlot := document_slot             documentOffset := docu ...\n                                        ^-----------^\n:1:409: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... slot             documentOffset := document_offset         }         return (document ...\n                                        ^-------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Order {\n        uint quantity;\n    }\n\n    Order public order;\n\n    constructor() public {\n        order.quantity = 15;\n    }\n\n    function retrieveOrderPointer() public view returns (uint slot, uint offset) {\n        uint orderSlot;\n        uint orderOffset;\n        assembly {\n            orderSlot := order_slot\n            orderOffset := order_offset\n        }\n        return (orderSlot, orderOffset);\n    }\n}",
          "error message": ":1:359: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             orderSlot := order_slot             orderOffset := order_o ...\n                                        ^--------^\n:1:397: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... er_slot             orderOffset := order_offset         }         return (orderSlo ...\n                                        ^----------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct User {\n        uint score;\n    }\n\n    User public user;\n\n    constructor() public {\n        user.score = 85;\n    }\n\n    function getUserPointer() public view returns (uint slot, uint offset) {\n        uint userSlot;\n        uint userOffset;\n        assembly {\n            userSlot := user_slot\n            userOffset := user_offset\n        }\n        return (userSlot, userOffset);\n    }\n}",
          "error message": ":1:340: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             userSlot := user_slot             userOffset := user_off ...\n                                        ^-------^\n:1:376: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ser_slot             userOffset := user_offset         }         return (userSlot ...\n                                        ^---------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct Task {\n        uint duration;\n    }\n\n    Task public task;\n\n    constructor() public {\n        task.duration = 60;\n    }\n\n    function fetchTaskPointer() public view returns (uint slot, uint offset) {\n        uint taskSlot;\n        uint taskOffset;\n        assembly {\n            taskSlot := task_slot\n            taskOffset := task_offset\n        }\n        return (taskSlot, taskOffset);\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"extra\";\n    }\n}",
          "error message": ":1:348: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             taskSlot := task_slot             taskOffset := task_off ...\n                                        ^-------^\n:1:384: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ask_slot             taskOffset := task_offset         }         return (taskSlot ...\n                                        ^---------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct Asset {\n        uint value;\n    }\n\n    Asset public asset;\n\n    constructor() public {\n        asset.value = 1000;\n    }\n\n    function retrieveAssetPointer() public view returns (uint slot, uint offset) {\n        uint assetSlot;\n        uint assetOffset;\n        assembly {\n            assetSlot := asset_slot\n            assetOffset := asset_offset\n        }\n        return (assetSlot, assetOffset);\n    }\n\n    function anotherExtraFunction() public pure returns (string memory) {\n        return \"another extra\";\n    }\n}",
          "error message": ":1:356: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             assetSlot := asset_slot             assetOffset := asset_o ...\n                                        ^--------^\n:1:394: DeclarationError: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... et_slot             assetOffset := asset_offset         }         return (assetSlo ...\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Item {\n        uint count;\n    }\n\n    Item public item;\n\n    constructor() public {\n        item.count = 100;\n    }\n\n    function getItemPointer() public view returns (uint slot, uint offset) {\n        uint itemSlot;\n        uint itemOffset;\n        assembly {\n            itemSlot := item.slot\n            itemOffset := item.offset\n        }\n        return (itemSlot, itemOffset);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Record {\n        uint number;\n    }\n\n    Record public record;\n\n    constructor() public {\n        record.number = 42;\n    }\n\n    function fetchRecordPointer() public view returns (uint slot, uint offset) {\n        uint recordSlot;\n        uint recordOffset;\n        assembly {\n            recordSlot := record.slot\n            recordOffset := record.offset\n        }\n        return (recordSlot, recordOffset);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Profile {\n        uint age;\n    }\n\n    Profile public profile;\n\n    constructor() public {\n        profile.age = 25;\n    }\n\n    function retrieveProfilePointer() public view returns (uint slot, uint offset) {\n        uint profileSlot;\n        uint profileOffset;\n        assembly {\n            profileSlot := profile.slot\n            profileOffset := profile.offset\n        }\n        return (profileSlot, profileOffset);\n    }\n\n    function dummyFunction() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Account {\n        uint balance;\n    }\n\n    Account public account;\n\n    constructor() public {\n        account.balance = 1000;\n    }\n\n    function getAccountPointer() public view returns (uint slot, uint offset) {\n        uint accountSlot;\n        uint accountOffset;\n        assembly {\n            accountSlot := account.slot\n            accountOffset := account.offset\n        }\n        return (accountSlot, accountOffset);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Product {\n        uint price;\n    }\n\n    Product public product;\n\n    constructor() public {\n        product.price = 50;\n    }\n\n    function fetchProductPointer() public view returns (uint slot, uint offset) {\n        uint productSlot;\n        uint productOffset;\n        assembly {\n            productSlot := product.slot\n            productOffset := product.offset\n        }\n        return (productSlot, productOffset);\n    }\n\n    function anotherDummyFunction() public pure returns (uint) {\n        return 1;\n    }\n\n    function extraDummyFunction() public pure returns (uint) {\n        return 2;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Document {\n        uint id;\n    }\n\n    Document public document;\n\n    constructor() public {\n        document.id = 7;\n    }\n\n    function getDocumentPointer() public view returns (uint slot, uint offset) {\n        uint documentSlot;\n        uint documentOffset;\n        assembly {\n            documentSlot := document.slot\n            documentOffset := document.offset\n        }\n        return (documentSlot, documentOffset);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Order {\n        uint quantity;\n    }\n\n    Order public order;\n\n    constructor() public {\n        order.quantity = 15;\n    }\n\n    function retrieveOrderPointer() public view returns (uint slot, uint offset) {\n        uint orderSlot;\n        uint orderOffset;\n        assembly {\n            orderSlot := order.slot\n            orderOffset := order.offset\n        }\n        return (orderSlot, orderOffset);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct User {\n        uint score;\n    }\n\n    User public user;\n\n    constructor() public {\n        user.score = 85;\n    }\n\n    function getUserPointer() public view returns (uint slot, uint offset) {\n        uint userSlot;\n        uint userOffset;\n        assembly {\n            userSlot := user.slot\n            userOffset := user.offset\n        }\n        return (userSlot, userOffset);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct Task {\n        uint duration;\n    }\n\n    Task public task;\n\n    constructor() public {\n        task.duration = 60;\n    }\n\n    function fetchTaskPointer() public view returns (uint slot, uint offset) {\n        uint taskSlot;\n        uint taskOffset;\n        assembly {\n            taskSlot := task.slot\n            taskOffset := task.offset\n        }\n        return (taskSlot, taskOffset);\n    }\n\n    function extraFunction() public pure returns (string memory) {\n        return \"extra\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct Asset {\n        uint value;\n    }\n\n    Asset public asset;\n\n    constructor() public {\n        asset.value = 1000;\n    }\n\n    function retrieveAssetPointer() public view returns (uint slot, uint offset) {\n        uint assetSlot;\n        uint assetOffset;\n        assembly {\n            assetSlot := asset.slot\n            assetOffset := asset.offset\n        }\n        return (assetSlot, assetOffset);\n    }\n\n    function anotherExtraFunction() public pure returns (string memory) {\n        return \"another extra\";\n    }\n}"
      }
    }
  },
  {
    "Changes45": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "If a struct or array contains a mapping, it can only be used in storage.\nPreviously, mapping members were silently skipped in memory, which\nis confusing and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct1 {\n    struct ExampleStruct {\n        uint256 value;\n        mapping(address => uint256) accounts;\n    }\n    \n    ExampleStruct[] public examples;\n\n    function createStruct(uint256 _value) public {\n        ExampleStruct memory newExample;\n        newExample.value = _value;\n        examples.push(newExample);\n    }\n\n    function setAccount(uint256 index, address user, uint256 balance) public {\n        examples[index].accounts[user] = balance;\n    }\n\n    function getAccountBalance(uint256 index, address user) public view returns (uint256) {\n        return examples[index].accounts[user];\n    }\n\n    function dummyFunc1() public pure returns (string memory) {\n        return \"Example1\";\n    }\n}",
          "error message": ":1:257: TypeError: Type struct MappingInStruct1.ExampleStruct is only valid in storage because it contains a (nested) mapping.\n ... t(uint256 _value) public {         ExampleStruct memory newExample;         newExample.value = _value ...\n                                        ^-----------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct2 {\n    struct DataStruct {\n        uint256 data;\n        mapping(address => uint256) userBalances;\n    }\n    \n    DataStruct[] public dataList;\n\n    function addData(uint256 _data) public {\n        DataStruct memory newData;\n        newData.data = _data;\n        dataList.push(newData);\n    }\n\n    function updateUserBalance(uint256 index, address user, uint256 amount) public {\n        dataList[index].userBalances[user] = amount;\n    }\n\n    function fetchBalance(uint256 index, address user) public view returns (uint256) {\n        return dataList[index].userBalances[user];\n    }\n}",
          "error message": ":1:248: TypeError: Type struct MappingInStruct2.DataStruct is only valid in storage because it contains a (nested) mapping.\n ... ta(uint256 _data) public {         DataStruct memory newData;         newData.data = _data;     ...\n                                        ^-----------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct3 {\n    struct CustomStruct {\n        uint256 number;\n        mapping(address => uint256) funds;\n    }\n    \n    CustomStruct[] public customData;\n\n    function insertData(uint256 _number) public {\n        CustomStruct memory newStruct;\n        newStruct.number = _number;\n        customData.push(newStruct);\n    }\n\n    function modifyFunds(uint256 index, address user, uint256 value) public {\n        customData[index].funds[user] = value;\n    }\n\n    function retrieveFunds(uint256 index, address user) public view returns (uint256) {\n        return customData[index].funds[user];\n    }\n\n    function dummyFunc2() public pure returns (uint256) {\n        return 100;\n    }\n\n    function dummyFunc3() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:254: TypeError: Type struct MappingInStruct3.CustomStruct is only valid in storage because it contains a (nested) mapping.\n ... (uint256 _number) public {         CustomStruct memory newStruct;         newStruct.number = _numbe ...\n                                        ^---------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct4 {\n    struct HolderStruct {\n        uint256 id;\n        mapping(address => uint256) tokens;\n    }\n    \n    HolderStruct[] public holders;\n\n    function newStruct(uint256 _id) public {\n        HolderStruct memory newHolder;\n        newHolder.id = _id;\n        holders.push(newHolder);\n    }\n\n    function setTokens(uint256 index, address user, uint256 quantity) public {\n        holders[index].tokens[user] = quantity;\n    }\n\n    function getTokens(uint256 index, address user) public view returns (uint256) {\n        return holders[index].tokens[user];\n    }\n\n    function dummyFunc4() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:243: TypeError: Type struct MappingInStruct4.HolderStruct is only valid in storage because it contains a (nested) mapping.\n ... ruct(uint256 _id) public {         HolderStruct memory newHolder;         newHolder.id = _id;       ...\n                                        ^---------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct5 {\n    struct ExampleData {\n        uint256 key;\n        mapping(address => uint256) values;\n    }\n    \n    ExampleData[] public dataCollection;\n\n    function addEntry(uint256 _key) public {\n        ExampleData memory entry;\n        entry.key = _key;\n        dataCollection.push(entry);\n    }\n\n    function setValue(uint256 index, address user, uint256 amount) public {\n        dataCollection[index].values[user] = amount;\n    }\n\n    function getValue(uint256 index, address user) public view returns (uint256) {\n        return dataCollection[index].values[user];\n    }\n\n    function anotherDummyFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
          "error message": ":1:249: TypeError: Type struct MappingInStruct5.ExampleData is only valid in storage because it contains a (nested) mapping.\n ... try(uint256 _key) public {         ExampleData memory entry;         entry.key = _key;         ...\n                                        ^----------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct6 {\n    struct ItemStruct {\n        uint256 id;\n        mapping(address => uint256) holdings;\n    }\n    \n    ItemStruct[] public items;\n\n    function createItem(uint256 _id) public {\n        ItemStruct memory newItem;\n        newItem.id = _id;\n        items.push(newItem);\n    }\n\n    function updateHoldings(uint256 index, address user, uint256 value) public {\n        items[index].holdings[user] = value;\n    }\n\n    function getHoldings(uint256 index, address user) public view returns (uint256) {\n        return items[index].holdings[user];\n    }\n\n    function dummyFunc5() public pure returns (string memory) {\n        return \"Dummy5\";\n    }\n\n    function dummyFunc6() public pure returns (uint256) {\n        return 123;\n    }\n}",
          "error message": ":1:240: TypeError: Type struct MappingInStruct6.ItemStruct is only valid in storage because it contains a (nested) mapping.\n ... Item(uint256 _id) public {         ItemStruct memory newItem;         newItem.id = _id;         ...\n                                        ^-----------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct7 {\n    struct AssetStruct {\n        uint256 assetId;\n        mapping(address => uint256) assetBalances;\n    }\n    \n    AssetStruct[] public assets;\n\n    function registerAsset(uint256 _assetId) public {\n        AssetStruct memory newAsset;\n        newAsset.assetId = _assetId;\n        assets.push(newAsset);\n    }\n\n    function assignAssetBalance(uint256 index, address user, uint256 amount) public {\n        assets[index].assetBalances[user] = amount;\n    }\n\n    function getAssetBalance(uint256 index, address user) public view returns (uint256) {\n        return assets[index].assetBalances[user];\n    }\n}",
          "error message": ":1:261: TypeError: Type struct MappingInStruct7.AssetStruct is only valid in storage because it contains a (nested) mapping.\n ... uint256 _assetId) public {         AssetStruct memory newAsset;         newAsset.assetId = _asset ...\n                                        ^-------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct8 {\n    struct RecordStruct {\n        uint256 id;\n        mapping(address => uint256) balances;\n    }\n    \n    RecordStruct[] public records;\n\n    function addRecord(uint256 _id) public {\n        RecordStruct memory newRecord;\n        newRecord.id = _id;\n        records.push(newRecord);\n    }\n\n    function changeBalance(uint256 index, address user, uint256 amount) public {\n        records[index].balances[user] = amount;\n    }\n\n    function viewBalance(uint256 index, address user) public view returns (uint256) {\n        return records[index].balances[user];\n    }\n\n    function dummyFunc7() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:245: TypeError: Type struct MappingInStruct8.RecordStruct is only valid in storage because it contains a (nested) mapping.\n ... cord(uint256 _id) public {         RecordStruct memory newRecord;         newRecord.id = _id;       ...\n                                        ^---------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct9 {\n    struct RegistryStruct {\n        uint256 identifier;\n        mapping(address => uint256) allocations;\n    }\n    \n    RegistryStruct[] public registries;\n\n    function insertRegistry(uint256 _identifier) public {\n        RegistryStruct memory newRegistry;\n        newRegistry.identifier = _identifier;\n        registries.push(newRegistry);\n    }\n\n    function setAllocation(uint256 index, address user, uint256 value) public {\n        registries[index].allocations[user] = value;\n    }\n\n    function getAllocation(uint256 index, address user) public view returns (uint256) {\n        return registries[index].allocations[user];\n    }\n\n    function yetAnotherDummyFunction() public pure returns (string memory) {\n        return \"dummy\";\n    }\n\n    function additionalFunc() public pure returns (string memory) {\n        return \"extra\";\n    }\n}",
          "error message": ":1:276: TypeError: Type struct MappingInStruct9.RegistryStruct is only valid in storage because it contains a (nested) mapping.\n ... t256 _identifier) public {         RegistryStruct memory newRegistry;         newRegistry.identifier =  ...\n                                        ^-------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct10 {\n    struct InfoStruct {\n        uint256 number;\n        mapping(address => uint256) userFunds;\n    }\n    \n    InfoStruct[] public infoList;\n\n    function addInfo(uint256 _number) public {\n        InfoStruct memory newInfo;\n        newInfo.number = _number;\n        infoList.push(newInfo);\n    }\n\n    function updateUserFunds(uint256 index, address user, uint256 amount) public {\n        infoList[index].userFunds[user] = amount;\n    }\n\n    function retrieveUserFunds(uint256 index, address user) public view returns (uint256) {\n        return infoList[index].userFunds[user];\n    }\n}",
          "error message": ":1:250: TypeError: Type struct MappingInStruct10.InfoStruct is only valid in storage because it contains a (nested) mapping.\n ... (uint256 _number) public {         InfoStruct memory newInfo;         newInfo.number = _number; ...\n                                        ^-----------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct1 {\n    struct ExampleStruct {\n        uint256 value;\n        mapping(address => uint256) accounts;\n    }\n    \n    ExampleStruct[] public examples;\n\n    function createStruct(uint256 _value) public {\n        ExampleStruct storage newExample = examples.push();\n        newExample.value = _value;\n    }\n\n    function setAccount(uint256 index, address user, uint256 balance) public {\n        examples[index].accounts[user] = balance;\n    }\n\n    function getAccountBalance(uint256 index, address user) public view returns (uint256) {\n        return examples[index].accounts[user];\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct2 {\n    struct DataStruct {\n        uint256 data;\n        mapping(address => uint256) userBalances;\n    }\n    \n    DataStruct[] public dataList;\n\n    function addData(uint256 _data) public {\n        DataStruct storage newData = dataList.push();\n        newData.data = _data;\n    }\n\n    function updateUserBalance(uint256 index, address user, uint256 amount) public {\n        dataList[index].userBalances[user] = amount;\n    }\n\n    function fetchBalance(uint256 index, address user) public view returns (uint256) {\n        return dataList[index].userBalances[user];\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct3 {\n    struct CustomStruct {\n        uint256 number;\n        mapping(address => uint256) funds;\n    }\n    \n    CustomStruct[] public customData;\n\n    function insertData(uint256 _number) public {\n        CustomStruct storage newStruct = customData.push();\n        newStruct.number = _number;\n    }\n\n    function modifyFunds(uint256 index, address user, uint256 value) public {\n        customData[index].funds[user] = value;\n    }\n\n    function retrieveFunds(uint256 index, address user) public view returns (uint256) {\n        return customData[index].funds[user];\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct4 {\n    struct HolderStruct {\n        uint256 id;\n        mapping(address => uint256) tokens;\n    }\n    \n    HolderStruct[] public holders;\n\n    function newStruct(uint256 _id) public {\n        HolderStruct storage newHolder = holders.push();\n        newHolder.id = _id;\n    }\n\n    function setTokens(uint256 index, address user, uint256 quantity) public {\n        holders[index].tokens[user] = quantity;\n    }\n\n    function getTokens(uint256 index, address user) public view returns (uint256) {\n        return holders[index].tokens[user];\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct5 {\n    struct ExampleData {\n        uint256 key;\n        mapping(address => uint256) values;\n    }\n    \n    ExampleData[] public dataCollection;\n\n    function addEntry(uint256 _key) public {\n        ExampleData storage entry = dataCollection.push();\n        entry.key = _key;\n    }\n\n    function setValue(uint256 index, address user, uint256 amount) public {\n        dataCollection[index].values[user] = amount;\n    }\n\n    function getValue(uint256 index, address user) public view returns (uint256) {\n        return dataCollection[index].values[user];\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct6 {\n    struct ItemStruct {\n        uint256 id;\n        mapping(address => uint256) holdings;\n    }\n    \n    ItemStruct[] public items;\n\n    function createItem(uint256 _id) public {\n        ItemStruct storage newItem = items.push();\n        newItem.id = _id;\n    }\n\n    function updateHoldings(uint256 index, address user, uint256 value) public {\n        items[index].holdings[user] = value;\n    }\n\n    function getHoldings(uint256 index, address user) public view returns (uint256) {\n        return items[index].holdings[user];\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct7 {\n    struct AssetStruct {\n        uint256 assetId;\n        mapping(address => uint256) assetBalances;\n    }\n    \n    AssetStruct[] public assets;\n\n    function registerAsset(uint256 _assetId) public {\n        AssetStruct storage newAsset = assets.push();\n        newAsset.assetId = _assetId;\n    }\n\n    function assignAssetBalance(uint256 index, address user, uint256 amount) public {\n        assets[index].assetBalances[user] = amount;\n    }\n\n    function getAssetBalance(uint256 index, address user) public view returns (uint256) {\n        return assets[index].assetBalances[user];\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct8 {\n    struct RecordStruct {\n        uint256 id;\n        mapping(address => uint256) balances;\n    }\n    \n    RecordStruct[] public records;\n\n    function addRecord(uint256 _id) public {\n        RecordStruct storage newRecord = records.push();\n        newRecord.id = _id;\n    }\n\n    function changeBalance(uint256 index, address user, uint256 amount) public {\n        records[index].balances[user] = amount;\n    }\n\n    function viewBalance(uint256 index, address user) public view returns (uint256) {\n        return records[index].balances[user];\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct9 {\n    struct RegistryStruct {\n        uint256 identifier;\n        mapping(address => uint256) allocations;\n    }\n    \n    RegistryStruct[] public registries;\n\n    function insertRegistry(uint256 _identifier) public {\n        RegistryStruct storage newRegistry = registries.push();\n        newRegistry.identifier = _identifier;\n    }\n\n    function setAllocation(uint256 index, address user, uint256 value) public {\n        registries[index].allocations[user] = value;\n    }\n\n    function getAllocation(uint256 index, address user) public view returns (uint256) {\n        return registries[index].allocations[user];\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract MappingInStruct10 {\n    struct InfoStruct {\n        uint256 number;\n        mapping(address => uint256) userFunds;\n    }\n    \n    InfoStruct[] public infoList;\n\n    function addInfo(uint256 _number) public {\n        InfoStruct storage newInfo = infoList.push();\n        newInfo.number = _number;\n    }\n\n    function updateUserFunds(uint256 index, address user, uint256 amount) public {\n        infoList[index].userFunds[user] = amount;\n    }\n\n    function retrieveUserFunds(uint256 index, address user) public view returns (uint256) {\n        return infoList[index].userFunds[user];\n    }\n}"
      }
    }
  },
  {
    "Changes46": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Assignments to structs or arrays in storage does not work if they contain\nmappings.\nPreviously, mappings were silently skipped during the copy operation, which\nis misleading and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Record {\n        mapping(address => uint) entries;\n        uint count;\n    }\n\n    Record record1;\n    Record record2;\n\n    function addEntry(address _addr, uint _value) public {\n        record1.entries[_addr] = _value;\n        record1.count += _value;\n    }\n\n    function copyRecord() public {\n        record2 = record1;\n    }\n\n    function getCount() public view returns (uint) {\n        return record2.count;\n    }\n}",
          "error message": ":1:358: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... tion copyRecord() public {         record2 = record1;     }      function get ...\n                                        ^-----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Container {\n        mapping(address => bool) flags;\n        uint total;\n    }\n\n    Container container1;\n    Container container2;\n\n    function setFlag(address _addr, bool _flag) public {\n        container1.flags[_addr] = _flag;\n        container1.total += _flag ? 1 : 0;\n    }\n\n    function duplicateContainer() public {\n        container2 = container1;\n    }\n\n    function getTotal() public view returns (uint) {\n        return container2.total;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:387: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... licateContainer() public {         container2 = container1;     }      function  ...\n                                        ^--------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Ledger {\n        mapping(address => uint) amounts;\n        uint sum;\n    }\n\n    Ledger ledger1;\n    Ledger ledger2;\n\n    function addAmount(address _addr, uint _amount) public {\n        ledger1.amounts[_addr] = _amount;\n        ledger1.sum += _amount;\n    }\n\n    function transferLedger() public {\n        ledger2 = ledger1;\n    }\n\n    function getSum() public view returns (uint) {\n        return ledger2.sum;\n    }\n\n    function dummyFunc() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
          "error message": ":1:362: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ...  transferLedger() public {         ledger2 = ledger1;     }      function get ...\n                                        ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Storage {\n        mapping(address => uint) balances;\n        uint balanceTotal;\n    }\n\n    Storage storage1;\n    Storage storage2;\n\n    function updateBalance(address _addr, uint _balance) public {\n        storage1.balances[_addr] = _balance;\n        storage1.balanceTotal += _balance;\n    }\n\n    function cloneStorage() public {\n        storage2 = storage1;\n    }\n\n    function getBalanceTotal() public view returns (uint) {\n        return storage2.balanceTotal;\n    }\n}",
          "error message": ":1:394: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... on cloneStorage() public {         storage2 = storage1;     }      function ge ...\n                                        ^------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Registry {\n        mapping(address => bool) active;\n        uint count;\n    }\n\n    Registry registry1;\n    Registry registry2;\n\n    function activate(address _addr) public {\n        registry1.active[_addr] = true;\n        registry1.count++;\n    }\n\n    function replicateRegistry() public {\n        registry2 = registry1;\n    }\n\n    function getCount() public view returns (uint) {\n        return registry2.count;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:354: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... plicateRegistry() public {         registry2 = registry1;     }      function g ...\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Book {\n        mapping(address => uint) pages;\n        uint pageCount;\n    }\n\n    Book book1;\n    Book book2;\n\n    function addPage(address _addr, uint _page) public {\n        book1.pages[_addr] = _page;\n        book1.pageCount += _page;\n    }\n\n    function copyBook() public {\n        book2 = book1;\n    }\n\n    function getPageCount() public view returns (uint) {\n        return book2.pageCount;\n    }\n}",
          "error message": ":1:342: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... nction copyBook() public {         book2 = book1;     }      function getPa ...\n                                        ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Profile {\n        mapping(address => uint) points;\n        uint totalPoints;\n    }\n\n    Profile profile1;\n    Profile profile2;\n\n    function addPoints(address _addr, uint _points) public {\n        profile1.points[_addr] = _points;\n        profile1.totalPoints += _points;\n    }\n\n    function duplicateProfile() public {\n        profile2 = profile1;\n    }\n\n    function getTotalPoints() public view returns (uint) {\n        return profile2.totalPoints;\n    }\n\n    function placeholderFunction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:385: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... uplicateProfile() public {         profile2 = profile1;     }      function ge ...\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct Account {\n        mapping(address => uint) credits;\n        uint creditTotal;\n    }\n\n    Account account1;\n    Account account2;\n\n    function addCredit(address _addr, uint _credit) public {\n        account1.credits[_addr] = _credit;\n        account1.creditTotal += _credit;\n    }\n\n    function mirrorAccount() public {\n        account2 = account1;\n    }\n\n    function getCreditTotal() public view returns (uint) {\n        return account2.creditTotal;\n    }\n}",
          "error message": ":1:384: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... n mirrorAccount() public {         account2 = account1;     }      function ge ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct Directory {\n        mapping(address => uint) numbers;\n        uint numberCount;\n    }\n\n    Directory directory1;\n    Directory directory2;\n\n    function setNumber(address _addr, uint _number) public {\n        directory1.numbers[_addr] = _number;\n        directory1.numberCount += _number;\n    }\n\n    function cloneDirectory() public {\n        directory2 = directory1;\n    }\n\n    function getNumberCount() public view returns (uint) {\n        return directory2.numberCount;\n    }\n}",
          "error message": ":1:399: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ...  cloneDirectory() public {         directory2 = directory1;     }      function  ...\n                                        ^--------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct Archive {\n        mapping(address => uint) records;\n        uint recordCount;\n    }\n\n    Archive archive1;\n    Archive archive2;\n\n    function addRecord(address _addr, uint _record) public {\n        archive1.records[_addr] = _record;\n        archive1.recordCount += _record;\n    }\n\n    function copyArchive() public {\n        archive2 = archive1;\n    }\n\n    function getRecordCount() public view returns (uint) {\n        return archive2.recordCount;\n    }\n\n    function additionalFunction() public pure returns (string memory) {\n        return \"Extra\";\n    }\n\n    function anotherFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": ":1:383: TypeError: Types in storage containing (nested) mappings cannot be assigned to.\n ... ion copyArchive() public {         archive2 = archive1;     }      function ge ...\n                                        ^------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract Example1 {\n    struct Record {\n        mapping(address => uint) entries;\n        uint count;\n    }\n\n    Record record1;\n    Record record2;\n\n    function addEntry(address _addr, uint _value) public {\n        record1.entries[_addr] = _value;\n        record1.count += _value;\n    }\n\n    function copyRecord() public {\n        record2.count = record1.count;\n    }\n\n    function getCount() public view returns (uint) {\n        return record2.count;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract Example2 {\n    struct Container {\n        mapping(address => bool) flags;\n        uint total;\n    }\n\n    Container container1;\n    Container container2;\n\n    function setFlag(address _addr, bool _flag) public {\n        container1.flags[_addr] = _flag;\n        container1.total += _flag ? 1 : 0;\n    }\n\n    function duplicateContainer() public {\n        container2.total = container1.total;\n    }\n\n    function getTotal() public view returns (uint) {\n        return container2.total;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract Example3 {\n    struct Ledger {\n        mapping(address => uint) amounts;\n        uint sum;\n    }\n\n    Ledger ledger1;\n    Ledger ledger2;\n\n    function addAmount(address _addr, uint _amount) public {\n        ledger1.amounts[_addr] = _amount;\n        ledger1.sum += _amount;\n    }\n\n    function transferLedger() public {\n        ledger2.sum = ledger1.sum;\n    }\n\n    function getSum() public view returns (uint) {\n        return ledger2.sum;\n    }\n\n    function dummyFunc() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract Example4 {\n    struct Storage {\n        mapping(address => uint) balances;\n        uint balanceTotal;\n    }\n\n    Storage storage1;\n    Storage storage2;\n\n    function updateBalance(address _addr, uint _balance) public {\n        storage1.balances[_addr] = _balance;\n        storage1.balanceTotal += _balance;\n    }\n\n    function cloneStorage() public {\n        storage2.balanceTotal = storage1.balanceTotal;\n    }\n\n    function getBalanceTotal() public view returns (uint) {\n        return storage2.balanceTotal;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract Example5 {\n    struct Registry {\n        mapping(address => bool) active;\n        uint count;\n    }\n\n    Registry registry1;\n    Registry registry2;\n\n    function activate(address _addr) public {\n        registry1.active[_addr] = true;\n        registry1.count++;\n    }\n\n    function replicateRegistry() public {\n        registry2.count = registry1.count;\n    }\n\n    function getCount() public view returns (uint) {\n        return registry2.count;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract Example6 {\n    struct Book {\n        mapping(address => uint) pages;\n        uint pageCount;\n    }\n\n    Book book1;\n    Book book2;\n\n    function addPage(address _addr, uint _page) public {\n        book1.pages[_addr] = _page;\n        book1.pageCount += _page;\n    }\n\n    function copyBook() public {\n        book2.pageCount = book1.pageCount;\n    }\n\n    function getPageCount() public view returns (uint) {\n        return book2.pageCount;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract Example7 {\n    struct Profile {\n        mapping(address => uint) points;\n        uint totalPoints;\n    }\n\n    Profile profile1;\n    Profile profile2;\n\n    function addPoints(address _addr, uint _points) public {\n        profile1.points[_addr] = _points;\n        profile1.totalPoints += _points;\n    }\n\n    function duplicateProfile() public {\n        profile2.totalPoints = profile1.totalPoints;\n    }\n\n    function getTotalPoints() public view returns (uint) {\n        return profile2.totalPoints;\n    }\n\n    function placeholderFunction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract Example8 {\n    struct Account {\n        mapping(address => uint) credits;\n        uint creditTotal;\n    }\n\n    Account account1;\n    Account account2;\n\n    function addCredit(address _addr, uint _credit) public {\n        account1.credits[_addr] = _credit;\n        account1.creditTotal += _credit;\n    }\n\n    function mirrorAccount() public {\n        account2.creditTotal = account1.creditTotal;\n    }\n\n    function getCreditTotal() public view returns (uint) {\n        return account2.creditTotal;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract Example9 {\n    struct Directory {\n        mapping(address => uint) numbers;\n        uint numberCount;\n    }\n\n    Directory directory1;\n    Directory directory2;\n\n    function setNumber(address _addr, uint _number) public {\n        directory1.numbers[_addr] = _number;\n        directory1.numberCount += _number;\n    }\n\n    function cloneDirectory() public {\n        directory2.numberCount = directory1.numberCount;\n    }\n\n    function getNumberCount() public view returns (uint) {\n        return directory2.numberCount;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract Example10 {\n    struct Archive {\n        mapping(address => uint) records;\n        uint recordCount;\n    }\n\n    Archive archive1;\n    Archive archive2;\n\n    function addRecord(address _addr, uint _record) public {\n        archive1.records[_addr] = _record;\n        archive1.recordCount += _record;\n    }\n\n    function copyArchive() public {\n        archive2.recordCount = archive1.recordCount;\n    }\n\n    function getRecordCount() public view returns (uint) {\n        return archive2.recordCount;\n    }\n\n    function additionalFunction() public pure returns (string memory) {\n        return \"Extra\";\n    }\n\n    function anotherFunction() public pure returns (uint) {\n        return 100;\n    }\n}"
      }
    }
  },
  {
    "Changes47": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Multiple events with the same name and parameter types in the same\ninheritance hierarchy are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract1 {\n    event LogEvent1(uint256 indexed id1);\n\n    function triggerEvent1(uint256 _id1) public {\n        emit LogEvent1(_id1);\n    }\n}\n\ncontract DerivedContract1 is BaseContract1 {\n    event LogEvent1(uint256 indexed id1);\n\n    function triggerDerivedEvent1(uint256 _id1) public {\n        emit LogEvent1(_id1);\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"This is unrelated.\";\n    }\n}",
          "error message": ":1:231: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract1 is BaseContract1 {     event LogEvent1(uint256 indexed id1);      function triggerDerivedEvent1 ...\n                                        ^-----------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract1 {     event LogEvent1(uint256 indexed id1);      function triggerEvent1(uint25 ...\n                                        ^-----------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract2 {\n    event ActionEvent(uint256 indexed actionId);\n\n    function performAction(uint256 _actionId) public {\n        emit ActionEvent(_actionId);\n    }\n}\n\ncontract DerivedContract2 is BaseContract2 {\n    event ActionEvent(uint256 indexed actionId);\n\n    function executeAction(uint256 _actionId) public {\n        emit ActionEvent(_actionId);\n    }\n\n    function additionalFunction1() public pure returns (uint256) {\n        return 42;\n    }\n\n    function additionalFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:250: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract2 is BaseContract2 {     event ActionEvent(uint256 indexed actionId);      function executeAction(uint25 ...\n                                        ^------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract2 {     event ActionEvent(uint256 indexed actionId);      function performAction(uint25 ...\n                                        ^------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract3 {\n    event ValueChanged(uint256 indexed newValue);\n\n    function changeValue(uint256 _newValue) public {\n        emit ValueChanged(_newValue);\n    }\n}\n\ncontract DerivedContract3 is BaseContract3 {\n    event ValueChanged(uint256 indexed newValue);\n\n    function updateValue(uint256 _newValue) public {\n        emit ValueChanged(_newValue);\n    }\n}",
          "error message": ":1:250: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract3 is BaseContract3 {     event ValueChanged(uint256 indexed newValue);      function updateValue(uint256  ...\n                                        ^-------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract3 {     event ValueChanged(uint256 indexed newValue);      function changeValue(uint256  ...\n                                        ^-------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract4 {\n    event DataEvent(uint256 indexed dataId);\n\n    function storeData(uint256 _dataId) public {\n        emit DataEvent(_dataId);\n    }\n\n    function helperFunction1() public pure returns (string memory) {\n        return \"Helper Function\";\n    }\n}\n\ncontract DerivedContract4 is BaseContract4 {\n    event DataEvent(uint256 indexed dataId);\n\n    function saveData(uint256 _dataId) public {\n        emit DataEvent(_dataId);\n    }\n}",
          "error message": ":1:346: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract4 is BaseContract4 {     event DataEvent(uint256 indexed dataId);      function saveData(uint256 _da ...\n                                        ^--------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract4 {     event DataEvent(uint256 indexed dataId);      function storeData(uint256 _d ...\n                                        ^--------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract5 {\n    event TransferEvent(uint256 indexed transferId);\n\n    function initiateTransfer(uint256 _transferId) public {\n        emit TransferEvent(_transferId);\n    }\n}\n\ncontract DerivedContract5 is BaseContract5 {\n    event TransferEvent(uint256 indexed transferId);\n\n    function completeTransfer(uint256 _transferId) public {\n        emit TransferEvent(_transferId);\n    }\n\n    function unrelatedFunction2() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Unrelated\"));\n    }\n}",
          "error message": ":1:263: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract5 is BaseContract5 {     event TransferEvent(uint256 indexed transferId);      function completeTransfer(uin ...\n                                        ^----------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract5 {     event TransferEvent(uint256 indexed transferId);      function initiateTransfer(uin ...\n                                        ^----------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract6 {\n    event LogMessage(uint256 indexed messageId);\n\n    function logMessage(uint256 _messageId) public {\n        emit LogMessage(_messageId);\n    }\n}\n\ncontract DerivedContract6 is BaseContract6 {\n    event LogMessage(uint256 indexed messageId);\n\n    function recordMessage(uint256 _messageId) public {\n        emit LogMessage(_messageId);\n    }\n\n    function anotherUnrelatedFunction() public pure returns (int256) {\n        return -1;\n    }\n}",
          "error message": ":1:248: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract6 is BaseContract6 {     event LogMessage(uint256 indexed messageId);      function recordMessage(uint25 ...\n                                        ^------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract6 {     event LogMessage(uint256 indexed messageId);      function logMessage(uint256 _ ...\n                                        ^------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract7 {\n    event StatusEvent(uint256 indexed statusId);\n\n    function changeStatus(uint256 _statusId) public {\n        emit StatusEvent(_statusId);\n    }\n}\n\ncontract DerivedContract7 is BaseContract7 {\n    event StatusEvent(uint256 indexed statusId);\n\n    function updateStatus(uint256 _statusId) public {\n        emit StatusEvent(_statusId);\n    }\n\n    function yetAnotherFunction() public pure returns (address) {\n        return address(this);\n    }\n}",
          "error message": ":1:249: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract7 is BaseContract7 {     event StatusEvent(uint256 indexed statusId);      function updateStatus(uint256 ...\n                                        ^------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract7 {     event StatusEvent(uint256 indexed statusId);      function changeStatus(uint256 ...\n                                        ^------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract8 {\n    event ProcessEvent(uint256 indexed processId);\n\n    function startProcess(uint256 _processId) public {\n        emit ProcessEvent(_processId);\n    }\n}\n\ncontract DerivedContract8 is BaseContract8 {\n    event ProcessEvent(uint256 indexed processId);\n\n    function executeProcess(uint256 _processId) public {\n        emit ProcessEvent(_processId);\n    }\n\n    function noRelatedFunction() public pure returns (string memory) {\n        return \"No relation\";\n    }\n}",
          "error message": ":1:254: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract8 is BaseContract8 {     event ProcessEvent(uint256 indexed processId);      function executeProcess(uint2 ...\n                                        ^--------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract8 {     event ProcessEvent(uint256 indexed processId);      function startProcess(uint256 ...\n                                        ^--------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract9 {\n    event NotifyEvent(uint256 indexed notifyId);\n\n    function notify(uint256 _notifyId) public {\n        emit NotifyEvent(_notifyId);\n    }\n\n    function unrelatedHelper() public pure returns (bool) {\n        return false;\n    }\n}\n\ncontract DerivedContract9 is BaseContract9 {\n    event NotifyEvent(uint256 indexed notifyId);\n\n    function alert(uint256 _notifyId) public {\n        emit NotifyEvent(_notifyId);\n    }\n}",
          "error message": ":1:332: DeclarationError: Event with same name and parameter types defined twice.\n ... edContract9 is BaseContract9 {     event NotifyEvent(uint256 indexed notifyId);      function alert(uint256 _notif ...\n                                        ^------------------------------------------^\n:1:54: Other declaration is here:\n ... 7.0;  contract BaseContract9 {     event NotifyEvent(uint256 indexed notifyId);      function notify(uint256 _noti ...\n                                        ^------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract10 {\n    event SignalEvent(uint256 indexed signalId);\n\n    function sendSignal(uint256 _signalId) public {\n        emit SignalEvent(_signalId);\n    }\n\n    function unrelatedComputation() public pure returns (uint256) {\n        return 12345;\n    }\n}\n\ncontract DerivedContract10 is BaseContract10 {\n    event SignalEvent(uint256 indexed signalId);\n\n    function transmitSignal(uint256 _signalId) public {\n        emit SignalEvent(_signalId);\n    }\n}",
          "error message": ":1:347: DeclarationError: Event with same name and parameter types defined twice.\n ... Contract10 is BaseContract10 {     event SignalEvent(uint256 indexed signalId);      function transmitSignal(uint2 ...\n                                        ^------------------------------------------^\n:1:55: Other declaration is here:\n ... .0;  contract BaseContract10 {     event SignalEvent(uint256 indexed signalId);      function sendSignal(uint256 _ ...\n                                        ^------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract BaseContract1 {\n    event LogEvent1(uint256 indexed id1);\n\n    function triggerEvent1(uint256 _id1) public {\n        emit LogEvent1(_id1);\n    }\n}\n\ncontract DerivedContract1 is BaseContract1 {\n    function triggerDerivedEvent1(uint256 _id1) public {\n        emit LogEvent1(_id1);\n    }\n\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"This is unrelated.\";\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract BaseContract2 {\n    event ActionEvent(uint256 indexed actionId);\n\n    function performAction(uint256 _actionId) public {\n        emit ActionEvent(_actionId);\n    }\n}\n\ncontract DerivedContract2 is BaseContract2 {\n    function executeAction(uint256 _actionId) public {\n        emit ActionEvent(_actionId);\n    }\n\n    function additionalFunction1() public pure returns (uint256) {\n        return 42;\n    }\n\n    function additionalFunction2() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract BaseContract3 {\n    event ValueChanged(uint256 indexed newValue);\n\n    function changeValue(uint256 _newValue) public {\n        emit ValueChanged(_newValue);\n    }\n}\n\ncontract DerivedContract3 is BaseContract3 {\n    function updateValue(uint256 _newValue) public {\n        emit ValueChanged(_newValue);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract BaseContract4 {\n    event DataEvent(uint256 indexed dataId);\n\n    function storeData(uint256 _dataId) public {\n        emit DataEvent(_dataId);\n    }\n\n    function helperFunction1() public pure returns (string memory) {\n        return \"Helper Function\";\n    }\n}\n\ncontract DerivedContract4 is BaseContract4 {\n    function saveData(uint256 _dataId) public {\n        emit DataEvent(_dataId);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract BaseContract5 {\n    event TransferEvent(uint256 indexed transferId);\n\n    function initiateTransfer(uint256 _transferId) public {\n        emit TransferEvent(_transferId);\n    }\n}\n\ncontract DerivedContract5 is BaseContract5 {\n    function completeTransfer(uint256 _transferId) public {\n        emit TransferEvent(_transferId);\n    }\n\n    function unrelatedFunction2() public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"Unrelated\"));\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract BaseContract6 {\n    event LogMessage(uint256 indexed messageId);\n\n    function logMessage(uint256 _messageId) public {\n        emit LogMessage(_messageId);\n    }\n}\n\ncontract DerivedContract6 is BaseContract6 {\n    function recordMessage(uint256 _messageId) public {\n        emit LogMessage(_messageId);\n    }\n\n    function anotherUnrelatedFunction() public pure returns (int256) {\n        return -1;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract BaseContract7 {\n    event StatusEvent(uint256 indexed statusId);\n\n    function changeStatus(uint256 _statusId) public {\n        emit StatusEvent(_statusId);\n    }\n}\n\ncontract DerivedContract7 is BaseContract7 {\n    function updateStatus(uint256 _statusId) public {\n        emit StatusEvent(_statusId);\n    }\n\n    function yetAnotherFunction() public pure returns (address) {\n        return address(this);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract BaseContract8 {\n    event ProcessEvent(uint256 indexed processId);\n\n    function startProcess(uint256 _processId) public {\n        emit ProcessEvent(_processId);\n    }\n}\n\ncontract DerivedContract8 is BaseContract8 {\n    function executeProcess(uint256 _processId) public {\n        emit ProcessEvent(_processId);\n    }\n\n    function noRelatedFunction() public pure returns (string memory) {\n        return \"No relation\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract BaseContract9 {\n    event NotifyEvent(uint256 indexed notifyId);\n\n    function notify(uint256 _notifyId) public {\n        emit NotifyEvent(_notifyId);\n    }\n\n    function unrelatedHelper() public pure returns (bool) {\n        return false;\n    }\n}\n\ncontract DerivedContract9 is BaseContract9 {\n    function alert(uint256 _notifyId) public {\n        emit NotifyEvent(_notifyId);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract BaseContract10 {\n    event SignalEvent(uint256 indexed signalId);\n\n    function sendSignal(uint256 _signalId) public {\n        emit SignalEvent(_signalId);\n    }\n\n    function unrelatedComputation() public pure returns (uint256) {\n        return 12345;\n    }\n}\n\ncontract DerivedContract10 is BaseContract10 {\n    function transmitSignal(uint256 _signalId) public {\n        emit SignalEvent(_signalId);\n    }\n}"
      }
    }
  },
  {
    "Changes48": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "<code>using A for B</code> only affects the contract it is mentioned in.\nPreviously, the effect was inherited. Now, you have to repeat the <code>using</code>\nstatement in all derived contracts that make use of the feature.Repeat the <code>using A for B</code> statements in all derived contracts if needed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary MathLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"MathLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract Parent {\n    using MathLib for uint;\n\n    uint public parentValue;\n\n    function setParentValue(uint _value) public {\n        parentValue = _value;\n    }\n\n    function increaseParentValue(uint _value) public {\n        parentValue = parentValue.add(_value);\n    }\n}\n\ncontract Child is Parent {\n    uint public childValue;\n\n    function setChildValue(uint _value) public {\n        childValue = _value;\n    }\n\n    function increaseChildValue(uint _value) public {\n        childValue = childValue.add(_value);\n    }\n}",
          "error message": ":1:704: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         childValue = childValue.add(_value);     } }\n                                        ^------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Utils {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"Utils: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Main {\n    using Utils for uint;\n\n    uint public mainValue;\n\n    function setMainValue(uint _value) public {\n        mainValue = _value;\n    }\n\n    function multiplyMainValue(uint _value) public {\n        mainValue = mainValue.multiply(_value);\n    }\n}\n\ncontract Sub is Main {\n    uint public subValue;\n\n    function setSubValue(uint _value) public {\n        subValue = _value;\n    }\n\n    function multiplySubValue(uint _value) public {\n        subValue = subValue.multiply(_value);\n    }\n}",
          "error message": ":1:690: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ... value) public {         subValue = subValue.multiply(_value);     } }\n                                        ^---------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Arithmetic {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Arithmetic: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract BaseContract {\n    using Arithmetic for uint;\n\n    uint public baseNum;\n\n    function setBaseNum(uint _num) public {\n        baseNum = _num;\n    }\n\n    function subtractFromBase(uint _num) public {\n        baseNum = baseNum.subtract(_num);\n    }\n}\n\ncontract DerivedContract is BaseContract {\n    uint public derivedNum;\n\n    function setDerivedNum(uint _num) public {\n        derivedNum = _num;\n    }\n\n    function subtractFromDerived(uint _num) public {\n        derivedNum = derivedNum.subtract(_num);\n    }\n}",
          "error message": ":1:692: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ... num) public {         derivedNum = derivedNum.subtract(_num);     } }\n                                        ^-----------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"Lib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Core {\n    using Lib for uint;\n\n    uint public coreValue;\n\n    function setCoreValue(uint _value) public {\n        coreValue = _value;\n    }\n\n    function divideCoreValue(uint _value) public {\n        coreValue = coreValue.divide(_value);\n    }\n}\n\ncontract Extended is Core {\n    uint public extendedValue;\n\n    function setExtendedValue(uint _value) public {\n        extendedValue = _value;\n    }\n\n    function divideExtendedValue(uint _value) public {\n        extendedValue = extendedValue.divide(_value);\n    }\n}",
          "error message": ":1:674: TypeError: Member \"divide\" not found or not visible after argument-dependent lookup in uint256.\n ... ) public {         extendedValue = extendedValue.divide(_value);     } }\n                                        ^------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Helper {\n    function mod(uint a, uint b) internal pure returns (uint) {\n        require(b != 0, \"Helper: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract Primary {\n    using Helper for uint;\n\n    uint public primaryValue;\n\n    function setPrimaryValue(uint _value) public {\n        primaryValue = _value;\n    }\n\n    function modPrimaryValue(uint _value) public {\n        primaryValue = primaryValue.mod(_value);\n    }\n}\n\ncontract Secondary is Primary {\n    uint public secondaryValue;\n\n    function setSecondaryValue(uint _value) public {\n        secondaryValue = _value;\n    }\n\n    function modSecondaryValue(uint _value) public {\n        secondaryValue = secondaryValue.mod(_value);\n    }\n}",
          "error message": ":1:700: TypeError: Member \"mod\" not found or not visible after argument-dependent lookup in uint256.\n ...  public {         secondaryValue = secondaryValue.mod(_value);     } }\n                                        ^----------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Calc {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"Calc: addition overflow\");\n        return c;\n    }\n}\n\ncontract Alpha {\n    using Calc for uint;\n\n    uint public alphaValue;\n\n    function setAlphaValue(uint _value) public {\n        alphaValue = _value;\n    }\n\n    function addAlphaValue(uint _value) public {\n        alphaValue = alphaValue.add(_value);\n    }\n}\n\ncontract Beta is Alpha {\n    uint public betaValue;\n\n    function setBetaValue(uint _value) public {\n        betaValue = _value;\n    }\n\n    function addBetaValue(uint _value) public {\n        betaValue = betaValue.add(_value);\n    }\n}",
          "error message": ":1:671: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         betaValue = betaValue.add(_value);     } }\n                                        ^-----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary MathUtil {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"MathUtil: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract First {\n    using MathUtil for uint;\n\n    uint public firstValue;\n\n    function setFirstValue(uint _value) public {\n        firstValue = _value;\n    }\n\n    function subtractFirstValue(uint _value) public {\n        firstValue = firstValue.subtract(_value);\n    }\n}\n\ncontract Second is First {\n    uint public secondValue;\n\n    function setSecondValue(uint _value) public {\n        secondValue = _value;\n    }\n\n    function subtractSecondValue(uint _value) public {\n        secondValue = secondValue.subtract(_value);\n    }\n}",
          "error message": ":1:698: TypeError: Member \"subtract\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         secondValue = secondValue.subtract(_value);     } }\n                                        ^------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary MyLib {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"MyLib: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Initial {\n    using MyLib for uint;\n\n    uint public initialValue;\n\n    function setInitialValue(uint _value) public {\n        initialValue = _value;\n    }\n\n    function multiplyInitialValue(uint _value) public {\n        initialValue = initialValue.multiply(_value);\n    }\n}\n\ncontract Final is Initial {\n    uint public finalValue;\n\n    function setFinalValue(uint _value) public {\n        finalValue = _value;\n    }\n\n    function multiplyFinalValue(uint _value) public {\n        finalValue = finalValue.multiply(_value);\n    }\n}",
          "error message": ":1:726: TypeError: Member \"multiply\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         finalValue = finalValue.multiply(_value);     } }\n                                        ^-----------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary UtilLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"UtilLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Root {\n    using UtilLib for uint;\n\n    uint public rootValue;\n\n    function setRootValue(uint _value) public {\n        rootValue = _value;\n    }\n\n    function divideRootValue(uint _value) public {\n        rootValue = rootValue.divide(_value);\n    }\n}\n\ncontract Branch is Root {\n    uint public branchValue;\n\n    function setBranchValue(uint _value) public {\n        branchValue = _value;\n    }\n\n    function divideBranchValue(uint _value) public {\n        branchValue = branchValue.divide(_value);\n    }\n}",
          "error message": ":1:674: TypeError: Member \"divide\" not found or not visible after argument-dependent lookup in uint256.\n ... ue) public {         branchValue = branchValue.divide(_value);     } }\n                                        ^----------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary ExtraMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ExtraMath: addition overflow\");\n        return c;\n    }\n}\n\ncontract Super {\n    using ExtraMath for uint;\n\n    uint public superValue;\n\n    function setSuperValue(uint _value) public {\n        superValue = _value;\n    }\n\n    function addSuperValue(uint _value) public {\n        superValue = superValue.add(_value);\n    }\n}\n\ncontract Ultra is Super {\n    uint public ultraValue;\n\n    function setUltraValue(uint _value) public {\n        ultraValue = _value;\n    }\n\n    function addUltraValue(uint _value) public {\n        ultraValue = ultraValue.add(_value);\n    }\n}",
          "error message": ":1:692: TypeError: Member \"add\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         ultraValue = ultraValue.add(_value);     } }\n                                        ^------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary MathLib {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"MathLib: addition overflow\");\n        return c;\n    }\n}\n\ncontract Parent {\n    using MathLib for uint;\n\n    uint public parentValue;\n\n    function setParentValue(uint _value) public {\n        parentValue = _value;\n    }\n\n    function increaseParentValue(uint _value) public {\n        parentValue = parentValue.add(_value);\n    }\n}\n\ncontract Child is Parent {\n    using MathLib for uint;\n\n    uint public childValue;\n\n    function setChildValue(uint _value) public {\n        childValue = _value;\n    }\n\n    function increaseChildValue(uint _value) public {\n        childValue = childValue.add(_value);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary Utils {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"Utils: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Main {\n    using Utils for uint;\n\n    uint public mainValue;\n\n    function setMainValue(uint _value) public {\n        mainValue = _value;\n    }\n\n    function multiplyMainValue(uint _value) public {\n        mainValue = mainValue.multiply(_value);\n    }\n}\n\ncontract Sub is Main {\n    using Utils for uint;\n\n    uint public subValue;\n\n    function setSubValue(uint _value) public {\n        subValue = _value;\n    }\n\n    function multiplySubValue(uint _value) public {\n        subValue = subValue.multiply(_value);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary Arithmetic {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"Arithmetic: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract BaseContract {\n    using Arithmetic for uint;\n\n    uint public baseNum;\n\n    function setBaseNum(uint _num) public {\n        baseNum = _num;\n    }\n\n    function subtractFromBase(uint _num) public {\n        baseNum = baseNum.subtract(_num);\n    }\n}\n\ncontract DerivedContract is BaseContract {\n    using Arithmetic for uint;\n\n    uint public derivedNum;\n\n    function setDerivedNum(uint _num) public {\n        derivedNum = _num;\n    }\n\n    function subtractFromDerived(uint _num) public {\n        derivedNum = derivedNum.subtract(_num);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary Lib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"Lib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Core {\n    using Lib for uint;\n\n    uint public coreValue;\n\n    function setCoreValue(uint _value) public {\n        coreValue = _value;\n    }\n\n    function divideCoreValue(uint _value) public {\n        coreValue = coreValue.divide(_value);\n    }\n}\n\ncontract Extended is Core {\n    using Lib for uint;\n\n    uint public extendedValue;\n\n    function setExtendedValue(uint _value) public {\n        extendedValue = _value;\n    }\n\n    function divideExtendedValue(uint _value) public {\n        extendedValue = extendedValue.divide(_value);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary Helper {\n    function mod(uint a, uint b) internal pure returns (uint) {\n        require(b != 0, \"Helper: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract Primary {\n    using Helper for uint;\n\n    uint public primaryValue;\n\n    function setPrimaryValue(uint _value) public {\n        primaryValue = _value;\n    }\n\n    function modPrimaryValue(uint _value) public {\n        primaryValue = primaryValue.mod(_value);\n    }\n}\n\ncontract Secondary is Primary {\n    using Helper for uint;\n\n    uint public secondaryValue;\n\n    function setSecondaryValue(uint _value) public {\n        secondaryValue = _value;\n    }\n\n    function modSecondaryValue(uint _value) public {\n        secondaryValue = secondaryValue.mod(_value);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary Calc {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"Calc: addition overflow\");\n        return c;\n    }\n}\n\ncontract Alpha {\n    using Calc for uint;\n\n    uint public alphaValue;\n\n    function setAlphaValue(uint _value) public {\n        alphaValue = _value;\n    }\n\n    function addAlphaValue(uint _value) public {\n        alphaValue = alphaValue.add(_value);\n    }\n}\n\ncontract Beta is Alpha {\n    using Calc for uint;\n\n    uint public betaValue;\n\n    function setBetaValue(uint _value) public {\n        betaValue = _value;\n    }\n\n    function addBetaValue(uint _value) public {\n        betaValue = betaValue.add(_value);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary MathUtil {\n    function subtract(uint a, uint b) internal pure returns (uint) {\n        require(b <= a, \"MathUtil: subtraction overflow\");\n        return a - b;\n    }\n}\n\ncontract First {\n    using MathUtil for uint;\n\n    uint public firstValue;\n\n    function setFirstValue(uint _value) public {\n        firstValue = _value;\n    }\n\n    function subtractFirstValue(uint _value) public {\n        firstValue = firstValue.subtract(_value);\n    }\n}\n\ncontract Second is First {\n    using MathUtil for uint;\n\n    uint public secondValue;\n\n    function setSecondValue(uint _value) public {\n        secondValue = _value;\n    }\n\n    function subtractSecondValue(uint _value) public {\n        secondValue = secondValue.subtract(_value);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary MyLib {\n    function multiply(uint a, uint b) internal pure returns (uint) {\n        uint c = a * b;\n        require(c / a == b, \"MyLib: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Initial {\n    using MyLib for uint;\n\n    uint public initialValue;\n\n    function setInitialValue(uint _value) public {\n        initialValue = _value;\n    }\n\n    function multiplyInitialValue(uint _value) public {\n        initialValue = initialValue.multiply(_value);\n    }\n}\n\ncontract Final is Initial {\n    using MyLib for uint;\n\n    uint public finalValue;\n\n    function setFinalValue(uint _value) public {\n        finalValue = _value;\n    }\n\n    function multiplyFinalValue(uint _value) public {\n        finalValue = finalValue.multiply(_value);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary UtilLib {\n    function divide(uint a, uint b) internal pure returns (uint) {\n        require(b > 0, \"UtilLib: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Root {\n    using UtilLib for uint;\n\n    uint public rootValue;\n\n    function setRootValue(uint _value) public {\n        rootValue = _value;\n    }\n\n    function divideRootValue(uint _value) public {\n        rootValue = rootValue.divide(_value);\n    }\n}\n\ncontract Branch is Root {\n    using UtilLib for uint;\n\n    uint public branchValue;\n\n    function setBranchValue(uint _value) public {\n        branchValue = _value;\n    }\n\n    function divideBranchValue(uint _value) public {\n        branchValue = branchValue.divide(_value);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary ExtraMath {\n    function add(uint a, uint b) internal pure returns (uint) {\n        uint c = a + b;\n        require(c >= a, \"ExtraMath: addition overflow\");\n        return c;\n    }\n}\n\ncontract Super {\n    using ExtraMath for uint;\n\n    uint public superValue;\n\n    function setSuperValue(uint _value) public {\n        superValue = _value;\n    }\n\n    function addSuperValue(uint _value) public {\n        superValue = superValue.add(_value);\n    }\n}\n\ncontract Ultra is Super {\n    using ExtraMath for uint;\n\n    uint public ultraValue;\n\n    function setUltraValue(uint _value) public {\n        ultraValue = _value;\n    }\n\n    function addUltraValue(uint _value) public {\n        ultraValue = ultraValue.add(_value);\n    }\n}"
      }
    }
  },
  {
    "Changes49": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "Shifts by signed types are disallowed.\nPreviously, shifts by negative amounts were allowed, but reverted at runtime.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    int public result;\n\n    function shiftRight(int x, int y) public {\n        result = x >> y;\n    }\n}",
          "error message": ":1:133: TypeError: Operator >> not compatible with types int256 and int256\npragma solidity^0.7.0;  contract Example1 {     int public result;      function shiftRight(int x, int y) public {         result = x >> y;     } }\n                                                                                                                                    ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    int public value;\n\n    function leftShift(int num, int amount) public {\n        value = num << amount;\n    }\n\n    function dummyFunction1() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": ":1:137: TypeError: Operator << not compatible with types int256 and int256\n ... t amount) public {         value = num << amount;     }      function dummyFunction ...\n                                        ^-----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    int public outcome;\n\n    function shift(int base, int offset) public {\n        outcome = base << offset;\n    }\n}",
          "error message": ":1:138: TypeError: Operator << not compatible with types int256 and int256\n ... offset) public {         outcome = base << offset;     } }\n                                        ^------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    int public data;\n\n    function shiftLeftBy(int a, int b) public {\n        data = a << b;\n    }\n\n    function anotherFunction() public pure returns (int) {\n        return -1;\n    }\n\n    function additionalFunction() public pure returns (int) {\n        return 100;\n    }\n}",
          "error message": ":1:130: TypeError: Operator << not compatible with types int256 and int256\n ...  a, int b) public {         data = a << b;     }      function anotherFuncti ...\n                                        ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    int public resultValue;\n\n    function rightShift(int number, int shiftBy) public {\n        resultValue = number >> shiftBy;\n    }\n}",
          "error message": ":1:154: TypeError: Operator >> not compatible with types int256 and int256\n ... By) public {         resultValue = number >> shiftBy;     } }\n                                        ^---------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    int public computedValue;\n\n    function performShift(int input, int shiftAmount) public {\n        computedValue = input << shiftAmount;\n    }\n}",
          "error message": ":1:163: TypeError: Operator << not compatible with types int256 and int256\n ... ) public {         computedValue = input << shiftAmount;     } }\n                                        ^------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    int public shiftedResult;\n\n    function shiftLeftOperation(int num, int shiftVal) public {\n        shiftedResult = num << shiftVal;\n    }\n\n    function unusedFunction() public pure returns (int) {\n        return 7;\n    }\n}",
          "error message": ":1:164: TypeError: Operator << not compatible with types int256 and int256\n ... ) public {         shiftedResult = num << shiftVal;     }      function unusedFunctio ...\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    int public shiftedData;\n\n    function shiftData(int value, int shiftBits) public {\n        shiftedData = value << shiftBits;\n    }\n}",
          "error message": ":1:154: TypeError: Operator << not compatible with types int256 and int256\n ... ts) public {         shiftedData = value << shiftBits;     } }\n                                        ^----------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    int public shiftOutcome;\n\n    function leftShiftOperation(int inputValue, int shiftByAmount) public {\n        shiftOutcome = inputValue << shiftByAmount;\n    }\n}",
          "error message": ":1:174: TypeError: Operator << not compatible with types int256 and int256\n ... t) public {         shiftOutcome = inputValue << shiftByAmount;     } }\n                                        ^-------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    int public finalResult;\n\n    function performLeftShift(int data, int shiftVal) public {\n        finalResult = data << shiftVal;\n    }\n\n    function additionalFunction1() public pure returns (int) {\n        return 256;\n    }\n}",
          "error message": ":1:160: TypeError: Operator << not compatible with types int256 and int256\n ... al) public {         finalResult = data << shiftVal;     }      function additionalFun ...\n                                        ^--------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public result;\n\n    function shiftRight(uint x, uint y) public {\n        result = x >> y;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public value;\n\n    function leftShift(uint num, uint amount) public {\n        value = num << amount;\n    }\n\n    function dummyFunction1() public pure returns (int) {\n        return 42;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public outcome;\n\n    function shift(uint base, uint offset) public {\n        outcome = base << offset;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public data;\n\n    function shiftLeftBy(uint a, uint b) public {\n        data = a << b;\n    }\n\n    function anotherFunction() public pure returns (int) {\n        return -1;\n    }\n\n    function additionalFunction() public pure returns (int) {\n        return 100;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public resultValue;\n\n    function rightShift(uint number, uint shiftBy) public {\n        resultValue = number >> shiftBy;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public computedValue;\n\n    function performShift(uint input, uint shiftAmount) public {\n        computedValue = input << shiftAmount;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public shiftedResult;\n\n    function shiftLeftOperation(uint num, uint shiftVal) public {\n        shiftedResult = num << shiftVal;\n    }\n\n    function unusedFunction() public pure returns (int) {\n        return 7;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public shiftedData;\n\n    function shiftData(uint value, uint shiftBits) public {\n        shiftedData = value << shiftBits;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public shiftOutcome;\n\n    function leftShiftOperation(uint inputValue, uint shiftByAmount) public {\n        shiftOutcome = inputValue << shiftByAmount;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public finalResult;\n\n    function performLeftShift(uint data, uint shiftVal) public {\n        finalResult = data << shiftVal;\n    }\n\n    function additionalFunction1() public pure returns (int) {\n        return 256;\n    }\n}"
      }
    }
  },
  {
    "Changes50": {
      "Version Migration": "0.5->0.7",
      "Knowledge": "The <code>finney</code> and <code>szabo</code> denominations are removed.\nThey are rarely used and do not make the actual amount readily visible. Instead, explicit\nvalues like <code>1e20</code> or the very common <code>gwei</code> can be used.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public amountInFinney = 2 finney;\n\n    function checkAmount() public view returns (uint) {\n        return amountInFinney;\n    }\n\n    function pay() public payable {\n        require(msg.value >= amountInFinney, \"Insufficient payment\");\n    }\n}",
          "error message": ":1:80: ParserError: Expected ';' but got identifier\n ...     uint public amountInFinney = 2 finney;      function checkAmount() publi ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public valueInSzabo = 10 szabo;\n\n    function deposit() public payable {\n        require(msg.value >= valueInSzabo, \"Deposit must be at least 10 szabo\");\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
          "error message": ":1:79: ParserError: Expected ';' but got identifier\n ...      uint public valueInSzabo = 10 szabo;      function deposit() public pa ...\n                                        ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public threshold = 5 finney;\n\n    function setThreshold(uint _newThreshold) public {\n        threshold = _newThreshold * 1 finney;\n    }\n\n    function isAboveThreshold(uint amount) public view returns (bool) {\n        return amount >= threshold;\n    }\n}",
          "error message": ":1:75: ParserError: Expected ';' but got identifier\n ... e3 {     uint public threshold = 5 finney;      function setThreshold(uint _ ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public smallAmount = 3 szabo;\n\n    function sendEther() public payable {\n        require(msg.value == smallAmount, \"Must send exactly 3 szabo\");\n    }\n\n    function currentAmount() public view returns (uint) {\n        return smallAmount;\n    }\n}",
          "error message": ":1:77: ParserError: Expected ';' but got identifier\n ...  {     uint public smallAmount = 3 szabo;      function sendEther() public  ...\n                                        ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public requiredAmount = 7 finney;\n\n    function receivePayment() public payable {\n        require(msg.value == requiredAmount, \"Must send 7 finney\");\n    }\n\n    function checkRequired() public view returns (uint) {\n        return requiredAmount;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:80: ParserError: Expected ';' but got identifier\n ...     uint public requiredAmount = 7 finney;      function receivePayment() pu ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public minimumSzabo = 50 szabo;\n\n    function contribute() public payable {\n        require(msg.value >= minimumSzabo, \"Contribution must be at least 50 szabo\");\n    }\n\n    function getMinimum() public view returns (uint) {\n        return minimumSzabo;\n    }\n\n    function dummyFunc() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:79: ParserError: Expected ';' but got identifier\n ...      uint public minimumSzabo = 50 szabo;      function contribute() public ...\n                                        ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public fee = 1 finney;\n\n    function payFee() public payable {\n        require(msg.value >= fee, \"Fee is 1 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return fee;\n    }\n}",
          "error message": ":1:69: ParserError: Expected ';' but got identifier\n ... Example7 {     uint public fee = 1 finney;      function payFee() public pay ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public donation = 20 szabo;\n\n    function donate() public payable {\n        require(msg.value == donation, \"Donate exactly 20 szabo\");\n    }\n\n    function getDonationAmount() public view returns (uint) {\n        return donation;\n    }\n}",
          "error message": ":1:75: ParserError: Expected ';' but got identifier\n ... e8 {     uint public donation = 20 szabo;      function donate() public pay ...\n                                        ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public cost = 15 finney;\n\n    function purchase() public payable {\n        require(msg.value >= cost, \"Cost is 15 finney\");\n    }\n\n    function getCost() public view returns (uint) {\n        return cost;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n}",
          "error message": ":1:71: ParserError: Expected ';' but got identifier\n ... ample9 {     uint public cost = 15 finney;      function purchase() public p ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public rate = 5 szabo;\n\n    function invest() public payable {\n        require(msg.value >= rate, \"Investment rate is 5 szabo\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rate;\n    }\n}",
          "error message": ":1:71: ParserError: Expected ';' but got identifier\n ... ample10 {     uint public rate = 5 szabo;      function invest() public pay ...\n                                        ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    uint public amountInFinney = 2 * 1e15;\n\n    function checkAmount() public view returns (uint) {\n        return amountInFinney;\n    }\n\n    function pay() public payable {\n        require(msg.value >= amountInFinney, \"Insufficient payment\");\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    uint public valueInSzabo = 10 * 1e12;\n\n    function deposit() public payable {\n        require(msg.value >= valueInSzabo, \"Deposit must be at least 10 szabo\");\n    }\n\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    uint public threshold = 5 * 1e15;\n\n    function setThreshold(uint _newThreshold) public {\n        threshold = _newThreshold * 1e15;\n    }\n\n    function isAboveThreshold(uint amount) public view returns (bool) {\n        return amount >= threshold;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    uint public smallAmount = 3 * 1e12;\n\n    function sendEther() public payable {\n        require(msg.value == smallAmount, \"Must send exactly 3 szabo\");\n    }\n\n    function currentAmount() public view returns (uint) {\n        return smallAmount;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    uint public requiredAmount = 7 * 1e15;\n\n    function receivePayment() public payable {\n        require(msg.value == requiredAmount, \"Must send 7 finney\");\n    }\n\n    function checkRequired() public view returns (uint) {\n        return requiredAmount;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    uint public minimumSzabo = 50 * 1e12;\n\n    function contribute() public payable {\n        require(msg.value >= minimumSzabo, \"Contribution must be at least 50 szabo\");\n    }\n\n    function getMinimum() public view returns (uint) {\n        return minimumSzabo;\n    }\n\n    function dummyFunc() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    uint public fee = 1 * 1e15;\n\n    function payFee() public payable {\n        require(msg.value >= fee, \"Fee is 1 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return fee;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    uint public donation = 20 * 1e12;\n\n    function donate() public payable {\n        require(msg.value == donation, \"Donate exactly 20 szabo\");\n    }\n\n    function getDonationAmount() public view returns (uint) {\n        return donation;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    uint public cost = 15 * 1e15;\n\n    function purchase() public payable {\n        require(msg.value >= cost, \"Cost is 15 finney\");\n    }\n\n    function getCost() public view returns (uint) {\n        return cost;\n    }\n\n    function helperFunction() public pure returns (string memory) {\n        return \"Helper\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    uint public rate = 5 * 1e12;\n\n    function invest() public payable {\n        require(msg.value >= rate, \"Investment rate is 5 szabo\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rate;\n    }\n}"
      }
    }
  },
  {
    "Changes51": {
      "Version Migration": "->0.5",
      "Knowledge": "The functions <code>.call()</code>, <code>.delegatecall()</code>, <code>staticcall()</code>,\n<code>keccak256()</code>, <code>sha256()</code> and <code>ripemd160()</code> now accept only a single\n<code>bytes</code> argument. Moreover, the argument is not padded. This was changed to\nmake more explicit and clear how the arguments are concatenated. Change every\n<code>.call()</code> (and family) to a <code>.call(\"\")</code> and every <code>.call(signature, a,\nb, c)</code> to use <code>.call(abi.encodeWithSignature(signature, a, b, c))</code> (the\nlast one only works for value types).  Change every <code>keccak256(a, b, c)</code> to\n<code>keccak256(abi.encodePacked(a, b, c))</code>. Even though it is not a breaking\nchange, it is suggested that developers change\n<code>x.call(bytes4(keccak256(\"f(uint256)\")), a, b)</code> to\n<code>x.call(abi.encodeWithSignature(\"f(uint256)\", a, b))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractOne {\n    function invokeDelegate(address delegate, uint256 val) public {\n        delegate.delegatecall(bytes4(keccak256(\"updateValue(uint256)\")), val);\n    }\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Hello, World!\";\n    }\n}",
          "error message": ":1:123: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... ate, uint256 val) public {         delegate.delegatecall(bytes4(keccak256(\"updateValue(uint256)\")), val);     }     function unrelatedFunct ...\n                                        ^-------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractTwo {\n    function getValue() public pure returns (bytes32) {\n        return sha256(123, 456);\n    }\n    function randomUtility() public pure returns (int) {\n        return -999;\n    }\n}",
          "error message": ":1:118: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return sha256(123, 456);     }     function randomUtility( ...\n                                        ^--------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractThree {\n    function checkHash(uint256 num1, uint256 num2) public pure returns (bytes32) {\n        return keccak256(num1, num2);\n    }\n    function checkEven(uint num) public pure returns (bool) {\n        return num % 2 == 0;\n    }\n}",
          "error message": ":1:147: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return keccak256(num1, num2);     }     function checkEven(uint ...\n                                        ^-------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractFour {\n    function generateHash(uint256 data1, uint256 data2) public pure returns (bytes32) {\n        return ripemd160(data1, data2);\n    }\n    function extraFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:151: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return ripemd160(data1, data2);     }     function extraFunction( ...\n                                        ^---------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractFive {\n    function callMethod(address addr, uint256 arg1) public {\n        addr.call(bytes4(keccak256(\"process(uint256)\")), arg1);\n    }\n    function helper() public pure returns (uint) { return 42; }\n    function anotherHelper() public pure returns (string memory) {\n        return \"Another Helper\";\n    }\n}",
          "error message": ":1:117: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... dr, uint256 arg1) public {         addr.call(bytes4(keccak256(\"process(uint256)\")), arg1);     }     function helper() publi ...\n                                        ^----------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractSix {\n    function execute(address target, uint256 arg) public {\n        target.call(bytes4(keccak256(\"execute(uint256)\")), arg);\n    }\n    function unusedFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:114: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... get, uint256 arg) public {         target.call(bytes4(keccak256(\"execute(uint256)\")), arg);     }     function unusedFunction ...\n                                        ^-----------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractSeven {\n    function hashData(uint256 a, uint256 b) public pure returns (bytes32) {\n        return keccak256(a, b);\n    }\n    function unused() public pure returns (uint) { return 0; }\n    function doubleValue(uint val) public pure returns (uint) {\n        return val * 2;\n    }\n}",
          "error message": ":1:140: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return keccak256(a, b);     }     function unused() publi ...\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractEight {\n    function callExternal(address externalAddress, uint256 param) public {\n        externalAddress.call(bytes4(keccak256(\"modify(uint256)\")), param);\n    }\n    function extra() public pure returns (uint) { return 1; }\n    function moreExtra() public pure returns (uint) { return 2; }\n    function randomValue() public pure returns (uint) {\n        return 123456;\n    }\n}",
          "error message": ":1:132: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... s, uint256 param) public {         externalAddress.call(bytes4(keccak256(\"modify(uint256)\")), param);     }     function extra() public ...\n                                        ^---------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractNine {\n    function sendCall(address callee, uint256 number) public {\n        callee.call(bytes4(keccak256(\"setNumber(uint256)\")), number);\n    }\n    function getRandomNumber() public pure returns (uint) {\n        return 987654321;\n    }\n}",
          "error message": ":1:119: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. If all your arguments are value types, you can use abi.encode(...) to properly generate it.\n ... , uint256 number) public {         callee.call(bytes4(keccak256(\"setNumber(uint256)\")), number);     }     function getRandomNumbe ...\n                                        ^----------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ContractTen {\n    function computeHash(uint256 x, uint256 y) public pure returns (bytes32) {\n        return sha256(x, y);\n    }\n    function getConstant() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": ":1:141: TypeError: Wrong argument count for function call: 2 arguments given but expected 1. This function requires a single bytes argument. Use abi.encodePacked(...) to obtain the pre-0.5.0 behaviour or abi.encode(...) to use ABI encoding.\n ... returns (bytes32) {         return sha256(x, y);     }     function getConstant()  ...\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ContractOne {\n    function invokeDelegate(address delegate, uint256 val) public {\n        delegate.delegatecall(abi.encodeWithSignature(\"updateValue(uint256)\", val));\n    }\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Hello, World!\";\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ContractTwo {\n    function getValue() public pure returns (bytes32) {\n        return sha256(abi.encodePacked(uint256(123), uint256(456)));\n    }\n    function randomUtility() public pure returns (int) {\n        return -999;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ContractThree {\n    function checkHash(uint256 num1, uint256 num2) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(num1, num2));\n    }\n    function checkEven(uint num) public pure returns (bool) {\n        return num % 2 == 0;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ContractFour {\n    function generateHash(uint256 data1, uint256 data2) public pure returns (bytes32) {\n        return ripemd160(abi.encodePacked(data1, data2));\n    }\n    function extraFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ContractFive {\n    function callMethod(address addr, uint256 arg1) public {\n        addr.call(abi.encodeWithSignature(\"process(uint256)\", arg1));\n    }\n    function helper() public pure returns (uint) { return 42; }\n    function anotherHelper() public pure returns (string memory) {\n        return \"Another Helper\";\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ContractSix {\n    function execute(address target, uint256 arg) public {\n        target.call(abi.encodeWithSignature(\"execute(uint256)\", arg));\n    }\n    function unusedFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ContractSeven {\n    function hashData(uint256 a, uint256 b) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(a, b));\n    }\n    function unused() public pure returns (uint) { return 0; }\n    function doubleValue(uint val) public pure returns (uint) {\n        return val * 2;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ContractEight {\n    function callExternal(address externalAddress, uint256 param) public {\n        externalAddress.call(abi.encodeWithSignature(\"modify(uint256)\", param));\n    }\n    function extra() public pure returns (uint) { return 1; }\n    function moreExtra() public pure returns (uint) { return 2; }\n    function randomValue() public pure returns (uint) {\n        return 123456;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ContractNine {\n    function sendCall(address callee, uint256 number) public {\n        callee.call(abi.encodeWithSignature(\"setNumber(uint256)\", number));\n    }\n    function getRandomNumber() public pure returns (uint) {\n        return 987654321;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ContractTen {\n    function computeHash(uint256 x, uint256 y) public pure returns (bytes32) {\n        return sha256(abi.encodePacked(x, y));\n    }\n    function getConstant() public pure returns (uint) {\n        return 100;\n    }\n}"
      }
    }
  },
  {
    "Changes52": {
      "Version Migration": "->0.5",
      "Knowledge": "Functions <code>.call()</code>, <code>.delegatecall()</code> and <code>.staticcall()</code> now return\n<code>(bool, bytes memory)</code> to provide access to the return data.  Change\n<code>bool success = otherContract.call(\"f\")</code> to <code>(bool success, bytes memory\ndata) = otherContract.call(\"f\")</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract DataProcessor {\n    address targetContract;\n    function processCall() public {\n        bool result = targetContract.call(abi.encodeWithSignature(\"processData()\"));\n    }\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Just a placeholder\";\n    }\n}",
          "error message": ":1:121: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... ion processCall() public {         bool result = targetContract.call(abi.encodeWithSignature(\"processData()\"));     }     function unrelatedFunct ...\n                                        ^-------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract UserManagement {\n    address userContract;\n    function addUser() public {\n        bool added = userContract.call(abi.encodeWithSignature(\"addUser()\"));\n    }\n    function unrelatedFunction2(uint256 data) public pure returns (uint256) {\n        return data + 1;\n    }\n}",
          "error message": ":1:116: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... unction addUser() public {         bool added = userContract.call(abi.encodeWithSignature(\"addUser()\"));     }     function unrelatedFunct ...\n                                        ^------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract TransactionLogger {\n    address loggerContract;\n    function logTransaction() public {\n        bool success = loggerContract.call(abi.encodeWithSignature(\"log()\"));\n    }\n    function unrelatedFunction3() public {\n    }\n}",
          "error message": ":1:128: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ...  logTransaction() public {         bool success = loggerContract.call(abi.encodeWithSignature(\"log()\"));     }     function unrelatedFunct ...\n                                        ^------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract PaymentGateway {\n    address paymentProcessor;\n    function initiatePayment() public {\n        bool paymentInitiated = paymentProcessor.call(abi.encodeWithSignature(\"pay()\"));\n    }\n    function randomTask() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:128: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... initiatePayment() public {         bool paymentInitiated = paymentProcessor.call(abi.encodeWithSignature(\"pay()\"));     }     function randomTask() p ...\n                                        ^-----------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract AccountValidator {\n    address accountService;\n    function validateAccount() public {\n        bool valid = accountService.call(abi.encodeWithSignature(\"validate()\"));\n    }\n    function unrelatedFunction4() private {\n    }\n}",
          "error message": ":1:128: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... validateAccount() public {         bool valid = accountService.call(abi.encodeWithSignature(\"validate()\"));     }     function unrelatedFunct ...\n                                        ^---------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract EventNotifier {\n    address eventHandler;\n    function notifyEvent() public {\n        bool notificationSent = eventHandler.call(abi.encodeWithSignature(\"notify()\"));\n    }\n    function processInputs(int x) public pure returns (int) {\n        return x * 2;\n    }\n}",
          "error message": ":1:119: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... ion notifyEvent() public {         bool notificationSent = eventHandler.call(abi.encodeWithSignature(\"notify()\"));     }     function processInputs( ...\n                                        ^----------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract QueryExecutor {\n    address queryService;\n    function executeQuery() public {\n        bool executed = queryService.call(abi.encodeWithSignature(\"execute()\"));\n    }\n    function logDetails(string memory details) public pure returns (string memory) {\n        return details;\n    }\n}",
          "error message": ":1:120: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... on executeQuery() public {         bool executed = queryService.call(abi.encodeWithSignature(\"execute()\"));     }     function logDetails(str ...\n                                        ^---------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract DeviceController {\n    address deviceManager;\n    function controlDevice() public {\n        bool controlled = deviceManager.call(abi.encodeWithSignature(\"control()\"));\n    }\n    function extraProcess(bool state) public pure returns (bool) {\n        return !state;\n    }\n}",
          "error message": ":1:125: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... n controlDevice() public {         bool controlled = deviceManager.call(abi.encodeWithSignature(\"control()\"));     }     function extraProcess(b ...\n                                        ^------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ResourceAllocator {\n    address resourceContract;\n    function allocateResource() public {\n        bool allocated = resourceContract.call(abi.encodeWithSignature(\"allocate()\"));\n    }\n    function unrelatedFunction5() public {\n    }\n}",
          "error message": ":1:132: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... llocateResource() public {         bool allocated = resourceContract.call(abi.encodeWithSignature(\"allocate()\"));     }     function unrelatedFunct ...\n                                        ^---------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract MembershipChecker {\n    address memberContract;\n    function checkMembership() public {\n        bool isMember = memberContract.call(abi.encodeWithSignature(\"check()\"));\n    }\n    function processMemberData(uint256 id) public pure returns (uint256) {\n        return id * 10;\n    }\n}",
          "error message": ":1:129: TypeError: Different number of components on the left hand side (1) than on the right hand side (2).\n ... checkMembership() public {         bool isMember = memberContract.call(abi.encodeWithSignature(\"check()\"));     }     function processMemberD ...\n                                        ^---------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract DataProcessor {\n    address targetContract;\n    function processCall() public {\n        (bool result, ) = targetContract.call(abi.encodeWithSignature(\"processData()\"));\n    }\n    function unrelatedFunction1() public pure returns (string memory) {\n        return \"Just a placeholder\";\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract UserManagement {\n    address userContract;\n    function addUser() public {\n        (bool added, ) = userContract.call(abi.encodeWithSignature(\"addUser()\"));\n    }\n    function unrelatedFunction2(uint256 data) public pure returns (uint256) {\n        return data + 1;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract TransactionLogger {\n    address loggerContract;\n    function logTransaction() public {\n        (bool success, ) = loggerContract.call(abi.encodeWithSignature(\"log()\"));\n    }\n    function unrelatedFunction3() public {\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract PaymentGateway {\n    address paymentProcessor;\n    function initiatePayment() public {\n        (bool paymentInitiated, ) = paymentProcessor.call(abi.encodeWithSignature(\"pay()\"));\n    }\n    function randomTask() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract AccountValidator {\n    address accountService;\n    function validateAccount() public {\n        (bool valid, ) = accountService.call(abi.encodeWithSignature(\"validate()\"));\n    }\n    function unrelatedFunction4() private {\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract EventNotifier {\n    address eventHandler;\n    function notifyEvent() public {\n        (bool notificationSent, ) = eventHandler.call(abi.encodeWithSignature(\"notify()\"));\n    }\n    function processInputs(int x) public pure returns (int) {\n        return x * 2;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract QueryExecutor {\n    address queryService;\n    function executeQuery() public {\n        (bool executed, ) = queryService.call(abi.encodeWithSignature(\"execute()\"));\n    }\n    function logDetails(string memory details) public pure returns (string memory) {\n        return details;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract DeviceController {\n    address deviceManager;\n    function controlDevice() public {\n        (bool controlled, ) = deviceManager.call(abi.encodeWithSignature(\"control()\"));\n    }\n    function extraProcess(bool state) public pure returns (bool) {\n        return !state;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ResourceAllocator {\n    address resourceContract;\n    function allocateResource() public {\n        (bool allocated, ) = resourceContract.call(abi.encodeWithSignature(\"allocate()\"));\n    }\n    function unrelatedFunction5() public {\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract MembershipChecker {\n    address memberContract;\n    function checkMembership() public {\n        (bool isMember, ) = memberContract.call(abi.encodeWithSignature(\"check()\"));\n    }\n    function processMemberData(uint256 id) public pure returns (uint256) {\n        return id * 10;\n    }\n}"
      }
    }
  },
  {
    "Changes53": {
      "Version Migration": "->0.5",
      "Knowledge": "Solidity now implements C99-style scoping rules for function local\nvariables, that is, variables can only be used after they have been\ndeclared and only in the same or nested scopes. Variables declared in the\ninitialization block of a <code>for</code> loop are valid at any point inside the\nloop.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleOne {\n    function calculateSum() public pure returns (uint) {\n        uint sum = 5;\n        { uint b = sum; }\n        return b;\n    }\n    function unrelatedOne() public pure returns (uint) { return 1; }\n}",
          "error message": ":1:166: DeclarationError: Undeclared identifier.\n ...   { uint b = sum; }         return b;     }     function unrelatedOne() ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleTwo {\n    function findMax() public pure returns (uint) {\n        uint max = 3;\n        { uint c = max; }\n        return c;\n    }\n    function helperFunction() public pure {}\n    function extraLogic() public pure returns (bool) { return true; }\n}",
          "error message": ":1:161: DeclarationError: Undeclared identifier.\n ...   { uint c = max; }         return c;     }     function helperFunction ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleThree {\n    function getLastNumber() public pure returns (uint) {\n        uint last = 9;\n        { uint d = last; }\n        return d;\n    }\n    function randomFunction() public pure {}\n    function additionalCode() public pure {}\n}",
          "error message": ":1:171: DeclarationError: Undeclared identifier.\n ...  { uint d = last; }         return d;     }     function randomFunction ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleFour {\n    function checkValue() public pure returns (uint) {\n        uint value = 7;\n        { uint e = value; }\n        return e;\n    }\n    function computeSomething() public pure returns (int) { return -1; }\n}",
          "error message": ":1:169: DeclarationError: Undeclared identifier.\n ... { uint e = value; }         return e;     }     function computeSomethi ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleFive {\n    function retrieveData() public pure returns (uint) {\n        uint data = 2;\n        { uint f = data; }\n        return f;\n    }\n    function anotherFunction() public pure {}\n    function logEvent() public pure {}\n}",
          "error message": ":1:169: DeclarationError: Undeclared identifier.\n ...  { uint f = data; }         return f;     }     function anotherFunctio ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleSix {\n    function computeResult() public pure returns (uint) {\n        uint result = 4;\n        { uint g = result; }\n        return g;\n    }\n    function executeExtra() public pure returns (string memory) { return \"Extra\"; }\n}",
          "error message": ":1:173: DeclarationError: Undeclared identifier.\n ...  uint g = result; }         return g;     }     function executeExtra() ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleSeven {\n    function fetchNumber() public pure returns (uint) {\n        uint number = 1;\n        { uint h = number; }\n        return h;\n    }\n    function unusedFunction() public pure {}\n    function extraFunction() public pure {}\n    function voidAction() public {}\n}",
          "error message": ":1:173: DeclarationError: Undeclared identifier.\n ...  uint h = number; }         return h;     }     function unusedFunction ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleEight {\n    function generateOutput() public pure returns (uint) {\n        uint output = 6;\n        { uint i = output; }\n        return i;\n    }\n    function processExtra() public pure {}\n}",
          "error message": ":1:176: DeclarationError: Undeclared identifier.\n ...  uint i = output; }         return i;     }     function processExtra() ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleNine {\n    function processInfo() public pure returns (uint) {\n        uint info = 8;\n        { uint j = info; }\n        return j;\n    }\n    function debug() public pure returns (uint) { return 42; }\n}",
          "error message": ":1:168: DeclarationError: Undeclared identifier.\n ...  { uint j = info; }         return j;     }     function debug() public ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleTen {\n    function analyzeInput() public pure returns (uint) {\n        uint input = 10;\n        { uint k = input; }\n        return k;\n    }\n    function someFunction() public pure {}\n    function anotherRandomFunction() public pure returns (string memory) { return \"Hello\"; }\n}",
          "error message": ":1:171: DeclarationError: Undeclared identifier.\n ... { uint k = input; }         return k;     }     function someFunction() ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ExampleOne {\n    function calculateSum() public pure returns (uint) {\n        uint sum = 5;\n        { uint b = sum; return b; }\n    }\n    function unrelatedOne() public pure returns (uint) { return 1; }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ExampleTwo {\n    function findMax() public pure returns (uint) {\n        uint max = 3;\n        { uint c = max; return c; }\n    }\n    function helperFunction() public pure {}\n    function extraLogic() public pure returns (bool) { return true; }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ExampleThree {\n    function getLastNumber() public pure returns (uint) {\n        uint last = 9;\n        { uint d = last; return d; }\n    }\n    function randomFunction() public pure {}\n    function additionalCode() public pure {}\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ExampleFour {\n    function checkValue() public pure returns (uint) {\n        uint value = 7;\n        { uint e = value; return e; }\n    }\n    function computeSomething() public pure returns (int) { return -1; }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ExampleFive {\n    function retrieveData() public pure returns (uint) {\n        uint data = 2;\n        { uint f = data; return f; }\n    }\n    function anotherFunction() public pure {}\n    function logEvent() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ExampleSix {\n    function computeResult() public pure returns (uint) {\n        uint result = 4;\n        { uint g = result; return g; }\n    }\n    function executeExtra() public pure returns (string memory) { return \"Extra\"; }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ExampleSeven {\n    function fetchNumber() public pure returns (uint) {\n        uint number = 1;\n        { uint h = number; return h; }\n    }\n    function unusedFunction() public pure {}\n    function extraFunction() public pure {}\n    function voidAction() public {}\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ExampleEight {\n    function generateOutput() public pure returns (uint) {\n        uint output = 6;\n        { uint i = output; return i; }\n    }\n    function processExtra() public pure {}\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ExampleNine {\n    function processInfo() public pure returns (uint) {\n        uint info = 8;\n        { uint j = info; return j; }\n    }\n    function debug() public pure returns (uint) { return 42; }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ExampleTen {\n    function analyzeInput() public pure returns (uint) {\n        uint input = 10;\n        { uint k = input; return k; }\n    }\n    function someFunction() public pure {}\n    function anotherRandomFunction() public pure returns (string memory) { return \"Hello\"; }\n}"
      }
    }
  },
  {
    "Changes54": {
      "Version Migration": "->0.5",
      "Knowledge": "Explicit function visibility is now mandatory.  Add <code>public</code> to every\nfunction and constructor, and <code>external</code> to every fallback or interface\nfunction that does not specify its visibility already.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleOne {\n    function increment(uint count) returns(uint) {\n        return count + 1;\n    }\n}",
          "error message": ":1:50: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ExampleOne {     function increment(uint count) returns(uint) {         return count + 1;     } }\n                                                 ^----------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleTwo {\n    function decrement(int num) returns(int) {\n        return num - 1;\n    }\n    function helper() public pure returns(bool) {\n        return true;\n    }\n}",
          "error message": ":1:50: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... y^0.5.0; contract ExampleTwo {     function decrement(int num) returns(int) {         return num - 1;     }     function helper() public pure  ...\n                                        ^----------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleThree {\n    function multiply(uint a, uint b) returns(uint) {\n        return a * b;\n    }\n    function dummy() private pure returns(uint) {\n        return 0;\n    }\n}",
          "error message": ":1:52: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... 0.5.0; contract ExampleThree {     function multiply(uint a, uint b) returns(uint) {         return a * b;     }     function dummy() private pure  ...\n                                        ^---------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleFour {\n    function divide(uint dividend, uint divisor) returns(uint) {\n        return dividend / divisor;\n    }\n    function randomFunction() public pure returns(string memory) {\n        return \"Solidity\";\n    }\n}",
          "error message": ":1:51: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... ^0.5.0; contract ExampleFour {     function divide(uint dividend, uint divisor) returns(uint) {         return dividend / divisor;     }     function randomFunction() publ ...\n                                        ^---------------------------------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleFive {\n    function getData() returns(bytes memory data) {\n        return \"dummy data\";\n    }\n}",
          "error message": ":1:51: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ExampleFive {     function getData() returns(bytes memory data) {         return \"dummy data\";     } }\n                                                  ^--------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleSix {\n    function checkValue(uint value) returns(bool) {\n        return value > 100;\n    }\n    function extraFunc() private pure returns(uint) {\n        return 42;\n    }\n    function anotherExtraFunc() public pure returns(uint) {\n        return 100;\n    }\n}",
          "error message": ":1:50: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... y^0.5.0; contract ExampleSix {     function checkValue(uint value) returns(bool) {         return value > 100;     }     function extraFunc() private p ...\n                                        ^-------------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleSeven {\n    function setValue(uint _value) returns(uint) {\n        return _value;\n    }\n}",
          "error message": ":1:52: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ExampleSeven {     function setValue(uint _value) returns(uint) {         return _value;     } }\n                                                   ^-------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleEight {\n    function process(uint steps) returns(uint) {\n        return steps * 10;\n    }\n    function helperOne() public pure returns(bool) {\n        return false;\n    }\n}",
          "error message": ":1:52: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... 0.5.0; contract ExampleEight {     function process(uint steps) returns(uint) {         return steps * 10;     }     function helperOne() public pu ...\n                                        ^---------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleNine {\n    function toggle(bool state) returns(bool) {\n        return !state;\n    }\n}",
          "error message": ":1:51: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ExampleNine {     function toggle(bool state) returns(bool) {         return !state;     } }\n                                                  ^----------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ExampleTen {\n    function calculate(int a, int b) returns(int) {\n        return a + b;\n    }\n}",
          "error message": ":1:50: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract ExampleTen {     function calculate(int a, int b) returns(int) {         return a + b;     } }\n                                                 ^-------------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ExampleOne {\n    function increment(uint count) public returns(uint) {\n        return count + 1;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ExampleTwo {\n    function decrement(int num) public returns(int) {\n        return num - 1;\n    }\n    function helper() public pure returns(bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ExampleThree {\n    function multiply(uint a, uint b) public returns(uint) {\n        return a * b;\n    }\n    function dummy() private pure returns(uint) {\n        return 0;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ExampleFour {\n    function divide(uint dividend, uint divisor) public returns(uint) {\n        return dividend / divisor;\n    }\n    function randomFunction() public pure returns(string memory) {\n        return \"Solidity\";\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ExampleFive {\n    function getData() public returns(bytes memory data) {\n        return \"dummy data\";\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ExampleSix {\n    function checkValue(uint value) public returns(bool) {\n        return value > 100;\n    }\n    function extraFunc() private pure returns(uint) {\n        return 42;\n    }\n    function anotherExtraFunc() public pure returns(uint) {\n        return 100;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ExampleSeven {\n    function setValue(uint _value) public returns(uint) {\n        return _value;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ExampleEight {\n    function process(uint steps) public returns(uint) {\n        return steps * 10;\n    }\n    function helperOne() public pure returns(bool) {\n        return false;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ExampleNine {\n    function toggle(bool state) public returns(bool) {\n        return !state;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ExampleTen {\n    function calculate(int a, int b) public returns(int) {\n        return a + b;\n    }\n}"
      }
    }
  },
  {
    "Changes55": {
      "Version Migration": "->0.5",
      "Knowledge": "Explicit conversions between unrelated contract types are now disallowed. You can only\nconvert from a contract type to one of its base or ancestor types. If you are sure that\na contract is compatible with the contract type you want to convert to, although it does not\ninherit from it, you can work around this by converting to <code>address</code> first.\nExample: if <code>A</code> and <code>B</code> are contract types, <code>B</code> does not inherit from <code>A</code> and\n<code>b</code> is a contract of type <code>B</code>, you can still convert <code>b</code> to type <code>A</code> using <code>A(address(b))</code>.\nNote that you still need to watch out for matching payable fallback functions, as explained below.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract Alpha {\n    function alphaFunc() public pure returns (string memory) { return \"Alpha Function\"; }\n}\ncontract Beta {\n    function betaFunc() public pure returns (string memory) { return \"Beta Function\"; }\n}\ncontract Convert {\n    Beta b = new Beta();\n    function performConversion() public view returns (string memory) {\n        Alpha a = Alpha(b);\n        return a.alphaFunc();\n    }\n}",
          "error message": ":1:372: TypeError: Explicit type conversion not allowed from \"contract Beta\" to \"contract Alpha\".\n ... string memory) {         Alpha a = Alpha(b);         return a.alphaFunc();     ...\n                                        ^------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract Device {\n    function deviceAction() public pure returns (string memory) { return \"Device Action\"; }\n}\ncontract Machine {\n    function machineAction() public pure returns (string memory) { return \"Machine Action\"; }\n}\ncontract Operation {\n    Machine m = new Machine();\n    function executeOperation() public view returns (string memory) {\n        Device d = Device(m);\n        return d.deviceAction();\n    }\n    function unrelatedFunc1() public pure {}\n}",
          "error message": ":1:392: TypeError: Explicit type conversion not allowed from \"contract Machine\" to \"contract Device\".\n ... tring memory) {         Device d = Device(m);         return d.deviceAction();  ...\n                                        ^-------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract Tree {\n    function treeMethod() public pure returns (string memory) { return \"Tree Method\"; }\n}\ncontract Leaf {\n    function leafMethod() public pure returns (string memory) { return \"Leaf Method\"; }\n}\ncontract Nature {\n    Leaf l = new Leaf();\n    function natureTest() public view returns (string memory) {\n        Tree t = Tree(l);\n        return t.treeMethod();\n    }\n    function extraFunc1() public pure {}\n    function extraFunc2() public pure {}\n}",
          "error message": ":1:360: TypeError: Explicit type conversion not allowed from \"contract Leaf\" to \"contract Tree\".\n ... (string memory) {         Tree t = Tree(l);         return t.treeMethod();    ...\n                                        ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Book {\n    function read() public pure returns (string memory) { return \"Reading Book\"; }\n}\ncontract Page {\n    function turn() public pure returns (string memory) { return \"Turning Page\"; }\n}\ncontract Library {\n    Page p = new Page();\n    function checkOut() public view returns (string memory) {\n        Book b = Book(p);\n        return b.read();\n    }\n}",
          "error message": ":1:349: TypeError: Explicit type conversion not allowed from \"contract Page\" to \"contract Book\".\n ... (string memory) {         Book b = Book(p);         return b.read();     } }\n                                        ^-----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract Ocean {\n    function wave() public pure returns (string memory) { return \"Ocean Wave\"; }\n}\ncontract River {\n    function flow() public pure returns (string memory) { return \"River Flow\"; }\n}\ncontract WaterBody {\n    River r = new River();\n    function hydration() public view returns (string memory) {\n        Ocean o = Ocean(r);\n        return o.wave();\n    }\n}",
          "error message": ":1:353: TypeError: Explicit type conversion not allowed from \"contract River\" to \"contract Ocean\".\n ... string memory) {         Ocean o = Ocean(r);         return o.wave();     } }\n                                        ^------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Sun {\n    function shine() public pure returns (string memory) { return \"Sun Shine\"; }\n}\ncontract Moon {\n    function glow() public pure returns (string memory) { return \"Moon Glow\"; }\n}\ncontract Celestial {\n    Moon m = new Moon();\n    function celestialDisplay() public view returns (string memory) {\n        Sun s = Sun(m);\n        return s.shine();\n    }\n}",
          "error message": ":1:352: TypeError: Explicit type conversion not allowed from \"contract Moon\" to \"contract Sun\".\n ...  (string memory) {         Sun s = Sun(m);         return s.shine();     } }\n                                        ^----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract Cat {\n    function meow() public pure returns (string memory) { return \"Cat Meow\"; }\n}\ncontract Dog {\n    function bark() public pure returns (string memory) { return \"Dog Bark\"; }\n}\ncontract Pet {\n    Dog d = new Dog();\n    function petSound() public view returns (string memory) {\n        Cat c = Cat(d);\n        return c.meow();\n    }\n}",
          "error message": ":1:332: TypeError: Explicit type conversion not allowed from \"contract Dog\" to \"contract Cat\".\n ...  (string memory) {         Cat c = Cat(d);         return c.meow();     } }\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract Apple {\n    function taste() public pure returns (string memory) { return \"Apple Taste\"; }\n}\ncontract Banana {\n    function peel() public pure returns (string memory) { return \"Banana Peel\"; }\n}\ncontract Fruit {\n    Banana b = new Banana();\n    function fruitTest() public view returns (string memory) {\n        Apple a = Apple(b);\n        return a.taste();\n    }\n}",
          "error message": ":1:355: TypeError: Explicit type conversion not allowed from \"contract Banana\" to \"contract Apple\".\n ... string memory) {         Apple a = Apple(b);         return a.taste();     } }\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract Chair {\n    function sit() public pure returns (string memory) { return \"Chair Sit\"; }\n}\ncontract Table {\n    function setup() public pure returns (string memory) { return \"Table Setup\"; }\n}\ncontract Furniture {\n    Table t = new Table();\n    function furnitureFunc() public view returns (string memory) {\n        Chair c = Chair(t);\n        return c.sit();\n    }\n}",
          "error message": ":1:357: TypeError: Explicit type conversion not allowed from \"contract Table\" to \"contract Chair\".\n ... string memory) {         Chair c = Chair(t);         return c.sit();     } }\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract Bird {\n    function fly() public pure returns (string memory) { return \"Bird Fly\"; }\n}\ncontract Fish {\n    function swim() public pure returns (string memory) { return \"Fish Swim\"; }\n}\ncontract Animal {\n    Fish f = new Fish();\n    function animalMove() public view returns (string memory) {\n        Bird b = Bird(f);\n        return b.fly();\n    }\n}",
          "error message": ":1:342: TypeError: Explicit type conversion not allowed from \"contract Fish\" to \"contract Bird\".\n ... (string memory) {         Bird b = Bird(f);         return b.fly();     } }\n                                        ^-----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract Alpha {\n    function alphaFunc() public pure returns (string memory) { return \"Alpha Function\"; }\n}\ncontract Beta {\n    function betaFunc() public pure returns (string memory) { return \"Beta Function\"; }\n}\ncontract Convert {\n    Beta b = new Beta();\n    function performConversion() public view returns (string memory) {\n        Alpha a = Alpha(address(b));\n        return a.alphaFunc();\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract Device {\n    function deviceAction() public pure returns (string memory) { return \"Device Action\"; }\n}\ncontract Machine {\n    function machineAction() public pure returns (string memory) { return \"Machine Action\"; }\n}\ncontract Operation {\n    Machine m = new Machine();\n    function executeOperation() public view returns (string memory) {\n        Device d = Device(address(m));\n        return d.deviceAction();\n    }\n    function unrelatedFunc1() public pure {}\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract Tree {\n    function treeMethod() public pure returns (string memory) { return \"Tree Method\"; }\n}\ncontract Leaf {\n    function leafMethod() public pure returns (string memory) { return \"Leaf Method\"; }\n}\ncontract Nature {\n    Leaf l = new Leaf();\n    function natureTest() public view returns (string memory) {\n        Tree t = Tree(address(l));\n        return t.treeMethod();\n    }\n    function extraFunc1() public pure {}\n    function extraFunc2() public pure {}\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Book {\n    function read() public pure returns (string memory) { return \"Reading Book\"; }\n}\ncontract Page {\n    function turn() public pure returns (string memory) { return \"Turning Page\"; }\n}\ncontract Library {\n    Page p = new Page();\n    function checkOut() public view returns (string memory) {\n        Book b = Book(address(p));\n        return b.read();\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract Ocean {\n    function wave() public pure returns (string memory) { return \"Ocean Wave\"; }\n}\ncontract River {\n    function flow() public pure returns (string memory) { return \"River Flow\"; }\n}\ncontract WaterBody {\n    River r = new River();\n    function hydration() public view returns (string memory) {\n        Ocean o = Ocean(address(r));\n        return o.wave();\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Sun {\n    function shine() public pure returns (string memory) { return \"Sun Shine\"; }\n}\ncontract Moon {\n    function glow() public pure returns (string memory) { return \"Moon Glow\"; }\n}\ncontract Celestial {\n    Moon m = new Moon();\n    function celestialDisplay() public view returns (string memory) {\n        Sun s = Sun(address(m));\n        return s.shine();\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract Cat {\n    function meow() public pure returns (string memory) { return \"Cat Meow\"; }\n}\ncontract Dog {\n    function bark() public pure returns (string memory) { return \"Dog Bark\"; }\n}\ncontract Pet {\n    Dog d = new Dog();\n    function petSound() public view returns (string memory) {\n        Cat c = Cat(address(d));\n        return c.meow();\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract Apple {\n    function taste() public pure returns (string memory) { return \"Apple Taste\"; }\n}\ncontract Banana {\n    function peel() public pure returns (string memory) { return \"Banana Peel\"; }\n}\ncontract Fruit {\n    Banana b = new Banana();\n    function fruitTest() public view returns (string memory) {\n        Apple a = Apple(address(b));\n        return a.taste();\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract Chair {\n    function sit() public pure returns (string memory) { return \"Chair Sit\"; }\n}\ncontract Table {\n    function setup() public pure returns (string memory) { return \"Table Setup\"; }\n}\ncontract Furniture {\n    Table t = new Table();\n    function furnitureFunc() public view returns (string memory) {\n        Chair c = Chair(address(t));\n        return c.sit();\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract Bird {\n    function fly() public pure returns (string memory) { return \"Bird Fly\"; }\n}\ncontract Fish {\n    function swim() public pure returns (string memory) { return \"Fish Swim\"; }\n}\ncontract Animal {\n    Fish f = new Fish();\n    function animalMove() public view returns (string memory) {\n        Bird b = Bird(address(f));\n        return b.fly();\n    }\n}"
      }
    }
  },
  {
    "Changes56": {
      "Version Migration": "->0.5",
      "Knowledge": "The <code>address</code> type  was split into <code>address</code> and <code>address payable</code>,\nwhere only <code>address payable</code> provides the <code>transfer</code> function.  An\n<code>address payable</code> can be directly converted to an <code>address</code>, but the\nother way around is not allowed. Converting <code>address</code> to <code>address\npayable</code> is possible via conversion through <code>uint160</code>. If <code>c</code> is a\ncontract, <code>address(c)</code> results in <code>address payable</code> only if <code>c</code> has a\npayable fallback function. If you use the <a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/common-patterns.html#withdrawal-pattern\"><span class=\"std std-ref\">withdraw pattern</a>,\nyou most likely do not have to change your code because <code>transfer</code>\nis only used on <code>msg.sender</code> instead of stored addresses and <code>msg.sender</code>\nis an <code>address payable</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract PaymentProcessor {\n    address admin;\n    constructor() public { admin = msg.sender; }\n    function sendFunds(uint amount) public { admin.transfer(amount); }\n    function logEvent() public { }\n}",
          "error message": ":1:165: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... on sendFunds(uint amount) public { admin.transfer(amount); }     function logEvent() ...\n                                        ^------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract AccountManager {\n    address userAccount;\n    constructor() public { userAccount = msg.sender; }\n    function issuePayment(uint256 sum) public { userAccount.transfer(sum); }\n    function helper() public pure returns (bool) { return true; }\n    function util() public { }\n}",
          "error message": ":1:178: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... issuePayment(uint256 sum) public { userAccount.transfer(sum); }     function helper() publ ...\n                                        ^------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract FundTransfer {\n    address ownerAddress;\n    constructor() public { ownerAddress = msg.sender; }\n    function transferAmount(uint amount) public { ownerAddress.transfer(amount); }\n}",
          "error message": ":1:180: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... ansferAmount(uint amount) public { ownerAddress.transfer(amount); } }\n                                        ^-------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract AssetDistributor {\n    address assetHolder;\n    constructor() public { assetHolder = msg.sender; }\n    function distributeAssets(uint total) public { assetHolder.transfer(total); }\n    function checkBalance() public view returns (uint) { return address(this).balance; }\n}",
          "error message": ":1:183: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... tributeAssets(uint total) public { assetHolder.transfer(total); }     function checkBalanc ...\n                                        ^------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract CashOut {\n    address beneficiary;\n    constructor() public { beneficiary = msg.sender; }\n    function cashOutFunds(uint value) public { beneficiary.transfer(value); }\n    function extraFunction() public pure {}\n}",
          "error message": ":1:170: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ...  cashOutFunds(uint value) public { beneficiary.transfer(value); }     function extraFuncti ...\n                                        ^------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract MoneySender {\n    address payable public payee;\n    constructor() public { payee = msg.sender; }\n    function sendMoney(uint cash) public { payee.transfer(cash); }\n    function logTransaction() public { }\n}",
          "error message": ""
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract PaymentGateway {\n    address client;\n    constructor() public { client = msg.sender; }\n    function executePayment(uint cashOut) public { client.transfer(cashOut); }\n    function logData() public { }\n    function extraData() public pure {}\n}",
          "error message": ":1:171: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... cutePayment(uint cashOut) public { client.transfer(cashOut); }     function logData() ...\n                                        ^-------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ExpenseHandler {\n    address holder;\n    constructor() public { holder = msg.sender; }\n    function handleWithdraw(uint amount) public { holder.transfer(amount); }\n}",
          "error message": ":1:170: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... ndleWithdraw(uint amount) public { holder.transfer(amount); } }\n                                        ^-------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract TransactionManager {\n    address accountManager;\n    constructor() public { accountManager = msg.sender; }\n    function processTransaction(uint quantity) public { accountManager.transfer(quantity); }\n    function recordActivity() public { }\n}",
          "error message": ":1:196: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... ransaction(uint quantity) public { accountManager.transfer(quantity); }     function recordAc ...\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract FinanceController {\n    address financeAdmin;\n    constructor() public { financeAdmin = msg.sender; }\n    function disburseFunds(uint funds) public { financeAdmin.transfer(funds); }\n    function extraLog() public { }\n    function additionalHelper() public pure returns (string memory) { return \"Helper\"; }\n}",
          "error message": ":1:183: TypeError: Member \"transfer\" not found or not visible after argument-dependent lookup in address.\n ... disburseFunds(uint funds) public { financeAdmin.transfer(funds); }     function extraLog()  ...\n                                        ^-------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract PaymentProcessor {\n    address payable admin;\n    constructor() public { admin = msg.sender; }\n    function sendFunds(uint amount) public { admin.transfer(amount); }\n    function logEvent() public { }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract AccountManager {\n    address payable userAccount;\n    constructor() public { userAccount = msg.sender; }\n    function issuePayment(uint256 sum) public { userAccount.transfer(sum); }\n    function helper() public pure returns (bool) { return true; }\n    function util() public { }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract FundTransfer {\n    address payable ownerAddress;\n    constructor() public { ownerAddress = msg.sender; }\n    function transferAmount(uint amount) public { ownerAddress.transfer(amount); }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract AssetDistributor {\n    address payable assetHolder;\n    constructor() public { assetHolder = msg.sender; }\n    function distributeAssets(uint total) public { assetHolder.transfer(total); }\n    function checkBalance() public view returns (uint) { return address(this).balance; }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract CashOut {\n    address payable beneficiary;\n    constructor() public { beneficiary = msg.sender; }\n    function cashOutFunds(uint value) public { beneficiary.transfer(value); }\n    function extraFunction() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract MoneySender {\n    address payable payee;\n    constructor() public { payee = msg.sender; }\n    function sendMoney(uint cash) public { payee.transfer(cash); }\n    function logTransaction() public { }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract PaymentGateway {\n    address payable client;\n    constructor() public { client = msg.sender; }\n    function executePayment(uint cashOut) public { client.transfer(cashOut); }\n    function logData() public { }\n    function extraData() public pure {}\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ExpenseHandler {\n    address payable holder;\n    constructor() public { holder = msg.sender; }\n    function handleWithdraw(uint amount) public { holder.transfer(amount); }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract TransactionManager {\n    address payable accountManager;\n    constructor() public { accountManager = msg.sender; }\n    function processTransaction(uint quantity) public { accountManager.transfer(quantity); }\n    function recordActivity() public { }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract FinanceController {\n    address payable financeAdmin;\n    constructor() public { financeAdmin = msg.sender; }\n    function disburseFunds(uint funds) public { financeAdmin.transfer(funds); }\n    function extraLog() public { }\n    function additionalHelper() public pure returns (string memory) { return \"Helper\"; }\n}"
      }
    }
  },
  {
    "Changes57": {
      "Version Migration": "->0.5",
      "Knowledge": "Conversions between <code>bytesX</code> and <code>uintY</code> of different size are now\ndisallowed due to <code>bytesX</code> padding on the right and <code>uintY</code> padding on\nthe left which may cause unexpected conversion results.  The size must now be\nadjusted within the type before the conversion.  For example, you can convert\na <code>bytes4</code> (4 bytes) to a <code>uint64</code> (8 bytes) by first converting the\n<code>bytes4</code> variable to <code>bytes8</code> and then to <code>uint64</code>. You get the\nopposite padding when converting through <code>uint32</code>. Before v0.5.0 any\nconversion between <code>bytesX</code> and <code>uintY</code> would go through <code>uint8X</code>. For\nexample <code>uint8(bytes3(0x291807))</code> would be converted to <code>uint8(uint24(bytes3(0x291807)))</code>\n(the result is <code>0x07</code>).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionOne {\n    function convertOne() public pure returns (uint) {\n        bytes3 b = 0x123456;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:154: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x123456;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionTwo {\n    function convertTwo() public pure returns (uint) {\n        bytes3 b = 0xabcdef;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function dummy() public pure {}\n}",
          "error message": ":1:154: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xabcdef;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionThree {\n    function convertThree() public pure returns (uint) {\n        bytes3 b = 0xfedcba;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function dummy() public pure {}\n    function dummyTwo() public pure {}\n}",
          "error message": ":1:158: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xfedcba;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionFour {\n    function convertFour() public pure returns (uint) {\n        bytes3 b = 0x456789;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:156: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x456789;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionFive {\n    function quickConvert() public pure returns (uint) {\n        bytes3 b = 0x998877;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function nonRelated() public pure {}\n}",
          "error message": ":1:157: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x998877;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionSix {\n    function dataChange() public pure returns (uint) {\n        bytes3 b = 0xa1b2c3;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:154: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xa1b2c3;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionSeven {\n    function shiftBytes() public pure returns (uint) {\n        bytes3 b = 0x1a2b3c;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:156: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x1a2b3c;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionEight {\n    function byteToUint() public pure returns (uint) {\n        bytes3 b = 0xabcdef;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function extraFunc() public pure {}\n}",
          "error message": ":1:156: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xabcdef;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionNine {\n    function transformData() public pure returns (uint) {\n        bytes3 b = 0x123abc;\n        uint32 num = uint32(b);\n        return num;\n    }\n    function extraOne() public pure {}\n    function extraTwo() public pure {}\n}",
          "error message": ":1:158: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0x123abc;         uint32 num = uint32(b);         return num;     }     fun ...\n                                        ^-------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ConversionTen {\n    function finalConvert() public pure returns (uint) {\n        bytes3 b = 0xabc123;\n        uint32 num = uint32(b);\n        return num;\n    }\n}",
          "error message": ":1:156: TypeError: Explicit type conversion not allowed from \"bytes3\" to \"uint32\".\n ... b = 0xabc123;         uint32 num = uint32(b);         return num;     } }\n                                        ^-------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ConversionOne {\n    function convertOne() public pure returns (uint) {\n        bytes3 b = 0x123456;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ConversionTwo {\n    function convertTwo() public pure returns (uint) {\n        bytes3 b = 0xabcdef;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function dummy() public pure {}\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ConversionThree {\n    function convertThree() public pure returns (uint) {\n        bytes3 b = 0xfedcba;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function dummy() public pure {}\n    function dummyTwo() public pure {}\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ConversionFour {\n    function convertFour() public pure returns (uint) {\n        bytes3 b = 0x456789;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ConversionFive {\n    function quickConvert() public pure returns (uint) {\n        bytes3 b = 0x998877;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function nonRelated() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ConversionSix {\n    function dataChange() public pure returns (uint) {\n        bytes3 b = 0xa1b2c3;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ConversionSeven {\n    function shiftBytes() public pure returns (uint) {\n        bytes3 b = 0x1a2b3c;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ConversionEight {\n    function byteToUint() public pure returns (uint) {\n        bytes3 b = 0xabcdef;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function extraFunc() public pure {}\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ConversionNine {\n    function transformData() public pure returns (uint) {\n        bytes3 b = 0x123abc;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n    function extraOne() public pure {}\n    function extraTwo() public pure {}\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ConversionTen {\n    function finalConvert() public pure returns (uint) {\n        bytes3 b = 0xabc123;\n        bytes32 b32 = bytes32(b);\n        bytes4 b4 = bytes4(b32);\n        uint32 num = uint32(b4);\n        return num;\n    }\n}"
      }
    }
  },
  {
    "Changes58": {
      "Version Migration": "->0.5",
      "Knowledge": "Using <code>msg.value</code> in non-payable functions (or introducing it via a\nmodifier) is disallowed as a security feature. Turn the function into\n<code>payable</code> or create a new internal function for the program logic that\nuses <code>msg.value</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract FundsTracker {\n    uint public totalFunds;\n    function increaseFunds() public {\n        totalFunds += msg.value;\n    }\n    function queryFunds() public view returns (uint) {\n        return totalFunds;\n    }\n}",
          "error message": ":1:136: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... s() public {         totalFunds += msg.value;     }     function queryFunds() p ...\n                                        ^-------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract AccountBalance {\n    uint public accountTotal;\n    function addToBalance() public {\n        accountTotal += msg.value;\n    }\n}",
          "error message": ":1:141: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... ) public {         accountTotal += msg.value;     } }\n                                        ^-------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract MoneyBox {\n    uint public savings;\n    function deposit() public {\n        savings += msg.value;\n    }\n    function checkSavings() public view returns (uint) {\n        return savings;\n    }\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:120: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... osit() public {         savings += msg.value;     }     function checkSavings() ...\n                                        ^-------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Transaction {\n    uint public transactions;\n    function addTransaction() public {\n        transactions += msg.value;\n    }\n}",
          "error message": ":1:140: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... ) public {         transactions += msg.value;     } }\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ContributionTracker {\n    uint public contributions;\n    function recordContribution() public {\n        contributions += msg.value;\n    }\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
          "error message": ":1:154: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ...  public {         contributions += msg.value;     }     function extraFunction1 ...\n                                        ^-------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract PaymentRecorder {\n    uint public payments;\n    function recordPayment() public {\n        payments += msg.value;\n    }\n    function extraFunction2() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": ":1:135: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... ent() public {         payments += msg.value;     }     function extraFunction2 ...\n                                        ^-------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract FundPool {\n    uint public poolBalance;\n    function contribute() public {\n        poolBalance += msg.value;\n    }\n}",
          "error message": ":1:131: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\npragma solidity^0.5.0; contract FundPool {     uint public poolBalance;     function contribute() public {         poolBalance += msg.value;     } }\n                                                                                                                                  ^-------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract CashRegister {\n    uint public cashTotal;\n    function receivePayment() public {\n        cashTotal += msg.value;\n    }\n    function anotherFunction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:135: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... nt() public {         cashTotal += msg.value;     }     function anotherFunctio ...\n                                        ^-------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract Wallet {\n    uint public walletBalance;\n    function receiveFunds() public {\n        walletBalance += msg.value;\n    }\n}",
          "error message": ":1:135: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ...  public {         walletBalance += msg.value;     } }\n                                        ^-------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract DonationBox {\n    uint public totalDonations;\n    function addDonation() public {\n        totalDonations += msg.value;\n    }\n    function someExtraFunction() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": ":1:141: TypeError: \"msg.value\" can only be used in payable public functions. Make the function \"payable\" or use an internal function to avoid this error.\n ... public {         totalDonations += msg.value;     }     function someExtraFunct ...\n                                        ^-------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract FundsTracker {\n    uint public totalFunds;\n    function increaseFunds() public payable {\n        totalFunds += msg.value;\n    }\n    function queryFunds() public view returns (uint) {\n        return totalFunds;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract AccountBalance {\n    uint public accountTotal;\n    function addToBalance() public payable {\n        accountTotal += msg.value;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract MoneyBox {\n    uint public savings;\n    function deposit() public payable {\n        savings += msg.value;\n    }\n    function checkSavings() public view returns (uint) {\n        return savings;\n    }\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Transaction {\n    uint public transactions;\n    function addTransaction() public payable {\n        transactions += msg.value;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ContributionTracker {\n    uint public contributions;\n    function recordContribution() public payable {\n        contributions += msg.value;\n    }\n    function extraFunction1() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract PaymentRecorder {\n    uint public payments;\n    function recordPayment() public payable {\n        payments += msg.value;\n    }\n    function extraFunction2() public pure returns (int) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract FundPool {\n    uint public poolBalance;\n    function contribute() public payable {\n        poolBalance += msg.value;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract CashRegister {\n    uint public cashTotal;\n    function receivePayment() public payable {\n        cashTotal += msg.value;\n    }\n    function anotherFunction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract Wallet {\n    uint public walletBalance;\n    function receiveFunds() public payable {\n        walletBalance += msg.value;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract DonationBox {\n    uint public totalDonations;\n    function addDonation() public payable {\n        totalDonations += msg.value;\n    }\n    function someExtraFunction() public pure returns (uint) {\n        return 123;\n    }\n}"
      }
    }
  },
  {
    "Changes59": {
      "Version Migration": "->0.5",
      "Knowledge": "Constructors must now be defined using the <code>constructor</code> keyword.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract Asset {\n    uint internal totalSupply;\n    function Asset(uint supply) public {\n        totalSupply = supply;\n    }\n    function getTotalSupply() public view returns (uint) {\n        return totalSupply;\n    }\n    function incrementSupply() public {\n        totalSupply += 1;\n    }\n}",
          "error message": ":1:76: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ...     uint internal totalSupply;     function Asset(uint supply) public {         totalSupply = supply;     }     function getTotalSupply() publ ...\n                                        ^----------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract Book {\n    uint public pageCount;\n    function Book(uint initialPages) public {\n        pageCount = initialPages;\n    }\n    function addPage() public {\n        pageCount += 1;\n    }\n}",
          "error message": ":1:71: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... k {     uint public pageCount;     function Book(uint initialPages) public {         pageCount = initialPages;     }     function addPage() public {    ...\n                                        ^-------------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract Vehicle {\n    uint internal mileage;\n    function Vehicle(uint initialMileage) public {\n        mileage = initialMileage;\n    }\n    function getMileage() public view returns (uint) {\n        return mileage;\n    }\n}",
          "error message": ":1:74: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... e {     uint internal mileage;     function Vehicle(uint initialMileage) public {         mileage = initialMileage;     }     function getMileage() public v ...\n                                        ^------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Product {\n    uint stockQuantity;\n    function Product(uint initialStock) public {\n        stockQuantity = initialStock;\n    }\n    function decrementStock() public {\n        if (stockQuantity > 0) {\n            stockQuantity -= 1;\n        }\n    }\n}",
          "error message": ":1:71: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... duct {     uint stockQuantity;     function Product(uint initialStock) public {         stockQuantity = initialStock;     }     function decrementStock() publ ...\n                                        ^--------------------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract Token {\n    uint public balance;\n    function Token(uint initialBalance) public {\n        balance = initialBalance;\n    }\n    function increaseBalance(uint amount) public {\n        balance += amount;\n    }\n}",
          "error message": ":1:70: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... ken {     uint public balance;     function Token(uint initialBalance) public {         balance = initialBalance;     }     function increaseBalance(uint  ...\n                                        ^----------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Member {\n    uint public age;\n    function Member(uint initialAge) public {\n        age = initialAge;\n    }\n    function celebrateBirthday() public {\n        age += 1;\n    }\n    function setNewAge(uint newAge) public {\n        age = newAge;\n    }\n}",
          "error message": ":1:67: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ...  Member {     uint public age;     function Member(uint initialAge) public {         age = initialAge;     }     function celebrateBirthday() p ...\n                                        ^-----------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract Coin {\n    uint public count;\n    function Coin(uint initialCount) public {\n        count = initialCount;\n    }\n    function increment() public {\n        count += 10;\n    }\n}",
          "error message": ":1:67: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ...  Coin {     uint public count;     function Coin(uint initialCount) public {         count = initialCount;     }     function increment() public {  ...\n                                        ^---------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract Box {\n    uint internal size;\n    function Box(uint initialSize) public {\n        size = initialSize;\n    }\n    function increaseSize() public {\n        size += 5;\n    }\n}",
          "error message": ":1:67: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ...  Box {     uint internal size;     function Box(uint initialSize) public {         size = initialSize;     }     function increaseSize() public ...\n                                        ^-----------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract Computer {\n    uint public processorSpeed;\n    function Computer(uint speed) public {\n        processorSpeed = speed;\n    }\n    function upgradeSpeed(uint increment) public {\n        processorSpeed += increment;\n    }\n}",
          "error message": ":1:80: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ...    uint public processorSpeed;     function Computer(uint speed) public {         processorSpeed = speed;     }     function upgradeSpeed(uint inc ...\n                                        ^--------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract Lamp {\n    uint public wattage;\n    function Lamp(uint initialWattage) public {\n        wattage = initialWattage;\n    }\n    function increaseWattage(uint amount) public {\n        wattage += amount;\n    }\n}",
          "error message": ":1:69: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use \"constructor(...) { ... }\" to define it.\n ... amp {     uint public wattage;     function Lamp(uint initialWattage) public {         wattage = initialWattage;     }     function increaseWattage(uint  ...\n                                        ^---------------------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract Asset {\n    uint internal totalSupply;\n    constructor(uint supply) public {\n        totalSupply = supply;\n    }\n    function getTotalSupply() public view returns (uint) {\n        return totalSupply;\n    }\n    function incrementSupply() public {\n        totalSupply += 1;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract Book {\n    uint public pageCount;\n    constructor(uint initialPages) public {\n        pageCount = initialPages;\n    }\n    function addPage() public {\n        pageCount += 1;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract Vehicle {\n    uint internal mileage;\n    constructor(uint initialMileage) public {\n        mileage = initialMileage;\n    }\n    function getMileage() public view returns (uint) {\n        return mileage;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Product {\n    uint stockQuantity;\n    constructor(uint initialStock) public {\n        stockQuantity = initialStock;\n    }\n    function decrementStock() public {\n        if (stockQuantity > 0) {\n            stockQuantity -= 1;\n        }\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract Token {\n    uint public balance;\n    constructor(uint initialBalance) public {\n        balance = initialBalance;\n    }\n    function increaseBalance(uint amount) public {\n        balance += amount;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Member {\n    uint public age;\n    constructor(uint initialAge) public {\n        age = initialAge;\n    }\n    function celebrateBirthday() public {\n        age += 1;\n    }\n    function setNewAge(uint newAge) public {\n        age = newAge;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract Coin {\n    uint public count;\n    constructor(uint initialCount) public {\n        count = initialCount;\n    }\n    function increment() public {\n        count += 10;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract Box {\n    uint internal size;\n    constructor(uint initialSize) public {\n        size = initialSize;\n    }\n    function increaseSize() public {\n        size += 5;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract Computer {\n    uint public processorSpeed;\n    constructor(uint speed) public {\n        processorSpeed = speed;\n    }\n    function upgradeSpeed(uint increment) public {\n        processorSpeed += increment;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract Lamp {\n    uint public wattage;\n    constructor(uint initialWattage) public {\n        wattage = initialWattage;\n    }\n    function increaseWattage(uint amount) public {\n        wattage += amount;\n    }\n}"
      }
    }
  },
  {
    "Changes60": {
      "Version Migration": "->0.5",
      "Knowledge": "Calling base constructors without parentheses is now disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract BaseOne {\n    uint data;\n    constructor(uint x) { data = x; }\n}\ncontract ChildOne is BaseOne(5) {}",
          "error message": ":1:62: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract BaseOne {     uint data;     constructor(uint x) { data = x; } } contract ChildOne is BaseOne(5) {}\n                                                             ^-------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract Storage {\n    uint amount;\n    constructor(uint x) { amount = x; }\n}\ncontract Keeper is Storage(100) {}",
          "error message": ":1:64: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract Storage {     uint amount;     constructor(uint x) { amount = x; } } contract Keeper is Storage(100) {}\n                                                               ^---------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract Record {\n    uint counter;\n    constructor(uint num) { counter = num; }\n}\ncontract Log is Record(42) {\n    function add() public { counter++; }\n}",
          "error message": ":1:64: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... act Record {     uint counter;     constructor(uint num) { counter = num; } } contract Log is Record(42) {     ...\n                                        ^--------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Item {\n    uint stock;\n    constructor(uint initialStock) { stock = initialStock; }\n}\ncontract Inventory is Item(150) {\n    function decrement() public { stock--; }\n    function increment() public { stock++; }\n}",
          "error message": ":1:60: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... ontract Item {     uint stock;     constructor(uint initialStock) { stock = initialStock; } } contract Inventory is Item(150)  ...\n                                        ^------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract Balance {\n    uint balance;\n    constructor(uint initBal) { balance = initBal; }\n}\ncontract Account is Balance(2000) {}",
          "error message": ":1:65: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... ct Balance {     uint balance;     constructor(uint initBal) { balance = initBal; } } contract Account is Balance(2000 ...\n                                        ^----------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Asset {\n    uint value;\n    constructor(uint initValue) { value = initValue; }\n}\ncontract Property is Asset(3000) {\n    function assess() public { value += 500; }\n}",
          "error message": ":1:61: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ... ntract Asset {     uint value;     constructor(uint initValue) { value = initValue; } } contract Property is Asset(3000) ...\n                                        ^------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract Box {\n    uint size;\n    constructor(uint sz) { size = sz; }\n}\ncontract Container is Box(500) {\n    function expand() public { size *= 2; }\n    function reduce() public { size /= 2; }\n}",
          "error message": ":1:58: SyntaxError: No visibility specified. Did you intend to add \"public\"?\n ...  contract Box {     uint size;     constructor(uint sz) { size = sz; } } contract Container is Box(500) { ...\n                                        ^---------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract Coin {\n    uint public count;\n    constructor(uint initCount) { count = initCount; }\n}\ncontract Purse is Coin(25) {}",
          "error message": ":1:67: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract Coin {     uint public count;     constructor(uint initCount) { count = initCount; } } contract Purse is Coin(25) {}\n                                                                  ^------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract BaseTen {\n    uint num;\n    constructor(uint number) { num = number; }\n}\ncontract DerivedTen is BaseTen(10) {}",
          "error message": ":1:61: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract BaseTen {     uint num;     constructor(uint number) { num = number; } } contract DerivedTen is BaseTen(10) {}\n                                                            ^----------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract Mark {\n    uint score;\n    constructor(uint initScore) { score = initScore; }\n}\ncontract Grade is Mark(88) {}",
          "error message": ":1:60: SyntaxError: No visibility specified. Did you intend to add \"public\"?\npragma solidity^0.5.0; contract Mark {     uint score;     constructor(uint initScore) { score = initScore; } } contract Grade is Mark(88) {}\n                                                           ^------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract BaseOne {\n    uint data;\n    constructor(uint x) public { data = x; }\n}\ncontract ChildOne is BaseOne {\n    constructor(uint init) BaseOne(init) public {}\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract Storage {\n    uint amount;\n    constructor(uint x) public { amount = x; }\n}\ncontract Keeper is Storage {\n    constructor(uint init) Storage(init) public {}\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract Record {\n    uint counter;\n    constructor(uint num) public { counter = num; }\n}\ncontract Log is Record {\n    constructor(uint init) Record(init) public {}\n    function add() public { counter++; }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Item {\n    uint stock;\n    constructor(uint initialStock) public { stock = initialStock; }\n}\ncontract Inventory is Item {\n    constructor(uint init) Item(init) public {}\n    function decrement() public { stock--; }\n    function increment() public { stock++; }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract Balance {\n    uint balance;\n    constructor(uint initBal) public { balance = initBal; }\n}\ncontract Account is Balance {\n    constructor(uint init) Balance(init) public {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Asset {\n    uint value;\n    constructor(uint initValue) public { value = initValue; }\n}\ncontract Property is Asset {\n    constructor(uint init) Asset(init) public {}\n    function assess() public { value += 500; }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract Box {\n    uint size;\n    constructor(uint sz) public { size = sz; }\n}\ncontract Container is Box {\n    constructor(uint init) Box(init) public {}\n    function expand() public { size *= 2; }\n    function reduce() public { size /= 2; }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract Coin {\n    uint public count;\n    constructor(uint initCount) public { count = initCount; }\n}\ncontract Purse is Coin {\n    constructor(uint init) Coin(init) public {}\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract BaseTen {\n    uint num;\n    constructor(uint number) public { num = number; }\n}\ncontract DerivedTen is BaseTen {\n    constructor(uint init) BaseTen(init) public {}\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract Mark {\n    uint score;\n    constructor(uint initScore) public { score = initScore; }\n}\ncontract Grade is Mark {\n    constructor(uint init) Mark(init) public {}\n}"
      }
    }
  },
  {
    "Changes61": {
      "Version Migration": "->0.5",
      "Knowledge": "<code>suicide</code> is now disallowed (in favor of <code>selfdestruct</code>).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Wallet {\n    address payable owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function terminate() public {\n        require(msg.sender == owner);\n        suicide(owner);\n    }\n\n    function deposit() public payable {}\n}",
          "error message": ":1:213: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... uire(msg.sender == owner);         suicide(owner);     }      function deposit() pub ...\n                                        ^------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\n\ncontract BankAccount {\n    address payable public accountOwner;\n\n    constructor() public {\n        accountOwner = msg.sender;\n    }\n\n    function destructContract() public {\n        require(msg.sender == accountOwner);\n        suicide(accountOwner);\n    }\n\n    function withdraw(uint amount) public {}\n    function getBalance() public view returns (uint) {}\n}",
          "error message": ":1:253: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... g.sender == accountOwner);         suicide(accountOwner);     }      function withdraw(uint ...\n                                        ^-------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Safe {\n    address payable private safeOwner;\n\n    constructor() public {\n        safeOwner = msg.sender;\n    }\n\n    function destroySafe() public {\n        if (msg.sender == safeOwner) {\n            suicide(safeOwner);\n        }\n    }\n}",
          "error message": ":1:234: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... sender == safeOwner) {             suicide(safeOwner);         }     } }\n                                        ^----------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\n\ncontract MyContract {\n    address payable public creator;\n\n    constructor() public {\n        creator = msg.sender;\n    }\n\n    function end() public {\n        require(msg.sender == creator);\n        suicide(creator);\n    }\n\n    function helper() private pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:224: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... re(msg.sender == creator);         suicide(creator);     }      function helper() priv ...\n                                        ^--------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Asset {\n    address payable public holder;\n\n    constructor() public {\n        holder = msg.sender;\n    }\n\n    function closeAsset() public {\n        require(msg.sender == holder);\n        suicide(holder);\n    }\n\n    function ping() public pure returns (string memory) {\n        return \"pong\";\n    }\n}",
          "error message": ":1:223: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... ire(msg.sender == holder);         suicide(holder);     }      function ping() public ...\n                                        ^-------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Membership {\n    address payable member;\n\n    constructor() public {\n        member = msg.sender;\n    }\n\n    function cancelMembership() public {\n        if (msg.sender == member) {\n            suicide(member);\n        }\n    }\n}",
          "error message": ":1:228: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... sg.sender == member) {             suicide(member);         }     } }\n                                        ^-------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\n\ncontract DepositBox {\n    address payable depositor;\n\n    constructor() public {\n        depositor = msg.sender;\n    }\n\n    function shutdown() public {\n        require(msg.sender == depositor);\n        suicide(depositor);\n    }\n}",
          "error message": ":1:228: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... (msg.sender == depositor);         suicide(depositor);     } }\n                                        ^----------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Company {\n    address payable ceo;\n\n    constructor() public {\n        ceo = msg.sender;\n    }\n\n    function dissolve() public {\n        require(msg.sender == ceo);\n        suicide(ceo);\n    }\n\n    function logEvent() public {}\n}",
          "error message": ":1:207: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... equire(msg.sender == ceo);         suicide(ceo);     }      function logEvent() pu ...\n                                        ^----------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Project {\n    address payable projectLead;\n\n    constructor() public {\n        projectLead = msg.sender;\n    }\n\n    function finalize() public {\n        if (msg.sender == projectLead) {\n            suicide(projectLead);\n        }\n    }\n\n    function addData(uint data) public {}\n}",
          "error message": ":1:232: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... nder == projectLead) {             suicide(projectLead);         }     }      function add ...\n                                        ^------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\n\ncontract Fundraiser {\n    address payable organizer;\n\n    constructor() public {\n        organizer = msg.sender;\n    }\n\n    function endFundraiser() public {\n        require(msg.sender == organizer);\n        suicide(organizer);\n    }\n}",
          "error message": ":1:233: TypeError: \"suicide\" has been deprecated in favour of \"selfdestruct\"\n ... (msg.sender == organizer);         suicide(organizer);     } }\n                                        ^----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\n\ncontract Wallet {\n    address payable owner;\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    function terminate() public {\n        require(msg.sender == owner);\n        selfdestruct(owner);\n    }\n\n    function deposit() public payable {}\n}",
        "Example2": "pragma solidity ^0.5.0;\n\ncontract BankAccount {\n    address payable public accountOwner;\n\n    constructor() public {\n        accountOwner = msg.sender;\n    }\n\n    function destructContract() public {\n        require(msg.sender == accountOwner);\n        selfdestruct(accountOwner);\n    }\n\n    function withdraw(uint amount) public {}\n    function getBalance() public view returns (uint) {}\n}",
        "Example3": "pragma solidity ^0.5.0;\n\ncontract Safe {\n    address payable private safeOwner;\n\n    constructor() public {\n        safeOwner = msg.sender;\n    }\n\n    function destroySafe() public {\n        if (msg.sender == safeOwner) {\n            selfdestruct(safeOwner);\n        }\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\n\ncontract MyContract {\n    address payable public creator;\n\n    constructor() public {\n        creator = msg.sender;\n    }\n\n    function end() public {\n        require(msg.sender == creator);\n        selfdestruct(creator);\n    }\n\n    function helper() private pure returns (uint) {\n        return 42;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\n\ncontract Asset {\n    address payable public holder;\n\n    constructor() public {\n        holder = msg.sender;\n    }\n\n    function closeAsset() public {\n        require(msg.sender == holder);\n        selfdestruct(holder);\n    }\n\n    function ping() public pure returns (string memory) {\n        return \"pong\";\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\n\ncontract Membership {\n    address payable member;\n\n    constructor() public {\n        member = msg.sender;\n    }\n\n    function cancelMembership() public {\n        if (msg.sender == member) {\n            selfdestruct(member);\n        }\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\n\ncontract DepositBox {\n    address payable depositor;\n\n    constructor() public {\n        depositor = msg.sender;\n    }\n\n    function shutdown() public {\n        require(msg.sender == depositor);\n        selfdestruct(depositor);\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\n\ncontract Company {\n    address payable ceo;\n\n    constructor() public {\n        ceo = msg.sender;\n    }\n\n    function dissolve() public {\n        require(msg.sender == ceo);\n        selfdestruct(ceo);\n    }\n\n    function logEvent() public {}\n}",
        "Example9": "pragma solidity ^0.5.0;\n\ncontract Project {\n    address payable projectLead;\n\n    constructor() public {\n        projectLead = msg.sender;\n    }\n\n    function finalize() public {\n        if (msg.sender == projectLead) {\n            selfdestruct(projectLead);\n        }\n    }\n\n    function addData(uint data) public {}\n}",
        "Example10": "pragma solidity ^0.5.0;\n\ncontract Fundraiser {\n    address payable organizer;\n\n    constructor() public {\n        organizer = msg.sender;\n    }\n\n    function endFundraiser() public {\n        require(msg.sender == organizer);\n        selfdestruct(organizer);\n    }\n}"
      }
    }
  },
  {
    "Changes62": {
      "Version Migration": "->0.5",
      "Knowledge": "<code>sha3</code> is now disallowed (in favor of <code>keccak256</code>).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorA {\n    function calculateHash(bytes32 input) public pure returns (bytes32) {\n        return sha3(input);\n    }\n    function extraFunctionA() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": ":1:139: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(input);     }     function extraFunctionA ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorB {\n    function hashData(bytes32 data) public pure returns (bytes32) {\n        return sha3(data);\n    }\n    function extraFunctionB(uint x) public pure returns (uint) {\n        return x + 1;\n    }\n}",
          "error message": ":1:133: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(data);     }     function extraFunctionB ...\n                                        ^--------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorC {\n    function getHash(bytes32 payload) public pure returns (bytes32) {\n        return sha3(payload);\n    }\n}",
          "error message": ":1:135: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(payload);     } }\n                                        ^-----------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorD {\n    function produceHash(bytes32 info) public pure returns (bytes32) {\n        return sha3(info);\n    }\n    function extraFunctionD1() public pure returns (uint) {\n        return 42;\n    }\n    function extraFunctionD2() public pure returns (uint) {\n        return 24;\n    }\n}",
          "error message": ":1:136: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(info);     }     function extraFunctionD ...\n                                        ^--------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorE {\n    function computeHash(bytes32 details) public pure returns (bytes32) {\n        return sha3(details);\n    }\n}",
          "error message": ":1:139: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(details);     } }\n                                        ^-----------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorF {\n    function makeHash(bytes32 element) public pure returns (bytes32) {\n        return sha3(element);\n    }\n}",
          "error message": ":1:136: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(element);     } }\n                                        ^-----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorG {\n    function createHash(bytes32 item) public pure returns (bytes32) {\n        return sha3(item);\n    }\n    function extraFunctionG() public pure returns (uint) {\n        return 99;\n    }\n}",
          "error message": ":1:135: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(item);     }     function extraFunctionG ...\n                                        ^--------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorH {\n    function deriveHash(bytes32 parameter) public pure returns (bytes32) {\n        return sha3(parameter);\n    }\n}",
          "error message": ":1:140: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(parameter);     } }\n                                        ^-------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorI {\n    function obtainHash(bytes32 attribute) public pure returns (bytes32) {\n        return sha3(attribute);\n    }\n    function extraFunctionI() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": ":1:140: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(attribute);     }     function extraFunctionI ...\n                                        ^-------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract HashGeneratorJ {\n    function encodeHash(bytes32 factor) public pure returns (bytes32) {\n        return sha3(factor);\n    }\n}",
          "error message": ":1:137: TypeError: \"sha3\" has been deprecated in favour of \"keccak256\"\n ... returns (bytes32) {         return sha3(factor);     } }\n                                        ^----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract HashGeneratorA {\n    function calculateHash(bytes32 input) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(input));\n    }\n    function extraFunctionA() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract HashGeneratorB {\n    function hashData(bytes32 data) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(data));\n    }\n    function extraFunctionB(uint x) public pure returns (uint) {\n        return x + 1;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract HashGeneratorC {\n    function getHash(bytes32 payload) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(payload));\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract HashGeneratorD {\n    function produceHash(bytes32 info) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(info));\n    }\n    function extraFunctionD1() public pure returns (uint) {\n        return 42;\n    }\n    function extraFunctionD2() public pure returns (uint) {\n        return 24;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract HashGeneratorE {\n    function computeHash(bytes32 details) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(details));\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract HashGeneratorF {\n    function makeHash(bytes32 element) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(element));\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract HashGeneratorG {\n    function createHash(bytes32 item) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(item));\n    }\n    function extraFunctionG() public pure returns (uint) {\n        return 99;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract HashGeneratorH {\n    function deriveHash(bytes32 parameter) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(parameter));\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract HashGeneratorI {\n    function obtainHash(bytes32 attribute) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(attribute));\n    }\n    function extraFunctionI() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract HashGeneratorJ {\n    function encodeHash(bytes32 factor) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(factor));\n    }\n}"
      }
    }
  },
  {
    "Changes63": {
      "Version Migration": "->0.5",
      "Knowledge": "<code>throw</code> is now disallowed (in favor of <code>revert</code>, <code>require</code> and\n<code>assert</code>).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractOne {\n    function throwError() public pure {\n        throw;\n    }\n    function extraFunction() public pure {}\n}",
          "error message": ":1:100: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... throwError() public pure {         throw;     }     function extraFunction( ...\n                                        ^---^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractTwo {\n    function failureCondition() public pure {\n        throw;\n    }\n}",
          "error message": ":1:106: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract ErrorContractTwo {     function failureCondition() public pure {         throw;     } }\n                                                                                                         ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractThree {\n    function triggerError() public pure {\n        throw;\n    }\n    function extraOne() public pure {}\n    function extraTwo() public pure {}\n}",
          "error message": ":1:104: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... iggerError() public pure {         throw;     }     function extraOne() pub ...\n                                        ^---^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractFour {\n    function activateThrow() public pure {\n        throw;\n    }\n}",
          "error message": ":1:104: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract ErrorContractFour {     function activateThrow() public pure {         throw;     } }\n                                                                                                       ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractFive {\n    function performThrow() public pure {\n        throw;\n    }\n    function extraFunc() public pure {}\n}",
          "error message": ":1:103: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... rformThrow() public pure {         throw;     }     function extraFunc() pu ...\n                                        ^---^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractSix {\n    function launchError() public pure {\n        throw;\n    }\n}",
          "error message": ":1:101: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract ErrorContractSix {     function launchError() public pure {         throw;     } }\n                                                                                                    ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractSeven {\n    function initiateError() public pure {\n        throw;\n    }\n    function additional() public pure {}\n    function anotherExtra() public pure {}\n}",
          "error message": ":1:105: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... tiateError() public pure {         throw;     }     function additional() p ...\n                                        ^---^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractEight {\n    function provokeFailure() public pure {\n        throw;\n    }\n}",
          "error message": ":1:106: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract ErrorContractEight {     function provokeFailure() public pure {         throw;     } }\n                                                                                                         ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractNine {\n    function throwErrorNow() public pure {\n        throw;\n    }\n    function anotherFunction() public pure {}\n}",
          "error message": ":1:104: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\n ... owErrorNow() public pure {         throw;     }     function anotherFunctio ...\n                                        ^---^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ErrorContractTen {\n    function induceError() public pure {\n        throw;\n    }\n}",
          "error message": ":1:101: SyntaxError: \"throw\" is deprecated in favour of \"revert()\", \"require()\" and \"assert()\".\npragma solidity^0.5.0; contract ErrorContractTen {     function induceError() public pure {         throw;     } }\n                                                                                                    ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract ErrorContractOne {\n    function throwError() public pure {\n        revert();\n    }\n    function extraFunction() public pure {}\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract ErrorContractTwo {\n    function failureCondition() public pure {\n        revert();\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract ErrorContractThree {\n    function triggerError() public pure {\n        revert();\n    }\n    function extraOne() public pure {}\n    function extraTwo() public pure {}\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract ErrorContractFour {\n    function activateThrow() public pure {\n        revert();\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract ErrorContractFive {\n    function performThrow() public pure {\n        revert();\n    }\n    function extraFunc() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract ErrorContractSix {\n    function launchError() public pure {\n        revert();\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract ErrorContractSeven {\n    function initiateError() public pure {\n        revert();\n    }\n    function additional() public pure {}\n    function anotherExtra() public pure {}\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract ErrorContractEight {\n    function provokeFailure() public pure {\n        revert();\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract ErrorContractNine {\n    function throwErrorNow() public pure {\n        revert();\n    }\n    function anotherFunction() public pure {}\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ErrorContractTen {\n    function induceError() public pure {\n        revert();\n    }\n}"
      }
    }
  },
  {
    "Changes64": {
      "Version Migration": "->0.5",
      "Knowledge": "The unit denomination <code>years</code> is now disallowed due to complications and\nconfusions about leap years.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract SavingsAccount {\n    address payable public beneficiary;\n    uint public releaseTime;\n\n    constructor() public {\n        beneficiary = msg.sender;\n        releaseTime = now + 1 years;\n    }\n\n    function releaseFunds() public {\n        require(now >= releaseTime, \"Funds are locked!\");\n        beneficiary.transfer(address(this).balance);\n    }\n}",
          "error message": ":1:209: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... ender;         releaseTime = now + 1 years;     }      function releaseFunds( ...\n                                        ^-----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract HolidaySavings {\n    address public saver;\n    uint public lockDate;\n\n    constructor() public {\n        saver = msg.sender;\n        lockDate = now + 2 years;\n    }\n\n    function claim() public {\n        require(now >= lockDate, \"Savings still locked!\");\n        msg.sender.transfer(address(this).balance);\n    }\n}",
          "error message": ":1:183: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... g.sender;         lockDate = now + 2 years;     }      function claim() publi ...\n                                        ^-----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract RentalContract {\n    address payable public tenant;\n    uint public endLease;\n\n    constructor() public {\n        tenant = msg.sender;\n        endLease = now + 5 years;\n    }\n\n    function terminateLease() public {\n        require(now >= endLease, \"Lease not ended yet!\");\n        selfdestruct(tenant);\n    }\n\n}",
          "error message": ":1:193: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... g.sender;         endLease = now + 5 years;     }      function terminateLeas ...\n                                        ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract EducationFund {\n    address payable public student;\n    uint public graduationTime;\n\n    constructor() public {\n        student = msg.sender;\n        graduationTime = now + 4 years;\n    }\n\n    function collectFunds() public {\n        require(now >= graduationTime, \"Cannot collect yet!\");\n        student.transfer(address(this).balance);\n    }\n}",
          "error message": ":1:206: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... er;         graduationTime = now + 4 years;     }      function collectFunds( ...\n                                        ^-----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract SubscriptionService {\n    address public subscriber;\n    uint public subscriptionEnd;\n\n    constructor() public {\n        subscriber = msg.sender;\n        subscriptionEnd = now + 3 years;\n    }\n\n    function unsubscribe() public {\n        require(now >= subscriptionEnd, \"Subscription active!\");\n    }\n}",
          "error message": ":1:212: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... r;         subscriptionEnd = now + 3 years;     }      function unsubscribe() ...\n                                        ^-----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract InvestmentLock {\n    address payable public investor;\n    uint public maturityDate;\n\n    constructor() public {\n        investor = msg.sender;\n        maturityDate = now + 10 years;\n    }\n\n    function retrieveInvestment() public {\n        require(now >= maturityDate, \"Investment locked!\");\n        investor.transfer(address(this).balance);\n    }\n}",
          "error message": ":1:205: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... nder;         maturityDate = now + 10 years;     }      function retrieveInves ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract PensionPlan {\n    address public retiree;\n    uint public retirementDate;\n\n    constructor() public {\n        retiree = msg.sender;\n        retirementDate = now + 20 years;\n    }\n\n    function receivePension() public {\n        require(now >= retirementDate, \"Too early for pension!\");\n    }\n}",
          "error message": ":1:196: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... er;         retirementDate = now + 20 years;     }      function receivePensio ...\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract MarriageContract {\n    address payable public spouse;\n    uint public anniversary;\n\n    constructor() public {\n        spouse = msg.sender;\n        anniversary = now + 1 years;\n    }\n\n    function celebrateAnniversary() public {\n        require(now >= anniversary, \"It's not time yet!\");\n    }\n}",
          "error message": ":1:201: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... ender;         anniversary = now + 1 years;     }      function celebrateAnni ...\n                                        ^-----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract WarrantyContract {\n    address public owner;\n    uint public warrantyExpire;\n\n    constructor() public {\n        owner = msg.sender;\n        warrantyExpire = now + 2 years;\n    }\n\n    function claimWarranty() public {\n        require(now >= warrantyExpire, \"Warranty not expired!\");\n    }\n}",
          "error message": ":1:197: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... er;         warrantyExpire = now + 2 years;     }      function claimWarranty ...\n                                        ^-----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract LoanTerm {\n    address payable public borrower;\n    uint public loanMaturity;\n\n    constructor() public {\n        borrower = msg.sender;\n        loanMaturity = now + 15 years;\n    }\n\n    function repayLoan() public {\n        require(now >= loanMaturity, \"Loan terms not yet met!\");\n        borrower.transfer(address(this).balance);\n    }\n}",
          "error message": ":1:199: TypeError: Using \"years\" as a unit denomination is deprecated.\n ... nder;         loanMaturity = now + 15 years;     }      function repayLoan() p ...\n                                        ^------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract SavingsAccount {\n    address payable public beneficiary;\n    uint public releaseTime;\n\n    constructor() public {\n        beneficiary = msg.sender;\n        releaseTime = now + 365 days;\n    }\n\n    function releaseFunds() public {\n        require(now >= releaseTime, \"Funds are locked!\");\n        beneficiary.transfer(address(this).balance);\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract HolidaySavings {\n    address public saver;\n    uint public lockDate;\n\n    constructor() public {\n        saver = msg.sender;\n        lockDate = now + 2 * 365 days;\n    }\n\n    function claim() public {\n        require(now >= lockDate, \"Savings still locked!\");\n        msg.sender.transfer(address(this).balance);\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract RentalContract {\n    address payable public tenant;\n    uint public endLease;\n\n    constructor() public {\n        tenant = msg.sender;\n        endLease = now + 5 * 365 days;\n    }\n\n    function terminateLease() public {\n        require(now >= endLease, \"Lease not ended yet!\");\n        selfdestruct(tenant);\n    }\n\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract EducationFund {\n    address payable public student;\n    uint public graduationTime;\n\n    constructor() public {\n        student = msg.sender;\n        graduationTime = now + 4 * 365 days;\n    }\n\n    function collectFunds() public {\n        require(now >= graduationTime, \"Cannot collect yet!\");\n        student.transfer(address(this).balance);\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract SubscriptionService {\n    address public subscriber;\n    uint public subscriptionEnd;\n\n    constructor() public {\n        subscriber = msg.sender;\n        subscriptionEnd = now + 3 * 365 days;\n    }\n\n    function unsubscribe() public {\n        require(now >= subscriptionEnd, \"Subscription active!\");\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract InvestmentLock {\n    address payable public investor;\n    uint public maturityDate;\n\n    constructor() public {\n        investor = msg.sender;\n        maturityDate = now + 10 * 365 days;\n    }\n\n    function retrieveInvestment() public {\n        require(now >= maturityDate, \"Investment locked!\");\n        investor.transfer(address(this).balance);\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract PensionPlan {\n    address public retiree;\n    uint public retirementDate;\n\n    constructor() public {\n        retiree = msg.sender;\n        retirementDate = now + 20 * 365 days;\n    }\n\n    function receivePension() public {\n        require(now >= retirementDate, \"Too early for pension!\");\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract MarriageContract {\n    address payable public spouse;\n    uint public anniversary;\n\n    constructor() public {\n        spouse = msg.sender;\n        anniversary = now + 365 days;\n    }\n\n    function celebrateAnniversary() public {\n        require(now >= anniversary, \"It's not time yet!\");\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract WarrantyContract {\n    address public owner;\n    uint public warrantyExpire;\n\n    constructor() public {\n        owner = msg.sender;\n        warrantyExpire = now + 2 * 365 days;\n    }\n\n    function claimWarranty() public {\n        require(now >= warrantyExpire, \"Warranty not expired!\");\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract LoanTerm {\n    address payable public borrower;\n    uint public loanMaturity;\n\n    constructor() public {\n        borrower = msg.sender;\n        loanMaturity = now + 15 * 365 days;\n    }\n\n    function repayLoan() public {\n        require(now >= loanMaturity, \"Loan terms not yet met!\");\n        borrower.transfer(address(this).balance);\n    }\n}"
      }
    }
  },
  {
    "Changes65": {
      "Version Migration": "->0.5",
      "Knowledge": "Trailing dots that are not followed by a number are now disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorOne {\n    function calculateValue() public pure returns (uint) {\n        uint value = 100.;\n        return value;\n    }\n    function helper() public pure returns (uint) { return 1; }\n}",
          "error message": ":1:135: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint value = 100.;         return value;     }     fu ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorTwo {\n    function fetchAmount() public pure returns (uint) {\n        uint amount = 50.;\n        return amount;\n    }\n    function extraFunction() public pure returns (uint) { return 2; }\n}",
          "error message": ":1:132: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint amount = 50.;         return amount;     }     f ...\n                                        ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorThree {\n    function getNumber() public pure returns (uint) {\n        uint number = 75.;\n        return number;\n    }\n}",
          "error message": ":1:132: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint number = 75.;         return number;     } }\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorFour {\n    function retrieveTotal() public pure returns (uint) {\n        uint total = 200.;\n        return total;\n    }\n    function anotherHelper() public pure returns (uint) { return 3; }\n    function anotherOne() public pure returns (uint) { return 4; }\n}",
          "error message": ":1:135: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint total = 200.;         return total;     }     fu ...\n                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorFive {\n    function extractData() public pure returns (uint) {\n        uint data = 30.;\n        return data;\n    }\n}",
          "error message": ":1:131: ParserError: Expected identifier but got ';'\n ... ns (uint) {         uint data = 30.;         return data;     } }\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorSix {\n    function measureDistance() public pure returns (uint) {\n        uint distance = 120.;\n        return distance;\n    }\n    function unused() public pure returns (uint) { return 5; }\n}",
          "error message": ":1:139: ParserError: Expected identifier but got ';'\n ... int) {         uint distance = 120.;         return distance;     }     ...\n                                        ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorSeven {\n    function calculateLength() public pure returns (uint) {\n        uint length = 180.;\n        return length;\n    }\n}",
          "error message": ":1:139: ParserError: Expected identifier but got ';'\n ... (uint) {         uint length = 180.;         return length;     } }\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorEight {\n    function evaluateRisk() public pure returns (uint) {\n        uint risk = 220.;\n        return risk;\n    }\n    function irrelevant() public pure returns (uint) { return 6; }\n    function notNeeded() public pure returns (uint) { return 7; }\n}",
          "error message": ":1:134: ParserError: Expected identifier but got ';'\n ... s (uint) {         uint risk = 220.;         return risk;     }     fun ...\n                                        ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorNine {\n    function determineWidth() public pure returns (uint) {\n        uint width = 130.;\n        return width;\n    }\n}",
          "error message": ":1:136: ParserError: Expected identifier but got ';'\n ...  (uint) {         uint width = 130.;         return width;     } }\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract DecimalErrorTen {\n    function assessHeight() public pure returns (uint) {\n        uint height = 250.;\n        return height;\n    }\n    function pointless() public pure returns (uint) { return 8; }\n}",
          "error message": ":1:134: ParserError: Expected identifier but got ';'\n ... (uint) {         uint height = 250.;         return height;     }     f ...\n                                        ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract DecimalErrorOne {\n    function calculateValue() public pure returns (uint) {\n        uint value = 100;\n        return value;\n    }\n    function helper() public pure returns (uint) { return 1; }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract DecimalErrorTwo {\n    function fetchAmount() public pure returns (uint) {\n        uint amount = 50;\n        return amount;\n    }\n    function extraFunction() public pure returns (uint) { return 2; }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract DecimalErrorThree {\n    function getNumber() public pure returns (uint) {\n        uint number = 75;\n        return number;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract DecimalErrorFour {\n    function retrieveTotal() public pure returns (uint) {\n        uint total = 200;\n        return total;\n    }\n    function anotherHelper() public pure returns (uint) { return 3; }\n    function anotherOne() public pure returns (uint) { return 4; }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract DecimalErrorFive {\n    function extractData() public pure returns (uint) {\n        uint data = 30;\n        return data;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract DecimalErrorSix {\n    function measureDistance() public pure returns (uint) {\n        uint distance = 120;\n        return distance;\n    }\n    function unused() public pure returns (uint) { return 5; }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract DecimalErrorSeven {\n    function calculateLength() public pure returns (uint) {\n        uint length = 180;\n        return length;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract DecimalErrorEight {\n    function evaluateRisk() public pure returns (uint) {\n        uint risk = 220;\n        return risk;\n    }\n    function irrelevant() public pure returns (uint) { return 6; }\n    function notNeeded() public pure returns (uint) { return 7; }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract DecimalErrorNine {\n    function determineWidth() public pure returns (uint) {\n        uint width = 130;\n        return width;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract DecimalErrorTen {\n    function assessHeight() public pure returns (uint) {\n        uint height = 250;\n        return height;\n    }\n    function pointless() public pure returns (uint) { return 8; }\n}"
      }
    }
  },
  {
    "Changes66": {
      "Version Migration": "->0.5",
      "Knowledge": "Combining hex numbers with unit denominations (e.g. <code>0x1e wei</code>) is now\ndisallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractOne {\n    function getHexValue() public pure returns (uint) {\n        uint amount = 0x2a wei;\n        return amount;\n    }\n}",
          "error message": ":1:131: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... rns (uint) {         uint amount = 0x2a wei;         return amount;     } }\n                                        ^------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractTwo {\n    function retrieveAmount() public pure returns (uint) {\n        uint total = 0x1f wei;\n        return total;\n    }\n    function dummyFunction() public pure {}\n}",
          "error message": ":1:133: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... urns (uint) {         uint total = 0x1f wei;         return total;     }     f ...\n                                        ^------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractThree {\n    function calculateHex() public pure returns (uint) {\n        uint result = 0x3b wei;\n        return result;\n    }\n    function helper() public pure {}\n    function extra() public pure {}\n}",
          "error message": ":1:134: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... rns (uint) {         uint result = 0x3b wei;         return result;     }      ...\n                                        ^------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractFour {\n    function fetchHex() public pure returns (uint) {\n        uint data = 0x10 wei;\n        return data;\n    }\n}",
          "error message": ":1:127: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... turns (uint) {         uint data = 0x10 wei;         return data;     } }\n                                        ^------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractFive {\n    function extractValue() public pure returns (uint) {\n        uint value = 0x55 wei;\n        return value;\n    }\n    function unrelated() public pure {}\n}",
          "error message": ":1:132: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... urns (uint) {         uint value = 0x55 wei;         return value;     }     f ...\n                                        ^------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractSix {\n    function hexOperation() public pure returns (uint) {\n        uint quantity = 0x2c wei;\n        return quantity;\n    }\n    function extraFunctionOne() public pure {}\n    function extraFunctionTwo() public pure {}\n}",
          "error message": ":1:134: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... s (uint) {         uint quantity = 0x2c wei;         return quantity;     }    ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractSeven {\n    function getHexData() public pure returns (uint) {\n        uint num = 0x44 wei;\n        return num;\n    }\n}",
          "error message": ":1:129: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... eturns (uint) {         uint num = 0x44 wei;         return num;     } }\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractEight {\n    function computeHex() public pure returns (uint) {\n        uint count = 0x22 wei;\n        return count;\n    }\n    function dummyOne() public pure {}\n}",
          "error message": ":1:131: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... urns (uint) {         uint count = 0x22 wei;         return count;     }     f ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractNine {\n    function processHex() public pure returns (uint) {\n        uint sum = 0x11 wei;\n        return sum;\n    }\n    function dummyTwo() public pure {}\n}",
          "error message": ":1:128: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... eturns (uint) {         uint sum = 0x11 wei;         return sum;     }     fun ...\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\n\ncontract ErrorContractTen {\n    function generateHex() public pure returns (uint) {\n        uint measure = 0x99 wei;\n        return measure;\n    }\n    function anotherDummy() public pure {}\n}",
          "error message": ":1:132: TypeError: Hexadecimal numbers cannot be used with unit denominations. You can use an expression of the form \"0x1234 * 1 day\" instead.\n ... ns (uint) {         uint measure = 0x99 wei;         return measure;     }     ...\n                                        ^------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\n\ncontract ErrorContractOne {\n    function getHexValue() public pure returns (uint) {\n        uint amount = 0x2a; \n        return amount;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\n\ncontract ErrorContractTwo {\n    function retrieveAmount() public pure returns (uint) {\n        uint total = 0x1f; \n        return total;\n    }\n    function dummyFunction() public pure {}\n}",
        "Example3": "pragma solidity ^0.5.0;\n\ncontract ErrorContractThree {\n    function calculateHex() public pure returns (uint) {\n        uint result = 0x3b; \n        return result;\n    }\n    function helper() public pure {}\n    function extra() public pure {}\n}",
        "Example4": "pragma solidity ^0.5.0;\n\ncontract ErrorContractFour {\n    function fetchHex() public pure returns (uint) {\n        uint data = 0x10; \n        return data;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\n\ncontract ErrorContractFive {\n    function extractValue() public pure returns (uint) {\n        uint value = 0x55; \n        return value;\n    }\n    function unrelated() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\n\ncontract ErrorContractSix {\n    function hexOperation() public pure returns (uint) {\n        uint quantity = 0x2c; \n        return quantity;\n    }\n    function extraFunctionOne() public pure {}\n    function extraFunctionTwo() public pure {}\n}",
        "Example7": "pragma solidity ^0.5.0;\n\ncontract ErrorContractSeven {\n    function getHexData() public pure returns (uint) {\n        uint num = 0x44; \n        return num;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\n\ncontract ErrorContractEight {\n    function computeHex() public pure returns (uint) {\n        uint count = 0x22; \n        return count;\n    }\n    function dummyOne() public pure {}\n}",
        "Example9": "pragma solidity ^0.5.0;\n\ncontract ErrorContractNine {\n    function processHex() public pure returns (uint) {\n        uint sum = 0x11; \n        return sum;\n    }\n    function dummyTwo() public pure {}\n}",
        "Example10": "pragma solidity ^0.5.0;\n\ncontract ErrorContractTen {\n    function generateHex() public pure returns (uint) {\n        uint measure = 0x99; \n        return measure;\n    }\n    function anotherDummy() public pure {}\n}"
      }
    }
  },
  {
    "Changes67": {
      "Version Migration": "->0.5",
      "Knowledge": "The prefix <code>0X</code> for hex numbers is disallowed, only <code>0x</code> is possible.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueOne {\n    function fetchValue() public pure returns (uint) {\n        return 0X1a2B3c;\n    }\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": ":1:117: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0X1a2B3c;     }     function dummyFu ...\n                                        ^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueTwo {\n    function getValue() public pure returns (uint) {\n        return 0X4D5e6F;\n    }\n}",
          "error message": ":1:115: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexValueTwo {     function getValue() public pure returns (uint) {         return 0X4D5e6F;     } }\n                                                                                                                  ^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueThree {\n    function retrieveValue() public pure returns (uint) {\n        return 0XA1B2C3;\n    }\n    function additionalFunc() public pure returns (string memory) {\n        return \"Hello\";\n    }\n    function anotherFunc() public pure returns (int) {\n        return -123;\n    }\n}",
          "error message": ":1:122: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0XA1B2C3;     }     function additio ...\n                                        ^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueFour {\n    function generateValue() public pure returns (uint) {\n        return 0XA1B2C3;\n    }\n}",
          "error message": ":1:121: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexValueFour {     function generateValue() public pure returns (uint) {         return 0XA1B2C3;     } }\n                                                                                                                        ^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueFive {\n    function readValue() public pure returns (uint) {\n        return 0XD4E5F6;\n    }\n    function extra() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": ":1:117: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0XD4E5F6;     }     function extra() ...\n                                        ^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueSix {\n    function showValue() public pure returns (uint) {\n        return 0XabcDEF;\n    }\n}",
          "error message": ":1:116: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexValueSix {     function showValue() public pure returns (uint) {         return 0XabcDEF;     } }\n                                                                                                                   ^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueSeven {\n    function emitValue() public pure returns (uint) {\n        return 0X123456;\n    }\n    function unnecessaryFunction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:118: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0X123456;     }     function unneces ...\n                                        ^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueEight {\n    function printValue() public pure returns (uint) {\n        return 0X789abc;\n    }\n}",
          "error message": ":1:119: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexValueEight {     function printValue() public pure returns (uint) {         return 0X789abc;     } }\n                                                                                                                      ^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueNine {\n    function calculateValue() public pure returns (uint) {\n        return 0XF1E2D3;\n    }\n    function someFunction() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": ":1:122: ParserError: Expected primary expression.\n ... re returns (uint) {         return 0XF1E2D3;     }     function someFun ...\n                                        ^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract HexValueTen {\n    function extractValue() public pure returns (uint) {\n        return 0X9A8B7C;\n    }\n}",
          "error message": ":1:119: ParserError: Expected primary expression.\npragma solidity^0.5.0; contract HexValueTen {     function extractValue() public pure returns (uint) {         return 0X9A8B7C;     } }\n                                                                                                                      ^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract HexValueOne {\n    function fetchValue() public pure returns (uint) {\n        return 0x1a2B3c;\n    }\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract HexValueTwo {\n    function getValue() public pure returns (uint) {\n        return 0x4D5e6F;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract HexValueThree {\n    function retrieveValue() public pure returns (uint) {\n        return 0xA1B2C3;\n    }\n    function additionalFunc() public pure returns (string memory) {\n        return \"Hello\";\n    }\n    function anotherFunc() public pure returns (int) {\n        return -123;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract HexValueFour {\n    function generateValue() public pure returns (uint) {\n        return 0xA1B2C3;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract HexValueFive {\n    function readValue() public pure returns (uint) {\n        return 0xD4E5F6;\n    }\n    function extra() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract HexValueSix {\n    function showValue() public pure returns (uint) {\n        return 0xabcDEF;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract HexValueSeven {\n    function emitValue() public pure returns (uint) {\n        return 0x123456;\n    }\n    function unnecessaryFunction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract HexValueEight {\n    function printValue() public pure returns (uint) {\n        return 0x789abc;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract HexValueNine {\n    function calculateValue() public pure returns (uint) {\n        return 0xF1E2D3;\n    }\n    function someFunction() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract HexValueTen {\n    function extractValue() public pure returns (uint) {\n        return 0x9A8B7C;\n    }\n}"
      }
    }
  },
  {
    "Changes68": {
      "Version Migration": "->0.5",
      "Knowledge": "Using <code>constant</code> as function state mutability modifier is now disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract Alpha {\n    uint256 public constant num = 100;\n    function fetchNum() public constant returns (uint256) {\n        return num;\n    }\n    function addExtra() public pure returns (uint256) {\n        return num + 20;\n    }\n}",
          "error message": ":1:111: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 00;     function fetchNum() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract Beta {\n    uint256 public constant count = 50;\n    function getCount() public constant returns (uint256) {\n        return count;\n    }\n}",
          "error message": ":1:111: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 50;     function getCount() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract Gamma {\n    uint256 public constant total = 200;\n    function retrieveTotal() public constant returns (uint256) {\n        return total;\n    }\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n    function anotherDummy() public pure returns (uint256) {\n        return 5;\n    }\n}",
          "error message": ":1:118: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ...    function retrieveTotal() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract Delta {\n    uint256 public constant amount = 300;\n    function showAmount() public constant returns (uint256) {\n        return amount;\n    }\n}",
          "error message": ":1:116: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... ;     function showAmount() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract Epsilon {\n    uint256 public constant value = 450;\n    function getValue() public constant returns (uint256) {\n        return value;\n    }\n    function extraValue() public pure returns (uint256) {\n        return value * 2;\n    }\n}",
          "error message": ":1:115: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 50;     function getValue() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract Zeta {\n    uint256 public constant item = 150;\n    function fetchItem() public constant returns (uint256) {\n        return item;\n    }\n}",
          "error message": ":1:112: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 0;     function fetchItem() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract Eta {\n    uint256 public constant score = 175;\n    function getScore() public constant returns (uint256) {\n        return score;\n    }\n    function useless() public pure returns (uint256) {\n        return 0;\n    }\n}",
          "error message": ":1:111: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 75;     function getScore() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract Theta {\n    uint256 public constant level = 80;\n    function retrieveLevel() public constant returns (uint256) {\n        return level;\n    }\n}",
          "error message": ":1:117: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ...    function retrieveLevel() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract Iota {\n    uint256 public constant data = 60;\n    function obtainData() public constant returns (uint256) {\n        return data;\n    }\n    function redundant() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": ":1:112: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... ;     function obtainData() public constant returns (uint256) {         return ...\n                                        ^------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract Kappa {\n    uint256 public constant factor = 90;\n    function getFactor() public constant returns (uint256) {\n        return factor;\n    }\n    function multiply() public pure returns (uint256) {\n        return factor * 2;\n    }\n}",
          "error message": ":1:114: ParserError: The state mutability modifier \"constant\" was removed in version 0.5.0. Use \"view\" or \"pure\" instead.\n ... 0;     function getFactor() public constant returns (uint256) {         return ...\n                                        ^------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract Alpha {\n    uint256 public constant num = 100;\n    function fetchNum() public view returns (uint256) {\n        return num;\n    }\n    function addExtra() public pure returns (uint256) {\n        return num + 20;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract Beta {\n    uint256 public constant count = 50;\n    function getCount() public view returns (uint256) {\n        return count;\n    }\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract Gamma {\n    uint256 public constant total = 200;\n    function retrieveTotal() public view returns (uint256) {\n        return total;\n    }\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n    function anotherDummy() public pure returns (uint256) {\n        return 5;\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract Delta {\n    uint256 public constant amount = 300;\n    function showAmount() public view returns (uint256) {\n        return amount;\n    }\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract Epsilon {\n    uint256 public constant value = 450;\n    function getValue() public view returns (uint256) {\n        return value;\n    }\n    function extraValue() public pure returns (uint256) {\n        return value * 2;\n    }\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract Zeta {\n    uint256 public constant item = 150;\n    function fetchItem() public view returns (uint256) {\n        return item;\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract Eta {\n    uint256 public constant score = 175;\n    function getScore() public view returns (uint256) {\n        return score;\n    }\n    function useless() public pure returns (uint256) {\n        return 0;\n    }\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract Theta {\n    uint256 public constant level = 80;\n    function retrieveLevel() public view returns (uint256) {\n        return level;\n    }\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract Iota {\n    uint256 public constant data = 60;\n    function obtainData() public view returns (uint256) {\n        return data;\n    }\n    function redundant() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract Kappa {\n    uint256 public constant factor = 90;\n    function getFactor() public view returns (uint256) {\n        return factor;\n    }\n    function multiply() public pure returns (uint256) {\n        return factor * 2;\n    }\n}"
      }
    }
  },
  {
    "Changes69": {
      "Version Migration": "->0.5",
      "Knowledge": "Empty return statements for functions with one or more return values are now\ndisallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.5.0;\ncontract Calculator {\n    function calculate() public pure returns (int) {\n        return;\n    }\n    function helper() private pure returns (int) {\n        return 1;\n    }\n}",
          "error message": ":1:107: TypeError: Return arguments required.\n ... ublic pure returns (int) {         return;     }     function helper() privat ...\n                                        ^-----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.5.0;\ncontract DataStorage {\n    function retrieve() public pure returns (bytes32) {\n        return;\n    }\n    function store(uint data) public pure {}\n    function clear() public pure {}\n}",
          "error message": ":1:111: TypeError: Return arguments required.\n ... c pure returns (bytes32) {         return;     }     function store(uint data ...\n                                        ^-----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.5.0;\ncontract UserInfo {\n    function getUser() public pure returns (address) {\n        return;\n    }\n}",
          "error message": ":1:107: TypeError: Return arguments required.\npragma solidity^0.5.0; contract UserInfo {     function getUser() public pure returns (address) {         return;     } }\n                                                                                                          ^-----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.5.0;\ncontract PaymentProcessor {\n    function processPayment() public pure returns (bool) {\n        return;\n    }\n    function logTransaction() public pure {}\n}",
          "error message": ":1:119: TypeError: Return arguments required.\n ... blic pure returns (bool) {         return;     }     function logTransaction( ...\n                                        ^-----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.5.0;\ncontract AccountManager {\n    function getAccountBalance() public pure returns (uint) {\n        return;\n    }\n    function setBalance(uint _newBalance) public pure {}\n    function validate() public pure {}\n}",
          "error message": ":1:120: TypeError: Return arguments required.\n ... blic pure returns (uint) {         return;     }     function setBalance(uint ...\n                                        ^-----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.5.0;\ncontract TokenGenerator {\n    function generateToken() public pure returns (bytes32) {\n        return;\n    }\n}",
          "error message": ":1:119: TypeError: Return arguments required.\npragma solidity^0.5.0; contract TokenGenerator {     function generateToken() public pure returns (bytes32) {         return;     } }\n                                                                                                                      ^-----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.5.0;\ncontract QueryHandler {\n    function handleQuery() public pure returns (string memory) {\n        return;\n    }\n    function extraFunction() public pure {}\n}",
          "error message": ":1:121: TypeError: Return arguments required.\n ...  returns (string memory) {         return;     }     function extraFunction() ...\n                                        ^-----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.5.0;\ncontract RandomNumber {\n    function getRandomNumber() public pure returns (uint) {\n        return;\n    }\n    function helperOne() public pure {}\n    function helperTwo() public pure {}\n}",
          "error message": ":1:116: TypeError: Return arguments required.\n ... blic pure returns (uint) {         return;     }     function helperOne() pub ...\n                                        ^-----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.5.0;\ncontract OrderManager {\n    function getOrderDetails() public pure returns (string memory) {\n        return;\n    }\n    function checkStatus() public pure {}\n}",
          "error message": ":1:125: TypeError: Return arguments required.\n ...  returns (string memory) {         return;     }     function checkStatus() p ...\n                                        ^-----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.5.0;\ncontract ConfigurationSetter {\n    function setConfiguration() public pure returns (bool) {\n        return;\n    }\n}",
          "error message": ":1:124: TypeError: Return arguments required.\npragma solidity^0.5.0; contract ConfigurationSetter {     function setConfiguration() public pure returns (bool) {         return;     } }\n                                                                                                                           ^-----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.5.0;\ncontract Calculator {\n    function calculate() public pure returns (int) {\n        return 0;\n    }\n    function helper() private pure returns (int) {\n        return 1;\n    }\n}",
        "Example2": "pragma solidity ^0.5.0;\ncontract DataStorage {\n    function retrieve() public pure returns (bytes32) {\n        return bytes32(0);\n    }\n    function store(uint data) public pure {}\n    function clear() public pure {}\n}",
        "Example3": "pragma solidity ^0.5.0;\ncontract UserInfo {\n    function getUser() public pure returns (address) {\n        return address(0);\n    }\n}",
        "Example4": "pragma solidity ^0.5.0;\ncontract PaymentProcessor {\n    function processPayment() public pure returns (bool) {\n        return false;\n    }\n    function logTransaction() public pure {}\n}",
        "Example5": "pragma solidity ^0.5.0;\ncontract AccountManager {\n    function getAccountBalance() public pure returns (uint) {\n        return 0;\n    }\n    function setBalance(uint _newBalance) public pure {}\n    function validate() public pure {}\n}",
        "Example6": "pragma solidity ^0.5.0;\ncontract TokenGenerator {\n    function generateToken() public pure returns (bytes32) {\n        return bytes32(0);\n    }\n}",
        "Example7": "pragma solidity ^0.5.0;\ncontract QueryHandler {\n    function handleQuery() public pure returns (string memory) {\n        return \"\";\n    }\n    function extraFunction() public pure {}\n}",
        "Example8": "pragma solidity ^0.5.0;\ncontract RandomNumber {\n    function getRandomNumber() public pure returns (uint) {\n        return 0;\n    }\n    function helperOne() public pure {}\n    function helperTwo() public pure {}\n}",
        "Example9": "pragma solidity ^0.5.0;\ncontract OrderManager {\n    function getOrderDetails() public pure returns (string memory) {\n        return \"\";\n    }\n    function checkStatus() public pure {}\n}",
        "Example10": "pragma solidity ^0.5.0;\ncontract ConfigurationSetter {\n    function setConfiguration() public pure returns (bool) {\n        return false;\n    }\n}"
      }
    }
  },
  {
    "Changes70": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "In external function and contract creation calls, Ether and gas is now specified using a new syntax:\n<code>x.f{gas: 10000, value: 2 ether}(arg1, arg2)</code>.\nThe old syntax \u2013 <code>x.f.gas(10000).value(2 ether)(arg1, arg2)</code> \u2013 will cause an error.Change <code>x.f.value(...)()</code> to <code>x.f{value: ...}()</code>. Similarly <code>(new C).value(...)()</code> to <code>new C{value: ...}()</code> and <code>x.f.gas(...).value(...)()</code> to <code>x.f{gas: ..., value: ...}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract Transaction {\n    address payable public destination;\n    constructor(address payable _destination) public {\n        destination = _destination;\n    }\n    function transferFunds() public payable {\n        (bool sent, ) = destination.call.gas(3000).value(msg.value)(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ...  payable {         (bool sent, ) = destination.call.gas(3000).value(msg.value)(\"\");        ...\n                                        ^------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract PaymentProcessor {\n    address payable public receiver;\n    constructor(address payable _receiver) public {\n        receiver = _receiver;\n    }\n    function processPayment() public payable {\n        (bool successful, ) = receiver.call.gas(4000).value(msg.value)(\"\");\n        require(successful, \"Payment failed\");\n    }\n    function utilityFunction() private pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... le {         (bool successful, ) = receiver.call.gas(4000).value(msg.value)(\"\");        ...\n                                        ^---------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract EtherSender {\n    address payable public payee;\n    constructor(address payable _payee) public {\n        payee = _payee;\n    }\n    function sendEtherToPayee() public payable {\n        (bool done, ) = payee.call.gas(5000).value(msg.value)(\"\");\n        require(done, \"Ether transfer failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ...  payable {         (bool done, ) = payee.call.gas(5000).value(msg.value)(\"\");        ...\n                                        ^------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract FundTransfer {\n    address payable public beneficiary;\n    constructor(address payable _beneficiary) public {\n        beneficiary = _beneficiary;\n    }\n    function executeTransfer() public payable {\n        (bool executed, ) = beneficiary.call.gas(6000).value(msg.value)(\"\");\n        require(executed, \"Transfer was not successful\");\n    }\n    function dummy() public pure {}\n    function helper() private pure {}\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... able {         (bool executed, ) = beneficiary.call.gas(6000).value(msg.value)(\"\");        ...\n                                        ^------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract CashDispatcher {\n    address payable public collector;\n    constructor(address payable _collector) public {\n        collector = _collector;\n    }\n    function dispatchCash() public payable {\n        (bool dispatched, ) = collector.call.gas(2500).value(msg.value)(\"\");\n        require(dispatched, \"Dispatch failed\");\n    }\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra Function\";\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... le {         (bool dispatched, ) = collector.call.gas(2500).value(msg.value)(\"\");        ...\n                                        ^----------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract MoneyRouter {\n    address payable public recipient;\n    constructor(address payable _recipient) public {\n        recipient = _recipient;\n    }\n    function routeFunds() public payable {\n        (bool routed, ) = recipient.call.gas(3500).value(msg.value)(\"\");\n        require(routed, \"Routing failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... ayable {         (bool routed, ) = recipient.call.gas(3500).value(msg.value)(\"\");        ...\n                                        ^----------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract ResourceAllocator {\n    address payable public allocator;\n    constructor(address payable _allocator) public {\n        allocator = _allocator;\n    }\n    function allocateResources() public payable {\n        (bool allocated, ) = allocator.call.gas(4500).value(msg.value)(\"\");\n        require(allocated, \"Allocation failed\");\n    }\n    function dummyFunction() public pure {}\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... ble {         (bool allocated, ) = allocator.call.gas(4500).value(msg.value)(\"\");        ...\n                                        ^----------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract PaymentGateway {\n    address payable public gatewayReceiver;\n    constructor(address payable _gatewayReceiver) public {\n        gatewayReceiver = _gatewayReceiver;\n    }\n    function makePayment() public payable {\n        (bool paid, ) = gatewayReceiver.call.gas(5500).value(msg.value)(\"\");\n        require(paid, \"Payment was not successful\");\n    }\n    function nonRelevantFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ...  payable {         (bool paid, ) = gatewayReceiver.call.gas(5500).value(msg.value)(\"\");        ...\n                                        ^----------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract EtherDistributor {\n    address payable public stakeholder;\n    constructor(address payable _stakeholder) public {\n        stakeholder = _stakeholder;\n    }\n    function distributeEther() public payable {\n        (bool distributed, ) = stakeholder.call.gas(2000).value(msg.value)(\"\");\n        require(distributed, \"Distribution failed\");\n    }\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... e {         (bool distributed, ) = stakeholder.call.gas(2000).value(msg.value)(\"\");        ...\n                                        ^------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract WealthTransfer {\n    address payable public heir;\n    constructor(address payable _heir) public {\n        heir = _heir;\n    }\n    function transferWealth() public payable {\n        (bool transferred, ) = heir.call.gas(7000).value(msg.value)(\"\");\n        require(transferred, \"Transfer failed\");\n    }\n    function irrelevant() public pure {}\n}",
          "error message": "Error: Using \".gas(...)\" is deprecated. Use \"{gas: ...}\" instead.\n ... e {         (bool transferred, ) = heir.call.gas(7000).value(msg.value)(\"\");        ...\n                                        ^-----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract Transaction {\n    address payable public destination;\n    constructor(address payable _destination) {\n        destination = _destination;\n    }\n    function transferFunds() public payable {\n        (bool sent, ) = destination.call{gas: 3000, value: msg.value}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract PaymentProcessor {\n    address payable public receiver;\n    constructor(address payable _receiver) {\n        receiver = _receiver;\n    }\n    function processPayment() public payable {\n        (bool successful, ) = receiver.call{gas: 4000, value: msg.value}(\"\");\n        require(successful, \"Payment failed\");\n    }\n    function utilityFunction() private pure returns (uint) {\n        return 42;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract EtherSender {\n    address payable public payee;\n    constructor(address payable _payee) {\n        payee = _payee;\n    }\n    function sendEtherToPayee() public payable {\n        (bool done, ) = payee.call{gas: 5000, value: msg.value}(\"\");\n        require(done, \"Ether transfer failed\");\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract FundTransfer {\n    address payable public beneficiary;\n    constructor(address payable _beneficiary) {\n        beneficiary = _beneficiary;\n    }\n    function executeTransfer() public payable {\n        (bool executed, ) = beneficiary.call{gas: 6000, value: msg.value}(\"\");\n        require(executed, \"Transfer was not successful\");\n    }\n    function dummy() public pure {}\n    function helper() private pure {}\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract CashDispatcher {\n    address payable public collector;\n    constructor(address payable _collector) {\n        collector = _collector;\n    }\n    function dispatchCash() public payable {\n        (bool dispatched, ) = collector.call{gas: 2500, value: msg.value}(\"\");\n        require(dispatched, \"Dispatch failed\");\n    }\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra Function\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract MoneyRouter {\n    address payable public recipient;\n    constructor(address payable _recipient) {\n        recipient = _recipient;\n    }\n    function routeFunds() public payable {\n        (bool routed, ) = recipient.call{gas: 3500, value: msg.value}(\"\");\n        require(routed, \"Routing failed\");\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract ResourceAllocator {\n    address payable public allocator;\n    constructor(address payable _allocator) {\n        allocator = _allocator;\n    }\n    function allocateResources() public payable {\n        (bool allocated, ) = allocator.call{gas: 4500, value: msg.value}(\"\");\n        require(allocated, \"Allocation failed\");\n    }\n    function dummyFunction() public pure {}\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract PaymentGateway {\n    address payable public gatewayReceiver;\n    constructor(address payable _gatewayReceiver) {\n        gatewayReceiver = _gatewayReceiver;\n    }\n    function makePayment() public payable {\n        (bool paid, ) = gatewayReceiver.call{gas: 5500, value: msg.value}(\"\");\n        require(paid, \"Payment was not successful\");\n    }\n    function nonRelevantFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract EtherDistributor {\n    address payable public stakeholder;\n    constructor(address payable _stakeholder) {\n        stakeholder = _stakeholder;\n    }\n    function distributeEther() public payable {\n        (bool distributed, ) = stakeholder.call{gas: 2000, value: msg.value}(\"\");\n        require(distributed, \"Distribution failed\");\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract WealthTransfer {\n    address payable public heir;\n    constructor(address payable _heir) {\n        heir = _heir;\n    }\n    function transferWealth() public payable {\n        (bool transferred, ) = heir.call{gas: 7000, value: msg.value}(\"\");\n        require(transferred, \"Transfer failed\");\n    }\n    function irrelevant() public pure {}\n}"
      }
    }
  },
  {
    "Changes71": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The global variable <code>now</code> is deprecated, <code>block.timestamp</code> should be used instead.\nThe single identifier <code>now</code> is too generic for a global variable and could give the impression\nthat it changes during transaction processing, whereas <code>block.timestamp</code> correctly\nreflects the fact that it is just a property of the block.Change <code>now</code> to <code>block.timestamp</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeValidator {\n    function currentTime() public view returns (uint) {\n        return now;\n    }\n    function additionalFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function additionalFunc ...\n                                        ^-^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract BlockTime {\n    function getBlockTime() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract BlockTime {     function getBlockTime() public view returns (uint) {         return now;     } }\n                                                                                                                    ^-^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract CheckNow {\n    function getTimeNow() public view returns (uint) {\n        return now;\n    }\n    function extraData() public pure returns (string memory) {\n        return \"Extra\";\n    }\n    function anotherFunction() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function extraData() pu ...\n                                        ^-^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract Schedule {\n    function scheduleTime() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract Schedule {     function scheduleTime() public view returns (uint) {         return now;     } }\n                                                                                                                   ^-^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract Timestamp {\n    function currentTimestamp() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract Timestamp {     function currentTimestamp() public view returns (uint) {         return now;     } }\n                                                                                                                        ^-^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeKeeper {\n    function keepTime() public view returns (uint) {\n        return now;\n    }\n    function unrelatedFunction() public pure returns (uint) {\n        return 123456;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function unrelatedFunct ...\n                                        ^-^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract EventTime {\n    function eventTimestamp() public view returns (uint) {\n        return now;\n    }\n    function unused() public pure returns (string memory) {\n        return \"unused\";\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function unused() publi ...\n                                        ^-^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract SystemTime {\n    function systemTime() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract SystemTime {     function systemTime() public view returns (uint) {         return now;     } }\n                                                                                                                   ^-^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract CurrentBlockTime {\n    function blockTimeNow() public view returns (uint) {\n        return now;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\npragma solidity^0.7.0; contract CurrentBlockTime {     function blockTimeNow() public view returns (uint) {         return now;     } }\n                                                                                                                           ^-^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract TimeCheck {\n    function checkCurrentTime() public view returns (uint) {\n        return now;\n    }\n    function additionalHelper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: \"now\" has been deprecated. Use \"block.timestamp\" instead.\n ... ew returns (uint) {         return now;     }     function additionalHelp ...\n                                        ^-^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract TimeValidator {\n    function currentTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function additionalFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract BlockTime {\n    function getBlockTime() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract CheckNow {\n    function getTimeNow() public view returns (uint) {\n        return block.timestamp;\n    }\n    function extraData() public pure returns (string memory) {\n        return \"Extra\";\n    }\n    function anotherFunction() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract Schedule {\n    function scheduleTime() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract Timestamp {\n    function currentTimestamp() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract TimeKeeper {\n    function keepTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function unrelatedFunction() public pure returns (uint) {\n        return 123456;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract EventTime {\n    function eventTimestamp() public view returns (uint) {\n        return block.timestamp;\n    }\n    function unused() public pure returns (string memory) {\n        return \"unused\";\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract SystemTime {\n    function systemTime() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract CurrentBlockTime {\n    function blockTimeNow() public view returns (uint) {\n        return block.timestamp;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract TimeCheck {\n    function checkCurrentTime() public view returns (uint) {\n        return block.timestamp;\n    }\n    function additionalHelper() public pure returns (bool) {\n        return false;\n    }\n}"
      }
    }
  },
  {
    "Changes72": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The token <code>gwei</code> is a keyword now (used to specify, e.g. <code>2 gwei</code> as a number)\nand cannot be used as an identifier.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract Example1 {\n    uint public gwei;\n    uint public total;\n\n    constructor(uint _total) {\n        gwei = 100;\n        total = _total;\n    }\n\n    function updateValues(uint _gwei, uint _total) public {\n        gwei = _gwei;\n        total = _total;\n    }\n\n    function displayValues() public view returns (uint, uint) {\n        return (gwei, total);\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example1 {     uint public gwei;     uint public total;      const ...\n                                        ^--^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract Example2 {\n    uint public gwei;\n    uint public value;\n\n    constructor(uint initialValue) {\n        gwei = 200;\n        value = initialValue;\n    }\n\n    function setValue(uint newValue) public {\n        value = newValue;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example2 {     uint public gwei;     uint public value;      const ...\n                                        ^--^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract Example3 {\n    uint public gwei;\n    uint public price;\n\n    constructor(uint startPrice) {\n        gwei = 300;\n        price = startPrice;\n    }\n\n    function adjustPrice(uint newPrice) public {\n        price = newPrice;\n    }\n\n    function currentPrice() public view returns (uint) {\n        return price;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example3 {     uint public gwei;     uint public price;      const ...\n                                        ^--^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract Example4 {\n    uint public gwei;\n    uint public count;\n\n    constructor(uint _count) {\n        gwei = 400;\n        count = _count;\n    }\n\n    function setCount(uint newCount) public {\n        count = newCount;\n    }\n\n    function getCount() public view returns (uint) {\n        return count;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example4 {     uint public gwei;     uint public count;      const ...\n                                        ^--^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract Example5 {\n    uint public gwei;\n    uint public quantity;\n\n    constructor(uint initialQuantity) {\n        gwei = 500;\n        quantity = initialQuantity;\n    }\n\n    function updateQuantity(uint newQuantity) public {\n        quantity = newQuantity;\n    }\n\n    function getQuantity() public view returns (uint) {\n        return quantity;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example5 {     uint public gwei;     uint public quantity;      co ...\n                                        ^--^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract Example6 {\n    uint public gwei;\n    uint public balance;\n\n    constructor(uint initialBalance) {\n        gwei = 600;\n        balance = initialBalance;\n    }\n\n    function modifyBalance(uint newBalance) public {\n        balance = newBalance;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balance;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example6 {     uint public gwei;     uint public balance;      con ...\n                                        ^--^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract Example7 {\n    uint public gwei;\n    uint public data;\n\n    constructor(uint initialData) {\n        gwei = 700;\n        data = initialData;\n    }\n\n    function setData(uint newData) public {\n        data = newData;\n    }\n\n    function getData() public view returns (uint) {\n        return data;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example7 {     uint public gwei;     uint public data;      constr ...\n                                        ^--^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract Example8 {\n    uint public gwei;\n    uint public level;\n\n    constructor(uint initialLevel) {\n        gwei = 800;\n        level = initialLevel;\n    }\n\n    function setLevel(uint newLevel) public {\n        level = newLevel;\n    }\n\n    function getLevel() public view returns (uint) {\n        return level;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example8 {     uint public gwei;     uint public level;      const ...\n                                        ^--^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract Example9 {\n    uint public gwei;\n    uint public index;\n\n    constructor(uint initialIndex) {\n        gwei = 900;\n        index = initialIndex;\n    }\n\n    function setIndex(uint newIndex) public {\n        index = newIndex;\n    }\n\n    function getIndex() public view returns (uint) {\n        return index;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ontract Example9 {     uint public gwei;     uint public index;      const ...\n                                        ^--^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract Example10 {\n    uint public gwei;\n    uint public rate;\n\n    constructor(uint initialRate) {\n        gwei = 1000;\n        rate = initialRate;\n    }\n\n    function updateRate(uint newRate) public {\n        rate = newRate;\n    }\n\n    function getRate() public view returns (uint) {\n        return rate;\n    }\n}",
          "error message": "Error: Expected identifier but got 'gwei'\n ... ntract Example10 {     uint public gwei;     uint public rate;      constr ...\n                                        ^--^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract Example1 {\n    uint public gweiAmount;\n    uint public total;\n\n    constructor(uint _total) {\n        gweiAmount = 100;\n        total = _total;\n    }\n\n    function updateValues(uint _gweiAmount, uint _total) public {\n        gweiAmount = _gweiAmount;\n        total = _total;\n    }\n\n    function displayValues() public view returns (uint, uint) {\n        return (gweiAmount, total);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract Example2 {\n    uint public gweiAmount;\n    uint public value;\n\n    constructor(uint initialValue) {\n        gweiAmount = 200;\n        value = initialValue;\n    }\n\n    function setValue(uint newValue) public {\n        value = newValue;\n    }\n\n    function getValue() public view returns (uint) {\n        return value;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract Example3 {\n    uint public gweiAmount;\n    uint public price;\n\n    constructor(uint startPrice) {\n        gweiAmount = 300;\n        price = startPrice;\n    }\n\n    function adjustPrice(uint newPrice) public {\n        price = newPrice;\n    }\n\n    function currentPrice() public view returns (uint) {\n        return price;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract Example4 {\n    uint public gweiAmount;\n    uint public count;\n\n    constructor(uint _count) {\n        gweiAmount = 400;\n        count = _count;\n    }\n\n    function setCount(uint newCount) public {\n        count = newCount;\n    }\n\n    function getCount() public view returns (uint) {\n        return count;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract Example5 {\n    uint public gweiAmount;\n    uint public quantity;\n\n    constructor(uint initialQuantity) {\n        gweiAmount = 500;\n        quantity = initialQuantity;\n    }\n\n    function updateQuantity(uint newQuantity) public {\n        quantity = newQuantity;\n    }\n\n    function getQuantity() public view returns (uint) {\n        return quantity;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract Example6 {\n    uint public gweiAmount;\n    uint public balance;\n\n    constructor(uint initialBalance) {\n        gweiAmount = 600;\n        balance = initialBalance;\n    }\n\n    function modifyBalance(uint newBalance) public {\n        balance = newBalance;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balance;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract Example7 {\n    uint public gweiAmount;\n    uint public data;\n\n    constructor(uint initialData) {\n        gweiAmount = 700;\n        data = initialData;\n    }\n\n    function setData(uint newData) public {\n        data = newData;\n    }\n\n    function getData() public view returns (uint) {\n        return data;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract Example8 {\n    uint public gweiAmount;\n    uint public level;\n\n    constructor(uint initialLevel) {\n        gweiAmount = 800;\n        level = initialLevel;\n    }\n\n    function setLevel(uint newLevel) public {\n        level = newLevel;\n    }\n\n    function getLevel() public view returns (uint) {\n        return level;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract Example9 {\n    uint public gweiAmount;\n    uint public index;\n\n    constructor(uint initialIndex) {\n        gweiAmount = 900;\n        index = initialIndex;\n    }\n\n    function setIndex(uint newIndex) public {\n        index = newIndex;\n    }\n\n    function getIndex() public view returns (uint) {\n        return index;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract Example10 {\n    uint public gweiAmount;\n    uint public rate;\n\n    constructor(uint initialRate) {\n        gweiAmount = 1000;\n        rate = initialRate;\n    }\n\n    function updateRate(uint newRate) public {\n        rate = newRate;\n    }\n\n    function getRate() public view returns (uint) {\n        return rate;\n    }\n}"
      }
    }
  },
  {
    "Changes73": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Disallow <code>.</code> in user-defined function and variable names in inline assembly.\nIt is still valid if you use Solidity in Yul-only mode.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyOne {\n    function computeValue() public pure returns (uint) {\n        uint a;\n        assembly {\n            let temp.value := 100\n            a := add(temp.value, 50)\n        }\n        return a;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let temp.value := 100             a := add(temp.v ...\n                                        ^--------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyTwo {\n    function calculateSum() public pure returns (uint) {\n        uint b;\n        assembly {\n            let sum.part := 75\n            b := add(sum.part, 25)\n        }\n        return b;\n    }\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let sum.part := 75             b := add(sum.par ...\n                                        ^------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyThree {\n    function fetchResult() public pure returns (uint) {\n        uint c;\n        assembly {\n            let result.data := 60\n            c := add(result.data, 40)\n        }\n        return c;\n    }\n    function randomFunc() public pure returns (uint) {\n        return 200;\n    }\n    function anotherFunc() public pure returns (uint) {\n        return 300;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let result.data := 60             c := add(result. ...\n                                        ^---------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyFour {\n    function generateOutput() public pure returns (uint) {\n        uint d;\n        assembly {\n            let output.code := 30\n            d := add(output.code, 70)\n        }\n        return d;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let output.code := 30             d := add(output. ...\n                                        ^---------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyFive {\n    function retrieveData() public pure returns (uint) {\n        uint e;\n        assembly {\n            let data.field := 20\n            e := add(data.field, 80)\n        }\n        return e;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let data.field := 20             e := add(data.fi ...\n                                        ^--------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblySix {\n    function gatherInfo() public pure returns (uint) {\n        uint f;\n        assembly {\n            let info.block := 45\n            f := add(info.block, 55)\n        }\n        return f;\n    }\n    function unusedFunction() public pure returns (uint) {\n        return 500;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let info.block := 45             f := add(info.bl ...\n                                        ^--------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblySeven {\n    function deriveNumber() public pure returns (uint) {\n        uint g;\n        assembly {\n            let number.source := 35\n            g := add(number.source, 65)\n        }\n        return g;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let number.source := 35             g := add(number. ...\n                                        ^-----------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyEight {\n    function extractValue() public pure returns (uint) {\n        uint h;\n        assembly {\n            let value.part := 95\n            h := add(value.part, 5)\n        }\n        return h;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let value.part := 95             h := add(value.p ...\n                                        ^--------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyNine {\n    function obtainElement() public pure returns (uint) {\n        uint i;\n        assembly {\n            let element.piece := 55\n            i := add(element.piece, 45)\n        }\n        return i;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let element.piece := 55             i := add(element ...\n                                        ^-----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\ncontract AssemblyTen {\n    function fetchParameter() public pure returns (uint) {\n        uint j;\n        assembly {\n            let parameter.detail := 85\n            j := add(parameter.detail, 15)\n        }\n        return j;\n    }\n}",
          "error message": "Error: User-defined identifiers in inline assembly cannot contain '.'.\n ...         assembly {             let parameter.detail := 85             j := add(paramet ...\n                                        ^--------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\ncontract AssemblyOne {\n    function computeValue() public pure returns (uint) {\n        uint a;\n        assembly {\n            let tempValue := 100\n            a := add(tempValue, 50)\n        }\n        return a;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\ncontract AssemblyTwo {\n    function calculateSum() public pure returns (uint) {\n        uint b;\n        assembly {\n            let sumPart := 75\n            b := add(sumPart, 25)\n        }\n        return b;\n    }\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\ncontract AssemblyThree {\n    function fetchResult() public pure returns (uint) {\n        uint c;\n        assembly {\n            let resultData := 60\n            c := add(resultData, 40)\n        }\n        return c;\n    }\n    function randomFunc() public pure returns (uint) {\n        return 200;\n    }\n    function anotherFunc() public pure returns (uint) {\n        return 300;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\ncontract AssemblyFour {\n    function generateOutput() public pure returns (uint) {\n        uint d;\n        assembly {\n            let outputCode := 30\n            d := add(outputCode, 70)\n        }\n        return d;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\ncontract AssemblyFive {\n    function retrieveData() public pure returns (uint) {\n        uint e;\n        assembly {\n            let dataField := 20\n            e := add(dataField, 80)\n        }\n        return e;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\ncontract AssemblySix {\n    function gatherInfo() public pure returns (uint) {\n        uint f;\n        assembly {\n            let infoBlock := 45\n            f := add(infoBlock, 55)\n        }\n        return f;\n    }\n    function unusedFunction() public pure returns (uint) {\n        return 500;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\ncontract AssemblySeven {\n    function deriveNumber() public pure returns (uint) {\n        uint g;\n        assembly {\n            let numberSource := 35\n            g := add(numberSource, 65)\n        }\n        return g;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\ncontract AssemblyEight {\n    function extractValue() public pure returns (uint) {\n        uint h;\n        assembly {\n            let valuePart := 95\n            h := add(valuePart, 5)\n        }\n        return h;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\ncontract AssemblyNine {\n    function obtainElement() public pure returns (uint) {\n        uint i;\n        assembly {\n            let elementPiece := 55\n            i := add(elementPiece, 45)\n        }\n        return i;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\ncontract AssemblyTen {\n    function fetchParameter() public pure returns (uint) {\n        uint j;\n        assembly {\n            let parameterDetail := 85\n            j := add(parameterDetail, 15)\n        }\n        return j;\n    }\n}"
      }
    }
  },
  {
    "Changes74": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Slot and offset of storage pointer variable <code>x</code> are accessed via <code>x.slot</code>\nand <code>x.offset</code> instead of <code>x_slot</code> and <code>x_offset</code>.Change <code>_slot</code> and <code>_offset</code> suffixes in inline assembly to <code>.slot</code> and <code>.offset</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Info {\n        uint256 amount;\n    }\n\n    Info private info;\n\n    function setAmount(uint256 _amount) public {\n        info.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return info.amount;\n    }\n\n    function getPointer() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 infoSlot;\n        uint256 infoOffset;\n        \n        assembly {\n            infoSlot := info_slot\n            infoOffset := info_offset\n        }\n        \n        return (infoSlot, infoOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             infoSlot := info_slot             infoOffset := info_off ...\n                                        ^-------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Record {\n        uint256 data;\n    }\n\n    Record private record;\n\n    function setData(uint256 _data) public {\n        record.data = _data;\n    }\n\n    function getData() public view returns (uint256) {\n        return record.data;\n    }\n\n    function pointerLocation() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 recordSlot;\n        uint256 recordOffset;\n        \n        assembly {\n            recordSlot := record_slot\n            recordOffset := record_offset\n        }\n        \n        return (recordSlot, recordOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             recordSlot := record_slot             recordOffset := record ...\n                                        ^---------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Value {\n        uint256 number;\n    }\n\n    Value private value;\n\n    function setNumber(uint256 _number) public {\n        value.number = _number;\n    }\n\n    function getNumber() public view returns (uint256) {\n        return value.number;\n    }\n\n    function storageInfo() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 valueSlot;\n        uint256 valueOffset;\n        \n        assembly {\n            valueSlot := value_slot\n            valueOffset := value_offset\n        }\n        \n        return (valueSlot, valueOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             valueSlot := value_slot             valueOffset := value_o ...\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Item {\n        uint256 price;\n    }\n\n    Item private item;\n\n    function setPrice(uint256 _price) public {\n        item.price = _price;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return item.price;\n    }\n\n    function getSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 itemSlot;\n        uint256 itemOffset;\n        \n        assembly {\n            itemSlot := item_slot\n            itemOffset := item_offset\n        }\n        \n        return (itemSlot, itemOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... assembly {             itemSlot := item_slot             itemOffset := item_off ...\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Entry {\n        uint256 value;\n    }\n\n    Entry private entry;\n\n    function setValue(uint256 _value) public {\n        entry.value = _value;\n    }\n\n    function getValue() public view returns (uint256) {\n        return entry.value;\n    }\n\n    function locateStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 entrySlot;\n        uint256 entryOffset;\n        \n        assembly {\n            entrySlot := entry_slot\n            entryOffset := entry_offset\n        }\n        \n        return (entrySlot, entryOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             entrySlot := entry_slot             entryOffset := entry_o ...\n                                        ^--------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Element {\n        uint256 count;\n    }\n\n    Element private element;\n\n    function setCount(uint256 _count) public {\n        element.count = _count;\n    }\n\n    function getCount() public view returns (uint256) {\n        return element.count;\n    }\n\n    function fetchStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 elementSlot;\n        uint256 elementOffset;\n        \n        assembly {\n            elementSlot := element_slot\n            elementOffset := element_offset\n        }\n        \n        return (elementSlot, elementOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             elementSlot := element_slot             elementOffset := eleme ...\n                                        ^----------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Stats {\n        uint256 score;\n    }\n\n    Stats private stats;\n\n    function setScore(uint256 _score) public {\n        stats.score = _score;\n    }\n\n    function getScore() public view returns (uint256) {\n        return stats.score;\n    }\n\n    function storageDetails() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 statsSlot;\n        uint256 statsOffset;\n        \n        assembly {\n            statsSlot := stats_slot\n            statsOffset := stats_offset\n        }\n        \n        return (statsSlot, statsOffset);\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... ssembly {             statsSlot := stats_slot             statsOffset := stats_o ...\n                                        ^--------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct Record {\n        uint256 value;\n    }\n\n    Record private record;\n\n    function setRecordValue(uint256 _value) public {\n        record.value = _value;\n    }\n\n    function getRecordValue() public view returns (uint256) {\n        return record.value;\n    }\n\n    function getStorageLocation() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 recordSlot;\n        uint256 recordOffset;\n        \n        assembly {\n            recordSlot := record_slot\n            recordOffset := record_offset\n        }\n        \n        return (recordSlot, recordOffset);\n    }\n\n    function anotherDummyFunction() public pure returns (string memory) {\n        return \"Hello, World!\";\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... sembly {             recordSlot := record_slot             recordOffset := record ...\n                                        ^---------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct Profile {\n        uint256 age;\n    }\n\n    Profile private profile;\n\n    function setAge(uint256 _age) public {\n        profile.age = _age;\n    }\n\n    function getAge() public view returns (uint256) {\n        return profile.age;\n    }\n\n    function storagePosition() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 profileSlot;\n        uint256 profileOffset;\n        \n        assembly {\n            profileSlot := profile_slot\n            profileOffset := profile_offset\n        }\n        \n        return (profileSlot, profileOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... embly {             profileSlot := profile_slot             profileOffset := profi ...\n                                        ^----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct Container {\n        uint256 size;\n    }\n\n    Container private container;\n\n    function setSize(uint256 _size) public {\n        container.size = _size;\n    }\n\n    function getSize() public view returns (uint256) {\n        return container.size;\n    }\n\n    function findStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 containerSlot;\n        uint256 containerOffset;\n        \n        assembly {\n            containerSlot := container_slot\n            containerOffset := container_offset\n        }\n        \n        return (containerSlot, containerOffset);\n    }\n}",
          "error message": "Error: Identifier not found. Use ``.slot`` and ``.offset`` to access storage variables.\n ... bly {             containerSlot := container_slot             containerOffset := con ...\n                                        ^------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Info {\n        uint256 amount;\n    }\n\n    Info private info;\n\n    function setAmount(uint256 _amount) public {\n        info.amount = _amount;\n    }\n\n    function getAmount() public view returns (uint256) {\n        return info.amount;\n    }\n\n    function getPointer() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 infoSlot;\n        uint256 infoOffset;\n        \n        assembly {\n            infoSlot := info.slot\n            infoOffset := info.offset\n        }\n        \n        return (infoSlot, infoOffset);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Record {\n        uint256 data;\n    }\n\n    Record private record;\n\n    function setData(uint256 _data) public {\n        record.data = _data;\n    }\n\n    function getData() public view returns (uint256) {\n        return record.data;\n    }\n\n    function pointerLocation() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 recordSlot;\n        uint256 recordOffset;\n        \n        assembly {\n            recordSlot := record.slot\n            recordOffset := record.offset\n        }\n        \n        return (recordSlot, recordOffset);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Value {\n        uint256 number;\n    }\n\n    Value private value;\n\n    function setNumber(uint256 _number) public {\n        value.number = _number;\n    }\n\n    function getNumber() public view returns (uint256) {\n        return value.number;\n    }\n\n    function storageInfo() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 valueSlot;\n        uint256 valueOffset;\n        \n        assembly {\n            valueSlot := value.slot\n            valueOffset := value.offset\n        }\n        \n        return (valueSlot, valueOffset);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Item {\n        uint256 price;\n    }\n\n    Item private item;\n\n    function setPrice(uint256 _price) public {\n        item.price = _price;\n    }\n\n    function getPrice() public view returns (uint256) {\n        return item.price;\n    }\n\n    function getSlotOffset() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 itemSlot;\n        uint256 itemOffset;\n        \n        assembly {\n            itemSlot := item.slot\n            itemOffset := item.offset\n        }\n        \n        return (itemSlot, itemOffset);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Entry {\n        uint256 value;\n    }\n\n    Entry private entry;\n\n    function setValue(uint256 _value) public {\n        entry.value = _value;\n    }\n\n    function getValue() public view returns (uint256) {\n        return entry.value;\n    }\n\n    function locateStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 entrySlot;\n        uint256 entryOffset;\n        \n        assembly {\n            entrySlot := entry.slot\n            entryOffset := entry.offset\n        }\n        \n        return (entrySlot, entryOffset);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Element {\n        uint256 count;\n    }\n\n    Element private element;\n\n    function setCount(uint256 _count) public {\n        element.count = _count;\n    }\n\n    function getCount() public view returns (uint256) {\n        return element.count;\n    }\n\n    function fetchStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 elementSlot;\n        uint256 elementOffset;\n        \n        assembly {\n            elementSlot := element.slot\n            elementOffset := element.offset\n        }\n        \n        return (elementSlot, elementOffset);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Stats {\n        uint256 score;\n    }\n\n    Stats private stats;\n\n    function setScore(uint256 _score) public {\n        stats.score = _score;\n    }\n\n    function getScore() public view returns (uint256) {\n        return stats.score;\n    }\n\n    function storageDetails() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 statsSlot;\n        uint256 statsOffset;\n        \n        assembly {\n            statsSlot := stats.slot\n            statsOffset := stats.offset\n        }\n        \n        return (statsSlot, statsOffset);\n    }\n\n    function dummyFunction() public pure returns (uint256) {\n        return 42;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct Record {\n        uint256 value;\n    }\n\n    Record private record;\n\n    function setRecordValue(uint256 _value) public {\n        record.value = _value;\n    }\n\n    function getRecordValue() public view returns (uint256) {\n        return record.value;\n    }\n\n    function getStorageLocation() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 recordSlot;\n        uint256 recordOffset;\n        \n        assembly {\n            recordSlot := record.slot\n            recordOffset := record.offset\n        }\n        \n        return (recordSlot, recordOffset);\n    }\n\n    function anotherDummyFunction() public pure returns (string memory) {\n        return \"Hello, World!\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct Profile {\n        uint256 age;\n    }\n\n    Profile private profile;\n\n    function setAge(uint256 _age) public {\n        profile.age = _age;\n    }\n\n    function getAge() public view returns (uint256) {\n        return profile.age;\n    }\n\n    function storagePosition() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 profileSlot;\n        uint256 profileOffset;\n        \n        assembly {\n            profileSlot := profile.slot\n            profileOffset := profile.offset\n        }\n        \n        return (profileSlot, profileOffset);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct Container {\n        uint256 size;\n    }\n\n    Container private container;\n\n    function setSize(uint256 _size) public {\n        container.size = _size;\n    }\n\n    function getSize() public view returns (uint256) {\n        return container.size;\n    }\n\n    function findStorage() public view returns (bytes32 slot, uint256 offset) {\n        bytes32 containerSlot;\n        uint256 containerOffset;\n        \n        assembly {\n            containerSlot := container.slot\n            containerOffset := container.offset\n        }\n        \n        return (containerSlot, containerOffset);\n    }\n}"
      }
    }
  },
  {
    "Changes75": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "If a struct or array contains a mapping, it can only be used in storage.\nPreviously, mapping members were silently skipped in memory, which\nis confusing and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Data {\n        uint value;\n        mapping(address => uint) points;\n    }\n\n    Data[] public dataList;\n\n    function addData(uint _value) public {\n        Data memory newData;\n        newData.value = _value;\n        dataList.push(newData);\n    }\n\n    function setPoints(uint index, address user, uint point) public {\n        dataList[index].points[user] = point;\n    }\n\n    function getPoints(uint index, address user) public view returns (uint) {\n        return dataList[index].points[user];\n    }\n}",
          "error message": "Error: Type struct Example1.Data is only valid in storage because it contains a (nested) mapping.\n ... Data(uint _value) public {         Data memory newData;         newData.value = _value;   ...\n                                        ^-----------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Record {\n        uint number;\n        mapping(address => uint) scores;\n    }\n\n    Record[] public records;\n\n    function createRecord(uint _number) public {\n        Record memory newRecord;\n        newRecord.number = _number;\n        records.push(newRecord);\n    }\n\n    function updateScore(uint index, address user, uint score) public {\n        records[index].scores[user] = score;\n    }\n\n    function retrieveScore(uint index, address user) public view returns (uint) {\n        return records[index].scores[user];\n    }\n}",
          "error message": "Error: Type struct Example2.Record is only valid in storage because it contains a (nested) mapping.\n ... ord(uint _number) public {         Record memory newRecord;         newRecord.number = _numbe ...\n                                        ^---------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Profile {\n        uint id;\n        mapping(address => uint) credits;\n    }\n\n    Profile[] public profiles;\n\n    function newProfile(uint _id) public {\n        Profile memory newProfile;\n        newProfile.id = _id;\n        profiles.push(newProfile);\n    }\n\n    function modifyCredit(uint index, address user, uint credit) public {\n        profiles[index].credits[user] = credit;\n    }\n\n    function fetchCredit(uint index, address user) public view returns (uint) {\n        return profiles[index].credits[user];\n    }\n}",
          "error message": "Error: Type struct Example3.Profile is only valid in storage because it contains a (nested) mapping.\n ... Profile(uint _id) public {         Profile memory newProfile;         newProfile.id = _id;      ...\n                                        ^-----------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Info {\n        uint key;\n        mapping(address => uint) values;\n    }\n\n    Info[] public infos;\n\n    function insertInfo(uint _key) public {\n        Info memory newInfo;\n        newInfo.key = _key;\n        infos.push(newInfo);\n    }\n\n    function assignValue(uint index, address user, uint value) public {\n        infos[index].values[user] = value;\n    }\n\n    function checkValue(uint index, address user) public view returns (uint) {\n        return infos[index].values[user];\n    }\n}",
          "error message": "Error: Type struct Example4.Info is only valid in storage because it contains a (nested) mapping.\n ... rtInfo(uint _key) public {         Info memory newInfo;         newInfo.key = _key;       ...\n                                        ^-----------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Item {\n        uint identifier;\n        mapping(address => uint) ratings;\n    }\n\n    Item[] public items;\n\n    function addItem(uint _identifier) public {\n        Item memory newItem;\n        newItem.identifier = _identifier;\n        items.push(newItem);\n    }\n\n    function rateItem(uint index, address user, uint rating) public {\n        items[index].ratings[user] = rating;\n    }\n\n    function getRating(uint index, address user) public view returns (uint) {\n        return items[index].ratings[user];\n    }\n\n    function dummyFunction1() public pure returns (string memory) {\n        return \"This is a dummy function\";\n    }\n}",
          "error message": "Error: Type struct Example5.Item is only valid in storage because it contains a (nested) mapping.\n ... uint _identifier) public {         Item memory newItem;         newItem.identifier = _ide ...\n                                        ^-----------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Entry {\n        uint code;\n        mapping(address => uint) allowances;\n    }\n\n    Entry[] public entries;\n\n    function createEntry(uint _code) public {\n        Entry memory newEntry;\n        newEntry.code = _code;\n        entries.push(newEntry);\n    }\n\n    function updateAllowance(uint index, address user, uint allowance) public {\n        entries[index].allowances[user] = allowance;\n    }\n\n    function viewAllowance(uint index, address user) public view returns (uint) {\n        return entries[index].allowances[user];\n    }\n\n    function dummyFunction2() public pure returns (string memory) {\n        return \"Another dummy function\";\n    }\n}",
          "error message": "Error: Type struct Example6.Entry is only valid in storage because it contains a (nested) mapping.\n ... Entry(uint _code) public {         Entry memory newEntry;         newEntry.code = _code;    ...\n                                        ^-------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Element {\n        uint idNumber;\n        mapping(address => uint) shares;\n    }\n\n    Element[] public elements;\n\n    function addElement(uint _idNumber) public {\n        Element memory newElement;\n        newElement.idNumber = _idNumber;\n        elements.push(newElement);\n    }\n\n    function setShare(uint index, address user, uint share) public {\n        elements[index].shares[user] = share;\n    }\n\n    function getShare(uint index, address user) public view returns (uint) {\n        return elements[index].shares[user];\n    }\n\n    function dummyFunction3() public pure returns (uint) {\n        return 42;\n    }\n\n    function dummyFunction4() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Type struct Example7.Element is only valid in storage because it contains a (nested) mapping.\n ... t(uint _idNumber) public {         Element memory newElement;         newElement.idNumber = _id ...\n                                        ^-----------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct Contract {\n        uint reference1;\n        mapping(address => uint) debts;\n    }\n\n    Contract[] public contracts;\n\n    function addContract(uint _reference) public {\n        Contract memory newContract;\n        newContract.reference1 = _reference;\n        contracts.push(newContract);\n    }\n\n    function setDebt(uint index, address user, uint debt) public {\n        contracts[index].debts[user] = debt;\n    }\n\n    function getDebt(uint index, address user) public view returns (uint) {\n        return contracts[index].debts[user];\n    }\n}",
          "error message": "Error: Type struct Example8.Contract is only valid in storage because it contains a (nested) mapping.\n ... (uint _reference) public {         Contract memory newContract;         newContract.reference1 =  ...\n                                        ^-------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct Record {\n        uint serial;\n        mapping(address => uint) stakes;\n    }\n\n    Record[] public records;\n\n    function newRecord(uint _serial) public {\n        Record memory newRecord;\n        newRecord.serial = _serial;\n        records.push(newRecord);\n    }\n\n    function assignStake(uint index, address user, uint stake) public {\n        records[index].stakes[user] = stake;\n    }\n\n    function getStake(uint index, address user) public view returns (uint) {\n        return records[index].stakes[user];\n    }\n\n    function dummyFunction5() public pure returns (string memory) {\n        return \"Just a dummy function\";\n    }\n\n    function dummyFunction6() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Type struct Example9.Record is only valid in storage because it contains a (nested) mapping.\n ... ord(uint _serial) public {         Record memory newRecord;         newRecord.serial = _seria ...\n                                        ^---------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct User {\n        uint userId;\n        mapping(address => uint) investments;\n    }\n\n    User[] public users;\n\n    function addUser(uint _userId) public {\n        User memory newUser;\n        newUser.userId = _userId;\n        users.push(newUser);\n    }\n\n    function setInvestment(uint index, address user, uint investment) public {\n        users[index].investments[user] = investment;\n    }\n\n    function getInvestment(uint index, address user) public view returns (uint) {\n        return users[index].investments[user];\n    }\n}",
          "error message": "Error: Type struct Example10.User is only valid in storage because it contains a (nested) mapping.\n ... ser(uint _userId) public {         User memory newUser;         newUser.userId = _userId; ...\n                                        ^-----------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Data {\n        uint value;\n        mapping(address => uint) points;\n    }\n\n    Data[] public dataList;\n\n    function addData(uint _value) public {\n        dataList.push();\n        Data storage newData = dataList[dataList.length - 1];\n        newData.value = _value;\n    }\n\n    function setPoints(uint index, address user, uint point) public {\n        dataList[index].points[user] = point;\n    }\n\n    function getPoints(uint index, address user) public view returns (uint) {\n        return dataList[index].points[user];\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Record {\n        uint number;\n        mapping(address => uint) scores;\n    }\n\n    Record[] public records;\n\n    function createRecord(uint _number) public {\n        records.push();\n        Record storage newRecord = records[records.length - 1];\n        newRecord.number = _number;\n    }\n\n    function updateScore(uint index, address user, uint score) public {\n        records[index].scores[user] = score;\n    }\n\n    function retrieveScore(uint index, address user) public view returns (uint) {\n        return records[index].scores[user];\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Profile {\n        uint id;\n        mapping(address => uint) credits;\n    }\n\n    Profile[] public profiles;\n\n    function newProfile(uint _id) public {\n        profiles.push();\n        Profile storage newProfile = profiles[profiles.length - 1];\n        newProfile.id = _id;\n    }\n\n    function modifyCredit(uint index, address user, uint credit) public {\n        profiles[index].credits[user] = credit;\n    }\n\n    function fetchCredit(uint index, address user) public view returns (uint) {\n        return profiles[index].credits[user];\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Info {\n        uint key;\n        mapping(address => uint) values;\n    }\n\n    Info[] public infos;\n\n    function insertInfo(uint _key) public {\n        infos.push();\n        Info storage newInfo = infos[infos.length - 1];\n        newInfo.key = _key;\n    }\n\n    function assignValue(uint index, address user, uint value) public {\n        infos[index].values[user] = value;\n    }\n\n    function checkValue(uint index, address user) public view returns (uint) {\n        return infos[index].values[user];\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Item {\n        uint identifier;\n        mapping(address => uint) ratings;\n    }\n\n    Item[] public items;\n\n    function addItem(uint _identifier) public {\n        items.push();\n        Item storage newItem = items[items.length - 1];\n        newItem.identifier = _identifier;\n    }\n\n    function rateItem(uint index, address user, uint rating) public {\n        items[index].ratings[user] = rating;\n    }\n\n    function getRating(uint index, address user) public view returns (uint) {\n        return items[index].ratings[user];\n    }\n\n    function dummyFunction1() public pure returns (string memory) {\n        return \"This is a dummy function\";\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Entry {\n        uint code;\n        mapping(address => uint) allowances;\n    }\n\n    Entry[] public entries;\n\n    function createEntry(uint _code) public {\n        entries.push();\n        Entry storage newEntry = entries[entries.length - 1];\n        newEntry.code = _code;\n    }\n\n    function updateAllowance(uint index, address user, uint allowance) public {\n        entries[index].allowances[user] = allowance;\n    }\n\n    function viewAllowance(uint index, address user) public view returns (uint) {\n        return entries[index].allowances[user];\n    }\n\n    function dummyFunction2() public pure returns (string memory) {\n        return \"Another dummy function\";\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Element {\n        uint idNumber;\n        mapping(address => uint) shares;\n    }\n\n    Element[] public elements;\n\n    function addElement(uint _idNumber) public {\n        elements.push();\n        Element storage newElement = elements[elements.length - 1];\n        newElement.idNumber = _idNumber;\n    }\n\n    function setShare(uint index, address user, uint share) public {\n        elements[index].shares[user] = share;\n    }\n\n    function getShare(uint index, address user) public view returns (uint) {\n        return elements[index].shares[user];\n    }\n\n    function dummyFunction3() public pure returns (uint) {\n        return 42;\n    }\n\n    function dummyFunction4() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct Contract {\n        uint reference1;\n        mapping(address => uint) debts;\n    }\n\n    Contract[] public contracts;\n\n    function addContract(uint _reference) public {\n        contracts.push();\n        Contract storage newContract = contracts[contracts.length - 1];\n        newContract.reference1 = _reference;\n    }\n\n    function setDebt(uint index, address user, uint debt) public {\n        contracts[index].debts[user] = debt;\n    }\n\n    function getDebt(uint index, address user) public view returns (uint) {\n        return contracts[index].debts[user];\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct Record {\n        uint serial;\n        mapping(address => uint) stakes;\n    }\n\n    Record[] public records;\n\n    function newRecord(uint _serial) public {\n        records.push();\n        Record storage newRecord = records[records.length - 1];\n        newRecord.serial = _serial;\n    }\n\n    function assignStake(uint index, address user, uint stake) public {\n        records[index].stakes[user] = stake;\n    }\n\n    function getStake(uint index, address user) public view returns (uint) {\n        return records[index].stakes[user];\n    }\n\n    function dummyFunction5() public pure returns (string memory) {\n        return \"Just a dummy function\";\n    }\n\n    function dummyFunction6() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct User {\n        uint userId;\n        mapping(address => uint) investments;\n    }\n\n    User[] public users;\n\n    function addUser(uint _userId) public {\n        users.push();\n        User storage newUser = users[users.length - 1];\n        newUser.userId = _userId;\n    }\n\n    function setInvestment(uint index, address user, uint investment) public {\n        users[index].investments[user] = investment;\n    }\n\n    function getInvestment(uint index, address user) public view returns (uint) {\n        return users[index].investments[user];\n    }\n}"
      }
    }
  },
  {
    "Changes76": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Assignments to structs or arrays in storage does not work if they contain\nmappings.\nPreviously, mappings were silently skipped during the copy operation, which\nis misleading and error-prone.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Info {\n        mapping(address => uint) data;\n        uint count;\n    }\n\n    Info[] public infoList;\n\n    function insertInfo() public {\n        Info storage newInfo = infoList.push();\n        newInfo.count = 50;\n        infoList[1] = newInfo;\n    }\n\n    function modifyData(uint idx, address addr, uint value) public {\n        Info storage info = infoList[idx];\n        info.data[addr] = value;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...        newInfo.count = 50;         infoList[1] = newInfo;     }      function mod ...\n                                        ^---------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Record {\n        mapping(address => uint) records;\n        uint number;\n    }\n\n    Record[] public recordList;\n\n    function appendRecord() public {\n        Record storage newRecord = recordList.push();\n        newRecord.number = 75;\n        recordList[2] = newRecord;\n    }\n\n    function changeRecords(uint idx, address user, uint amount) public {\n        Record storage record = recordList[idx];\n        record.records[user] = amount;\n    }\n    \n    function dummyFunction1() public pure returns (string memory) {\n        return \"Hello World!\";\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...     newRecord.number = 75;         recordList[2] = newRecord;     }      function c ...\n                                        ^-----------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Entry {\n        mapping(address => uint) values;\n        uint total;\n    }\n\n    Entry[] public entryList;\n\n    function addEntry() public {\n        Entry storage newEntry = entryList.push();\n        newEntry.total = 150;\n        entryList[3] = newEntry;\n    }\n\n    function updateValues(uint index, address addr, uint val) public {\n        Entry storage entry = entryList[index];\n        entry.values[addr] = val;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...      newEntry.total = 150;         entryList[3] = newEntry;     }      function up ...\n                                        ^----------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint sum;\n    }\n\n    Log[] public logList;\n\n    function newLog() public {\n        Log storage logItem = logList.push();\n        logItem.sum = 200;\n        logList[4] = logItem;\n    }\n\n    function editEntries(uint idx, address account, uint amt) public {\n        Log storage logItem = logList[idx];\n        logItem.entries[account] = amt;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...         logItem.sum = 200;         logList[4] = logItem;     }      function edi ...\n                                        ^--------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Detail {\n        mapping(address => uint) info;\n        uint total;\n    }\n\n    Detail[] public detailList;\n\n    function createDetail() public {\n        Detail storage newDetail = detailList.push();\n        newDetail.total = 300;\n        detailList[5] = newDetail;\n    }\n\n    function modifyInfo(uint idx, address user, uint val) public {\n        Detail storage detail = detailList[idx];\n        detail.info[user] = val;\n    }\n    \n    function dummyFunction2() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...     newDetail.total = 300;         detailList[5] = newDetail;     }      function m ...\n                                        ^-----------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Account {\n        mapping(address => uint) balances;\n        uint amount;\n    }\n\n    Account[] public accountList;\n\n    function addAccount() public {\n        Account storage newAccount = accountList.push();\n        newAccount.amount = 400;\n        accountList[6] = newAccount;\n    }\n\n    function updateBalances(uint idx, address addr, uint amount) public {\n        Account storage account = accountList[idx];\n        account.balances[addr] = amount;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...   newAccount.amount = 400;         accountList[6] = newAccount;     }      function  ...\n                                        ^------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Profile {\n        mapping(address => uint) details;\n        uint score;\n    }\n\n    Profile[] public profileList;\n\n    function addProfile() public {\n        Profile storage newProfile = profileList.push();\n        newProfile.score = 500;\n        profileList[7] = newProfile;\n    }\n\n    function changeDetails(uint idx, address user, uint value) public {\n        Profile storage profile = profileList[idx];\n        profile.details[user] = value;\n    }\n    \n    function dummyFunction3() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...    newProfile.score = 500;         profileList[7] = newProfile;     }      function  ...\n                                        ^------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct Item {\n        mapping(address => uint) attributes;\n        uint quantity;\n    }\n\n    Item[] public itemList;\n\n    function addItem() public {\n        Item storage newItem = itemList.push();\n        newItem.quantity = 600;\n        itemList[8] = newItem;\n    }\n\n    function updateAttributes(uint idx, address user, uint val) public {\n        Item storage item = itemList[idx];\n        item.attributes[user] = val;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...    newItem.quantity = 600;         itemList[8] = newItem;     }      function upd ...\n                                        ^---------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct History {\n        mapping(address => uint) records;\n        uint total;\n    }\n\n    History[] public historyList;\n\n    function newHistory() public {\n        History storage history = historyList.push();\n        history.total = 700;\n        historyList[9] = history;\n    }\n\n    function modifyRecords(uint idx, address addr, uint value) public {\n        History storage history = historyList[idx];\n        history.records[addr] = value;\n    }\n    \n    function dummyFunction4() public pure returns (address) {\n        return address(0);\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...       history.total = 700;         historyList[9] = history;     }      function mod ...\n                                        ^------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct Asset {\n        mapping(address => uint) holdings;\n        uint value;\n    }\n\n    Asset[] public assetList;\n\n    function addAsset() public {\n        Asset storage newAsset = assetList.push();\n        newAsset.value = 800;\n        assetList[10] = newAsset;\n    }\n\n    function updateHoldings(uint idx, address user, uint amount) public {\n        Asset storage asset = assetList[idx];\n        asset.holdings[user] = amount;\n    }\n}",
          "error message": "Error: Types in storage containing (nested) mappings cannot be assigned to.\n ...      newAsset.value = 800;         assetList[10] = newAsset;     }      function up ...\n                                        ^-----------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example1 {\n    struct Info {\n        mapping(address => uint) data;\n        uint count;\n    }\n\n    Info[] public infoList;\n\n    function insertInfo() public {\n        Info storage newInfo = infoList.push();\n        newInfo.count = 50;\n    }\n\n    function modifyData(uint idx, address addr, uint value) public {\n        Info storage info = infoList[idx];\n        info.data[addr] = value;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example2 {\n    struct Record {\n        mapping(address => uint) records;\n        uint number;\n    }\n\n    Record[] public recordList;\n\n    function appendRecord() public {\n        Record storage newRecord = recordList.push();\n        newRecord.number = 75;\n    }\n\n    function changeRecords(uint idx, address user, uint amount) public {\n        Record storage record = recordList[idx];\n        record.records[user] = amount;\n    }\n    \n    function dummyFunction1() public pure returns (string memory) {\n        return \"Hello World!\";\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example3 {\n    struct Entry {\n        mapping(address => uint) values;\n        uint total;\n    }\n\n    Entry[] public entryList;\n\n    function addEntry() public {\n        Entry storage newEntry = entryList.push();\n        newEntry.total = 150;\n    }\n\n    function updateValues(uint index, address addr, uint val) public {\n        Entry storage entry = entryList[index];\n        entry.values[addr] = val;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example4 {\n    struct Log {\n        mapping(address => uint) entries;\n        uint sum;\n    }\n\n    Log[] public logList;\n\n    function newLog() public {\n        Log storage logItem = logList.push();\n        logItem.sum = 200;\n    }\n\n    function editEntries(uint idx, address account, uint amt) public {\n        Log storage logItem = logList[idx];\n        logItem.entries[account] = amt;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example5 {\n    struct Detail {\n        mapping(address => uint) info;\n        uint total;\n    }\n\n    Detail[] public detailList;\n\n    function createDetail() public {\n        Detail storage newDetail = detailList.push();\n        newDetail.total = 300;\n    }\n\n    function modifyInfo(uint idx, address user, uint val) public {\n        Detail storage detail = detailList[idx];\n        detail.info[user] = val;\n    }\n    \n    function dummyFunction2() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example6 {\n    struct Account {\n        mapping(address => uint) balances;\n        uint amount;\n    }\n\n    Account[] public accountList;\n\n    function addAccount() public {\n        Account storage newAccount = accountList.push();\n        newAccount.amount = 400;\n    }\n\n    function updateBalances(uint idx, address addr, uint amount) public {\n        Account storage account = accountList[idx];\n        account.balances[addr] = amount;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example7 {\n    struct Profile {\n        mapping(address => uint) details;\n        uint score;\n    }\n\n    Profile[] public profileList;\n\n    function addProfile() public {\n        Profile storage newProfile = profileList.push();\n        newProfile.score = 500;\n    }\n\n    function changeDetails(uint idx, address user, uint value) public {\n        Profile storage profile = profileList[idx];\n        profile.details[user] = value;\n    }\n    \n    function dummyFunction3() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example8 {\n    struct Item {\n        mapping(address => uint) attributes;\n        uint quantity;\n    }\n\n    Item[] public itemList;\n\n    function addItem() public {\n        Item storage newItem = itemList.push();\n        newItem.quantity = 600;\n    }\n\n    function updateAttributes(uint idx, address user, uint val) public {\n        Item storage item = itemList[idx];\n        item.attributes[user] = val;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example9 {\n    struct History {\n        mapping(address => uint) records;\n        uint total;\n    }\n\n    History[] public historyList;\n\n    function newHistory() public {\n        History storage history = historyList.push();\n        history.total = 700;\n    }\n\n    function modifyRecords(uint idx, address addr, uint value) public {\n        History storage history = historyList[idx];\n        history.records[addr] = value;\n    }\n    \n    function dummyFunction4() public pure returns (address) {\n        return address(0);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example10 {\n    struct Asset {\n        mapping(address => uint) holdings;\n        uint value;\n    }\n\n    Asset[] public assetList;\n\n    function addAsset() public {\n        Asset storage newAsset = assetList.push();\n        newAsset.value = 800;\n    }\n\n    function updateHoldings(uint idx, address user, uint amount) public {\n        Asset storage asset = assetList[idx];\n        asset.holdings[user] = amount;\n    }\n}"
      }
    }
  },
  {
    "Changes77": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Visibility (<code>public</code> / <code>internal</code>) is not needed for constructors anymore:\nTo prevent a contract from being created, it can be marked <code>abstract</code>.\nThis makes the visibility concept for constructors obsolete.Remove the <code>public</code> keyword from every constructor.Remove the <code>internal</code> keyword from every constructor and add <code>abstract</code> to the contract (if not already present).",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract SampleContract1 {\n    address public admin;\n\n    constructor() internal {\n        admin = msg.sender;\n    }\n\n    function getAdmin() public view returns (address) {\n        return admin;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... 1 {     address public admin;      constructor() internal {         admin = msg.sender;     }      function getAdmin() public vi ...\n                                        ^--------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract TestContract2 {\n    address public manager;\n\n    constructor() internal {\n        manager = msg.sender;\n    }\n\n    function getManager() public view returns (address) {\n        return manager;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... {     address public manager;      constructor() internal {         manager = msg.sender;     }      function getManager() public  ...\n                                        ^----------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ExampleContract3 {\n    address public creator;\n\n    constructor() internal {\n        creator = msg.sender;\n    }\n\n    function getCreator() public view returns (address) {\n        return creator;\n    }\n\n    function isCreator(address _address) public view returns (bool) {\n        return _address == creator;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... {     address public creator;      constructor() internal {         creator = msg.sender;     }      function getCreator() public  ...\n                                        ^----------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract DemoContract4 {\n    address public owner;\n\n    constructor() internal {\n        owner = msg.sender;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... 4 {     address public owner;      constructor() internal {         owner = msg.sender;     }      function getOwner() public vi ...\n                                        ^--------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MyContract5 {\n    address public primary;\n\n    constructor() internal {\n        primary = msg.sender;\n    }\n\n    function getPrimary() public view returns (address) {\n        return primary;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... {     address public primary;      constructor() internal {         primary = msg.sender;     }      function getPrimary() public  ...\n                                        ^----------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract SampleContract6 {\n    address public holder;\n\n    constructor() internal {\n        holder = msg.sender;\n    }\n\n    function getHolder() public view returns (address) {\n        return holder;\n    }\n\n    function isHolder(address _address) public view returns (bool) {\n        return _address == holder;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...  {     address public holder;      constructor() internal {         holder = msg.sender;     }      function getHolder() public v ...\n                                        ^---------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract TestContract7 {\n    address public chief;\n\n    constructor() internal {\n        chief = msg.sender;\n    }\n\n    function getChief() public view returns (address) {\n        return chief;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... 7 {     address public chief;      constructor() internal {         chief = msg.sender;     }      function getChief() public vi ...\n                                        ^--------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ExampleContract8 {\n    address public lead;\n\n    constructor() internal {\n        lead = msg.sender;\n    }\n\n    function getLead() public view returns (address) {\n        return lead;\n    }\n\n    function getGreeting() public pure returns (string memory) {\n        return \"Hello, world!\";\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ... t8 {     address public lead;      constructor() internal {         lead = msg.sender;     }      function getLead() public vie ...\n                                        ^-------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract DemoContract9 {\n    address public master;\n\n    constructor() internal {\n        master = msg.sender;\n    }\n\n    function getMaster() public view returns (address) {\n        return master;\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...  {     address public master;      constructor() internal {         master = msg.sender;     }      function getMaster() public v ...\n                                        ^---------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract MyContract10 {\n    address public controller;\n\n    constructor() internal {\n        controller = msg.sender;\n    }\n\n    function getController() public view returns (address) {\n        return controller;\n    }\n\n    function getMessage() public pure returns (string memory) {\n        return \"Contract deployed!\";\n    }\n}",
          "error message": "Error: Non-abstract contracts cannot have internal constructors. Remove the \"internal\" keyword and make the contract abstract to fix this.\n ...    address public controller;      constructor() internal {         controller = msg.sender;     }      function getController() publ ...\n                                        ^-------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract SampleContract1 {\n    address public admin;\n\n    constructor() {\n        admin = msg.sender;\n    }\n\n    function getAdmin() public view returns (address) {\n        return admin;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract TestContract2 {\n    address public manager;\n\n    constructor() {\n        manager = msg.sender;\n    }\n\n    function getManager() public view returns (address) {\n        return manager;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ExampleContract3 {\n    address public creator;\n\n    constructor() {\n        creator = msg.sender;\n    }\n\n    function getCreator() public view returns (address) {\n        return creator;\n    }\n\n    function isCreator(address _address) public view returns (bool) {\n        return _address == creator;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract DemoContract4 {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function getOwner() public view returns (address) {\n        return owner;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract MyContract5 {\n    address public primary;\n\n    constructor() {\n        primary = msg.sender;\n    }\n\n    function getPrimary() public view returns (address) {\n        return primary;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract SampleContract6 {\n    address public holder;\n\n    constructor() {\n        holder = msg.sender;\n    }\n\n    function getHolder() public view returns (address) {\n        return holder;\n    }\n\n    function isHolder(address _address) public view returns (bool) {\n        return _address == holder;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract TestContract7 {\n    address public chief;\n\n    constructor() {\n        chief = msg.sender;\n    }\n\n    function getChief() public view returns (address) {\n        return chief;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract ExampleContract8 {\n    address public lead;\n\n    constructor() {\n        lead = msg.sender;\n    }\n\n    function getLead() public view returns (address) {\n        return lead;\n    }\n\n    function getGreeting() public pure returns (string memory) {\n        return \"Hello, world!\";\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract DemoContract9 {\n    address public master;\n\n    constructor() {\n        master = msg.sender;\n    }\n\n    function getMaster() public view returns (address) {\n        return master;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract MyContract10 {\n    address public controller;\n\n    constructor() {\n        controller = msg.sender;\n    }\n\n    function getController() public view returns (address) {\n        return controller;\n    }\n\n    function getMessage() public pure returns (string memory) {\n        return \"Contract deployed!\";\n    }\n}"
      }
    }
  },
  {
    "Changes78": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Type Checker: Disallow <code>virtual</code> for library functions:\nSince libraries cannot be inherited from, library functions should not be virtual.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib1 {\n    function multiply(uint256 x, uint256 y) public pure virtual returns (uint256) {\n        return x * y;\n    }\n}\n\ncontract Example1 {\n    using Lib1 for uint256;\n\n    function product(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.multiply(b);\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib1 {     function multiply(uint256 x, uint256 y) public pure virtual returns (uint256) {         return x * y;     } }  contract Example1 {     using L ...\n                                        ^---------------------------------------------------------------------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib2 {\n    function subtract(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        return a - b;\n    }\n}\n\ncontract Example2 {\n    using Lib2 for uint256;\n\n    function difference(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.subtract(b);\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib2 {     function subtract(uint256 a, uint256 b) public pure virtual returns (uint256) {         return a - b;     } }  contract Example2 {     using L ...\n                                        ^---------------------------------------------------------------------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib3 {\n    function divide(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        require(b > 0, \"Division by zero\");\n        return a / b;\n    }\n}\n\ncontract Example3 {\n    using Lib3 for uint256;\n\n    function quotient(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.divide(b);\n    }\n\n    function randomFunction(uint256 a) public pure returns (uint256) {\n        return a * 2;\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib3 {     function divide(uint256 a, uint256 b) public pure virtual returns (uint256) {         require(b > 0, \"Division by zero\");         return a / b;     } }  contract Example3 {     using L ...\n                                        ^---------------------------------------------------------------------------------------------------------------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib4 {\n    function mod(uint256 a, uint256 b) public pure virtual returns (uint256) {\n        require(b != 0, \"Modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract Example4 {\n    using Lib4 for uint256;\n\n    function remainder(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.mod(b);\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib4 {     function mod(uint256 a, uint256 b) public pure virtual returns (uint256) {         require(b != 0, \"Modulo by zero\");         return a % b;     } }  contract Example4 {     using L ...\n                                        ^-----------------------------------------------------------------------------------------------------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib5 {\n    function power(uint256 base, uint256 exp) public pure virtual returns (uint256) {\n        return base ** exp;\n    }\n}\n\ncontract Example5 {\n    using Lib5 for uint256;\n\n    function exponent(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.power(b);\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib5 {     function power(uint256 base, uint256 exp) public pure virtual returns (uint256) {         return base ** exp;     } }  contract Example5 {     using L ...\n                                        ^-----------------------------------------------------------------------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib6 {\n    function increment(uint256 a) public pure virtual returns (uint256) {\n        return a + 1;\n    }\n}\n\ncontract Example6 {\n    using Lib6 for uint256;\n\n    function incrementByOne(uint256 a) public pure returns (uint256) {\n        return a.increment();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib6 {     function increment(uint256 a) public pure virtual returns (uint256) {         return a + 1;     } }  contract Example6 {     using L ...\n                                        ^-----------------------------------------------------------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib7 {\n    function decrement(uint256 a) public pure virtual returns (uint256) {\n        return a - 1;\n    }\n}\n\ncontract Example7 {\n    using Lib7 for uint256;\n\n    function decrementByOne(uint256 a) public pure returns (uint256) {\n        return a.decrement();\n    }\n\n    function randomFunction(uint256 a) public pure returns (uint256) {\n        return a / 2;\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib7 {     function decrement(uint256 a) public pure virtual returns (uint256) {         return a - 1;     } }  contract Example7 {     using L ...\n                                        ^-----------------------------------------------------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib8 {\n    function square(uint256 a) public pure virtual returns (uint256) {\n        return a * a;\n    }\n}\n\ncontract Example8 {\n    using Lib8 for uint256;\n\n    function squareOf(uint256 a) public pure returns (uint256) {\n        return a.square();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib8 {     function square(uint256 a) public pure virtual returns (uint256) {         return a * a;     } }  contract Example8 {     using L ...\n                                        ^--------------------------------------------------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib9 {\n    function cube(uint256 a) public pure virtual returns (uint256) {\n        return a * a * a;\n    }\n}\n\ncontract Example9 {\n    using Lib9 for uint256;\n\n    function cubeOf(uint256 a) public pure returns (uint256) {\n        return a.cube();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... olidity^0.7.0;  library Lib9 {     function cube(uint256 a) public pure virtual returns (uint256) {         return a * a * a;     } }  contract Example9 {     using L ...\n                                        ^----------------------------------------------------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Lib10 {\n    function isEven(uint256 a) public pure virtual returns (bool) {\n        return a % 2 == 0;\n    }\n}\n\ncontract Example10 {\n    using Lib10 for uint256;\n\n    function checkEven(uint256 a) public pure returns (bool) {\n        return a.isEven();\n    }\n}",
          "error message": "Error: Library functions cannot be \"virtual\".\n ... lidity^0.7.0;  library Lib10 {     function isEven(uint256 a) public pure virtual returns (bool) {         return a % 2 == 0;     } }  contract Example10 {     using  ...\n                                        ^----------------------------------------------------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary Lib1 {\n    function multiply(uint256 x, uint256 y) public pure returns (uint256) {\n        return x * y;\n    }\n}\n\ncontract Example1 {\n    using Lib1 for uint256;\n\n    function product(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.multiply(b);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary Lib2 {\n    function subtract(uint256 a, uint256 b) public pure returns (uint256) {\n        return a - b;\n    }\n}\n\ncontract Example2 {\n    using Lib2 for uint256;\n\n    function difference(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.subtract(b);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary Lib3 {\n    function divide(uint256 a, uint256 b) public pure returns (uint256) {\n        require(b > 0, \"Division by zero\");\n        return a / b;\n    }\n}\n\ncontract Example3 {\n    using Lib3 for uint256;\n\n    function quotient(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.divide(b);\n    }\n\n    function randomFunction(uint256 a) public pure returns (uint256) {\n        return a * 2;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary Lib4 {\n    function mod(uint256 a, uint256 b) public pure returns (uint256) {\n        require(b != 0, \"Modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract Example4 {\n    using Lib4 for uint256;\n\n    function remainder(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.mod(b);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary Lib5 {\n    function power(uint256 base, uint256 exp) public pure returns (uint256) {\n        return base ** exp;\n    }\n}\n\ncontract Example5 {\n    using Lib5 for uint256;\n\n    function exponent(uint256 a, uint256 b) public pure returns (uint256) {\n        return a.power(b);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary Lib6 {\n    function increment(uint256 a) public pure returns (uint256) {\n        return a + 1;\n    }\n}\n\ncontract Example6 {\n    using Lib6 for uint256;\n\n    function incrementByOne(uint256 a) public pure returns (uint256) {\n        return a.increment();\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary Lib7 {\n    function decrement(uint256 a) public pure returns (uint256) {\n        return a - 1;\n    }\n}\n\ncontract Example7 {\n    using Lib7 for uint256;\n\n    function decrementByOne(uint256 a) public pure returns (uint256) {\n        return a.decrement();\n    }\n\n    function randomFunction(uint256 a) public pure returns (uint256) {\n        return a / 2;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary Lib8 {\n    function square(uint256 a) public pure returns (uint256) {\n        return a * a;\n    }\n}\n\ncontract Example8 {\n    using Lib8 for uint256;\n\n    function squareOf(uint256 a) public pure returns (uint256) {\n        return a.square();\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary Lib9 {\n    function cube(uint256 a) public pure returns (uint256) {\n        return a * a * a;\n    }\n}\n\ncontract Example9 {\n    using Lib9 for uint256;\n\n    function cubeOf(uint256 a) public pure returns (uint256) {\n        return a.cube();\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary Lib10 {\n    function isEven(uint256 a) public pure returns (bool) {\n        return a % 2 == 0;\n    }\n}\n\ncontract Example10 {\n    using Lib10 for uint256;\n\n    function checkEven(uint256 a) public pure returns (bool) {\n        return a.isEven();\n    }\n}"
      }
    }
  },
  {
    "Changes79": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Multiple events with the same name and parameter types in the same\ninheritance hierarchy are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Base {\n    event LogEvent(uint256 indexed key, string text);\n\n    function triggerEvent(uint256 _key, string memory _text) public {\n        emit LogEvent(_key, _text);\n    }\n}\n\ncontract Derived1 is Base {\n    event LogEvent(uint256 indexed key, string text);\n\n    function triggerEvent1(uint256 _key, string memory _text) public {\n        emit LogEvent(_key, _text);\n    }\n}\n\ncontract Derived2 is Base {\n    event LogEvent(uint256 indexed key, string text);\n\n    function triggerEvent2(uint256 _key, string memory _text) public {\n        emit LogEvent(_key, _text);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... }  contract Derived1 is Base {     event LogEvent(uint256 indexed key, string text);      function triggerEvent1(uint25 ...\n                                        ^-----------------------------------------------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Super {\n    event Notify(uint256 indexed code, string info);\n\n    function sendNotification(uint256 _code, string memory _info) public {\n        emit Notify(_code, _info);\n    }\n}\n\ncontract SubA is Super {\n    event Notify(uint256 indexed code, string info);\n\n    function sendNotificationA(uint256 _code, string memory _info) public {\n        emit Notify(_code, _info);\n    }\n}\n\ncontract SubB is Super {\n    event Notify(uint256 indexed code, string info);\n\n    function sendNotificationB(uint256 _code, string memory _info) public {\n        emit Notify(_code, _info);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...  } }  contract SubA is Super {     event Notify(uint256 indexed code, string info);      function sendNotificationA(ui ...\n                                        ^----------------------------------------------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Main {\n    event Alert(uint256 indexed id, string msg);\n\n    function raiseAlert(uint256 _id, string memory _msg) public {\n        emit Alert(_id, _msg);\n    }\n}\n\ncontract Branch1 is Main {\n    event Alert(uint256 indexed id, string msg);\n\n    function raiseAlert1(uint256 _id, string memory _msg) public {\n        emit Alert(_id, _msg);\n    }\n}\n\ncontract Branch2 is Main {\n    event Alert(uint256 indexed id, string msg);\n\n    function raiseAlert2(uint256 _id, string memory _msg) public {\n        emit Alert(_id, _msg);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...  }  contract Branch1 is Main {     event Alert(uint256 indexed id, string msg);      function raiseAlert1(uint256  ...\n                                        ^------------------------------------------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Head {\n    event Signal(uint256 indexed number, string data);\n\n    function sendSignal(uint256 _number, string memory _data) public {\n        emit Signal(_number, _data);\n    }\n}\n\ncontract NodeA is Head {\n    event Signal(uint256 indexed number, string data);\n\n    function sendSignalA(uint256 _number, string memory _data) public {\n        emit Signal(_number, _data);\n    }\n}\n\ncontract NodeB is Head {\n    event Signal(uint256 indexed number, string data);\n\n    function sendSignalB(uint256 _number, string memory _data) public {\n        emit Signal(_number, _data);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...  } }  contract NodeA is Head {     event Signal(uint256 indexed number, string data);      function sendSignalA(uint256  ...\n                                        ^------------------------------------------------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Root {\n    event Message(uint256 indexed index, string content);\n\n    function dispatchMessage(uint256 _index, string memory _content) public {\n        emit Message(_index, _content);\n    }\n}\n\ncontract Leaf1 is Root {\n    event Message(uint256 indexed index, string content);\n\n    function dispatchMessage1(uint256 _index, string memory _content) public {\n        emit Message(_index, _content);\n    }\n}\n\ncontract Leaf2 is Root {\n    event Message(uint256 indexed index, string content);\n\n    function dispatchMessage2(uint256 _index, string memory _content) public {\n        emit Message(_index, _content);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ...  } }  contract Leaf1 is Root {     event Message(uint256 indexed index, string content);      function dispatchMessage1(uin ...\n                                        ^---------------------------------------------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Origin {\n    event Ping(uint256 indexed id, string note);\n\n    function sendPing(uint256 _id, string memory _note) public {\n        emit Ping(_id, _note);\n    }\n}\n\ncontract PointA is Origin {\n    event Ping(uint256 indexed id, string note);\n\n    function sendPingA(uint256 _id, string memory _note) public {\n        emit Ping(_id, _note);\n    }\n}\n\ncontract PointB is Origin {\n    event Ping(uint256 indexed id, string note);\n\n    function sendPingB(uint256 _id, string memory _note) public {\n        emit Ping(_id, _note);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... }  contract PointA is Origin {     event Ping(uint256 indexed id, string note);      function sendPingA(uint256 _i ...\n                                        ^------------------------------------------^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Core {\n    event Report(uint256 indexed number, string detail);\n\n    function generateReport(uint256 _number, string memory _detail) public {\n        emit Report(_number, _detail);\n    }\n}\n\ncontract Segment1 is Core {\n    event Report(uint256 indexed number, string detail);\n\n    function generateReport1(uint256 _number, string memory _detail) public {\n        emit Report(_number, _detail);\n    }\n}\n\ncontract Segment2 is Core {\n    event Report(uint256 indexed number, string detail);\n\n    function generateReport2(uint256 _number, string memory _detail) public {\n        emit Report(_number, _detail);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... }  contract Segment1 is Core {     event Report(uint256 indexed number, string detail);      function generateReport1(uint ...\n                                        ^--------------------------------------------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Foundation {\n    event Log(uint256 indexed id, string description);\n\n    function writeLog(uint256 _id, string memory _description) public {\n        emit Log(_id, _description);\n    }\n}\n\ncontract TierA is Foundation {\n    event Log(uint256 indexed id, string description);\n\n    function writeLogA(uint256 _id, string memory _description) public {\n        emit Log(_id, _description);\n    }\n}\n\ncontract TierB is Foundation {\n    event Log(uint256 indexed id, string description);\n\n    function writeLogB(uint256 _id, string memory _description) public {\n        emit Log(_id, _description);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... contract TierA is Foundation {     event Log(uint256 indexed id, string description);      function writeLogA(uint256 _i ...\n                                        ^------------------------------------------------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BaseContract {\n    event ActionEvent(uint256 indexed id, string data);\n\n    function performAction(uint256 _id, string memory _data) public {\n        emit ActionEvent(_id, _data);\n    }\n}\n\ncontract ExtendedA is BaseContract {\n    event ActionEvent(uint256 indexed id, string data);\n\n    function performActionA(uint256 _id, string memory _data) public {\n        emit ActionEvent(_id, _data);\n    }\n}\n\ncontract ExtendedB is BaseContract {\n    event ActionEvent(uint256 indexed id, string data);\n\n    function performActionB(uint256 _id, string memory _data) public {\n        emit ActionEvent(_id, _data);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... ct ExtendedA is BaseContract {     event ActionEvent(uint256 indexed id, string data);      function performActionA(uint2 ...\n                                        ^-------------------------------------------------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Primary {\n    event EventLog(uint256 indexed key, string message);\n\n    function logEvent(uint256 _key, string memory _message) public {\n        emit EventLog(_key, _message);\n    }\n}\n\ncontract Secondary1 is Primary {\n    event EventLog(uint256 indexed key, string message);\n\n    function logEvent1(uint256 _key, string memory _message) public {\n        emit EventLog(_key, _message);\n    }\n}\n\ncontract Secondary2 is Primary {\n    event EventLog(uint256 indexed key, string message);\n\n    function logEvent2(uint256 _key, string memory _message) public {\n        emit EventLog(_key, _message);\n    }\n}",
          "error message": "Error: Event with same name and parameter types defined twice.\n ... ntract Secondary1 is Primary {     event EventLog(uint256 indexed key, string message);      function logEvent1(uint256 _k ...\n                                        ^--------------------------------------------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Base {\n    event LogEventBase(uint256 indexed key, string text);\n\n    function triggerEvent(uint256 _key, string memory _text) public {\n        emit LogEventBase(_key, _text);\n    }\n}\n\ncontract Derived1 is Base {\n    event LogEventDerived1(uint256 indexed key, string text);\n\n    function triggerEvent1(uint256 _key, string memory _text) public {\n        emit LogEventDerived1(_key, _text);\n    }\n}\n\ncontract Derived2 is Base {\n    event LogEventDerived2(uint256 indexed key, string text);\n\n    function triggerEvent2(uint256 _key, string memory _text) public {\n        emit LogEventDerived2(_key, _text);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Super {\n    event NotifySuper(uint256 indexed code, string info);\n\n    function sendNotification(uint256 _code, string memory _info) public {\n        emit NotifySuper(_code, _info);\n    }\n}\n\ncontract SubA is Super {\n    event NotifySubA(uint256 indexed code, string info);\n\n    function sendNotificationA(uint256 _code, string memory _info) public {\n        emit NotifySubA(_code, _info);\n    }\n}\n\ncontract SubB is Super {\n    event NotifySubB(uint256 indexed code, string info);\n\n    function sendNotificationB(uint256 _code, string memory _info) public {\n        emit NotifySubB(_code, _info);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Main {\n    event AlertMain(uint256 indexed id, string msg);\n\n    function raiseAlert(uint256 _id, string memory _msg) public {\n        emit AlertMain(_id, _msg);\n    }\n}\n\ncontract Branch1 is Main {\n    event AlertBranch1(uint256 indexed id, string msg);\n\n    function raiseAlert1(uint256 _id, string memory _msg) public {\n        emit AlertBranch1(_id, _msg);\n    }\n}\n\ncontract Branch2 is Main {\n    event AlertBranch2(uint256 indexed id, string msg);\n\n    function raiseAlert2(uint256 _id, string memory _msg) public {\n        emit AlertBranch2(_id, _msg);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Head {\n    event SignalHead(uint256 indexed number, string data);\n\n    function sendSignal(uint256 _number, string memory _data) public {\n        emit SignalHead(_number, _data);\n    }\n}\n\ncontract NodeA is Head {\n    event SignalNodeA(uint256 indexed number, string data);\n\n    function sendSignalA(uint256 _number, string memory _data) public {\n        emit SignalNodeA(_number, _data);\n    }\n}\n\ncontract NodeB is Head {\n    event SignalNodeB(uint256 indexed number, string data);\n\n    function sendSignalB(uint256 _number, string memory _data) public {\n        emit SignalNodeB(_number, _data);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Root {\n    event MessageRoot(uint256 indexed index, string content);\n\n    function dispatchMessage(uint256 _index, string memory _content) public {\n        emit MessageRoot(_index, _content);\n    }\n}\n\ncontract Leaf1 is Root {\n    event MessageLeaf1(uint256 indexed index, string content);\n\n    function dispatchMessage1(uint256 _index, string memory _content) public {\n        emit MessageLeaf1(_index, _content);\n    }\n}\n\ncontract Leaf2 is Root {\n    event MessageLeaf2(uint256 indexed index, string content);\n\n    function dispatchMessage2(uint256 _index, string memory _content) public {\n        emit MessageLeaf2(_index, _content);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Origin {\n    event PingOrigin(uint256 indexed id, string note);\n\n    function sendPing(uint256 _id, string memory _note) public {\n        emit PingOrigin(_id, _note);\n    }\n}\n\ncontract PointA is Origin {\n    event PingPointA(uint256 indexed id, string note);\n\n    function sendPingA(uint256 _id, string memory _note) public {\n        emit PingPointA(_id, _note);\n    }\n}\n\ncontract PointB is Origin {\n    event PingPointB(uint256 indexed id, string note);\n\n    function sendPingB(uint256 _id, string memory _note) public {\n        emit PingPointB(_id, _note);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Core {\n    event ReportCore(uint256 indexed number, string detail);\n\n    function generateReport(uint256 _number, string memory _detail) public {\n        emit ReportCore(_number, _detail);\n    }\n}\n\ncontract Segment1 is Core {\n    event ReportSegment1(uint256 indexed number, string detail);\n\n    function generateReport1(uint256 _number, string memory _detail) public {\n        emit ReportSegment1(_number, _detail);\n    }\n}\n\ncontract Segment2 is Core {\n    event ReportSegment2(uint256 indexed number, string detail);\n\n    function generateReport2(uint256 _number, string memory _detail) public {\n        emit ReportSegment2(_number, _detail);\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Foundation {\n    event LogFoundation(uint256 indexed id, string description);\n\n    function writeLog(uint256 _id, string memory _description) public {\n        emit LogFoundation(_id, _description);\n    }\n}\n\ncontract TierA is Foundation {\n    event LogTierA(uint256 indexed id, string description);\n\n    function writeLogA(uint256 _id, string memory _description) public {\n        emit LogTierA(_id, _description);\n    }\n}\n\ncontract TierB is Foundation {\n    event LogTierB(uint256 indexed id, string description);\n\n    function writeLogB(uint256 _id, string memory _description) public {\n        emit LogTierB(_id, _description);\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract BaseContract {\n    event ActionEventBase(uint256 indexed id, string data);\n\n    function performAction(uint256 _id, string memory _data) public {\n        emit ActionEventBase(_id, _data);\n    }\n}\n\ncontract ExtendedA is BaseContract {\n    event ActionEventExtendedA(uint256 indexed id, string data);\n\n    function performActionA(uint256 _id, string memory _data) public {\n        emit ActionEventExtendedA(_id, _data);\n    }\n}\n\ncontract ExtendedB is BaseContract {\n    event ActionEventExtendedB(uint256 indexed id, string data);\n\n    function performActionB(uint256 _id, string memory _data) public {\n        emit ActionEventExtendedB(_id, _data);\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Primary {\n    event EventLogPrimary(uint256 indexed key, string message);\n\n    function logEvent(uint256 _key, string memory _message) public {\n        emit EventLogPrimary(_key, _message);\n    }\n}\n\ncontract Secondary1 is Primary {\n    event EventLogSecondary1(uint256 indexed key, string message);\n\n    function logEvent1(uint256 _key, string memory _message) public {\n        emit EventLogSecondary1(_key, _message);\n    }\n}\n\ncontract Secondary2 is Primary {\n    event EventLogSecondary2(uint256 indexed key, string message);\n\n    function logEvent2(uint256 _key, string memory _message) public {\n        emit EventLogSecondary2(_key, _message);\n    }\n}"
      }
    }
  },
  {
    "Changes80": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "<code>using A for B</code> only affects the contract it is mentioned in.\nPreviously, the effect was inherited. Now, you have to repeat the <code>using</code>\nstatement in all derived contracts that make use of the feature.Repeat the <code>using A for B</code> statements in all derived contracts if needed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Arithmetic {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"Arithmetic: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Super {\n    using Arithmetic for uint256;\n    \n    uint256 public superValue;\n    \n    function multiply(uint256 _value) public {\n        superValue = _value.mul(2);\n    }\n}\n\ncontract Sub is Super {\n    function double(uint256 _value) public {\n        superValue = _value.mul(4);\n    }\n}",
          "error message": "Error: Member \"mul\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         superValue = _value.mul(4);     } }\n                                        ^--------^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Operations {\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"Operations: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Main {\n    using Operations for uint256;\n    \n    uint256 public mainValue;\n    \n    function divide(uint256 _value) public {\n        mainValue = _value.div(2);\n    }\n}\n\ncontract Extension is Main {\n    function halve(uint256 _value) public {\n        mainValue = _value.div(3);\n    }\n}",
          "error message": "Error: Member \"div\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         mainValue = _value.div(3);     } }\n                                        ^--------^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Calc {\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Calc: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract Core {\n    using Calc for uint256;\n    \n    uint256 public coreValue;\n    \n    function modulus(uint256 _value) public {\n        coreValue = _value.mod(3);\n    }\n}\n\ncontract Extra is Core {\n    function remainder(uint256 _value) public {\n        coreValue = _value.mod(5);\n    }\n}",
          "error message": "Error: Member \"mod\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         coreValue = _value.mod(5);     } }\n                                        ^--------^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary AdvancedMath {\n    function pow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 result = 1;\n        for (uint256 i = 0; i < exp; i++) {\n            result = result * base;\n        }\n        return result;\n    }\n}\n\ncontract Framework {\n    using AdvancedMath for uint256;\n    \n    uint256 public frameworkValue;\n    \n    function power(uint256 _base, uint256 _exp) public {\n        frameworkValue = _base.pow(_exp);\n    }\n}\n\ncontract Extend is Framework {\n    function exponentiate(uint256 _base, uint256 _exp) public {\n        frameworkValue = _base.pow(_exp + 1);\n    }\n}",
          "error message": "Error: Member \"pow\" not found or not visible after argument-dependent lookup in uint256.\n ...  public {         frameworkValue = _base.pow(_exp + 1);     } }\n                                        ^-------^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Financial {\n    function addPercent(uint256 a, uint256 percent) internal pure returns (uint256) {\n        return a + (a * percent / 100);\n    }\n}\n\ncontract BaseContract {\n    using Financial for uint256;\n    \n    uint256 public baseAmount;\n    \n    function increase(uint256 _amount, uint256 _percent) public {\n        baseAmount = _amount.addPercent(_percent);\n    }\n}\n\ncontract DerivedContract is BaseContract {\n    function increment(uint256 _amount, uint256 _percent) public {\n        baseAmount = _amount.addPercent(_percent + 5);\n    }\n}",
          "error message": "Error: Member \"addPercent\" not found or not visible after argument-dependent lookup in uint256.\n ... ent) public {         baseAmount = _amount.addPercent(_percent + 5);     } }\n                                        ^----------------^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Stats {\n    function avg(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b) / 2;\n    }\n}\n\ncontract Analysis {\n    using Stats for uint256;\n    \n    uint256 public analysisResult;\n    \n    function average(uint256 _a, uint256 _b) public {\n        analysisResult = _a.avg(_b);\n    }\n}\n\ncontract Report is Analysis {\n    function mean(uint256 _a, uint256 _b) public {\n        analysisResult = _a.avg(_b + 1);\n    }\n}",
          "error message": "Error: Member \"avg\" not found or not visible after argument-dependent lookup in uint256.\n ...  public {         analysisResult = _a.avg(_b + 1);     } }\n                                        ^----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Computation {\n    function increment(uint256 a) internal pure returns (uint256) {\n        return a + 1;\n    }\n}\n\ncontract Processor {\n    using Computation for uint256;\n    \n    uint256 public processedValue;\n    \n    function process(uint256 _value) public {\n        processedValue = _value.increment();\n    }\n}\n\ncontract Engine is Processor {\n    function execute(uint256 _value) public {\n        processedValue = _value.increment() + 2;\n    }\n}",
          "error message": "Error: Member \"increment\" not found or not visible after argument-dependent lookup in uint256.\n ...  public {         processedValue = _value.increment() + 2;     } }\n                                        ^--------------^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Transformation {\n    function double(uint256 a) internal pure returns (uint256) {\n        return a * 2;\n    }\n}\n\ncontract Transformer {\n    using Transformation for uint256;\n    \n    uint256 public transformedValue;\n    \n    function transform(uint256 _value) public {\n        transformedValue = _value.double();\n    }\n}\n\ncontract Converter is Transformer {\n    function convert(uint256 _value) public {\n        transformedValue = _value.double() + 1;\n    }\n}",
          "error message": "Error: Member \"double\" not found or not visible after argument-dependent lookup in uint256.\n ... ublic {         transformedValue = _value.double() + 1;     } }\n                                        ^-----------^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Util {\n    function square(uint256 a) internal pure returns (uint256) {\n        return a * a;\n    }\n}\n\ncontract Calculator {\n    using Util for uint256;\n    \n    uint256 public calcValue;\n    \n    function squareValue(uint256 _value) public {\n        calcValue = _value.square();\n    }\n}\n\ncontract Computator is Calculator {\n    function compute(uint256 _value) public {\n        calcValue = _value.square() + 10;\n    }\n}",
          "error message": "Error: Member \"square\" not found or not visible after argument-dependent lookup in uint256.\n ... alue) public {         calcValue = _value.square() + 10;     } }\n                                        ^-----------^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\nlibrary Enhancer {\n    function enhance(uint256 a) internal pure returns (uint256) {\n        return a + 100;\n    }\n}\n\ncontract Basic {\n    using Enhancer for uint256;\n    \n    uint256 public basicValue;\n    \n    function boost(uint256 _value) public {\n        basicValue = _value.enhance();\n    }\n}\n\ncontract Advanced is Basic {\n    function amplify(uint256 _value) public {\n        basicValue = _value.enhance() * 2;\n    }\n}",
          "error message": "Error: Member \"enhance\" not found or not visible after argument-dependent lookup in uint256.\n ... lue) public {         basicValue = _value.enhance() * 2;     } }\n                                        ^------------^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\nlibrary Arithmetic {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        require(c / a == b, \"Arithmetic: multiplication overflow\");\n        return c;\n    }\n}\n\ncontract Super {\n    using Arithmetic for uint256;\n    \n    uint256 public superValue;\n    \n    function multiply(uint256 _value) public {\n        superValue = _value.mul(2);\n    }\n}\n\ncontract Sub is Super {\n    using Arithmetic for uint256;\n    \n    function double(uint256 _value) public {\n        superValue = _value.mul(4);\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\nlibrary Operations {\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"Operations: division by zero\");\n        return a / b;\n    }\n}\n\ncontract Main {\n    using Operations for uint256;\n    \n    uint256 public mainValue;\n    \n    function divide(uint256 _value) public {\n        mainValue = _value.div(2);\n    }\n}\n\ncontract Extension is Main {\n    using Operations for uint256;\n    \n    function halve(uint256 _value) public {\n        mainValue = _value.div(3);\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\nlibrary Calc {\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"Calc: modulo by zero\");\n        return a % b;\n    }\n}\n\ncontract Core {\n    using Calc for uint256;\n    \n    uint256 public coreValue;\n    \n    function modulus(uint256 _value) public {\n        coreValue = _value.mod(3);\n    }\n}\n\ncontract Extra is Core {\n    using Calc for uint256;\n    \n    function remainder(uint256 _value) public {\n        coreValue = _value.mod(5);\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\nlibrary AdvancedMath {\n    function pow(uint256 base, uint256 exp) internal pure returns (uint256) {\n        uint256 result = 1;\n        for (uint256 i = 0; i < exp; i++) {\n            result = result * base;\n        }\n        return result;\n    }\n}\n\ncontract Framework {\n    using AdvancedMath for uint256;\n    \n    uint256 public frameworkValue;\n    \n    function power(uint256 _base, uint256 _exp) public {\n        frameworkValue = _base.pow(_exp);\n    }\n}\n\ncontract Extend is Framework {\n    using AdvancedMath for uint256;\n    \n    function exponentiate(uint256 _base, uint256 _exp) public {\n        frameworkValue = _base.pow(_exp + 1);\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\nlibrary Financial {\n    function addPercent(uint256 a, uint256 percent) internal pure returns (uint256) {\n        return a + (a * percent / 100);\n    }\n}\n\ncontract BaseContract {\n    using Financial for uint256;\n    \n    uint256 public baseAmount;\n    \n    function increase(uint256 _amount, uint256 _percent) public {\n        baseAmount = _amount.addPercent(_percent);\n    }\n}\n\ncontract DerivedContract is BaseContract {\n    using Financial for uint256;\n    \n    function increment(uint256 _amount, uint256 _percent) public {\n        baseAmount = _amount.addPercent(_percent + 5);\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\nlibrary Stats {\n    function avg(uint256 a, uint256 b) internal pure returns (uint256) {\n        return (a + b) / 2;\n    }\n}\n\ncontract Analysis {\n    using Stats for uint256;\n    \n    uint256 public analysisResult;\n    \n    function average(uint256 _a, uint256 _b) public {\n        analysisResult = _a.avg(_b);\n    }\n}\n\ncontract Report is Analysis {\n    using Stats for uint256;\n    \n    function mean(uint256 _a, uint256 _b) public {\n        analysisResult = _a.avg(_b + 1);\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\nlibrary Computation {\n    function increment(uint256 a) internal pure returns (uint256) {\n        return a + 1;\n    }\n}\n\ncontract Processor {\n    using Computation for uint256;\n    \n    uint256 public processedValue;\n    \n    function process(uint256 _value) public {\n        processedValue = _value.increment();\n    }\n}\n\ncontract Engine is Processor {\n    using Computation for uint256;\n    \n    function execute(uint256 _value) public {\n        processedValue = _value.increment() + 2;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\nlibrary Transformation {\n    function double(uint256 a) internal pure returns (uint256) {\n        return a * 2;\n    }\n}\n\ncontract Transformer {\n    using Transformation for uint256;\n    \n    uint256 public transformedValue;\n    \n    function transform(uint256 _value) public {\n        transformedValue = _value.double();\n    }\n}\n\ncontract Converter is Transformer {\n    using Transformation for uint256;\n    \n    function convert(uint256 _value) public {\n        transformedValue = _value.double() + 1;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\nlibrary Util {\n    function square(uint256 a) internal pure returns (uint256) {\n        return a * a;\n    }\n}\n\ncontract Calculator {\n    using Util for uint256;\n    \n    uint256 public calcValue;\n    \n    function squareValue(uint256 _value) public {\n        calcValue = _value.square();\n    }\n}\n\ncontract Computator is Calculator {\n    using Util for uint256;\n    \n    function compute(uint256 _value) public {\n        calcValue = _value.square() + 10;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\nlibrary Enhancer {\n    function enhance(uint256 a) internal pure returns (uint256) {\n        return a + 100;\n    }\n}\n\ncontract Basic {\n    using Enhancer for uint256;\n    \n    uint256 public basicValue;\n    \n    function boost(uint256 _value) public {\n        basicValue = _value.enhance();\n    }\n}\n\ncontract Advanced is Basic {\n    using Enhancer for uint256;\n    \n    function amplify(uint256 _value) public {\n        basicValue = _value.enhance() * 2;\n    }\n}"
      }
    }
  },
  {
    "Changes81": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "Shifts by signed types are disallowed.\nPreviously, shifts by negative amounts were allowed, but reverted at runtime.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftExample1 {\n    function shiftLeft(int8 x, int8 y) public pure returns (int8) {\n        return x << y;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\npragma solidity^0.7.0;  contract ShiftExample1 {     function shiftLeft(int8 x, int8 y) public pure returns (int8) {         return x << y;     } }\n                                                                                                                                    ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitwiseShift {\n    function leftShift(int8 a, int8 b) public pure returns (int8) {\n        return a << b;\n    }\n\n    function unusedFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return a << b;     }      function unusedFunctio ...\n                                        ^----^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftOperations {\n    function shiftAmount(int8 m, int8 n) public pure returns (int8) {\n        return m << n;\n    }\n\n    function anotherFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return m << n;     }      function anotherFuncti ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitShift {\n    function shiftBits(int8 c, int8 d) public pure returns (int8) {\n        return c << d;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\npragma solidity^0.7.0;  contract BitShift {     function shiftBits(int8 c, int8 d) public pure returns (int8) {         return c << d;     } }\n                                                                                                                               ^----^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract LeftShiftExample {\n    function shiftExample(int8 p, int8 q) public pure returns (int8) {\n        return p << q;\n    }\n\n    function dummyFunction1() public pure returns (address) {\n        return address(0);\n    }\n\n    function dummyFunction2() public pure returns (int256) {\n        return 123456;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return p << q;     }      function dummyFunction ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Shifting {\n    function performShift(int8 v, int8 w) public pure returns (int8) {\n        return v << w;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\npragma solidity^0.7.0;  contract Shifting {     function performShift(int8 v, int8 w) public pure returns (int8) {         return v << w;     } }\n                                                                                                                                  ^----^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftTest {\n    function shiftValue(int8 s, int8 t) public pure returns (int8) {\n        return s << t;\n    }\n\n    function randomFunction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return s << t;     }      function randomFunctio ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract BitManipulation {\n    function manipulateBits(int8 g, int8 h) public pure returns (int8) {\n        return g << h;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return g << h;     } }\n                                        ^----^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftLeft {\n    function leftShiftOperation(int8 i, int8 j) public pure returns (int8) {\n        return i << j;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return i << j;     } }\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract ShiftHandler {\n    function handleShift(int8 k, int8 l) public pure returns (int8) {\n        return k << l;\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 789;\n    }\n}",
          "error message": "Error: Operator << not compatible with types int8 and int8\n ... re returns (int8) {         return k << l;     }      function extraFunction ...\n                                        ^----^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract ShiftExample1 {\n    function shiftLeft(int8 x, uint8 y) public pure returns (int8) {\n        return x << y;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract BitwiseShift {\n    function leftShift(int8 a, uint8 b) public pure returns (int8) {\n        return a << b;\n    }\n\n    function unusedFunction1() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract ShiftOperations {\n    function shiftAmount(int8 m, uint8 n) public pure returns (int8) {\n        return m << n;\n    }\n\n    function anotherFunction() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract BitShift {\n    function shiftBits(int8 c, uint8 d) public pure returns (int8) {\n        return c << d;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract LeftShiftExample {\n    function shiftExample(int8 p, uint8 q) public pure returns (int8) {\n        return p << q;\n    }\n\n    function dummyFunction1() public pure returns (address) {\n        return address(0);\n    }\n\n    function dummyFunction2() public pure returns (int256) {\n        return 123456;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Shifting {\n    function performShift(int8 v, uint8 w) public pure returns (int8) {\n        return v << w;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract ShiftTest {\n    function shiftValue(int8 s, uint8 t) public pure returns (int8) {\n        return s << t;\n    }\n\n    function randomFunction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract BitManipulation {\n    function manipulateBits(int8 g, uint8 h) public pure returns (int8) {\n        return g << h;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract ShiftLeft {\n    function leftShiftOperation(int8 i, uint8 j) public pure returns (int8) {\n        return i << j;\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract ShiftHandler {\n    function handleShift(int8 k, uint8 l) public pure returns (int8) {\n        return k << l;\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 789;\n    }\n}"
      }
    }
  },
  {
    "Changes82": {
      "Version Migration": "0.6->0.7",
      "Knowledge": "The <code>finney</code> and <code>szabo</code> denominations are removed.\nThey are rarely used and do not make the actual amount readily visible. Instead, explicit\nvalues like <code>1e20</code> or the very common <code>gwei</code> can be used.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public feeInFinney = 3 finney;\n\n    function payFee() public payable {\n        require(msg.value >= feeInFinney, \"Fee is 3 finney\");\n    }\n\n    function getFee() public view returns (uint) {\n        return feeInFinney;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...  {     uint public feeInFinney = 3 finney;      function payFee() public pay ...\n                                        ^----^"
        },
        "Example2": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public donationInSzabo = 25 szabo;\n\n    function donate() public payable {\n        require(msg.value >= donationInSzabo, \"Minimum donation is 25 szabo\");\n    }\n\n    function getDonation() public view returns (uint) {\n        return donationInSzabo;\n    }\n\n    function anotherFunc() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...   uint public donationInSzabo = 25 szabo;      function donate() public pay ...\n                                        ^---^"
        },
        "Example3": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public valueInFinney = 5 finney;\n\n    function setValue(uint newValue) public {\n        valueInFinney = newValue * 1 finney;\n    }\n\n    function getValue() public view returns (uint) {\n        return valueInFinney;\n    }\n\n    function randomFunc() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...      uint public valueInFinney = 5 finney;      function setValue(uint newVa ...\n                                        ^----^"
        },
        "Example4": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public minSzabo = 30 szabo;\n\n    function deposit() public payable {\n        require(msg.value >= minSzabo, \"Must deposit at least 30 szabo\");\n    }\n\n    function getMin() public view returns (uint) {\n        return minSzabo;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... 14 {     uint public minSzabo = 30 szabo;      function deposit() public pa ...\n                                        ^---^"
        },
        "Example5": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public maxFinney = 50 finney;\n\n    function setMax(uint newMax) public {\n        maxFinney = newMax * 1 finney;\n    }\n\n    function getMax() public view returns (uint) {\n        return maxFinney;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... 5 {     uint public maxFinney = 50 finney;      function setMax(uint newMax) ...\n                                        ^----^"
        },
        "Example6": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public requiredSzabo = 75 szabo;\n\n    function sendFunds() public payable {\n        require(msg.value >= requiredSzabo, \"Need at least 75 szabo\");\n    }\n\n    function getRequired() public view returns (uint) {\n        return requiredSzabo;\n    }\n\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...     uint public requiredSzabo = 75 szabo;      function sendFunds() public  ...\n                                        ^---^"
        },
        "Example7": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public feeFinney = 4 finney;\n\n    function pay() public payable {\n        require(msg.value >= feeFinney, \"Fee is 4 finney\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return feeFinney;\n    }\n\n    function additionalFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... 17 {     uint public feeFinney = 4 finney;      function pay() public payabl ...\n                                        ^----^"
        },
        "Example8": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public amountSzabo = 40 szabo;\n\n    function contribute() public payable {\n        require(msg.value >= amountSzabo, \"Contribution must be at least 40 szabo\");\n    }\n\n    function getAmount() public view returns (uint) {\n        return amountSzabo;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... {     uint public amountSzabo = 40 szabo;      function contribute() public ...\n                                        ^---^"
        },
        "Example9": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public rateFinney = 6 finney;\n\n    function invest() public payable {\n        require(msg.value >= rateFinney, \"Investment rate is 6 finney\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rateFinney;\n    }\n\n    function someFunction() public pure returns (string memory) {\n        return \"some\";\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ... 9 {     uint public rateFinney = 6 finney;      function invest() public pay ...\n                                        ^----^"
        },
        "Example10": {
          "code": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public thresholdSzabo = 100 szabo;\n\n    function setThreshold(uint newThreshold) public {\n        thresholdSzabo = newThreshold * 1 szabo;\n    }\n\n    function getThreshold() public view returns (uint) {\n        return thresholdSzabo;\n    }\n}",
          "error message": "Error: Expected ';' but got identifier\n ...   uint public thresholdSzabo = 100 szabo;      function setThreshold(uint n ...\n                                        ^---^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.7.0;\n\ncontract Example11 {\n    uint public feeInWei = 3e15;\n\n    function payFee() public payable {\n        require(msg.value >= feeInWei, \"Fee is 3 finney equivalent in wei\");\n    }\n\n    function getFee() public view returns (uint) {\n        return feeInWei;\n    }\n\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example2": "pragma solidity ^0.7.0;\n\ncontract Example12 {\n    uint public donationInWei = 25e12;\n\n    function donate() public payable {\n        require(msg.value >= donationInWei, \"Minimum donation is 25 szabo equivalent in wei\");\n    }\n\n    function getDonation() public view returns (uint) {\n        return donationInWei;\n    }\n\n    function anotherFunc() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.7.0;\n\ncontract Example13 {\n    uint public valueInWei = 5e15;\n\n    function setValue(uint newValue) public {\n        valueInWei = newValue * 1e15;\n    }\n\n    function getValue() public view returns (uint) {\n        return valueInWei;\n    }\n\n    function randomFunc() public pure returns (string memory) {\n        return \"random\";\n    }\n}",
        "Example4": "pragma solidity ^0.7.0;\n\ncontract Example14 {\n    uint public minWei = 30e12;\n\n    function deposit() public payable {\n        require(msg.value >= minWei, \"Must deposit at least 30 szabo equivalent in wei\");\n    }\n\n    function getMin() public view returns (uint) {\n        return minWei;\n    }\n}",
        "Example5": "pragma solidity ^0.7.0;\n\ncontract Example15 {\n    uint public maxWei = 50e15;\n\n    function setMax(uint newMax) public {\n        maxWei = newMax * 1e15;\n    }\n\n    function getMax() public view returns (uint) {\n        return maxWei;\n    }\n}",
        "Example6": "pragma solidity ^0.7.0;\n\ncontract Example16 {\n    uint public requiredWei = 75e12;\n\n    function sendFunds() public payable {\n        require(msg.value >= requiredWei, \"Need at least 75 szabo equivalent in wei\");\n    }\n\n    function getRequired() public view returns (uint) {\n        return requiredWei;\n    }\n\n    function helper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.7.0;\n\ncontract Example17 {\n    uint public feeWei = 4e15;\n\n    function pay() public payable {\n        require(msg.value >= feeWei, \"Fee is 4 finney equivalent in wei\");\n    }\n\n    function feeAmount() public view returns (uint) {\n        return feeWei;\n    }\n\n    function additionalFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example8": "pragma solidity ^0.7.0;\n\ncontract Example18 {\n    uint public amountWei = 40e12;\n\n    function contribute() public payable {\n        require(msg.value >= amountWei, \"Contribution must be at least 40 szabo equivalent in wei\");\n    }\n\n    function getAmount() public view returns (uint) {\n        return amountWei;\n    }\n}",
        "Example9": "pragma solidity ^0.7.0;\n\ncontract Example19 {\n    uint public rateWei = 6e15;\n\n    function invest() public payable {\n        require(msg.value >= rateWei, \"Investment rate is 6 finney equivalent in wei\");\n    }\n\n    function getRate() public view returns (uint) {\n        return rateWei;\n    }\n\n    function someFunction() public pure returns (string memory) {\n        return \"some\";\n    }\n}",
        "Example10": "pragma solidity ^0.7.0;\n\ncontract Example20 {\n    uint public thresholdWei = 100e12;\n\n    function setThreshold(uint newThreshold) public {\n        thresholdWei = newThreshold * 1e12;\n    }\n\n    function getThreshold() public view returns (uint) {\n        return thresholdWei;\n    }\n}"
      }
    }
  },
  {
    "Changes83": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractA {\n    byte itemA;\n    function setItemA(byte newValue) public {\n        itemA = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/2.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractA {     byte itemA;     function setItemA(byte newValue) public {         itemA = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractB {\n    byte itemB;\n    function updateItemB(byte newValue) public {\n        itemB = newValue;\n    }\n    function extraFunctionB1() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/3.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractB {     byte itemB;     function updateItemB(by ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractC {\n    byte itemC;\n    function modifyItemC(byte newValue) public {\n        itemC = newValue;\n    }\n    function extraFunctionC1() public pure returns (bool) {\n        return true;\n    }\n    function extraFunctionC2() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/4.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractC {     byte itemC;     function modifyItemC(by ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractD {\n    byte itemD;\n    function adjustItemD(byte newValue) public {\n        itemD = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/5.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractD {     byte itemD;     function adjustItemD(byte newValue) public {         itemD = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractE {\n    byte itemE;\n    function changeItemE(byte newValue) public {\n        itemE = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/6.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractE {     byte itemE;     function changeItemE(byte newValue) public {         itemE = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractF {\n    byte itemF;\n    function shiftItemF(byte newValue) public {\n        itemF = newValue;\n    }\n    function extraFunctionF1() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/7.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractF {     byte itemF;     function shiftItemF(byt ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractG {\n    byte itemG;\n    function switchItemG(byte newValue) public {\n        itemG = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/8.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractG {     byte itemG;     function switchItemG(byte newValue) public {         itemG = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractH {\n    byte itemH;\n    function replaceItemH(byte newValue) public {\n        itemH = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/9.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractH {     byte itemH;     function replaceItemH(byte newValue) public {         itemH = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractI {\n    byte itemI;\n    function setItemI(byte newValue) public {\n        itemI = newValue;\n    }\n    function extraFunctionI1() public pure returns (uint) {\n        return 999;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/10.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractI {     byte itemI;     function setItemI(byte  ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractJ {\n    byte itemJ;\n    function updateItemJ(byte newValue) public {\n        itemJ = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/11.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractJ {     byte itemJ;     function updateItemJ(byte newValue) public {         itemJ = newValue;     } }\n  |                                                 ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractA {\n    bytes1 itemA;\n    function setItemA(bytes1 newValue) public {\n        itemA = newValue;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractB {\n    bytes1 itemB;\n    function updateItemB(bytes1 newValue) public {\n        itemB = newValue;\n    }\n    function extraFunctionB1() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractC {\n    bytes1 itemC;\n    function modifyItemC(bytes1 newValue) public {\n        itemC = newValue;\n    }\n    function extraFunctionC1() public pure returns (bool) {\n        return true;\n    }\n    function extraFunctionC2() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractD {\n    bytes1 itemD;\n    function adjustItemD(bytes1 newValue) public {\n        itemD = newValue;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractE {\n    bytes1 itemE;\n    function changeItemE(bytes1 newValue) public {\n        itemE = newValue;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractF {\n    bytes1 itemF;\n    function shiftItemF(bytes1 newValue) public {\n        itemF = newValue;\n    }\n    function extraFunctionF1() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractG {\n    bytes1 itemG;\n    function switchItemG(bytes1 newValue) public {\n        itemG = newValue;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractH {\n    bytes1 itemH;\n    function replaceItemH(bytes1 newValue) public {\n        itemH = newValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractI {\n    bytes1 itemI;\n    function setItemI(bytes1 newValue) public {\n        itemI = newValue;\n    }\n    function extraFunctionI1() public pure returns (uint) {\n        return 999;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractJ {\n    bytes1 itemJ;\n    function updateItemJ(bytes1 newValue) public {\n        itemJ = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes84": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions from negative literals and literals larger than <code>type(uint160).max</code> to\n<code>address</code> are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractOne {\n    function convertNegative() public pure returns (address) {\n        int num = -1;\n        return address(uint160(num));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/12.sol:1:156:\n  |\n1 |  ... t num = -1;         return address(uint160(num));     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwo {\n    function handleConversion() public pure returns (address) {\n        int val = -2;\n        return address(uint160(val));\n    }\n    function helper() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/13.sol:1:157:\n  |\n1 |  ... t val = -2;         return address(uint160(val));     }     function helper() publ ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThree {\n    function negativeToAddress() public pure returns (address) {\n        int negative = -3;\n        return address(uint160(negative));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/14.sol:1:165:\n  |\n1 |  ... ative = -3;         return address(uint160(negative));     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractFour {\n    function adjustNegative() public pure returns (address) {\n        int negNumber = -4;\n        return address(uint160(negNumber));\n    }\n    function additionalFunc() public pure returns (bool) {\n        return true;\n    }\n    function anotherFunc() public pure returns (string memory) {\n        return \"extra\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/15.sol:1:162:\n  |\n1 |  ... umber = -4;         return address(uint160(negNumber));     }     function additionalFun ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractFive {\n    function transformNegative() public pure returns (address) {\n        int negativeValue = -5;\n        return address(uint160(negativeValue));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/16.sol:1:169:\n  |\n1 |  ... Value = -5;         return address(uint160(negativeValue));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractSix {\n    function shiftNegative() public pure returns (address) {\n        int negVal = -6;\n        return address(uint160(negVal));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/17.sol:1:157:\n  |\n1 |  ... egVal = -6;         return address(uint160(negVal));     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractSeven {\n    function convertNeg() public pure returns (address) {\n        int value = -7;\n        return address(uint160(value));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/18.sol:1:155:\n  |\n1 |  ... value = -7;         return address(uint160(value));     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractEight {\n    function routeNegative() public pure returns (address) {\n        int negInt = -8;\n        return address(uint160(negInt));\n    }\n    function simpleFunction() public pure returns (int) {\n        return 0;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/19.sol:1:159:\n  |\n1 |  ... egInt = -8;         return address(uint160(negInt));     }     function simpleFunctio ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractNine {\n    function negateToAddress() public pure returns (address) {\n        int negativeInteger = -9;\n        return address(uint160(negativeInteger));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/20.sol:1:169:\n  |\n1 |  ... teger = -9;         return address(uint160(negativeInteger));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTen {\n    function negativeShift() public pure returns (address) {\n        int neg = -10;\n        return address(uint160(neg));\n    }\n    function extraFunction() public pure returns (uint) {\n        return 1;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/21.sol:1:155:\n  |\n1 |  ...  neg = -10;         return address(uint160(neg));     }     function extraFunction ...\n  |                                         ^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractOne {\n    function convertNegative() public pure returns (address) {\n        uint num = 1;\n        return address(uint160(num));\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractTwo {\n    function handleConversion() public pure returns (address) {\n        uint val = 2;\n        return address(uint160(val));\n    }\n    function helper() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractThree {\n    function negativeToAddress() public pure returns (address) {\n        uint negative = 3;\n        return address(uint160(negative));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractFour {\n    function adjustNegative() public pure returns (address) {\n        uint negNumber = 4;\n        return address(uint160(negNumber));\n    }\n    function additionalFunc() public pure returns (bool) {\n        return true;\n    }\n    function anotherFunc() public pure returns (string memory) {\n        return \"extra\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractFive {\n    function transformNegative() public pure returns (address) {\n        uint negativeValue = 5;\n        return address(uint160(negativeValue));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractSix {\n    function shiftNegative() public pure returns (address) {\n        uint negVal = 6;\n        return address(uint160(negVal));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractSeven {\n    function convertNeg() public pure returns (address) {\n        uint value = 7;\n        return address(uint160(value));\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractEight {\n    function routeNegative() public pure returns (address) {\n        uint negInt = 8;\n        return address(uint160(negInt));\n    }\n    function simpleFunction() public pure returns (int) {\n        return 0;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractNine {\n    function negateToAddress() public pure returns (address) {\n        uint negativeInteger = 9;\n        return address(uint160(negativeInteger));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractTen {\n    function negativeShift() public pure returns (address) {\n        uint neg = 10;\n        return address(uint160(neg));\n    }\n    function extraFunction() public pure returns (uint) {\n        return 1;\n    }\n}"
      }
    }
  },
  {
    "Changes85": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and an integer type <code>T</code> are only allowed if the literal\nlies between <code>type(T).min</code> and <code>type(T).max</code>. In particular, replace usages of <code>uint(-1)</code>\nwith <code>type(uint).max</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleOne {\n    function fetchMaxValue() public pure returns (uint) {\n        uint maxValue = uint(-1);\n        return maxValue;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/22.sol:1:129:\n  |\n1 |  ... s (uint) {         uint maxValue = uint(-1);         return maxValue;     } }\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwo {\n    function retrieveLimit() public pure returns (uint) {\n        uint limit = uint(-1);\n        return limit;\n    }\n    function dummyFunction() public pure returns (uint) {\n        return 0;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/23.sol:1:126:\n  |\n1 |  ... urns (uint) {         uint limit = uint(-1);         return limit;     }     f ...\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThree {\n    function getMaxInt() public pure returns (uint) {\n        uint maxInt = uint(-1);\n        return maxInt;\n    }\n    function anotherDummy() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/24.sol:1:125:\n  |\n1 |  ... rns (uint) {         uint maxInt = uint(-1);         return maxInt;     }      ...\n  |                                         ^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleFour {\n    function calculateBoundary() public pure returns (uint) {\n        uint boundary = uint(-1);\n        return boundary;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/25.sol:1:134:\n  |\n1 |  ... s (uint) {         uint boundary = uint(-1);         return boundary;     } }\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleFive {\n    function getUpperLimit() public pure returns (uint) {\n        uint upperLimit = uint(-1);\n        return upperLimit;\n    }\n    function extraFunctionOne() public pure returns (uint) {\n        return 1;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/26.sol:1:132:\n  |\n1 |  ... (uint) {         uint upperLimit = uint(-1);         return upperLimit;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleSix {\n    function pullMaxValue() public pure returns (uint) {\n        uint maxVal = uint(-1);\n        return maxVal;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/27.sol:1:126:\n  |\n1 |  ... rns (uint) {         uint maxVal = uint(-1);         return maxVal;     } }\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleSeven {\n    function extractLimitValue() public pure returns (uint) {\n        uint limitValue = uint(-1);\n        return limitValue;\n    }\n    function extraFunctionTwo() public pure returns (uint) {\n        return 2;\n    }\n    function extraFunctionThree() public pure returns (uint) {\n        return 3;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/28.sol:1:137:\n  |\n1 |  ... (uint) {         uint limitValue = uint(-1);         return limitValue;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleEight {\n    function deriveBoundary() public pure returns (uint) {\n        uint boundaryValue = uint(-1);\n        return boundaryValue;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/29.sol:1:137:\n  |\n1 |  ... nt) {         uint boundaryValue = uint(-1);         return boundaryValue;     ...\n  |                                         ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleNine {\n    function queryMaxInt() public pure returns (uint) {\n        uint queryInt = uint(-1);\n        return queryInt;\n    }\n    function irrelevant() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/30.sol:1:128:\n  |\n1 |  ... s (uint) {         uint queryInt = uint(-1);         return queryInt;     }    ...\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTen {\n    function findUpperLimit() public pure returns (uint) {\n        uint upperBoundary = uint(-1);\n        return upperBoundary;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/31.sol:1:135:\n  |\n1 |  ... nt) {         uint upperBoundary = uint(-1);         return upperBoundary;     ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ExampleOne {\n    function fetchMaxValue() public pure returns (uint) {\n        uint maxValue = type(uint).max;\n        return maxValue;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleTwo {\n    function retrieveLimit() public pure returns (uint) {\n        uint limit = type(uint).max;\n        return limit;\n    }\n    function dummyFunction() public pure returns (uint) {\n        return 0;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ExampleThree {\n    function getMaxInt() public pure returns (uint) {\n        uint maxInt = type(uint).max;\n        return maxInt;\n    }\n    function anotherDummy() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ExampleFour {\n    function calculateBoundary() public pure returns (uint) {\n        uint boundary = type(uint).max;\n        return boundary;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ExampleFive {\n    function getUpperLimit() public pure returns (uint) {\n        uint upperLimit = type(uint).max;\n        return upperLimit;\n    }\n    function extraFunctionOne() public pure returns (uint) {\n        return 1;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ExampleSix {\n    function pullMaxValue() public pure returns (uint) {\n        uint maxVal = type(uint).max;\n        return maxVal;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ExampleSeven {\n    function extractLimitValue() public pure returns (uint) {\n        uint limitValue = type(uint).max;\n        return limitValue;\n    }\n    function extraFunctionTwo() public pure returns (uint) {\n        return 2;\n    }\n    function extraFunctionThree() public pure returns (uint) {\n        return 3;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ExampleEight {\n    function deriveBoundary() public pure returns (uint) {\n        uint boundaryValue = type(uint).max;\n        return boundaryValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ExampleNine {\n    function queryMaxInt() public pure returns (uint) {\n        uint queryInt = type(uint).max;\n        return queryInt;\n    }\n    function irrelevant() public pure returns (string memory) {\n        return \"Nothing\";\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ExampleTen {\n    function findUpperLimit() public pure returns (uint) {\n        uint upperBoundary = type(uint).max;\n        return upperBoundary;\n    }\n}"
      }
    }
  },
  {
    "Changes86": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and enums are only allowed if the literal can\nrepresent a value in the enum.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example2 {\n    enum Phase { Start, Middle, End }\n    Phase public currentPhase;\n    function triggerError() public {\n        currentPhase = Phase(5); \n    }\n    function extraFunction() public pure returns (int) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example2.Phase\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/32.sol:1:174:\n  |\n1 |  ... () public {         currentPhase = Phase(5);      }     function extraFunction ...\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example3 {\n    enum Level { Low, Medium, High }\n    Level public securityLevel;\n    function setOverflowLevel() public {\n        securityLevel = Level(3); \n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example3.Level\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/33.sol:1:179:\n  |\n1 |  ... ) public {         securityLevel = Level(3);      } }\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example4 {\n    enum Option { None, Some, Many }\n    Option public choice;\n    function assignInvalid() public {\n        choice = Option(4); \n    }\n    function helpFunction() public pure returns (bool) {\n        return true;\n    }\n    function anotherHelper() public pure returns (string memory) {\n        return \"More help\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example4.Option\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/34.sol:1:163:\n  |\n1 |  ... nvalid() public {         choice = Option(4);      }     function helpFunction( ...\n  |                                         ^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example5 {\n    enum State { Idle, Running, Stopped }\n    State public machineState;\n    function setState() public {\n        machineState = State(6);\n    }\n    function randomFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 6\" to \"enum Example5.State\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/35.sol:1:174:\n  |\n1 |  ... () public {         machineState = State(6);     }     function randomFunction ...\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example6 {\n    enum Condition { New, Used, Refurbished }\n    Condition public itemCondition;\n    function updateCondition() public {\n        itemCondition = Condition(7);\n    }\n    function utilityFunction() public pure returns (int) {\n        int x = -1;\n        return x;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 7\" to \"enum Example6.Condition\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/36.sol:1:191:\n  |\n1 |  ... ) public {         itemCondition = Condition(7);     }     function utilityFunctio ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example7 {\n    enum Activity { Sleeping, Running, Eating }\n    Activity public currentActivity;\n    function performAction() public {\n        currentActivity = Activity(8);\n    }\n    function someFunction() public pure returns (bytes32) {\n        return \"data\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 8\" to \"enum Example7.Activity\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/37.sol:1:194:\n  |\n1 |  ... public {         currentActivity = Activity(8);     }     function someFunction() ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example8 {\n    enum Mood { Happy, Sad, Angry }\n    Mood public currentMood;\n    function setMood() public {\n        currentMood = Mood(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example8.Mood\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/38.sol:1:164:\n  |\n1 |  ... d() public {         currentMood = Mood(3);     } }\n  |                                         ^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example9 {\n    enum Position { First, Second, Third }\n    Position public racePosition;\n    function setPosition() public {\n        racePosition = Position(5);\n    }\n    function helper() public pure returns (string memory) {\n        return \"Useful\";\n    }\n    function anotherOne() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example9.Position\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/39.sol:1:181:\n  |\n1 |  ... () public {         racePosition = Position(5);     }     function helper() publi ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example10 {\n    enum Temperature { Cold, Warm, Hot }\n    Temperature public waterTemp;\n    function setTemperature() public {\n        waterTemp = Temperature(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example10.Temperature\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/40.sol:1:180:\n  |\n1 |  ... ure() public {         waterTemp = Temperature(4);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example11 {\n    enum Quantity { Few, Some, Many }\n    Quantity public itemCount;\n    function adjustQuantity() public {\n        itemCount = Quantity(5);\n    }\n    function auxiliary() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example11.Quantity\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/41.sol:1:174:\n  |\n1 |  ... ity() public {         itemCount = Quantity(5);     }     function auxiliary() pu ...\n  |                                         ^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example2 {\n    enum Phase { Start, Middle, End }\n    Phase public currentPhase;\n    function triggerError() public {\n        currentPhase = Phase.Start;\n    }\n    function extraFunction() public pure returns (int) {\n        return 42;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example3 {\n    enum Level { Low, Medium, High }\n    Level public securityLevel;\n    function setOverflowLevel() public {\n        securityLevel = Level.High;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example4 {\n    enum Option { None, Some, Many }\n    Option public choice;\n    function assignInvalid() public {\n        choice = Option.Many;\n    }\n    function helpFunction() public pure returns (bool) {\n        return true;\n    }\n    function anotherHelper() public pure returns (string memory) {\n        return \"More help\";\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example5 {\n    enum State { Idle, Running, Stopped }\n    State public machineState;\n    function setState() public {\n        machineState = State.Stopped;\n    }\n    function randomFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example6 {\n    enum Condition { New, Used, Refurbished }\n    Condition public itemCondition;\n    function updateCondition() public {\n        itemCondition = Condition.Used;\n    }\n    function utilityFunction() public pure returns (int) {\n        int x = -1;\n        return x;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example7 {\n    enum Activity { Sleeping, Running, Eating }\n    Activity public currentActivity;\n    function performAction() public {\n        currentActivity = Activity.Running;\n    }\n    function someFunction() public pure returns (bytes32) {\n        return \"data\";\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example8 {\n    enum Mood { Happy, Sad, Angry }\n    Mood public currentMood;\n    function setMood() public {\n        currentMood = Mood.Happy;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example9 {\n    enum Position { First, Second, Third }\n    Position public racePosition;\n    function setPosition() public {\n        racePosition = Position.First;\n    }\n    function helper() public pure returns (string memory) {\n        return \"Useful\";\n    }\n    function anotherOne() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example10 {\n    enum Temperature { Cold, Warm, Hot }\n    Temperature public waterTemp;\n    function setTemperature() public {\n        waterTemp = Temperature.Warm;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example11 {\n    enum Quantity { Few, Some, Many }\n    Quantity public itemCount;\n    function adjustQuantity() public {\n        itemCount = Quantity.Some;\n    }\n    function auxiliary() public pure returns (bool) {\n        return false;\n    }\n}"
      }
    }
  },
  {
    "Changes87": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Explicit conversions between literals and <code>address</code> type (e.g. <code>address(literal)</code>) have the\ntype <code>address</code> instead of <code>address payable</code>. One can get a payable address type by using an\nexplicit conversion, i.e., <code>payable(literal)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example2 {\n    function transferMoney(address recipient, uint amount) public {\n        address payable wallet = address(0x456);\n        wallet.transfer(amount);\n    }\n\n    function calculateSum() public pure returns (uint) {\n        return 3 + 5;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/42.sol:1:121:\n  |\n1 |  ... ent, uint amount) public {         address payable wallet = address(0x456);         wallet.transfer(amount);  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example3 {\n    function sendEther(address to, uint value) public {\n        address payable payee = address(0x789);\n        payee.transfer(value);\n    }\n\n    function multiplyValues() public pure returns (uint) {\n        uint x = 4;\n        uint y = 2;\n        return x * y;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/43.sol:1:109:\n  |\n1 |  ... s to, uint value) public {         address payable payee = address(0x789);         payee.transfer(value);    ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example4 {\n    function payout(address destination, uint sum) public {\n        address payable beneficiary = address(0xABC);\n        beneficiary.transfer(sum);\n    }\n\n    function getRandomNumber() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/44.sol:1:113:\n  |\n1 |  ... nation, uint sum) public {         address payable beneficiary = address(0xABC);         beneficiary.transfer(sum) ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example5 {\n    function disburseFunds(address addr, uint funds) public {\n        address payable receiver = address(0xDEF);\n        receiver.transfer(funds);\n    }\n\n    function addNumbers() public pure returns (uint) {\n        uint num1 = 7;\n        uint num2 = 3;\n        return num1 + num2;\n    }\n\n    function subtractNumbers() public pure returns (uint) {\n        return 10 - 4;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/45.sol:1:115:\n  |\n1 |  ... addr, uint funds) public {         address payable receiver = address(0xDEF);         receiver.transfer(funds); ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example6 {\n    function allocateResources(address participant, uint amount) public {\n        address payable entity = address(0xFED);\n        entity.transfer(amount);\n    }\n\n    function divideNumbers() public pure returns (uint) {\n        uint a = 24;\n        uint b = 6;\n        return a / b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/46.sol:1:127:\n  |\n1 |  ... ant, uint amount) public {         address payable entity = address(0xFED);         entity.transfer(amount);  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example7 {\n    function remitPayment(address payee, uint payment) public {\n        address payable account = address(0xCBA);\n        account.transfer(payment);\n    }\n\n    function getDifference() public pure returns (uint) {\n        return 9 - 1;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/47.sol:1:117:\n  |\n1 |  ... ee, uint payment) public {         address payable account = address(0xCBA);         account.transfer(payment) ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example8 {\n    function handleTransaction(address client, uint cash) public {\n        address payable depositor = address(0x321);\n        depositor.transfer(cash);\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/48.sol:1:120:\n  |\n1 |  ... lient, uint cash) public {         address payable depositor = address(0x321);         depositor.transfer(cash); ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example9 {\n    function processPayment(address user, uint credit) public {\n        address payable supplier = address(0x654);\n        supplier.transfer(credit);\n    }\n\n    function countItems() public pure returns (uint) {\n        return 20;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/49.sol:1:117:\n  |\n1 |  ... ser, uint credit) public {         address payable supplier = address(0x654);         supplier.transfer(credit) ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example10 {\n    function executePayment(address vendor, uint payAmount) public {\n        address payable seller = address(0x987);\n        seller.transfer(payAmount);\n    }\n\n    function calculateArea(uint length, uint width) public pure returns (uint) {\n        return length * width;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/50.sol:1:123:\n  |\n1 |  ... , uint payAmount) public {         address payable seller = address(0x987);         seller.transfer(payAmount ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example11 {\n    function forwardFunds(address beneficiary, uint quantity) public {\n        address payable receiver = address(0x852);\n        receiver.transfer(quantity);\n    }\n\n    function getMaximum(uint a, uint b) public pure returns (uint) {\n        return a > b ? a : b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/51.sol:1:125:\n  |\n1 |  ... y, uint quantity) public {         address payable receiver = address(0x852);         receiver.transfer(quantit ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example2 {\n    function transferMoney(address recipient, uint amount) public {\n        address payable wallet = payable(address(0x456));\n        wallet.transfer(amount);\n    }\n\n    function calculateSum() public pure returns (uint) {\n        return 3 + 5;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example3 {\n    function sendEther(address to, uint value) public {\n        address payable payee = payable(address(0x789));\n        payee.transfer(value);\n    }\n\n    function multiplyValues() public pure returns (uint) {\n        uint x = 4;\n        uint y = 2;\n        return x * y;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example4 {\n    function payout(address destination, uint sum) public {\n        address payable beneficiary = payable(address(0xABC));\n        beneficiary.transfer(sum);\n    }\n\n    function getRandomNumber() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example5 {\n    function disburseFunds(address addr, uint funds) public {\n        address payable receiver = payable(address(0xDEF));\n        receiver.transfer(funds);\n    }\n\n    function addNumbers() public pure returns (uint) {\n        uint num1 = 7;\n        uint num2 = 3;\n        return num1 + num2;\n    }\n\n    function subtractNumbers() public pure returns (uint) {\n        return 10 - 4;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example6 {\n    function allocateResources(address participant, uint amount) public {\n        address payable entity = payable(address(0xFED));\n        entity.transfer(amount);\n    }\n\n    function divideNumbers() public pure returns (uint) {\n        uint a = 24;\n        uint b = 6;\n        return a / b;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example7 {\n    function remitPayment(address payee, uint payment) public {\n        address payable account = payable(address(0xCBA));\n        account.transfer(payment);\n    }\n\n    function getDifference() public pure returns (uint) {\n        return 9 - 1;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example8 {\n    function handleTransaction(address client, uint cash) public {\n        address payable depositor = payable(address(0x321));\n        depositor.transfer(cash);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example9 {\n    function processPayment(address user, uint credit) public {\n        address payable supplier = payable(address(0x654));\n        supplier.transfer(credit);\n    }\n\n    function countItems() public pure returns (uint) {\n        return 20;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example10 {\n    function executePayment(address vendor, uint payAmount) public {\n        address payable seller = payable(address(0x987));\n        seller.transfer(payAmount);\n    }\n\n    function calculateArea(uint length, uint width) public pure returns (uint) {\n        return length * width;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example11 {\n    function forwardFunds(address beneficiary, uint quantity) public {\n        address payable receiver = payable(address(0x852));\n        receiver.transfer(quantity);\n    }\n\n    function getMaximum(uint a, uint b) public pure returns (uint) {\n        return a > b ? a : b;\n    }\n}"
      }
    }
  },
  {
    "Changes88": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/types.html#address-literals\"><span class=\"std std-ref\">Address literals</a> have the type <code>address</code> instead of <code>address\npayable</code>. They can be converted to <code>address payable</code> by using an explicit conversion, e.g.\n<code>payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Wallet {\n    address payable public mainAccount;\n    constructor() {\n        mainAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/52.sol:1:124:\n  |\n1 |  ... structor() {         mainAccount = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    address payable public paymentAddress;\n    constructor() {\n        paymentAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function unrelatedMethod() internal {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/53.sol:1:140:\n  |\n1 |  ... uctor() {         paymentAddress = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function unrelatedMetho ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Donation {\n    address payable public charity;\n    constructor() {\n        charity = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function extraFunction1() external pure returns (bool) { return true; }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/54.sol:1:118:\n  |\n1 |  ...  constructor() {         charity = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function extraFunction1 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Fundraiser {\n    address payable public fundDestination;\n    constructor() {\n        fundDestination = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function dummy() public {}\n    function anotherDummy() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/55.sol:1:136:\n  |\n1 |  ... ctor() {         fundDestination = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function dummy() public ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract TokenSale {\n    address payable public saleWallet;\n    constructor() {\n        saleWallet = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/56.sol:1:125:\n  |\n1 |  ... nstructor() {         saleWallet = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Investment {\n    address payable public investor;\n    constructor() {\n        investor = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function unrelatedFunction() private {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/57.sol:1:122:\n  |\n1 |  ... constructor() {         investor = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function unrelatedFunct ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Dividend {\n    address payable public holder;\n    constructor() {\n        holder = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function somethingElse() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/58.sol:1:116:\n  |\n1 |  ...   constructor() {         holder = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function somethingElse( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Auction {\n    address payable public highestBidder;\n    constructor() {\n        highestBidder = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function anyFunction() external pure {}\n    function anotherFunction() external pure {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/59.sol:1:129:\n  |\n1 |  ... ructor() {         highestBidder = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function anyFunction()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Crowdfunding {\n    address payable public projectOwner;\n    constructor() {\n        projectOwner = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/60.sol:1:132:\n  |\n1 |  ... tructor() {         projectOwner = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Staking {\n    address payable public staker;\n    constructor() {\n        staker = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function dummyFunction() internal {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/61.sol:1:115:\n  |\n1 |  ...   constructor() {         staker = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function dummyFunction( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Wallet {\n    address payable public mainAccount;\n    constructor() {\n        mainAccount = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    address payable public paymentAddress;\n    constructor() {\n        paymentAddress = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function unrelatedMethod() internal {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Donation {\n    address payable public charity;\n    constructor() {\n        charity = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function extraFunction1() external pure returns (bool) { return true; }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Fundraiser {\n    address payable public fundDestination;\n    constructor() {\n        fundDestination = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function dummy() public {}\n    function anotherDummy() public {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract TokenSale {\n    address payable public saleWallet;\n    constructor() {\n        saleWallet = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Investment {\n    address payable public investor;\n    constructor() {\n        investor = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function unrelatedFunction() private {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Dividend {\n    address payable public holder;\n    constructor() {\n        holder = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function somethingElse() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Auction {\n    address payable public highestBidder;\n    constructor() {\n        highestBidder = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function anyFunction() external pure {}\n    function anotherFunction() external pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Crowdfunding {\n    address payable public projectOwner;\n    constructor() {\n        projectOwner = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Staking {\n    address payable public staker;\n    constructor() {\n        staker = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function dummyFunction() internal {}\n}"
      }
    }
  },
  {
    "Changes89": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>address(uint)</code> and <code>uint(address)</code>: converting both type-category and width. Replace this by\n<code>address(uint160(uint))</code> and <code>uint(uint160(address))</code> respectively.Add intermediate explicit type conversions if required.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Convert {\n    function convertAddressToUint(address x) public pure returns (uint) {\n        return uint(x);\n    }\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/62.sol:1:132:\n  |\n1 |  ... re returns (uint) {         return uint(x);     }     function extraFunction( ...\n  |                                         ^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Transform {\n    function transformUintToAddress(uint y) public pure returns (address) {\n        return address(y);\n    }\n    function anotherExtraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/63.sol:1:136:\n  |\n1 |  ... returns (address) {         return address(y);     }     function anotherExtraFu ...\n  |                                         ^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Adjust {\n    function adjustAddressToUint(address a) public pure returns (uint) {\n        return uint(a);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/64.sol:1:130:\n  |\n1 | pragma solidity^0.8.0; contract Adjust {     function adjustAddressToUint(address a) public pure returns (uint) {         return uint(a);     } }\n  |                                                                                                                                  ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Modify {\n    function modifyUintToAddress(uint b) public pure returns (address) {\n        return address(b);\n    }\n    function unusedFunction1() public pure returns (uint) {\n        return 200;\n    }\n    function unusedFunction2() public pure returns (uint) {\n        return 300;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/65.sol:1:130:\n  |\n1 |  ... returns (address) {         return address(b);     }     function unusedFunction ...\n  |                                         ^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Change {\n    function changeUintToAddress(uint q) public pure returns (address) {\n        return address(q);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/66.sol:1:130:\n  |\n1 | pragma solidity^0.8.0; contract Change {     function changeUintToAddress(uint q) public pure returns (address) {         return address(q);     } }\n  |                                                                                                                                  ^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Exchange {\n    function exchangeAddressToUint(address c) public pure returns (uint) {\n        return uint(c);\n    }\n    function dummyFunction() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/67.sol:1:134:\n  |\n1 |  ... re returns (uint) {         return uint(c);     }     function dummyFunction( ...\n  |                                         ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Shift {\n    function shiftUintToAddress(uint d) public pure returns (address) {\n        return address(d);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/68.sol:1:128:\n  |\n1 | pragma solidity^0.8.0; contract Shift {     function shiftUintToAddress(uint d) public pure returns (address) {         return address(d);     } }\n  |                                                                                                                                ^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Alter {\n    function alterAddressToUint(address e) public pure returns (uint) {\n        return uint(e);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/69.sol:1:128:\n  |\n1 | pragma solidity^0.8.0; contract Alter {     function alterAddressToUint(address e) public pure returns (uint) {         return uint(e);     } }\n  |                                                                                                                                ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Flip {\n    function flipUintToAddress(uint f) public pure returns (address) {\n        return address(f);\n    }\n    function extraAction() public pure returns (uint) {\n        return 400;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/70.sol:1:126:\n  |\n1 |  ... returns (address) {         return address(f);     }     function extraAction()  ...\n  |                                         ^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ConvertAgain {\n    function convertAgainAddressToUint(address g) public pure returns (uint) {\n        return uint(g);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/71.sol:1:142:\n  |\n1 |  ... re returns (uint) {         return uint(g);     } }\n  |                                         ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Convert {\n    function convertAddressToUint(address x) public pure returns (uint) {\n        return uint(uint160(x));\n    }\n    function extraFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Transform {\n    function transformUintToAddress(uint y) public pure returns (address) {\n        return address(uint160(y));\n    }\n    function anotherExtraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Adjust {\n    function adjustAddressToUint(address a) public pure returns (uint) {\n        return uint(uint160(a));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Modify {\n    function modifyUintToAddress(uint b) public pure returns (address) {\n        return address(uint160(b));\n    }\n    function unusedFunction1() public pure returns (uint) {\n        return 200;\n    }\n    function unusedFunction2() public pure returns (uint) {\n        return 300;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Change {\n    function changeUintToAddress(uint q) public pure returns (address) {\n        return address(uint160(q));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Exchange {\n    function exchangeAddressToUint(address c) public pure returns (uint) {\n        return uint(uint160(c));\n    }\n    function dummyFunction() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Shift {\n    function shiftUintToAddress(uint d) public pure returns (address) {\n        return address(uint160(d));\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Alter {\n    function alterAddressToUint(address e) public pure returns (uint) {\n        return uint(uint160(e));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Flip {\n    function flipUintToAddress(uint f) public pure returns (address) {\n        return address(uint160(f));\n    }\n    function extraAction() public pure returns (uint) {\n        return 400;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ConvertAgain {\n    function convertAgainAddressToUint(address g) public pure returns (uint) {\n        return uint(uint160(g));\n    }\n}"
      }
    }
  },
  {
    "Changes90": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>payable(uint160)</code>, <code>payable(bytes20)</code> and <code>payable(integer-literal)</code>: converting both\ntype-category and state-mutability. Replace this by <code>payable(address(uint160))</code>,\n<code>payable(address(bytes20))</code> and <code>payable(address(integer-literal))</code> respectively. Note that\n<code>payable(0)</code> is valid and is an exception to the rule.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract UniqueProcessor {\n    function adjustNumber(uint160 input) public pure returns (address payable) {\n        return payable(input);\n    }\n    function additionalAction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/72.sol:1:147:\n  |\n1 |  ... (address payable) {         return payable(input);     }     function additionalActi ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract DataModifier {\n    function transformValue(uint160 data) public pure returns (address payable) {\n        return payable(data);\n    }\n    function getValue() public pure returns (uint256) {\n        return 200;\n    }\n    function isActive() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/73.sol:1:145:\n  |\n1 |  ... (address payable) {         return payable(data);     }     function getValue() pub ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueManager {\n    function processInput(uint160 number) public pure returns (address payable) {\n        return payable(number);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/74.sol:1:145:\n  |\n1 |  ... (address payable) {         return payable(number);     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentHandler {\n    function handlePayment(uint160 amount) public pure returns (address payable) {\n        return payable(amount);\n    }\n    function getNumber() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/75.sol:1:148:\n  |\n1 |  ... (address payable) {         return payable(amount);     }     function getNumber() pu ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetConverter {\n    function convertAsset(uint160 asset) public pure returns (address payable) {\n        return payable(asset);\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Extra data\";\n    }\n    function checkActive() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/76.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(asset);     }     function extraMethod()  ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract FundProcessor {\n    function transferFund(uint160 fund) public pure returns (address payable) {\n        return payable(fund);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/77.sol:1:144:\n  |\n1 |  ... (address payable) {         return payable(fund);     } }\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract CurrencyHandler {\n    function manageCurrency(uint160 currency) public pure returns (address payable) {\n        return payable(currency);\n    }\n    function getBoolean() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/78.sol:1:152:\n  |\n1 |  ... (address payable) {         return payable(currency);     }     function getBoolean() p ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceAllocator {\n    function allocateResource(uint160 resource) public pure returns (address payable) {\n        return payable(resource);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/79.sol:1:156:\n  |\n1 |  ... (address payable) {         return payable(resource);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentAllocator {\n    function allocatePayment(uint160 payment) public pure returns (address payable) {\n        return payable(payment);\n    }\n    function checkFlag() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/80.sol:1:153:\n  |\n1 |  ... (address payable) {         return payable(payment);     }     function checkFlag() pu ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneyProcessor {\n    function processMoney(uint160 money) public pure returns (address payable) {\n        return payable(money);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/81.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(money);     } }\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract UniqueProcessor {\n    function adjustNumber(uint160 input) public pure returns (address payable) {\n        return payable(address(input));\n    }\n    function additionalAction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract DataModifier {\n    function transformValue(uint160 data) public pure returns (address payable) {\n        return payable(address(data));\n    }\n    function getValue() public pure returns (uint256) {\n        return 200;\n    }\n    function isActive() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ValueManager {\n    function processInput(uint160 number) public pure returns (address payable) {\n        return payable(address(number));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract PaymentHandler {\n    function handlePayment(uint160 amount) public pure returns (address payable) {\n        return payable(address(amount));\n    }\n    function getNumber() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract AssetConverter {\n    function convertAsset(uint160 asset) public pure returns (address payable) {\n        return payable(address(asset));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Extra data\";\n    }\n    function checkActive() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract FundProcessor {\n    function transferFund(uint160 fund) public pure returns (address payable) {\n        return payable(address(fund));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract CurrencyHandler {\n    function manageCurrency(uint160 currency) public pure returns (address payable) {\n        return payable(address(currency));\n    }\n    function getBoolean() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ResourceAllocator {\n    function allocateResource(uint160 resource) public pure returns (address payable) {\n        return payable(address(resource));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract PaymentAllocator {\n    function allocatePayment(uint160 payment) public pure returns (address payable) {\n        return payable(address(payment));\n    }\n    function checkFlag() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract MoneyProcessor {\n    function processMoney(uint160 money) public pure returns (address payable) {\n        return payable(address(money));\n    }\n}"
      }
    }
  },
  {
    "Changes91": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>int80(bytes10)</code> and <code>bytes10(int80)</code>: converting both type-category and sign. Replace this by\n<code>int80(uint80(bytes10))</code> and <code>bytes10(uint80(int80)</code> respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterOne {\n    function convertType(bytes10 data) public pure returns (int80) {\n        return int80(data);\n    }\n    function auxiliaryFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/82.sol:1:132:\n  |\n1 |  ... e returns (int80) {         return int80(data);     }     function auxiliaryFunct ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract DataHandler {\n    function transformData(int80 value) public pure returns (bytes10) {\n        return bytes10(value);\n    }\n    function getNumber() public pure returns (int) {\n        return -1;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/83.sol:1:134:\n  |\n1 |  ... returns (bytes10) {         return bytes10(value);     }     function getNumber() pu ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ConversionTool {\n    function bytesToInt(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/84.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract QuickConverter {\n    function intToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function randomFunction() public pure returns (bool) {\n        return true;\n    }\n    function anotherRandom() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/85.sol:1:134:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function randomFunction ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ByteToInt {\n    function changeFormat(bytes10 bytesInput) public pure returns (int80) {\n        return int80(bytesInput);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/86.sol:1:136:\n  |\n1 |  ... e returns (int80) {         return int80(bytesInput);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IntToByte {\n    function formatChange(int80 intInput) public pure returns (bytes10) {\n        return bytes10(intInput);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/87.sol:1:134:\n  |\n1 |  ... returns (bytes10) {         return bytes10(intInput);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract SimpleConvert {\n    function simpleBytesToInt(bytes10 basicInput) public pure returns (int80) {\n        return int80(basicInput);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/88.sol:1:144:\n  |\n1 |  ... e returns (int80) {         return int80(basicInput);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract BasicTransform {\n    function basicIntToBytes(int80 simpleInput) public pure returns (bytes10) {\n        return bytes10(simpleInput);\n    }\n    function extraFunction1() public pure returns (uint256) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/89.sol:1:145:\n  |\n1 |  ... returns (bytes10) {         return bytes10(simpleInput);     }     function extraFunction1 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Encode {\n    function encodeBytes(bytes10 encodedInput) public pure returns (int80) {\n        return int80(encodedInput);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/90.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(encodedInput);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Decode {\n    function decodeInt(int80 decodedInput) public pure returns (bytes10) {\n        return bytes10(decodedInput);\n    }\n    function extraFunction2() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/91.sol:1:132:\n  |\n1 |  ... returns (bytes10) {         return bytes10(decodedInput);     }     function extraFunction2 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ConverterOne {\n    function convertType(bytes10 data) public pure returns (int80) {\n        return int80(uint80(data));\n    }\n    function auxiliaryFunction() public pure returns (uint) {\n        return 100;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract DataHandler {\n    function transformData(int80 value) public pure returns (bytes10) {\n        return bytes10(uint80(value));\n    }\n    function getNumber() public pure returns (int) {\n        return -1;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ConversionTool {\n    function bytesToInt(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract QuickConverter {\n    function intToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function randomFunction() public pure returns (bool) {\n        return true;\n    }\n    function anotherRandom() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ByteToInt {\n    function changeFormat(bytes10 bytesInput) public pure returns (int80) {\n        return int80(uint80(bytesInput));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IntToByte {\n    function formatChange(int80 intInput) public pure returns (bytes10) {\n        return bytes10(uint80(intInput));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract SimpleConvert {\n    function simpleBytesToInt(bytes10 basicInput) public pure returns (int80) {\n        return int80(uint80(basicInput));\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract BasicTransform {\n    function basicIntToBytes(int80 simpleInput) public pure returns (bytes10) {\n        return bytes10(uint80(simpleInput));\n    }\n    function extraFunction1() public pure returns (uint256) {\n        return 42;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Encode {\n    function encodeBytes(bytes10 encodedInput) public pure returns (int80) {\n        return int80(uint80(encodedInput));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Decode {\n    function decodeInt(int80 decodedInput) public pure returns (bytes10) {\n        return bytes10(uint80(decodedInput));\n    }\n    function extraFunction2() public pure returns (string memory) {\n        return \"Hello\";\n    }\n}"
      }
    }
  },
  {
    "Changes92": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "<code>Contract(uint)</code>: converting both type-category and width. Replace this by\n<code>Contract(address(uint160(uint)))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterOne {\n    function transform(uint value) public pure returns (address) {\n        address result = address(value);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/92.sol:1:140:\n  |\n1 |  ... ddress) {         address result = address(value);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterTwo {\n    function fetch(uint input) public pure returns (address) {\n        address output = address(input);\n        return output;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/93.sol:1:136:\n  |\n1 |  ... ddress) {         address output = address(input);         return output;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterThree {\n    function retrieve(uint number) public pure returns (address) {\n        address account = address(number);\n        return account;\n    }\n    function helper() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/94.sol:1:143:\n  |\n1 |  ... dress) {         address account = address(number);         return account;     }     ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterFour {\n    function extract(uint data) public pure returns (address) {\n        address addr = address(data);\n        return addr;\n    }\n    function extraFunction() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/95.sol:1:136:\n  |\n1 |  ... (address) {         address addr = address(data);         return addr;     }     fu ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterFive {\n    function pull(uint parameter) public pure returns (address) {\n        address element = address(parameter);\n        return element;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/96.sol:1:141:\n  |\n1 |  ... dress) {         address element = address(parameter);         return element;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterSix {\n    function convert(uint num) public pure returns (address) {\n        address resultAddress = address(num);\n        return resultAddress;\n    }\n    function extra() public pure {}\n    function additional() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/97.sol:1:143:\n  |\n1 |  ...  {         address resultAddress = address(num);         return resultAddress;     ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterSeven {\n    function get(uint value) public pure returns (address) {\n        address result = address(value);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/98.sol:1:136:\n  |\n1 |  ... ddress) {         address result = address(value);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterEight {\n    function generate(uint input) public pure returns (address) {\n        address generatedAddress = address(input);\n        return generatedAddress;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/99.sol:1:151:\n  |\n1 |  ...         address generatedAddress = address(input);         return generatedAddress;  ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterNine {\n    function capture(uint value) public pure returns (address) {\n        address capturedAddress = address(value);\n        return capturedAddress;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/100.sol:1:148:\n  |\n1 |  ...          address capturedAddress = address(value);         return capturedAddress;   ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterTen {\n    function make(uint data) public pure returns (address) {\n        address newData = address(data);\n        return newData;\n    }\n    function unused() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/101.sol:1:135:\n  |\n1 |  ... dress) {         address newData = address(data);         return newData;     }     ...\n  |                                         ^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ConverterOne {\n    function transform(uint value) public pure returns (address) {\n        address result = address(uint160(value));\n        return result;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ConverterTwo {\n    function fetch(uint input) public pure returns (address) {\n        address output = address(uint160(input));\n        return output;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ConverterThree {\n    function retrieve(uint number) public pure returns (address) {\n        address account = address(uint160(number));\n        return account;\n    }\n    function helper() public pure {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ConverterFour {\n    function extract(uint data) public pure returns (address) {\n        address addr = address(uint160(data));\n        return addr;\n    }\n    function extraFunction() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ConverterFive {\n    function pull(uint parameter) public pure returns (address) {\n        address element = address(uint160(parameter));\n        return element;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ConverterSix {\n    function convert(uint num) public pure returns (address) {\n        address resultAddress = address(uint160(num));\n        return resultAddress;\n    }\n    function extra() public pure {}\n    function additional() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ConverterSeven {\n    function get(uint value) public pure returns (address) {\n        address result = address(uint160(value));\n        return result;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ConverterEight {\n    function generate(uint input) public pure returns (address) {\n        address generatedAddress = address(uint160(input));\n        return generatedAddress;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ConverterNine {\n    function capture(uint value) public pure returns (address) {\n        address capturedAddress = address(uint160(value));\n        return capturedAddress;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ConverterTen {\n    function make(uint data) public pure returns (address) {\n        address newData = address(uint160(data));\n        return newData;\n    }\n    function unused() public pure {}\n}"
      }
    }
  },
  {
    "Changes93": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Function call options can only be given once, i.e. <code>c.f{gas: 10000}{value: 1}()</code> is invalid and has to be changed to <code>c.f{gas: 10000, value: 1}()</code>.Combine <code>c.f{gas: 10000}{value: 1}()</code> to <code>c.f{gas: 10000, value: 1}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetTransfer {\n    address payable public receiver;\n    function disburseFunds() public {\n        receiver.call{gas: 5000}{value: 2 ether}(\"\");\n    }\n    function checkBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/102.sol:1:132:\n  |\n1 |  ... n disburseFunds() public {         receiver.call{gas: 5000}{value: 2 ether}(\"\");     }     function checkBalan ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentSystem {\n    address payable public payee;\n    function processPayment() public {\n        payee.call{gas: 1000}{value: 1 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/103.sol:1:130:\n  |\n1 |  ...  processPayment() public {         payee.call{gas: 1000}{value: 1 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract DataStorage {\n    address payable public storageWallet;\n    function storeData() public {\n        storageWallet.call{gas: 2000}{value: 3 ether}(\"\");\n    }\n    function clearData() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/104.sol:1:131:\n  |\n1 |  ... ction storeData() public {         storageWallet.call{gas: 2000}{value: 3 ether}(\"\");     }     function clearData( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract TransactionHandler {\n    address payable public beneficiary;\n    function handleTransaction() public {\n        beneficiary.call{gas: 8000}{value: 5 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/105.sol:1:144:\n  |\n1 |  ... ndleTransaction() public {         beneficiary.call{gas: 8000}{value: 5 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceAllocator {\n    address payable public allocator;\n    function allocateResource() public {\n        allocator.call{gas: 3000}{value: 4 ether}(\"\");\n    }\n    function releaseResource() public {}\n    function isActive() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/106.sol:1:140:\n  |\n1 |  ... llocateResource() public {         allocator.call{gas: 3000}{value: 4 ether}(\"\");     }     function releaseRes ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract FundManager {\n    address payable public fundReceiver;\n    function manageFunds() public {\n        fundReceiver.call{gas: 7000}{value: 3 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/107.sol:1:132:\n  |\n1 |  ... ion manageFunds() public {         fundReceiver.call{gas: 7000}{value: 3 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneyDispatcher {\n    address payable public dispatcher;\n    function dispatchFunds() public {\n        dispatcher.call{gas: 6000}{value: 2 ether}(\"\");\n    }\n    function totalDispatched() public pure returns (uint) {\n        return 1000;\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/108.sol:1:136:\n  |\n1 |  ... n dispatchFunds() public {         dispatcher.call{gas: 6000}{value: 2 ether}(\"\");     }     function totalDispa ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentGateway {\n    address payable public gateway;\n    function executePayment() public {\n        gateway.call{gas: 4500}{value: 1 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/109.sol:1:133:\n  |\n1 |  ...  executePayment() public {         gateway.call{gas: 4500}{value: 1 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract FinancialController {\n    address payable public controller;\n    function controlFinance() public {\n        controller.call{gas: 5500}{value: 3 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/110.sol:1:141:\n  |\n1 |  ...  controlFinance() public {         controller.call{gas: 5500}{value: 3 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneyFlow {\n    address payable public treasurer;\n    function directFlow() public {\n        treasurer.call{gas: 2500}{value: 1 ether}(\"\");\n    }\n    function resetFlow() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/111.sol:1:126:\n  |\n1 |  ... tion directFlow() public {         treasurer.call{gas: 2500}{value: 1 ether}(\"\");     }     function resetFlow( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract AssetTransfer {\n    address payable public receiver;\n    function disburseFunds() public {\n        receiver.call{gas: 5000, value: 2 ether}(\"\");\n    }\n    function checkBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract PaymentSystem {\n    address payable public payee;\n    function processPayment() public {\n        payee.call{gas: 1000, value: 1 ether}(\"\");\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract DataStorage {\n    address payable public storageWallet;\n    function storeData() public {\n        storageWallet.call{gas: 2000, value: 3 ether}(\"\");\n    }\n    function clearData() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract TransactionHandler {\n    address payable public beneficiary;\n    function handleTransaction() public {\n        beneficiary.call{gas: 8000, value: 5 ether}(\"\");\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ResourceAllocator {\n    address payable public allocator;\n    function allocateResource() public {\n        allocator.call{gas: 3000, value: 4 ether}(\"\");\n    }\n    function releaseResource() public {}\n    function isActive() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract FundManager {\n    address payable public fundReceiver;\n    function manageFunds() public {\n        fundReceiver.call{gas: 7000, value: 3 ether}(\"\");\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract MoneyDispatcher {\n    address payable public dispatcher;\n    function dispatchFunds() public {\n        dispatcher.call{gas: 6000, value: 2 ether}(\"\");\n    }\n    function totalDispatched() public pure returns (uint) {\n        return 1000;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract PaymentGateway {\n    address payable public gateway;\n    function executePayment() public {\n        gateway.call{gas: 4500, value: 1 ether}(\"\");\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract FinancialController {\n    address payable public controller;\n    function controlFinance() public {\n        controller.call{gas: 5500, value: 3 ether}(\"\");\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract MoneyFlow {\n    address payable public treasurer;\n    function directFlow() public {\n        treasurer.call{gas: 2500, value: 1 ether}(\"\");\n    }\n    function resetFlow() public {}\n}"
      }
    }
  },
  {
    "Changes94": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The global functions <code>log0</code>, <code>log1</code>, <code>log2</code>, <code>log3</code> and <code>log4</code> have been removed.Use inline assembly as a replacement for <code>log0</code>, \u2026, <code>log4</code>.13.These are low-level functions that were largely unused. Their behavior can be accessed from inline assembly.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract DataLogger {\n    function logData(uint256 info) public {\n        bytes memory dataBytes = abi.encodePacked(info);\n        assembly {\n            log0(dataBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/112.sol:1:178:\n  |\n1 |  ... o);         assembly {             log0(dataBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract EventRecorder {\n    function logData(uint256 info) public {\n        bytes memory dataBytes = abi.encodePacked(info);\n        assembly {\n            log0(dataBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/113.sol:1:181:\n  |\n1 |  ... o);         assembly {             log0(dataBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract TransactionLogger {\n    function logTransaction(bytes32 txData) public {\n        assembly {\n            log3(txData, txData, txData, txData)\n        }\n    }\n    function helper() internal pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Function expects 5 arguments but got 4.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/114.sol:1:137:\n  |\n1 |  ... c {         assembly {             log3(txData, txData, txData, txData)    ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract MetricLogger {\n    function logMetric(uint256 metric) public {\n        bytes memory metricData = abi.encodePacked(metric);\n        assembly {\n            log4(metricData, metric, metric, metric, metric)\n        }\n    }\n    function extra() public pure {}\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/115.sol:1:187:\n  |\n1 |  ... c);         assembly {             log4(metricData, metric, metric, metric ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract InfoLogger {\n    function logInfo(uint256 detail) public {\n        bytes memory detailBytes = abi.encodePacked(detail);\n        assembly {\n            log1(detailBytes, detail)\n        }\n    }\n    function anotherFunction() public pure {}\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/116.sol:1:184:\n  |\n1 |  ... l);         assembly {             log1(detailBytes, detail)         }     ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract DetailRecorder {\n    function recordDetail(uint256 data) public {\n        bytes memory dataInfo = abi.encodePacked(data);\n        assembly {\n            log1(dataInfo, data)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/117.sol:1:186:\n  |\n1 |  ... a);         assembly {             log1(dataInfo, data)         }     } }\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ActivityLogger {\n    function logActivity(uint256 activityId) public {\n        bytes memory activityBytes = abi.encodePacked(activityId);\n        assembly {\n            log2(activityBytes, activityId, activityId)\n        }\n    }\n    function unused() public pure {}\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/118.sol:1:202:\n  |\n1 |  ... d);         assembly {             log2(activityBytes, activityId, activit ...\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorLogger {\n    function logError(string memory errorMessage) public {\n        bytes memory errorBytes = bytes(errorMessage);\n        assembly {\n            log0(errorBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/119.sol:1:192:\n  |\n1 |  ... e);         assembly {             log0(errorBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract SignalLogger {\n    function logSignal(uint256 signal) public {\n        bytes memory signalData = abi.encodePacked(signal);\n        assembly {\n            log3(signalData, signal, signal, signal)\n        }\n    }\n}",
          "error message": "Error: Function expects 5 arguments but got 4.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/120.sol:1:187:\n  |\n1 |  ... l);         assembly {             log3(signalData, signal, signal, signal ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract MessageLogger {\n    function logMessage(string memory message) public {\n        bytes memory messageBytes = bytes(message);\n        assembly {\n            log4(messageBytes, messageBytes, messageBytes, messageBytes, messageBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/121.sol:1:188:\n  |\n1 |  ... e);         assembly {             log4(messageBytes, messageBytes, messag ...\n  |                                         ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract DataLogger {\n    event Data(uint256 info);\n    function logData(uint256 info) public {\n        emit Data(info);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract EventRecorder {\n    event Event(int256 number);\n    function recordEvent(int256 number) public {\n        emit Event(number);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract TransactionLogger {\n    event Event(int256 number);\n    function recordEvent(int256 number) public {\n        emit Event(number);\n    }\n\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract MetricLogger {\n    event Metric(uint256 metric);\n    function logMetric(uint256 metric) public {\n        emit Metric(metric);\n    }\n    function extra() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract InfoLogger {\n    event Info(uint256 detail);\n    function logInfo(uint256 detail) public {\n        emit Info(detail);\n    }\n    function anotherFunction() public pure {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract DetailRecorder {\n    event Detail(uint256 data);\n    function recordDetail(uint256 data) public {\n        emit Detail(data);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ActivityLogger {\n    event Activity(uint256 activityId);\n    function logActivity(uint256 activityId) public {\n        emit Activity(activityId);\n    }\n    function unused() public pure {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ErrorLogger {\n    event Error(string errorMessage);\n    function logError(string memory errorMessage) public {\n        emit Error(errorMessage);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract SignalLogger {\n    event Signal(uint256 signal);\n    function logSignal(uint256 signal) public {\n        emit Signal(signal);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract MessageLogger {\n    event Message(string message);\n    function logMessage(string memory message) public {\n        emit Message(message);\n    }\n}"
      }
    }
  },
  {
    "Changes95": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Declarations with the name <code>this</code>, <code>super</code> and <code>_</code> are disallowed, with the exception of\npublic functions and events. The exception is to make it possible to declare interfaces of contracts\nimplemented in languages other than Solidity that do permit such function names.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example2 {\n    uint256 public super;\n\n    function setSuper(uint256 _value) public {\n        super = _value;  \n    }\n\n    function multiply(uint256 a, uint256 b) public pure returns (uint256) {\n        return a * b;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/122.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract Example2 {     uint256 public super;      function setSuper(uint256 _v ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example3 {\n    int public _;\n\n    function set_(int _value) public {\n        _ = _value;  \n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/123.sol:1:49:\n  |\n1 | pragma solidity^0.8.0;  contract Example3 {     int public _;      function set_(int _value) public {         _ = _value;       } }\n  |                                                 ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example4 {\n    string public this;\n\n    function setThis(string memory _value) public {\n        this = _value;  \n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/124.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract Example4 {     string public this;      function setThis(string memo ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example5 {\n    bytes32 public super;\n\n    function setSuper(bytes32 _value) public {\n        super = _value;  \n    }\n\n    function subtract(uint256 a, uint256 b) public pure returns (uint256) {\n        return a - b;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/125.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract Example5 {     bytes32 public super;      function setSuper(bytes32 _v ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example6 {\n    bool public _;\n\n    function set_(bool _value) public {\n        _ = _value;  \n    }\n\n    function check(uint256 a) public pure returns (bool) {\n        return a > 0;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/126.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract Example6 {     bool public _;      function set_(bool _value) p ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example7 {\n    address public this;\n\n    function setThis(address _value) public {\n        this = _value;  \n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/127.sol:1:49:\n  |\n1 | pragma solidity^0.8.0;  contract Example7 {     address public this;      function setThis(address _value) public {         this = _value;       } }\n  |                                                 ^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example8 {\n    uint256 public super;\n\n    function setSuper(uint256 _value) public {\n        super = _value;  \n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/128.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract Example8 {     uint256 public super;      function setSuper(uint256 _v ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example9 {\n    uint256 public this;\n\n    function setThis(uint256 _value) public {\n        this = _value;  \n    }\n\n    function compare(uint256 a, uint256 b) public pure returns (bool) {\n        return a == b;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/129.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract Example9 {     uint256 public this;      function setThis(uint256 _va ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example10 {\n    int256 public _;\n\n    function set_(int256 _value) public {\n        _ = _value;  \n    }\n\n    function increment(int256 a) public pure returns (int256) {\n        return a + 1;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/130.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract Example10 {     int256 public _;      function set_(int256 _value) ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example11 {\n    uint256 public this;\n\n    function setThis(uint256 _value) public {\n        this = _value;  \n    }\n\n    function divide(uint256 a, uint256 b) public pure returns (uint256) {\n        return a / b;\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 100;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/131.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract Example11 {     uint256 public this;      function setThis(uint256 _va ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example2 {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;  \n    }\n\n    function multiply(uint256 a, uint256 b) public pure returns (uint256) {\n        return a * b;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example3 {\n    int public value;\n\n    function setValue(int _value) public {\n        value = _value;  \n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example4 {\n    string public value;\n\n    function setValue(string memory _value) public {\n        value = _value;  \n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example5 {\n    bytes32 public value;\n\n    function setValue(bytes32 _value) public {\n        value = _value;  \n    }\n\n    function subtract(uint256 a, uint256 b) public pure returns (uint256) {\n        return a - b;\n    }\n\n    function dummyFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example6 {\n    bool public value;\n\n    function setValue(bool _value) public {\n        value = _value;  \n    }\n\n    function check(uint256 a) public pure returns (bool) {\n        return a > 0;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example7 {\n    address public value;\n\n    function setValue(address _value) public {\n        value = _value;  \n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example8 {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;  \n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example9 {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;  \n    }\n\n    function compare(uint256 a, uint256 b) public pure returns (bool) {\n        return a == b;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example10 {\n    int256 public value;\n\n    function setValue(int256 _value) public {\n        value = _value;  \n    }\n\n    function increment(int256 a) public pure returns (int256) {\n        return a + 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example11 {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;  \n    }\n\n    function divide(uint256 a, uint256 b) public pure returns (uint256) {\n        return a / b;\n    }\n\n    function extraFunction() public pure returns (uint256) {\n        return 100;\n    }\n}"
      }
    }
  },
  {
    "Changes96": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Remove support for the <code>b</code>, <code>f</code>, and <code>v</code> escape sequences in code.\nThey can still be inserted via hexadecimal escapes, e.g. <code>x08</code>, <code>x0c</code>, and <code>x0b</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract EscapeSequenceOne {\n    string public bellChar = \"Bell character: \\b\";\n    function getBellChar() public view returns (string memory) {\n        return bellChar;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/132.sol:1:82:\n  |\n1 |  ... One {     string public bellChar = \"Bell character: \\b\";     function getBellChar() publi ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract EscapeSequenceTwo {\n    string public formFeed = \"Form feed: \\f\";\n    function retrieveFormFeed() public view returns (string memory) {\n        return formFeed;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/133.sol:1:82:\n  |\n1 |  ... Two {     string public formFeed = \"Form feed: \\f\";     function retrieveFormFeed()  ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract EscapeSequenceThree {\n    string public verticalTab = \"Vertical tab: \\v\";\n    function fetchVerticalTab() public view returns (string memory) {\n        return verticalTab;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/134.sol:1:87:\n  |\n1 |  ...  {     string public verticalTab = \"Vertical tab: \\v\";     function fetchVerticalTab()  ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract DataStorage {\n    string public dataFeed = \"Data feed: \\b\";\n    function getDataFeed() public view returns (string memory) {\n        return dataFeed;\n    }\n    function extraMethod() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/135.sol:1:76:\n  |\n1 |  ... age {     string public dataFeed = \"Data feed: \\b\";     function getDataFeed() publi ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract InfoRetrieval {\n    string public verticalInfo = \"Vertical info: \\v\";\n    function getVerticalInfo() public view returns (string memory) {\n        return verticalInfo;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/136.sol:1:82:\n  |\n1 |  ... {     string public verticalInfo = \"Vertical info: \\v\";     function getVerticalInfo() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract CharacterEscape {\n    string public escapeCharacter = \"Escape char: \\f\";\n    function getEscapeCharacter() public view returns (string memory) {\n        return escapeCharacter;\n    }\n    function unrelatedFunction() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/137.sol:1:87:\n  |\n1 |  ...    string public escapeCharacter = \"Escape char: \\f\";     function getEscapeCharacter( ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract BellSound {\n    string public bellSound = \"Bell sound: \\b\";\n    function getBellSound() public view returns (string memory) {\n        return bellSound;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/138.sol:1:75:\n  |\n1 |  ... nd {     string public bellSound = \"Bell sound: \\b\";     function getBellSound() publ ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Tabulation {\n    string public tabulationChar = \"Tabulation character: \\v\";\n    function getTabulationChar() public view returns (string memory) {\n        return tabulationChar;\n    }\n    function anotherUnrelatedFunction() public pure returns (uint) {\n        return 456;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/139.sol:1:81:\n  |\n1 |  ...     string public tabulationChar = \"Tabulation character: \\v\";     function getTabulationChar() ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract FeedLine {\n    string public feedLine = \"Feed line: \\f\";\n    function getFeedLine() public view returns (string memory) {\n        return feedLine;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/140.sol:1:73:\n  |\n1 |  ... ine {     string public feedLine = \"Feed line: \\f\";     function getFeedLine() publi ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract VisualFeed {\n    string public visualFeed = \"Visual feed: \\b\";\n    function getVisualFeed() public view returns (string memory) {\n        return visualFeed;\n    }\n    function extraMethodOne() public pure returns (string memory) {\n        return \"Extra content\";\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/141.sol:1:77:\n  |\n1 |  ... d {     string public visualFeed = \"Visual feed: \\b\";     function getVisualFeed() pub ...\n  |                                         ^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract EscapeSequenceOne {\n    string public bellChar = \"Bell character: \\x08\";\n    function getBellChar() public view returns (string memory) {\n        return bellChar;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract EscapeSequenceTwo {\n    string public formFeed = \"Form feed: \\x0c\";\n    function retrieveFormFeed() public view returns (string memory) {\n        return formFeed;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract EscapeSequenceThree {\n    string public verticalTab = \"Vertical tab: \\x0b\";\n    function fetchVerticalTab() public view returns (string memory) {\n        return verticalTab;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract DataStorage {\n    string public dataFeed = \"Data feed: \\x08\";\n    function getDataFeed() public view returns (string memory) {\n        return dataFeed;\n    }\n    function extraMethod() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract InfoRetrieval {\n    string public verticalInfo = \"Vertical info: \\x0b\";\n    function getVerticalInfo() public view returns (string memory) {\n        return verticalInfo;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract CharacterEscape {\n    string public escapeCharacter = \"Escape char: \\x0c\";\n    function getEscapeCharacter() public view returns (string memory) {\n        return escapeCharacter;\n    }\n    function unrelatedFunction() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract BellSound {\n    string public bellSound = \"Bell sound: \\x08\";\n    function getBellSound() public view returns (string memory) {\n        return bellSound;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Tabulation {\n    string public tabulationChar = \"Tabulation character: \\x0b\";\n    function getTabulationChar() public view returns (string memory) {\n        return tabulationChar;\n    }\n    function anotherUnrelatedFunction() public pure returns (uint) {\n        return 456;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract FeedLine {\n    string public feedLine = \"Feed line: \\x0c\";\n    function getFeedLine() public view returns (string memory) {\n        return feedLine;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract VisualFeed {\n    string public visualFeed = \"Visual feed: \\x08\";\n    function getVisualFeed() public view returns (string memory) {\n        return visualFeed;\n    }\n    function extraMethodOne() public pure returns (string memory) {\n        return \"Extra content\";\n    }\n}"
      }
    }
  },
  {
    "Changes97": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The global variables <code>tx.origin</code> and <code>msg.sender</code> have the type <code>address</code> instead of\n<code>address payable</code>. One can convert them into <code>address payable</code> by using an explicit\nconversion, i.e., <code>payable(tx.origin)</code> or <code>payable(msg.sender)</code>.This change was done since the compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible.Change <code>msg.sender.transfer(x)</code> to <code>payable(msg.sender).transfer(x)</code> or use a stored variable of <code>address payable</code> type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract FundCollector {\n    function collectFunds() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/142.sol:1:102:\n  |\n1 | pragma solidity^0.8.0; contract FundCollector {     function collectFunds() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                      ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentGateway {\n    function pay() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function helper() external pure returns (uint) { return 42; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/143.sol:1:94:\n  |\n1 |  ... ion pay() public payable {         msg.sender.transfer(msg.value);     }     function hel ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Wallet {\n    function withdraw() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function randomFunction() public pure returns (string memory) { return \"Hello\"; }\n    function anotherFunction() public pure {}\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/144.sol:1:91:\n  |\n1 |  ... ithdraw() public payable {         msg.sender.transfer(msg.value);     }     function ran ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract RefundProcessor {\n    function processRefund() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/145.sol:1:105:\n  |\n1 | pragma solidity^0.8.0; contract RefundProcessor {     function processRefund() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract CashHandler {\n    function handleCash() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function extraMethod() public pure returns (bool) { return true; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/146.sol:1:98:\n  |\n1 |  ... dleCash() public payable {         msg.sender.transfer(msg.value);     }     function ext ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneyTransfer {\n    function transferMoney() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/147.sol:1:103:\n  |\n1 | pragma solidity^0.8.0; contract MoneyTransfer {     function transferMoney() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                       ^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract DonationReceiver {\n    function receiveDonation() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/148.sol:1:108:\n  |\n1 | pragma solidity^0.8.0; contract DonationReceiver {     function receiveDonation() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                            ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract FeeCollector {\n    function collectFee() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function unused() public pure {}\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/149.sol:1:99:\n  |\n1 |  ... lectFee() public payable {         msg.sender.transfer(msg.value);     }     function unu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract SubscriptionManager {\n    function manageSubscription() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/150.sol:1:114:\n  |\n1 |  ... ription() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentReceiver {\n    function receivePayment() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function dummy() public pure returns (uint) { return 1; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/151.sol:1:106:\n  |\n1 |  ... Payment() public payable {         msg.sender.transfer(msg.value);     }     function dum ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract FundCollector {\n    function collectFunds() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract PaymentGateway {\n    function pay() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function helper() external pure returns (uint) { return 42; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Wallet {\n    function withdraw() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function randomFunction() public pure returns (string memory) { return \"Hello\"; }\n    function anotherFunction() public pure {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract RefundProcessor {\n    function processRefund() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract CashHandler {\n    function handleCash() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function extraMethod() public pure returns (bool) { return true; }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract MoneyTransfer {\n    function transferMoney() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract DonationReceiver {\n    function receiveDonation() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract FeeCollector {\n    function collectFee() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function unused() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract SubscriptionManager {\n    function manageSubscription() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract PaymentReceiver {\n    function receivePayment() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function dummy() public pure returns (uint) { return 1; }\n}"
      }
    }
  },
  {
    "Changes98": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "The <code>chainid</code> builtin in inline assembly is now considered <code>view</code> instead of <code>pure</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract IdentityCheck {\n    function fetchChainId() public pure returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid\n        }\n        return id;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/152.sol:1:167:\n  |\n1 |  ...       assembly {             id := chainid         }         return id;     } ...\n  |                                         ^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkVerifier {\n    function retrieveNetworkId() public pure returns (uint256) {\n        uint256 networkId;\n        assembly {\n            networkId := chainid\n        }\n        return networkId;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/153.sol:1:188:\n  |\n1 |  ... ssembly {             networkId := chainid         }         return networkId ...\n  |                                         ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainInspector {\n    function detectChain() public pure returns (uint256) {\n        uint256 chain;\n        assembly {\n            chain := chainid\n        }\n        return chain;\n    }\n    function dummyFunction() public pure returns (uint256) { return 1; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/154.sol:1:173:\n  |\n1 |  ...    assembly {             chain := chainid         }         return chain;    ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainValidator {\n    function validateChain() public pure returns (uint256) {\n        uint256 validChain;\n        assembly {\n            validChain := chainid\n        }\n        return validChain;\n    }\n    function extraOne() public pure returns (uint256) { return 2; }\n    function extraTwo() public pure returns (uint256) { return 3; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/155.sol:1:185:\n  |\n1 |  ... sembly {             validChain := chainid         }         return validChai ...\n  |                                         ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkCheck {\n    function getNetwork() public pure returns (uint256) {\n        uint256 network;\n        assembly {\n            network := chainid\n        }\n        return network;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/156.sol:1:174:\n  |\n1 |  ...  assembly {             network := chainid         }         return network;  ...\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainQuery {\n    function queryChain() public pure returns (uint256) {\n        uint256 query;\n        assembly {\n            query := chainid\n        }\n        return query;\n    }\n    function unrelated() public pure returns (uint256) { return 5; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/157.sol:1:168:\n  |\n1 |  ...    assembly {             query := chainid         }         return query;    ...\n  |                                         ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainFetch {\n    function fetchId() public pure returns (uint256) {\n        uint256 idFetch;\n        assembly {\n            idFetch := chainid\n        }\n        return idFetch;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/158.sol:1:169:\n  |\n1 |  ...  assembly {             idFetch := chainid         }         return idFetch;  ...\n  |                                         ^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainIdentifier {\n    function identifyChain() public pure returns (uint256) {\n        uint256 identifier;\n        assembly {\n            identifier := chainid\n        }\n        return identifier;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/159.sol:1:186:\n  |\n1 |  ... sembly {             identifier := chainid         }         return identifie ...\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainLookup {\n    function lookupChain() public pure returns (uint256) {\n        uint256 lookup;\n        assembly {\n            lookup := chainid\n        }\n        return lookup;\n    }\n    function nothingRelated() public pure returns (uint256) { return 10; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/160.sol:1:172:\n  |\n1 |  ...   assembly {             lookup := chainid         }         return lookup;   ...\n  |                                         ^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainDeterminer {\n    function determineChain() public pure returns (uint256) {\n        uint256 determine;\n        assembly {\n            determine := chainid\n        }\n        return determine;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/161.sol:1:185:\n  |\n1 |  ... ssembly {             determine := chainid         }         return determine ...\n  |                                         ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract IdentityCheck {\n    function fetchChainId() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract NetworkVerifier {\n    function retrieveNetworkId() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ChainInspector {\n    function detectChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function dummyFunction() public pure returns (uint256) { return 1; }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ChainValidator {\n    function validateChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function extraOne() public pure returns (uint256) { return 2; }\n    function extraTwo() public pure returns (uint256) { return 3; }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract NetworkCheck {\n    function getNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ChainQuery {\n    function queryChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function unrelated() public pure returns (uint256) { return 5; }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ChainFetch {\n    function fetchId() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ChainIdentifier {\n    function identifyChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ChainLookup {\n    function lookupChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function nothingRelated() public pure returns (uint256) { return 10; }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ChainDeterminer {\n    function determineChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}"
      }
    }
  },
  {
    "Changes99": {
      "Version Migration": "0.6->0.8",
      "Knowledge": "Unary negation cannot be used on unsigned integers anymore, only on signed integers.Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. <code>type(uint256).max - x + 1</code>, while ensuring that <code>x</code> is not zero)",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract CalculateOne {\n    function calcOne(uint x) public pure returns (uint) {\n        return -x;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/162.sol:1:121:\n  |\n1 | pragma solidity^0.8.0; contract CalculateOne {     function calcOne(uint x) public pure returns (uint) {         return -x;     } }\n  |                                                                                                                         ^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ComputeValue {\n    function compute(uint y) public pure returns (uint) {\n        return -y;\n    }\n    function helper() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/163.sol:1:121:\n  |\n1 |  ... re returns (uint) {         return -y;     }     function helper() publi ...\n  |                                         ^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ProcessInput {\n    function process(uint256 z) public pure returns (uint256) {\n        uint256 result = -z;\n        return result;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/164.sol:1:137:\n  |\n1 |  ... int256) {         uint256 result = -z;         return result;     } }\n  |                                         ^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract NumberTransform {\n    function transform(uint a) public pure returns (uint) {\n        return -a;\n    }\n    function extraFunction() public pure {}\n    function anotherFunction() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/165.sol:1:126:\n  |\n1 |  ... re returns (uint) {         return -a;     }     function extraFunction( ...\n  |                                         ^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract FlipValue {\n    function flip(uint b) public pure returns (uint) {\n        return -b;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/166.sol:1:115:\n  |\n1 | pragma solidity^0.8.0; contract FlipValue {     function flip(uint b) public pure returns (uint) {         return -b;     } }\n  |                                                                                                                   ^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract InvertNumber {\n    function invert(uint c) public pure returns (uint) {\n        return -c;\n    }\n    function unused() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/167.sol:1:120:\n  |\n1 |  ... re returns (uint) {         return -c;     }     function unused() publi ...\n  |                                         ^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ReverseSign {\n    function reverse(uint d) public pure returns (uint) {\n        return -d;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/168.sol:1:120:\n  |\n1 | pragma solidity^0.8.0; contract ReverseSign {     function reverse(uint d) public pure returns (uint) {         return -d;     } }\n  |                                                                                                                        ^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract NegativeValue {\n    function negative(uint e) public pure returns (uint) {\n        return -e;\n    }\n    function doNothing() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/169.sol:1:123:\n  |\n1 |  ... re returns (uint) {         return -e;     }     function doNothing() pu ...\n  |                                         ^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract SubtractFromZero {\n    function subtract(uint f) public pure returns (uint) {\n        return -f;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/170.sol:1:126:\n  |\n1 | pragma solidity^0.8.0; contract SubtractFromZero {     function subtract(uint f) public pure returns (uint) {         return -f;     } }\n  |                                                                                                                              ^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract OppositeValue {\n    function opposite(uint g) public pure returns (uint) {\n        return -g;\n    }\n    function helperOne() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.6-0.8/0.6-0.8-train-error/171.sol:1:123:\n  |\n1 |  ... re returns (uint) {         return -g;     }     function helperOne() pu ...\n  |                                         ^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract CalculateOne {\n    function calcOne(uint x) public pure returns (uint) {\n        return type(uint).max - x + 1;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ComputeValue {\n    function compute(uint y) public pure returns (uint) {\n        return type(uint).max - y + 1;\n    }\n    function helper() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ProcessInput {\n    function process(uint256 z) public pure returns (uint256) {\n        return type(uint256).max - z + 1;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract NumberTransform {\n    function transform(uint a) public pure returns (uint) {\n        return type(uint).max - a + 1;\n    }\n    function extraFunction() public pure {}\n    function anotherFunction() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract FlipValue {\n    function flip(uint b) public pure returns (uint) {\n        return type(uint).max - b + 1;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract InvertNumber {\n    function invert(uint c) public pure returns (uint) {\n        return type(uint).max - c + 1;\n    }\n    function unused() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ReverseSign {\n    function reverse(uint d) public pure returns (uint) {\n        return type(uint).max - d + 1;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract NegativeValue {\n    function negative(uint e) public pure returns (uint) {\n        return type(uint).max - e + 1;\n    }\n    function doNothing() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract SubtractFromZero {\n    function subtract(uint f) public pure returns (uint) {\n        return type(uint).max - f + 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract OppositeValue {\n    function opposite(uint g) public pure returns (uint) {\n        return type(uint).max - g + 1;\n    }\n    function helperOne() public pure {}\n}"
      }
    }
  },
  {
    "Changes100": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractEE {\n    byte itemEE;\n    function setItemEE(byte newValue) public {\n        itemEE = newValue;\n    }\n    function extraFunctionEE() public pure returns (string memory) {\n        return \"Extra EE\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/2.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractEE {     byte itemEE;     function setItemEE(byt ...\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractFF {\n    byte itemFF;\n    function modifyItemFF(byte newValue) public {\n        itemFF = newValue;\n    }\n    function randomFunctionFF() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/3.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractFF {     byte itemFF;     function modifyItemFF( ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractGG {\n    byte itemGG;\n    function updateItemGG(byte newValue) public {\n        itemGG = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/4.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractGG {     byte itemGG;     function updateItemGG(byte newValue) public {         itemGG = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractHH {\n    byte itemHH;\n    function changeItemHH(byte newValue) public {\n        itemHH = newValue;\n    }\n    function helperFunctionHH() public pure returns (int) {\n        return 256;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/5.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractHH {     byte itemHH;     function changeItemHH( ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractII {\n    byte itemII;\n    function adjustItemII(byte newValue) public {\n        itemII = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/6.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractII {     byte itemII;     function adjustItemII(byte newValue) public {         itemII = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractJJ {\n    byte itemJJ;\n    function setItemJJ(byte newValue) public {\n        itemJJ = newValue;\n    }\n    function extraFunctionJJ() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/7.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractJJ {     byte itemJJ;     function setItemJJ(byt ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractKK {\n    byte itemKK;\n    function deployItemKK(byte newValue) public {\n        itemKK = newValue;\n    }\n    function dummyFunctionKK() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/8.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractKK {     byte itemKK;     function deployItemKK( ...\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractLL {\n    byte itemLL;\n    function storeItemLL(byte newValue) public {\n        itemLL = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/9.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractLL {     byte itemLL;     function storeItemLL(byte newValue) public {         itemLL = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractMM {\n    byte itemMM;\n    function replaceItemMM(byte newValue) public {\n        itemMM = newValue;\n    }\n    function extraFunctionMM() public pure returns (int) {\n        return -123;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/10.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractMM {     byte itemMM;     function replaceItemMM ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractNN {\n    byte itemNN;\n    function refreshItemNN(byte newValue) public {\n        itemNN = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/11.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractNN {     byte itemNN;     function refreshItemNN(byte newValue) public {         itemNN = newValue;     } }\n  |                                                  ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractEE {\n    bytes1 itemEE;\n    function setItemEE(bytes1 newValue) public {\n        itemEE = newValue;\n    }\n    function extraFunctionEE() public pure returns (string memory) {\n        return \"Extra EE\";\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractFF {\n    bytes1 itemFF;\n    function modifyItemFF(bytes1 newValue) public {\n        itemFF = newValue;\n    }\n    function randomFunctionFF() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractGG {\n    bytes1 itemGG;\n    function updateItemGG(bytes1 newValue) public {\n        itemGG = newValue;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractHH {\n    bytes1 itemHH;\n    function changeItemHH(bytes1 newValue) public {\n        itemHH = newValue;\n    }\n    function helperFunctionHH() public pure returns (int) {\n        return 256;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractII {\n    bytes1 itemII;\n    function adjustItemII(bytes1 newValue) public {\n        itemII = newValue;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractJJ {\n    bytes1 itemJJ;\n    function setItemJJ(bytes1 newValue) public {\n        itemJJ = newValue;\n    }\n    function extraFunctionJJ() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractKK {\n    bytes1 itemKK;\n    function deployItemKK(bytes1 newValue) public {\n        itemKK = newValue;\n    }\n    function dummyFunctionKK() public pure returns (string memory) {\n        return \"Dummy\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractLL {\n    bytes1 itemLL;\n    function storeItemLL(bytes1 newValue) public {\n        itemLL = newValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractMM {\n    bytes1 itemMM;\n    function replaceItemMM(bytes1 newValue) public {\n        itemMM = newValue;\n    }\n    function extraFunctionMM() public pure returns (int) {\n        return -123;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractNN {\n    bytes1 itemNN;\n    function refreshItemNN(bytes1 newValue) public {\n        itemNN = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes101": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions from negative literals and literals larger than <code>type(uint160).max</code> to\n<code>address</code> are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyOne {\n    function convertNegativeThirtyOne() public pure returns (address) {\n        int neg = -31;\n        return address(uint160(neg));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/12.sol:1:172:\n  |\n1 |  ...  neg = -31;         return address(uint160(neg));     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyTwo {\n    function makeAddressNegative() public pure returns (address) {\n        int negative = -32;\n        return address(uint160(negative));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/13.sol:1:172:\n  |\n1 |  ... tive = -32;         return address(uint160(negative));     }     function extraMethod() ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyThree {\n    function negativeToAddressThirtyThree() public pure returns (address) {\n        int num = -33;\n        return address(uint160(num));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/14.sol:1:178:\n  |\n1 |  ...  num = -33;         return address(uint160(num));     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFour {\n    function addressFromNegThirtyFour() public pure returns (address) {\n        int numNeg = -34;\n        return address(uint160(numNeg));\n    }\n    function checkValue() public pure returns (uint) {\n        return 34;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/15.sol:1:176:\n  |\n1 |  ... mNeg = -34;         return address(uint160(numNeg));     }     function checkValue()  ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFive {\n    function convertNegToAddrThirtyFive() public pure returns (address) {\n        int negInt = -35;\n        return address(uint160(negInt));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/16.sol:1:178:\n  |\n1 |  ... gInt = -35;         return address(uint160(negInt));     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySix {\n    function castNegativeInteger() public pure returns (address) {\n        int negative = -36;\n        return address(uint160(negative));\n    }\n    function unrelatedFunction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/17.sol:1:172:\n  |\n1 |  ... tive = -36;         return address(uint160(negative));     }     function unrelatedFunc ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySeven {\n    function negativeToIntAddress() public pure returns (address) {\n        int badNumber = -37;\n        return address(uint160(badNumber));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/18.sol:1:176:\n  |\n1 |  ... mber = -37;         return address(uint160(badNumber));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyEight {\n    function castToAddressFromNeg() public pure returns (address) {\n        int negativeValue = -38;\n        return address(uint160(negativeValue));\n    }\n    function returnValue() public pure returns (int) {\n        return -38;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/19.sol:1:180:\n  |\n1 |  ... alue = -38;         return address(uint160(negativeValue));     }     function returnValue() ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyNine {\n    function negativeValueToAddress() public pure returns (address) {\n        int value = -39;\n        return address(uint160(value));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/20.sol:1:173:\n  |\n1 |  ... alue = -39;         return address(uint160(value));     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractForty {\n    function negativeToAddressConversion() public pure returns (address) {\n        int negativeForty = -40;\n        return address(uint160(negativeForty));\n    }\n    function simpleFunc() public pure returns (uint) {\n        return 40;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/21.sol:1:181:\n  |\n1 |  ... orty = -40;         return address(uint160(negativeForty));     }     function simpleFunc()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyOne {\n    function validOperation() public pure returns (uint) {\n        int neg = -31;\n        return uint(neg);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyTwo {\n    function makeAddressPositive() public pure returns (address) {\n        uint positive = 32;\n        return address(uint160(positive));\n    }\n    function extraMethod() public pure returns (string memory) {\n        return \"Hello World\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyThree {\n    function positiveToAddress() public pure returns (address) {\n        uint num = 33;\n        return address(uint160(num));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFour {\n    function addressFromPositive() public pure returns (address) {\n        uint numPos = 34;\n        return address(uint160(numPos));\n    }\n    function checkValue() public pure returns (uint) {\n        return 34;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyFive {\n    function convertPosToAddr() public pure returns (address) {\n        uint posInt = 35;\n        return address(uint160(posInt));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySix {\n    function castPositiveInteger() public pure returns (address) {\n        uint positive = 36;\n        return address(uint160(positive));\n    }\n    function unrelatedFunction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractThirtySeven {\n    function positiveToIntAddress() public pure returns (address) {\n        uint goodNumber = 37;\n        return address(uint160(goodNumber));\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyEight {\n    function castToAddressFromPos() public pure returns (address) {\n        uint positiveValue = 38;\n        return address(uint160(positiveValue));\n    }\n    function returnValue() public pure returns (int) {\n        return -38;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractThirtyNine {\n    function positiveValueToAddress() public pure returns (address) {\n        uint value = 39;\n        return address(uint160(value));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractForty {\n    function positiveToAddressConversion() public pure returns (address) {\n        uint positiveForty = 40;\n        return address(uint160(positiveForty));\n    }\n    function simpleFunc() public pure returns (uint) {\n        return 40;\n    }\n}"
      }
    }
  },
  {
    "Changes102": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and an integer type <code>T</code> are only allowed if the literal\nlies between <code>type(T).min</code> and <code>type(T).max</code>. In particular, replace usages of <code>uint(-1)</code>\nwith <code>type(uint).max</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyOne {\n    function deriveCeiling() public pure returns (uint) {\n        uint ceiling = uint(-1);\n        return ceiling;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/22.sol:1:134:\n  |\n1 |  ... ns (uint) {         uint ceiling = uint(-1);         return ceiling;     } }\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyTwo {\n    function calculateMaxCap() public pure returns (uint) {\n        uint maxCap = uint(-1);\n        return maxCap;\n    }\n    function randomHelper() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/23.sol:1:135:\n  |\n1 |  ... rns (uint) {         uint maxCap = uint(-1);         return maxCap;     }      ...\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyThree {\n    function establishLimit() public pure returns (uint) {\n        uint limit = uint(-1);\n        return limit;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/24.sol:1:135:\n  |\n1 |  ... urns (uint) {         uint limit = uint(-1);         return limit;     } }\n  |                                         ^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFour {\n    function reachMaximum() public pure returns (uint) {\n        uint maximumReach = uint(-1);\n        return maximumReach;\n    }\n    function extraFunctionFive() public pure returns (string memory) {\n        return \"Just a string\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/25.sol:1:139:\n  |\n1 |  ... int) {         uint maximumReach = uint(-1);         return maximumReach;      ...\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFive {\n    function pinpointCeiling() public pure returns (uint) {\n        uint ceilingPinpoint = uint(-1);\n        return ceilingPinpoint;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/26.sol:1:145:\n  |\n1 |  ... ) {         uint ceilingPinpoint = uint(-1);         return ceilingPinpoint;   ...\n  |                                         ^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySix {\n    function getExtremeValue() public pure returns (uint) {\n        uint extremeValue = uint(-1);\n        return extremeValue;\n    }\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 567;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/27.sol:1:141:\n  |\n1 |  ... int) {         uint extremeValue = uint(-1);         return extremeValue;      ...\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySeven {\n    function calculateBoundaryMax() public pure returns (uint) {\n        uint boundaryCalculation = uint(-1);\n        return boundaryCalculation;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/28.sol:1:155:\n  |\n1 |  ...         uint boundaryCalculation = uint(-1);         return boundaryCalculatio ...\n  |                                         ^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyEight {\n    function derivePeak() public pure returns (uint) {\n        uint peakDerivation = uint(-1);\n        return peakDerivation;\n    }\n    function extraFunctionSix() public pure returns (int) {\n        return -999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/29.sol:1:140:\n  |\n1 |  ... t) {         uint peakDerivation = uint(-1);         return peakDerivation;    ...\n  |                                         ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyNine {\n    function secureMaximum() public pure returns (uint) {\n        uint secureMax = uint(-1);\n        return secureMax;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/30.sol:1:137:\n  |\n1 |  ...  (uint) {         uint secureMax = uint(-1);         return secureMax;     } }\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleForty {\n    function identifyMaxValue() public pure returns (uint) {\n        uint maxValue = uint(-1);\n        return maxValue;\n    }\n    function unrelatedTwo() public pure returns (string memory) {\n        return \"Random text\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/31.sol:1:134:\n  |\n1 |  ... s (uint) {         uint maxValue = uint(-1);         return maxValue;     }    ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyOne {\n    function deriveCeiling() public pure returns (uint) {\n        uint ceiling = type(uint).max;\n        return ceiling;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyTwo {\n    function calculateMaxCap() public pure returns (uint) {\n        uint maxCap = type(uint).max;\n        return maxCap;\n    }\n    function randomHelper() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyThree {\n    function establishLimit() public pure returns (uint) {\n        uint limit = type(uint).max;\n        return limit;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFour {\n    function reachMaximum() public pure returns (uint) {\n        uint maximumReach = type(uint).max;\n        return maximumReach;\n    }\n    function extraFunctionFive() public pure returns (string memory) {\n        return \"Just a string\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyFive {\n    function pinpointCeiling() public pure returns (uint) {\n        uint ceilingPinpoint = type(uint).max;\n        return ceilingPinpoint;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySix {\n    function getExtremeValue() public pure returns (uint) {\n        uint extremeValue = type(uint).max;\n        return extremeValue;\n    }\n    function dummyFunctionTwo() public pure returns (uint) {\n        return 567;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtySeven {\n    function calculateBoundaryMax() public pure returns (uint) {\n        uint boundaryCalculation = type(uint).max;\n        return boundaryCalculation;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyEight {\n    function derivePeak() public pure returns (uint) {\n        uint peakDerivation = type(uint).max;\n        return peakDerivation;\n    }\n    function extraFunctionSix() public pure returns (int) {\n        return -999;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ExampleThirtyNine {\n    function secureMaximum() public pure returns (uint) {\n        uint secureMax = type(uint).max;\n        return secureMax;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ExampleForty {\n    function identifyMaxValue() public pure returns (uint) {\n        uint maxValue = type(uint).max;\n        return maxValue;\n    }\n    function unrelatedTwo() public pure returns (string memory) {\n        return \"Random text\";\n    }\n}"
      }
    }
  },
  {
    "Changes103": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and enums are only allowed if the literal can\nrepresent a value in the enum.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    enum Speed { Slow, Fast }\n    Speed public carSpeed;\n    function setSpeed() public {\n        carSpeed = Speed(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example32.Speed\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/32.sol:1:155:\n  |\n1 |  ... peed() public {         carSpeed = Speed(3);     } }\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    enum Frequency { Never, Rarely, Often, Always }\n    Frequency public loginFrequency;\n    function setFrequency() public {\n        loginFrequency = Frequency(5);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example33.Frequency\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/33.sol:1:197:\n  |\n1 |  ...  public {         loginFrequency = Frequency(5);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    enum Status { Single, Married, Divorced }\n    Status public maritalStatus;\n    function updateStatus() public {\n        maritalStatus = Status(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example34.Status\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/34.sol:1:186:\n  |\n1 |  ... ) public {         maritalStatus = Status(4);     } }\n  |                                         ^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    enum Direction { Up, Down, Left, Right }\n    Direction public swipeDirection;\n    function swipe() public {\n        swipeDirection = Direction(5);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example35.Direction\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/35.sol:1:183:\n  |\n1 |  ...  public {         swipeDirection = Direction(5);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    enum Action { Buy, Sell, Hold }\n    Action public tradingAction;\n    function takeAction() public {\n        tradingAction = Action(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example36.Action\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/36.sol:1:174:\n  |\n1 |  ... ) public {         tradingAction = Action(4);     } }\n  |                                         ^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    enum Condition { Good, Fair, Poor }\n    Condition public itemCondition;\n    function setCondition() public {\n        itemCondition = Condition(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example37.Condition\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/37.sol:1:183:\n  |\n1 |  ... ) public {         itemCondition = Condition(4);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    enum Temperature { Cold, Warm, Hot }\n    Temperature public waterTemperature;\n    function setTemperature() public {\n        waterTemperature = Temperature(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example38.Temperature\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/38.sol:1:194:\n  |\n1 |  ... ublic {         waterTemperature = Temperature(4);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    enum Position { First, Second, Third }\n    Position public racePosition;\n    function setPosition() public {\n        racePosition = Position(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example39.Position\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/39.sol:1:182:\n  |\n1 |  ... () public {         racePosition = Position(4);     } }\n  |                                         ^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    enum Response { Yes, No }\n    Response public userResponse;\n    function setResponse() public {\n        userResponse = Response(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example40.Response\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/40.sol:1:169:\n  |\n1 |  ... () public {         userResponse = Response(3);     } }\n  |                                         ^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    enum Quality { High, Medium, Low }\n    Quality public productQuality;\n    function adjustQuality() public {\n        productQuality = Quality(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example41.Quality\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/41.sol:1:183:\n  |\n1 |  ...  public {         productQuality = Quality(4);     } }\n  |                                         ^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    enum Speed { Slow, Fast }\n    Speed public carSpeed;\n    function setSpeed() public {\n        carSpeed = Speed(1);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    enum Frequency { Never, Rarely, Often, Always }\n    Frequency public loginFrequency;\n    function setFrequency() public {\n        loginFrequency = Frequency(3);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    enum Status { Single, Married, Divorced }\n    Status public maritalStatus;\n    function updateStatus() public {\n        maritalStatus = Status(2);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    enum Direction { Up, Down, Left, Right }\n    Direction public swipeDirection;\n    function swipe() public {\n        swipeDirection = Direction(3);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    enum Action { Buy, Sell, Hold }\n    Action public tradingAction;\n    function takeAction() public {\n        tradingAction = Action(2);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    enum Condition { Good, Fair, Poor }\n    Condition public itemCondition;\n    function setCondition() public {\n        itemCondition = Condition(2);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    enum Temperature { Cold, Warm, Hot }\n    Temperature public waterTemperature;\n    function setTemperature() public {\n        waterTemperature = Temperature(2);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    enum Position { First, Second, Third }\n    Position public racePosition;\n    function setPosition() public {\n        racePosition = Position(2);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    enum Response { Yes, No }\n    Response public userResponse;\n    function setResponse() public {\n        userResponse = Response(1);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    enum Quality { High, Medium, Low }\n    Quality public productQuality;\n    function adjustQuality() public {\n        productQuality = Quality(2);\n    }\n}"
      }
    }
  },
  {
    "Changes104": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and <code>address</code> type (e.g. <code>address(literal)</code>) have the\ntype <code>address</code> instead of <code>address payable</code>. One can get a payable address type by using an\nexplicit conversion, i.e., <code>payable(literal)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    function issuePayments(address employee, uint256 salary) public {\n        address payable payrollAccount = address(0xFFF);\n        payrollAccount.transfer(salary);\n    }\n\n    function sumOfSquares(uint[] memory nums) public pure returns (uint total) {\n        total = 0;\n        for (uint i = 0; i < nums.length; i++) {\n            total += nums[i] * nums[i];\n        }\n        return total;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/42.sol:1:124:\n  |\n1 |  ... , uint256 salary) public {         address payable payrollAccount = address(0xFFF);         payrollAccount.transfer(s ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    function payDividends(address investor, uint256 dividends) public {\n        address payable investmentAccount = address(0x111);\n        investmentAccount.transfer(dividends);\n    }\n\n    function sumOfEvens(uint limit) public pure returns (uint sum) {\n        sum = 0;\n        for (uint i = 0; i <= limit; i += 2) {\n            sum += i;\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/43.sol:1:126:\n  |\n1 |  ... int256 dividends) public {         address payable investmentAccount = address(0x111);         investmentAccount.transfe ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    function clearDebt(address debtor, uint256 amount) public {\n        address payable debtAccount = address(0x222);\n        debtAccount.transfer(amount);\n    }\n\n    function powerOfTwo(uint n) public pure returns (uint) {\n        return 2**n;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/44.sol:1:118:\n  |\n1 |  ... , uint256 amount) public {         address payable debtAccount = address(0x222);         debtAccount.transfer(amou ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    function grantScholarship(address student, uint256 scholarship) public {\n        address payable schoolAccount = address(0x333);\n        schoolAccount.transfer(scholarship);\n    }\n\n    function isPrime(uint num) public pure returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/45.sol:1:131:\n  |\n1 |  ... t256 scholarship) public {         address payable schoolAccount = address(0x333);         schoolAccount.transfer(sc ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    function refundCustomer(address customer, uint256 refundAmount) public {\n        address payable refundAccount = address(0x444);\n        refundAccount.transfer(refundAmount);\n    }\n\n    function factorial(uint n) public pure returns (uint result) {\n        result = 1;\n        for (uint i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/46.sol:1:131:\n  |\n1 |  ... 256 refundAmount) public {         address payable refundAccount = address(0x444);         refundAccount.transfer(re ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    function payOutInsurance(address insured, uint256 claimAmount) public {\n        address payable insuranceAccount = address(0x555);\n        insuranceAccount.transfer(claimAmount);\n    }\n\n    function calculateModulus(uint a, uint b) public pure returns (uint) {\n        return a % b;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/47.sol:1:130:\n  |\n1 |  ... t256 claimAmount) public {         address payable insuranceAccount = address(0x555);         insuranceAccount.transfer ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    function settleBill(address vendor, uint256 billAmount) public {\n        address payable vendorAccount = address(0x666);\n        vendorAccount.transfer(billAmount);\n    }\n\n    function countOddNumbers(uint limit) public pure returns (uint count) {\n        for (uint i = 1; i < limit; i += 2) {\n            count++;\n        }\n        return count;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/48.sol:1:123:\n  |\n1 |  ... nt256 billAmount) public {         address payable vendorAccount = address(0x666);         vendorAccount.transfer(bi ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    function payRoyalties(address author, uint256 royalties) public {\n        address payable royaltyAccount = address(0x777);\n        royaltyAccount.transfer(royalties);\n    }\n\n    function fibonacci(uint n) public pure returns (uint) {\n        if (n == 0) return 0;\n        else if (n == 1) return 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/49.sol:1:124:\n  |\n1 |  ... int256 royalties) public {         address payable royaltyAccount = address(0x777);         royaltyAccount.transfer(r ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    function distributeInterest(address accountHolder, uint256 interest) public {\n        address payable bankAccount = address(0x888);\n        bankAccount.transfer(interest);\n    }\n\n    function sumOfArray(uint[] memory array) public pure returns (uint sum) {\n        for (uint i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/50.sol:1:136:\n  |\n1 |  ... uint256 interest) public {         address payable bankAccount = address(0x888);         bankAccount.transfer(inte ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    function redeemPoints(address member, uint256 points) public {\n        address payable membershipAccount = address(0x999);\n        membershipAccount.transfer(points);\n    }\n\n    function generatePrimes(uint limit) public pure returns (uint[] memory primes) {\n        bool[] memory isPrime = new bool[](limit + 1);\n        for (uint i = 2; i <= limit; i++) isPrime[i] = true;\n        for (uint p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (uint j = p * p; j <= limit; j += p) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        uint count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) count++;\n        }\n        primes = new uint[](count);\n        count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) {\n                primes[count++] = i;\n            }\n        }\n        return primes;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/51.sol:1:121:\n  |\n1 |  ... , uint256 points) public {         address payable membershipAccount = address(0x999);         membershipAccount.transfe ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example32 {\n    function issuePayments(address employee, uint256 salary) public {\n        address payable payrollAccount = payable(employee);\n        payrollAccount.transfer(salary);\n    }\n\n    function sumOfSquares(uint[] memory nums) public pure returns (uint total) {\n        total = 0;\n        for (uint i = 0; i < nums.length; i++) {\n            total += nums[i] * nums[i];\n        }\n        return total;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example33 {\n    function payDividends(address investor, uint256 dividends) public {\n        address payable investmentAccount = payable(investor);\n        investmentAccount.transfer(dividends);\n    }\n\n    function sumOfEvens(uint limit) public pure returns (uint sum) {\n        sum = 0;\n        for (uint i = 0; i <= limit; i += 2) {\n            sum += i;\n        }\n        return sum;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example34 {\n    function clearDebt(address debtor, uint256 amount) public {\n        address payable debtAccount = payable(debtor);\n        debtAccount.transfer(amount);\n    }\n\n    function powerOfTwo(uint n) public pure returns (uint) {\n        return 2**n;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example35 {\n    function grantScholarship(address student, uint256 scholarship) public {\n        address payable schoolAccount = payable(student);\n        schoolAccount.transfer(scholarship);\n    }\n\n    function isPrime(uint num) public pure returns (bool) {\n        if (num < 2) {\n            return false;\n        }\n        for (uint i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example36 {\n    function refundCustomer(address customer, uint256 refundAmount) public {\n        address payable refundAccount = payable(customer);\n        refundAccount.transfer(refundAmount);\n    }\n\n    function factorial(uint n) public pure returns (uint result) {\n        result = 1;\n        for (uint i = 2; i <= n; i++) {\n            result *= i;\n        }\n        return result;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example37 {\n    function payOutInsurance(address insured, uint256 claimAmount) public {\n        address payable insuranceAccount = payable(insured);\n        insuranceAccount.transfer(claimAmount);\n    }\n\n    function calculateModulus(uint a, uint b) public pure returns (uint) {\n        return a % b;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example38 {\n    function settleBill(address vendor, uint256 billAmount) public {\n        address payable vendorAccount = payable(vendor);\n        vendorAccount.transfer(billAmount);\n    }\n\n    function countOddNumbers(uint limit) public pure returns (uint count) {\n        for (uint i = 1; i < limit; i += 2) {\n            count++;\n        }\n        return count;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example39 {\n    function payRoyalties(address author, uint256 royalties) public {\n        address payable royaltyAccount = payable(author);\n        royaltyAccount.transfer(royalties);\n    }\n\n    function fibonacci(uint n) public pure returns (uint) {\n        if (n == 0) return 0;\n        else if (n == 1) return 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example40 {\n    function distributeInterest(address accountHolder, uint256 interest) public {\n        address payable bankAccount = payable(accountHolder);\n        bankAccount.transfer(interest);\n    }\n\n    function sumOfArray(uint[] memory array) public pure returns (uint sum) {\n        for (uint i = 0; i < array.length; i++) {\n            sum += array[i];\n        }\n        return sum;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example41 {\n    function redeemPoints(address member, uint256 points) public {\n        address payable membershipAccount = payable(member);\n        membershipAccount.transfer(points);\n    }\n\n    function generatePrimes(uint limit) public pure returns (uint[] memory primes) {\n        bool[] memory isPrime = new bool[](limit + 1);\n        for (uint i = 2; i <= limit; i++) isPrime[i] = true;\n        for (uint p = 2; p * p <= limit; p++) {\n            if (isPrime[p]) {\n                for (uint j = p * p; j <= limit; j += p) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        uint count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) count++;\n        }\n        primes = new uint[](count);\n        count = 0;\n        for (uint i = 2; i <= limit; i++) {\n            if (isPrime[i]) {\n                primes[count++] = i;\n            }\n        }\n        return primes;\n    }\n}"
      }
    }
  },
  {
    "Changes105": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/types.html#address-literals\"><span class=\"std std-ref\">Address literals</a> have the type <code>address</code> instead of <code>address\npayable</code>. They can be converted to <code>address payable</code> by using an explicit conversion, e.g.\n<code>payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract11 {\n    address payable public account11;\n    constructor() {\n        account11 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/52.sol:1:124:\n  |\n1 |  ... onstructor() {         account11 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract12 {\n    address payable public account12;\n    constructor() {\n        account12 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/53.sol:1:124:\n  |\n1 |  ... onstructor() {         account12 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract13 {\n    address payable public account13;\n    constructor() {\n        account13 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/54.sol:1:124:\n  |\n1 |  ... onstructor() {         account13 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract14 {\n    address payable public account14;\n    constructor() {\n        account14 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/55.sol:1:124:\n  |\n1 |  ... onstructor() {         account14 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract15 {\n    address payable public account15;\n    constructor() {\n        account15 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/56.sol:1:124:\n  |\n1 |  ... onstructor() {         account15 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract16 {\n    address payable public account16;\n    constructor() {\n        account16 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random6() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/57.sol:1:124:\n  |\n1 |  ... onstructor() {         account16 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random6() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract17 {\n    address payable public account17;\n    constructor() {\n        account17 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random7() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/58.sol:1:124:\n  |\n1 |  ... onstructor() {         account17 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random7() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract18 {\n    address payable public account18;\n    constructor() {\n        account18 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random8() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/59.sol:1:124:\n  |\n1 |  ... onstructor() {         account18 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random8() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract19 {\n    address payable public account19;\n    constructor() {\n        account19 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/60.sol:1:124:\n  |\n1 |  ... onstructor() {         account19 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract20 {\n    address payable public account20;\n    constructor() {\n        account20 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/61.sol:1:124:\n  |\n1 |  ... onstructor() {         account20 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Contract11 {\n    address payable public account11;\n    constructor() {\n        account11 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Contract12 {\n    address payable public account12;\n    constructor() {\n        account12 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Contract13 {\n    address payable public account13;\n    constructor() {\n        account13 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Contract14 {\n    address payable public account14;\n    constructor() {\n        account14 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Contract15 {\n    address payable public account15;\n    constructor() {\n        account15 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Contract16 {\n    address payable public account16;\n    constructor() {\n        account16 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random6() public {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Contract17 {\n    address payable public account17;\n    constructor() {\n        account17 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random7() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Contract18 {\n    address payable public account18;\n    constructor() {\n        account18 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random8() public {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Contract19 {\n    address payable public account19;\n    constructor() {\n        account19 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Contract20 {\n    address payable public account20;\n    constructor() {\n        account20 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}"
      }
    }
  },
  {
    "Changes106": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>address(uint)</code> and <code>uint(address)</code>: converting both type-category and width. Replace this by\n<code>address(uint160(uint))</code> and <code>uint(uint160(address))</code> respectively.Add intermediate explicit type conversions if required.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Reevaluate {\n    function reevaluateUintToAddress(uint ab) public pure returns (address) {\n        return address(ab);\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a function\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/62.sol:1:139:\n  |\n1 |  ... returns (address) {         return address(ab);     }     function randomFunction ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Reinterpret {\n    function reinterpretAddressToUint(address ac) public pure returns (uint) {\n        return uint(ac);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/63.sol:1:141:\n  |\n1 |  ... re returns (uint) {         return uint(ac);     } }\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Reorganize {\n    function reorganizeUintToAddress(uint ad) public pure returns (address) {\n        return address(ad);\n    }\n    function secondaryAction() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/64.sol:1:139:\n  |\n1 |  ... returns (address) {         return address(ad);     }     function secondaryActio ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Reposition {\n    function repositionAddressToUint(address ae) public pure returns (uint) {\n        return uint(ae);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/65.sol:1:139:\n  |\n1 |  ... re returns (uint) {         return uint(ae);     } }\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Reconstruct {\n    function reconstructUintToAddress(uint af) public pure returns (address) {\n        return address(af);\n    }\n    function unusedMethod() public pure returns (int) {\n        return 999;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/66.sol:1:141:\n  |\n1 |  ... returns (address) {         return address(af);     }     function unusedMethod() ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Reintegrate {\n    function reintegrateAddressToUint(address ag) public pure returns (uint) {\n        return uint(ag);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/67.sol:1:141:\n  |\n1 |  ... re returns (uint) {         return uint(ag);     } }\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Redistribute {\n    function redistributeUintToAddress(uint ah) public pure returns (address) {\n        return address(ah);\n    }\n    function extraHelper() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/68.sol:1:143:\n  |\n1 |  ... returns (address) {         return address(ah);     }     function extraHelper()  ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Remodel {\n    function remodelAddressToUint(address ai) public pure returns (uint) {\n        return uint(ai);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/69.sol:1:133:\n  |\n1 | pragma solidity^0.8.0; contract Remodel {     function remodelAddressToUint(address ai) public pure returns (uint) {         return uint(ai);     } }\n  |                                                                                                                                     ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Revamp {\n    function revampUintToAddress(uint aj) public pure returns (address) {\n        return address(aj);\n    }\n    function optionalFunction() public pure returns (uint) {\n        return 256;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/70.sol:1:131:\n  |\n1 |  ... returns (address) {         return address(aj);     }     function optionalFuncti ...\n  |                                         ^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Retrofit {\n    function retrofitAddressToUint(address ak) public pure returns (uint) {\n        return uint(ak);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/71.sol:1:135:\n  |\n1 |  ... re returns (uint) {         return uint(ak);     } }\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Reevaluate {\n    function reevaluateUintToAddress(uint ab) public pure returns (address) {\n        return address(uint160(ab));\n    }\n    function randomFunction() public pure returns (string memory) {\n        return \"Just a function\";\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Reinterpret {\n    function reinterpretAddressToUint(address ac) public pure returns (uint) {\n        return uint(uint160(ac));\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Reorganize {\n    function reorganizeUintToAddress(uint ad) public pure returns (address) {\n        return address(uint160(ad));\n    }\n    function secondaryAction() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Reposition {\n    function repositionAddressToUint(address ae) public pure returns (uint) {\n        return uint(uint160(ae));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Reconstruct {\n    function reconstructUintToAddress(uint af) public pure returns (address) {\n        return address(uint160(af));\n    }\n    function unusedMethod() public pure returns (int) {\n        return 999;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Reintegrate {\n    function reintegrateAddressToUint(address ag) public pure returns (uint) {\n        return uint(uint160(ag));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Redistribute {\n    function redistributeUintToAddress(uint ah) public pure returns (address) {\n        return address(uint160(ah));\n    }\n    function extraHelper() public pure returns (string memory) {\n        return \"Additional\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Remodel {\n    function remodelAddressToUint(address ai) public pure returns (uint) {\n        return uint(uint160(ai));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Revamp {\n    function revampUintToAddress(uint aj) public pure returns (address) {\n        return address(uint160(aj));\n    }\n    function optionalFunction() public pure returns (uint) {\n        return 256;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Retrofit {\n    function retrofitAddressToUint(address ak) public pure returns (uint) {\n        return uint(uint160(ak));\n    }\n}"
      }
    }
  },
  {
    "Changes107": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>payable(uint160)</code>, <code>payable(bytes20)</code> and <code>payable(integer-literal)</code>: converting both\ntype-category and state-mutability. Replace this by <code>payable(address(uint160))</code>,\n<code>payable(address(bytes20))</code> and <code>payable(address(integer-literal))</code> respectively. Note that\n<code>payable(0)</code> is valid and is an exception to the rule.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ProfitDistributor {\n    function distributeProfit(uint160 profit) public pure returns (address payable) {\n        return payable(profit);\n    }\n    function checkProfit() public pure returns (uint) {\n        return 1000;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/72.sol:1:154:\n  |\n1 |  ... (address payable) {         return payable(profit);     }     function checkProfit()  ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetRegistrar {\n    function registerAsset(uint160 asset) public pure returns (address payable) {\n        return payable(asset);\n    }\n    function isActiveRegistrar() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/73.sol:1:147:\n  |\n1 |  ... (address payable) {         return payable(asset);     }     function isActiveRegist ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract DebtManager {\n    function manageDebt(uint160 debt) public pure returns (address payable) {\n        return payable(debt);\n    }\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra Function\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/74.sol:1:140:\n  |\n1 |  ... (address payable) {         return payable(debt);     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract CashFlowProcessor {\n    function processCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(cashFlow);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/75.sol:1:155:\n  |\n1 |  ... (address payable) {         return payable(cashFlow);     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract LiabilityHandler {\n    function handleLiability(uint160 liability) public pure returns (address payable) {\n        return payable(liability);\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/76.sol:1:155:\n  |\n1 |  ... (address payable) {         return payable(liability);     }     function extraData() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IncomeProcessor {\n    function processIncome(uint160 income) public pure returns (address payable) {\n        return payable(income);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/77.sol:1:149:\n  |\n1 |  ... (address payable) {         return payable(income);     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract TaxCollector {\n    function collectTax(uint160 taxAmount) public pure returns (address payable) {\n        return payable(taxAmount);\n    }\n    function getTaxRate() public pure returns (uint) {\n        return 15;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/78.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(taxAmount);     }     function getTaxRate() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract FundingController {\n    function controlFunding(uint160 funding) public pure returns (address payable) {\n        return payable(funding);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/79.sol:1:153:\n  |\n1 |  ... (address payable) {         return payable(funding);     } }\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneyHandler {\n    function handleMoney(uint160 money) public pure returns (address payable) {\n        return payable(money);\n    }\n    function checkBalance() public pure returns (int) {\n        return 1000;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/80.sol:1:143:\n  |\n1 |  ... (address payable) {         return payable(money);     }     function checkBalance() ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantAllocator {\n    function allocateGrant(uint160 grant) public pure returns (address payable) {\n        return payable(grant);\n    }\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/81.sol:1:147:\n  |\n1 |  ... (address payable) {         return payable(grant);     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ProfitDistributor {\n    function distributeProfit(uint160 profit) public pure returns (address payable) {\n        return payable(address(uint160(profit)));\n    }\n    function checkProfit() public pure returns (uint) {\n        return 1000;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract AssetRegistrar {\n    function registerAsset(uint160 asset) public pure returns (address payable) {\n        return payable(address(uint160(asset)));\n    }\n    function isActiveRegistrar() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract DebtManager {\n    function manageDebt(uint160 debt) public pure returns (address payable) {\n        return payable(address(uint160(debt)));\n    }\n    function extraFunction() public pure returns (string memory) {\n        return \"Extra Function\";\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract CashFlowProcessor {\n    function processCashFlow(uint160 cashFlow) public pure returns (address payable) {\n        return payable(address(uint160(cashFlow)));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract LiabilityHandler {\n    function handleLiability(uint160 liability) public pure returns (address payable) {\n        return payable(address(uint160(liability)));\n    }\n    function extraData() public pure returns (uint) {\n        return 42;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IncomeProcessor {\n    function processIncome(uint160 income) public pure returns (address payable) {\n        return payable(address(uint160(income)));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract TaxCollector {\n    function collectTax(uint160 taxAmount) public pure returns (address payable) {\n        return payable(address(uint160(taxAmount)));\n    }\n    function getTaxRate() public pure returns (uint) {\n        return 15;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract FundingController {\n    function controlFunding(uint160 funding) public pure returns (address payable) {\n        return payable(address(uint160(funding)));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract MoneyHandler {\n    function handleMoney(uint160 money) public pure returns (address payable) {\n        return payable(address(uint160(money)));\n    }\n    function checkBalance() public pure returns (int) {\n        return 1000;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract GrantAllocator {\n    function allocateGrant(uint160 grant) public pure returns (address payable) {\n        return payable(address(uint160(grant)));\n    }\n    function extraFunction() public pure returns (bool) {\n        return true;\n    }\n}"
      }
    }
  },
  {
    "Changes108": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>int80(bytes10)</code> and <code>bytes10(int80)</code>: converting both type-category and sign. Replace this by\n<code>int80(uint80(bytes10))</code> and <code>bytes10(uint80(int80)</code> respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterGamma {\n    function gammaConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function extraGammaFunction() public pure returns (uint256) {\n        return 255;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/82.sol:1:136:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function extraGammaFunc ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract DataReformer {\n    function reformData(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function randomGammaMethod() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/83.sol:1:132:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function randomGammaMet ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract TypeModifier {\n    function modifyType(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/84.sol:1:132:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract RapidConverter {\n    function rapidConversion(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function helperGamma() public pure returns (int) {\n        return 321;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/85.sol:1:139:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function helperGamma()  ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract BytesToIntegerConverter {\n    function bytesToInteger(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/86.sol:1:147:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IntegerToBytesConverter {\n    function integerToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/87.sol:1:147:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract EasyTransform {\n    function easyConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function additionalGammaMethod() public pure returns (string memory) {\n        return \"ExtraString\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/88.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function additionalGamm ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract BasicTypeModifier {\n    function basicConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/89.sol:1:139:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract DataTranscoder {\n    function transcodeData(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function extraGammaAction() public pure returns (uint) {\n        return 888;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/90.sol:1:137:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function extraGammaActi ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract DataTransmuter {\n    function transmuteData(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function dummyGammaValue() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/91.sol:1:137:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function dummyGammaValu ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ConverterGamma {\n    function gammaConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function extraGammaFunction() public pure returns (uint256) {\n        return 255;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract DataReformer {\n    function reformData(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function randomGammaMethod() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract TypeModifier {\n    function modifyType(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract RapidConverter {\n    function rapidConversion(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function helperGamma() public pure returns (int) {\n        return 321;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract BytesToIntegerConverter {\n    function bytesToInteger(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IntegerToBytesConverter {\n    function integerToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract EasyTransform {\n    function easyConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function additionalGammaMethod() public pure returns (string memory) {\n        return \"ExtraString\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract BasicTypeModifier {\n    function basicConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract DataTranscoder {\n    function transcodeData(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function extraGammaAction() public pure returns (uint) {\n        return 888;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract DataTransmuter {\n    function transmuteData(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function dummyGammaValue() public pure returns (bool) {\n        return false;\n    }\n}"
      }
    }
  },
  {
    "Changes109": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>Contract(uint)</code>: converting both type-category and width. Replace this by\n<code>Contract(address(uint160(uint)))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverOne {\n    function modify(uint index) public pure returns (address) {\n        address result = address(index);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/92.sol:1:136:\n  |\n1 |  ... ddress) {         address result = address(index);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverTwo {\n    function shift(uint data) public pure returns (address) {\n        address addr = address(data);\n        return addr;\n    }\n    function helperFunction() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/93.sol:1:132:\n  |\n1 |  ... (address) {         address addr = address(data);         return addr;     }     fu ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverThree {\n    function update(uint num) public pure returns (address) {\n        address addr = address(num);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/94.sol:1:134:\n  |\n1 |  ... (address) {         address addr = address(num);         return addr;     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverFour {\n    function calculate(uint input) public pure returns (address) {\n        address variable = address(input);\n        return variable;\n    }\n    function extraMethod() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/95.sol:1:142:\n  |\n1 |  ... ress) {         address variable = address(input);         return variable;     }    ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverFive {\n    function process(uint value) public pure returns (address) {\n        address addr = address(value);\n        return addr;\n    }\n    function anotherExtra() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/96.sol:1:136:\n  |\n1 |  ... (address) {         address addr = address(value);         return addr;     }     fu ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverSix {\n    function convert(uint data) public pure returns (address) {\n        address resultAddr = address(data);\n        return resultAddr;\n    }\n    function additionalMethod() public pure {}\n    function extraHelper() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/97.sol:1:140:\n  |\n1 |  ... ss) {         address resultAddr = address(data);         return resultAddr;     }  ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverSeven {\n    function transmit(uint amount) public pure returns (address) {\n        address result = address(amount);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/98.sol:1:141:\n  |\n1 |  ... ddress) {         address result = address(amount);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverEight {\n    function deliver(uint quantity) public pure returns (address) {\n        address output = address(quantity);\n        return output;\n    }\n    function unused() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/99.sol:1:142:\n  |\n1 |  ... ddress) {         address output = address(quantity);         return output;     }      ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverNine {\n    function fetch(uint number) public pure returns (address) {\n        address addr = address(number);\n        return addr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/100.sol:1:135:\n  |\n1 |  ... (address) {         address addr = address(number);         return addr;     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ResolverTen {\n    function derive(uint param) public pure returns (address) {\n        address addressVar = address(param);\n        return addressVar;\n    }\n    function methodOne() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/101.sol:1:140:\n  |\n1 |  ... ss) {         address addressVar = address(param);         return addressVar;     }  ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ResolverOne {\n    function modify(uint index) public pure returns (address) {\n        address result = address(uint160(index));\n        return result;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ResolverTwo {\n    function shift(uint data) public pure returns (address) {\n        address addr = address(uint160(data));\n        return addr;\n    }\n    function helperFunction() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ResolverThree {\n    function update(uint num) public pure returns (address) {\n        address addr = address(uint160(num));\n        return addr;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ResolverFour {\n    function calculate(uint input) public pure returns (address) {\n        address variable = address(uint160(input));\n        return variable;\n    }\n    function extraMethod() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ResolverFive {\n    function process(uint value) public pure returns (address) {\n        address addr = address(uint160(value));\n        return addr;\n    }\n    function anotherExtra() public pure {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ResolverSix {\n    function convert(uint data) public pure returns (address) {\n        address resultAddr = address(uint160(data));\n        return resultAddr;\n    }\n    function additionalMethod() public pure {}\n    function extraHelper() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ResolverSeven {\n    function transmit(uint amount) public pure returns (address) {\n        address result = address(uint160(amount));\n        return result;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ResolverEight {\n    function deliver(uint quantity) public pure returns (address) {\n        address output = address(uint160(quantity));\n        return output;\n    }\n    function unused() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ResolverNine {\n    function fetch(uint number) public pure returns (address) {\n        address addr = address(uint160(number));\n        return addr;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ResolverTen {\n    function derive(uint param) public pure returns (address) {\n        address addressVar = address(uint160(param));\n        return addressVar;\n    }\n    function methodOne() public pure {}\n}"
      }
    }
  },
  {
    "Changes110": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Function call options can only be given once, i.e. <code>c.f{gas: 10000}{value: 1}()</code> is invalid and has to be changed to <code>c.f{gas: 10000, value: 1}()</code>.Combine <code>c.f{gas: 10000}{value: 1}()</code> to <code>c.f{gas: 10000, value: 1}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract FundingAllocation {\n    address payable public fundsAllocator;\n    function allocateFunds() public {\n        fundsAllocator.call{gas: 3000}{value: 2 ether}(\"\");\n    }\n    function validateAllocation() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/102.sol:1:142:\n  |\n1 |  ... n allocateFunds() public {         fundsAllocator.call{gas: 3000}{value: 2 ether}(\"\");     }     function validateAl ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract LoanIssuer {\n    address payable public issuer;\n    function issueLoan() public {\n        issuer.call{gas: 4000}{value: 5 ether}(\"\");\n    }\n    function recordIssuance() public {}\n    function loanSummary() public pure returns (string memory) {\n        return \"Loan Issued\";\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/103.sol:1:123:\n  |\n1 |  ... ction issueLoan() public {         issuer.call{gas: 4000}{value: 5 ether}(\"\");     }     function recordIssu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceManagement {\n    address payable public manager;\n    function manageResources() public {\n        manager.call{gas: 2500}{value: 1 ether}(\"\");\n    }\n    function reportStatus() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/104.sol:1:138:\n  |\n1 |  ... manageResources() public {         manager.call{gas: 2500}{value: 1 ether}(\"\");     }     function reportStat ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract InvestmentPortfolio {\n    address payable public portfolioManager;\n    function managePortfolio() public {\n        portfolioManager.call{gas: 5000}{value: 6 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/105.sol:1:148:\n  |\n1 |  ... managePortfolio() public {         portfolioManager.call{gas: 5000}{value: 6 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract DonationPlatform {\n    address payable public charity;\n    function sendDonation() public {\n        charity.call{gas: 3500}{value: 3 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/106.sol:1:133:\n  |\n1 |  ... on sendDonation() public {         charity.call{gas: 3500}{value: 3 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract RiskAssessment {\n    address payable public assessor;\n    function assessRisk() public {\n        assessor.call{gas: 5500}{value: 4 ether}(\"\");\n    }\n    function getRiskLevel() public pure returns (uint) {\n        return 5;\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/107.sol:1:130:\n  |\n1 |  ... tion assessRisk() public {         assessor.call{gas: 5500}{value: 4 ether}(\"\");     }     function getRiskLev ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract WealthDistribution {\n    address payable public distributor;\n    function distributeWealth() public {\n        distributor.call{gas: 6000}{value: 2.5 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/108.sol:1:143:\n  |\n1 |  ... istributeWealth() public {         distributor.call{gas: 6000}{value: 2.5 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract TalentFund {\n    address payable public talent;\n    function fundTalent() public {\n        talent.call{gas: 4500}{value: 1 ether}(\"\");\n    }\n    function monitorFunds() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/109.sol:1:124:\n  |\n1 |  ... tion fundTalent() public {         talent.call{gas: 4500}{value: 1 ether}(\"\");     }     function monitorFun ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    address payable public processor;\n    function processPayment() public {\n        processor.call{gas: 7000}{value: 5 ether}(\"\");\n    }\n    function finalizeProcess() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/110.sol:1:137:\n  |\n1 |  ...  processPayment() public {         processor.call{gas: 7000}{value: 5 ether}(\"\");     }     function finalizePr ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract EmergencyFund {\n    address payable public emergency;\n    function releaseFunds() public {\n        emergency.call{gas: 8000}{value: 7 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/111.sol:1:132:\n  |\n1 |  ... on releaseFunds() public {         emergency.call{gas: 8000}{value: 7 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract FundingAllocation {\n    address payable public fundsAllocator;\n    function allocateFunds() public {\n        fundsAllocator.call{gas: 3000, value: 2 ether}(\"\");\n    }\n    function validateAllocation() public {}\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract LoanIssuer {\n    address payable public issuer;\n    function issueLoan() public {\n        issuer.call{gas: 4000, value: 5 ether}(\"\");\n    }\n    function recordIssuance() public {}\n    function loanSummary() public pure returns (string memory) {\n        return \"Loan Issued\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ResourceManagement {\n    address payable public manager;\n    function manageResources() public {\n        manager.call{gas: 2500, value: 1 ether}(\"\");\n    }\n    function reportStatus() public {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract InvestmentPortfolio {\n    address payable public portfolioManager;\n    function managePortfolio() public {\n        portfolioManager.call{gas: 5000, value: 6 ether}(\"\");\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract DonationPlatform {\n    address payable public charity;\n    function sendDonation() public {\n        charity.call{gas: 3500, value: 3 ether}(\"\");\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract RiskAssessment {\n    address payable public assessor;\n    function assessRisk() public {\n        assessor.call{gas: 5500, value: 4 ether}(\"\");\n    }\n    function getRiskLevel() public pure returns (uint) {\n        return 5;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract WealthDistribution {\n    address payable public distributor;\n    function distributeWealth() public {\n        distributor.call{gas: 6000, value: 2.5 ether}(\"\");\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract TalentFund {\n    address payable public talent;\n    function fundTalent() public {\n        talent.call{gas: 4500, value: 1 ether}(\"\");\n    }\n    function monitorFunds() public {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract PaymentProcessor {\n    address payable public processor;\n    function processPayment() public {\n        processor.call{gas: 7000, value: 5 ether}(\"\");\n    }\n    function finalizeProcess() public {}\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract EmergencyFund {\n    address payable public emergency;\n    function releaseFunds() public {\n        emergency.call{gas: 8000, value: 7 ether}(\"\");\n    }\n}"
      }
    }
  },
  {
    "Changes111": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The global functions <code>log0</code>, <code>log1</code>, <code>log2</code>, <code>log3</code> and <code>log4</code> have been removed.Use inline assembly as a replacement for <code>log0</code>, \u2026, <code>log4</code>.13.These are low-level functions that were largely unused. Their behavior can be accessed from inline assembly.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract SignalLogger {\n    function logSignal(uint256 signalValue) public {\n        bytes memory signalBytes = abi.encodePacked(signalValue);\n        assembly {\n            log0(signalBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/112.sol:1:198:\n  |\n1 |  ... e);         assembly {             log0(signalBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ReviewTracker {\n    function trackReview(int256 reviewScore) public {\n        bytes memory reviewData = abi.encodePacked(reviewScore);\n        assembly {\n            log1(reviewData, reviewScore)\n        }\n    }\n    function additionalMethod() public pure returns (uint) { return 100; }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/113.sol:1:199:\n  |\n1 |  ... e);         assembly {             log1(reviewData, reviewScore)         } ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract QueryLogger {\n    function logQuery(bytes32 queryHash) public {\n        assembly {\n            log4(queryHash, queryHash, queryHash, queryHash, queryHash)\n        }\n    }\n    function helper() public pure {}\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/114.sol:1:128:\n  |\n1 |  ... c {         assembly {             log4(queryHash, queryHash, queryHash, q ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ActivityTracker {\n    function trackActivity(uint256 activityCode) public {\n        bytes memory activityData = abi.encodePacked(activityCode);\n        assembly {\n            log3(activityData, activityCode, activityCode, activityCode)\n        }\n    }\n}",
          "error message": "Error: Function expects 5 arguments but got 4.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/115.sol:1:208:\n  |\n1 |  ... e);         assembly {             log3(activityData, activityCode, activi ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ChallengeLogger {\n    function logChallenge(uint256 challengeId) public {\n        bytes memory challengeBytes = abi.encodePacked(challengeId);\n        assembly {\n            log2(challengeBytes, challengeId, challengeId)\n        }\n    }\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/116.sol:1:207:\n  |\n1 |  ... d);         assembly {             log2(challengeBytes, challengeId, chall ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IssueLogger {\n    function logIssue(uint256 issueNumber) public {\n        bytes memory issueBytes = abi.encodePacked(issueNumber);\n        assembly {\n            log0(issueBytes)\n        }\n    }\n    function anotherHelper() public pure {}\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/117.sol:1:195:\n  |\n1 |  ... r);         assembly {             log0(issueBytes)         }     }     fu ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract AlertRecorder {\n    function recordAlert(string memory alertText) public {\n        bytes memory alertBytes = bytes(alertText);\n        assembly {\n            log0(alertBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/118.sol:1:191:\n  |\n1 |  ... t);         assembly {             log0(alertBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract UpdateNotifier {\n    function notifyUpdate(uint256 updateTag) public {\n        bytes memory updateBytes = abi.encodePacked(updateTag);\n        assembly {\n            log1(updateBytes, updateTag)\n        }\n    }\n    function extraFeature() public pure {}\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/119.sol:1:199:\n  |\n1 |  ... g);         assembly {             log1(updateBytes, updateTag)         }  ...\n  |                                         ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract FeedbackTracker {\n    function trackFeedback(uint256 feedbackNumber) public {\n        bytes memory feedbackBytes = abi.encodePacked(feedbackNumber);\n        assembly {\n            log2(feedbackBytes, feedbackNumber, feedbackNumber)\n        }\n    }\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/120.sol:1:213:\n  |\n1 |  ... r);         assembly {             log2(feedbackBytes, feedbackNumber, fee ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract NotificationDispatcher {\n    function dispatchNotification(string memory notificationMessage) public {\n        bytes memory notificationBytes = bytes(notificationMessage);\n        assembly {\n            log1(notificationBytes, notificationMessage)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/121.sol:1:236:\n  |\n1 |  ... e);         assembly {             log1(notificationBytes, notificationMes ...\n  |                                         ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract SignalLogger {\n    event SignalLogged(uint256 signalValue);\n    function logSignal(uint256 signalValue) public {\n        emit SignalLogged(signalValue);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ReviewTracker {\n    event ReviewTracked(int256 reviewScore);\n    function trackReview(int256 reviewScore) public {\n        emit ReviewTracked(reviewScore);\n    }\n    function additionalMethod() public pure returns (uint) { return 100; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract QueryLogger {\n    event QueryLogged(bytes32 queryHash);\n    function logQuery(bytes32 queryHash) public {\n        emit QueryLogged(queryHash);\n    }\n    function helper() public pure {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ActivityTracker {\n    event ActivityTracked(uint256 activityCode);\n    function trackActivity(uint256 activityCode) public {\n        emit ActivityTracked(activityCode);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ChallengeLogger {\n    event ChallengeLogged(uint256 challengeId);\n    function logChallenge(uint256 challengeId) public {\n        emit ChallengeLogged(challengeId);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IssueLogger {\n    event IssueLogged(uint256 issueNumber);\n    function logIssue(uint256 issueNumber) public {\n        emit IssueLogged(issueNumber);\n    }\n    function anotherHelper() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract AlertRecorder {\n    event AlertRecorded(string alertText);\n    function recordAlert(string memory alertText) public {\n        emit AlertRecorded(alertText);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract UpdateNotifier {\n    event UpdateNotified(uint256 updateTag);\n    function notifyUpdate(uint256 updateTag) public {\n        emit UpdateNotified(updateTag);\n    }\n    function extraFeature() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract FeedbackTracker {\n    event FeedbackTracked(uint256 feedbackNumber);\n    function trackFeedback(uint256 feedbackNumber) public {\n        emit FeedbackTracked(feedbackNumber);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract NotificationDispatcher {\n    event NotificationDispatched(string notificationMessage);\n    function dispatchNotification(string memory notificationMessage) public {\n        emit NotificationDispatched(notificationMessage);\n    }\n}"
      }
    }
  },
  {
    "Changes112": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Declarations with the name <code>this</code>, <code>super</code> and <code>_</code> are disallowed, with the exception of\npublic functions and events. The exception is to make it possible to declare interfaces of contracts\nimplemented in languages other than Solidity that do permit such function names.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorOne {\n    uint256 public super;\n\n    function updateSuper(uint256 val) public {\n        super = val;\n    }\n\n    function extraOne() public pure returns (uint256) {\n        return 10;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/122.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract ErrorOne {     uint256 public super;      function updateSuper(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorTwo {\n    string public this;\n\n    function setThis(string calldata val) public {\n        this = val;\n    }\n\n    function extraTwo() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/123.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract ErrorTwo {     string public this;      function setThis(string call ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorThree {\n    bool public _;\n\n    function toggle_() public {\n        _ = !_;\n    }\n\n    function extraThree() public pure returns (string memory) {\n        return \"toggle\";\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/124.sol:1:51:\n  |\n1 |  ... ^0.8.0;  contract ErrorThree {     bool public _;      function toggle_() public {  ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorFour {\n    uint256 public this;\n\n    function modifyThis(uint256 newValue) public {\n        this = newValue;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/125.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ErrorFour {     uint256 public this;      function modifyThis(uint256  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorFive {\n    bytes32 public super;\n\n    function changeSuper(bytes32 newVal) public {\n        super = newVal;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/126.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ErrorFive {     bytes32 public super;      function changeSuper(bytes32 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorSix {\n    uint256 public _;\n\n    function increment_() public {\n        _ += 1;\n    }\n\n    function extraSix() public pure returns (uint256) {\n        return _;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/127.sol:1:49:\n  |\n1 |  ... ty^0.8.0;  contract ErrorSix {     uint256 public _;      function increment_() public ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorSeven {\n    address public this;\n\n    function updateThis(address newVal) public {\n        this = newVal;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/128.sol:1:51:\n  |\n1 |  ... ^0.8.0;  contract ErrorSeven {     address public this;      function updateThis(address  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorEight {\n    int256 public super;\n\n    function decrementSuper(int256 decrementValue) public {\n        super -= decrementValue;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/129.sol:1:51:\n  |\n1 |  ... ^0.8.0;  contract ErrorEight {     int256 public super;      function decrementSuper(int2 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorNine {\n    uint256 public this;\n\n    function refreshThis(uint256 value) public {\n        this = value;\n    }\n\n    function extraNine() public pure returns (uint256) {\n        return 100;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/130.sol:1:50:\n  |\n1 |  ... y^0.8.0;  contract ErrorNine {     uint256 public this;      function refreshThis(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ErrorTen {\n    string public _;\n\n    function set_(string calldata newVal) public {\n        _ = newVal;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/131.sol:1:49:\n  |\n1 | pragma solidity^0.8.0;  contract ErrorTen {     string public _;      function set_(string calldata newVal) public {         _ = newVal;     } }\n  |                                                 ^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract FixedOne {\n    uint256 public value;\n\n    function updateValue(uint256 val) public {\n        value = val;\n    }\n\n    function extraOne() public pure returns (uint256) {\n        return 10;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract FixedTwo {\n    string public variable;\n\n    function setVariable(string calldata val) public {\n        variable = val;\n    }\n\n    function extraTwo() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract FixedThree {\n    bool public state;\n\n    function toggleState() public {\n        state = !state;\n    }\n\n    function extraThree() public pure returns (string memory) {\n        return \"toggle\";\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract FixedFour {\n    uint256 public value;\n\n    function modifyValue(uint256 newValue) public {\n        value = newValue;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract FixedFive {\n    bytes32 public value;\n\n    function changeValue(bytes32 newVal) public {\n        value = newVal;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract FixedSix {\n    uint256 public value;\n\n    function incrementValue() public {\n        value += 1;\n    }\n\n    function extraSix() public pure returns (uint256) {\n        return value;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract FixedSeven {\n    address public addressValue;\n\n    function updateAddress(address newVal) public {\n        addressValue = newVal;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract FixedEight {\n    int256 public value;\n\n    function decrementValue(int256 decrementValue) public {\n        value -= decrementValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract FixedNine {\n    uint256 public value;\n\n    function refreshValue(uint256 newVal) public {\n        value = newVal;\n    }\n\n    function extraNine() public pure returns (uint256) {\n        return 100;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract FixedTen {\n    string public value;\n\n    function setValue(string calldata newVal) public {\n        value = newVal;\n    }\n}"
      }
    }
  },
  {
    "Changes113": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Remove support for the <code>b</code>, <code>f</code>, and <code>v</code> escape sequences in code.\nThey can still be inserted via hexadecimal escapes, e.g. <code>x08</code>, <code>x0c</code>, and <code>x0b</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharOne {\n    string public sequenceOne = \"Invalid sequence: \\b\";\n    function getSequenceOne() public view returns (string memory) {\n        return sequenceOne;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/132.sol:1:82:\n  |\n1 |  ...  {     string public sequenceOne = \"Invalid sequence: \\b\";     function getSequenceOne() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharTwo {\n    string public sequenceTwo = \"Invalid sequence: \\f\";\n    function getSequenceTwo() public view returns (string memory) {\n        return sequenceTwo;\n    }\n    function randomExtra() public pure returns (int) {\n        return 22;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/133.sol:1:82:\n  |\n1 |  ...  {     string public sequenceTwo = \"Invalid sequence: \\f\";     function getSequenceTwo() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharThree {\n    string public sequenceThree = \"Invalid sequence: \\v\";\n    function getSequenceThree() public view returns (string memory) {\n        return sequenceThree;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/134.sol:1:86:\n  |\n1 |  ...      string public sequenceThree = \"Invalid sequence: \\v\";     function getSequenceThree()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharFour {\n    string public sequenceFour = \"Invalid sequence: \\b\";\n    function getSequenceFour() public view returns (string memory) {\n        return sequenceFour;\n    }\n    function unusedFunction() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/135.sol:1:84:\n  |\n1 |  ... {     string public sequenceFour = \"Invalid sequence: \\b\";     function getSequenceFour() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharFive {\n    string public sequenceFive = \"Invalid sequence: \\v\";\n    function getSequenceFive() public view returns (string memory) {\n        return sequenceFive;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/136.sol:1:84:\n  |\n1 |  ... {     string public sequenceFive = \"Invalid sequence: \\v\";     function getSequenceFive() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharSix {\n    string public sequenceSix = \"Invalid sequence: \\f\";\n    function getSequenceSix() public view returns (string memory) {\n        return sequenceSix;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/137.sol:1:82:\n  |\n1 |  ...  {     string public sequenceSix = \"Invalid sequence: \\f\";     function getSequenceSix() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharSeven {\n    string public sequenceSeven = \"Invalid sequence: \\b\";\n    function getSequenceSeven() public view returns (string memory) {\n        return sequenceSeven;\n    }\n    function helperFunction() public pure returns (uint) {\n        return 777;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/138.sol:1:86:\n  |\n1 |  ...      string public sequenceSeven = \"Invalid sequence: \\b\";     function getSequenceSeven()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharEight {\n    string public sequenceEight = \"Invalid sequence: \\v\";\n    function getSequenceEight() public view returns (string memory) {\n        return sequenceEight;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/139.sol:1:86:\n  |\n1 |  ...      string public sequenceEight = \"Invalid sequence: \\v\";     function getSequenceEight()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharNine {\n    string public sequenceNine = \"Invalid sequence: \\f\";\n    function getSequenceNine() public view returns (string memory) {\n        return sequenceNine;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/140.sol:1:84:\n  |\n1 |  ... {     string public sequenceNine = \"Invalid sequence: \\f\";     function getSequenceNine() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract InvalidCharTen {\n    string public sequenceTen = \"Invalid sequence: \\b\";\n    function getSequenceTen() public view returns (string memory) {\n        return sequenceTen;\n    }\n    function additionalMethod() public pure returns (string memory) {\n        return \"Additional content\";\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/141.sol:1:82:\n  |\n1 |  ...  {     string public sequenceTen = \"Invalid sequence: \\b\";     function getSequenceTen() pu ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract InvalidCharOne {\n    string public sequenceOne = \"Invalid sequence: \\x08\";\n    function getSequenceOne() public view returns (string memory) {\n        return sequenceOne;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract InvalidCharTwo {\n    string public sequenceTwo = \"Invalid sequence: \\x0c\";\n    function getSequenceTwo() public view returns (string memory) {\n        return sequenceTwo;\n    }\n    function randomExtra() public pure returns (int) {\n        return 22;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract InvalidCharThree {\n    string public sequenceThree = \"Invalid sequence: \\x0b\";\n    function getSequenceThree() public view returns (string memory) {\n        return sequenceThree;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract InvalidCharFour {\n    string public sequenceFour = \"Invalid sequence: \\x08\";\n    function getSequenceFour() public view returns (string memory) {\n        return sequenceFour;\n    }\n    function unusedFunction() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract InvalidCharFive {\n    string public sequenceFive = \"Invalid sequence: \\x0b\";\n    function getSequenceFive() public view returns (string memory) {\n        return sequenceFive;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract InvalidCharSix {\n    string public sequenceSix = \"Invalid sequence: \\x0c\";\n    function getSequenceSix() public view returns (string memory) {\n        return sequenceSix;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract InvalidCharSeven {\n    string public sequenceSeven = \"Invalid sequence: \\x08\";\n    function getSequenceSeven() public view returns (string memory) {\n        return sequenceSeven;\n    }\n    function helperFunction() public pure returns (uint) {\n        return 777;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract InvalidCharEight {\n    string public sequenceEight = \"Invalid sequence: \\x0b\";\n    function getSequenceEight() public view returns (string memory) {\n        return sequenceEight;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract InvalidCharNine {\n    string public sequenceNine = \"Invalid sequence: \\x0c\";\n    function getSequenceNine() public view returns (string memory) {\n        return sequenceNine;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract InvalidCharTen {\n    string public sequenceTen = \"Invalid sequence: \\x08\";\n    function getSequenceTen() public view returns (string memory) {\n        return sequenceTen;\n    }\n    function additionalMethod() public pure returns (string memory) {\n        return \"Additional content\";\n    }\n}"
      }
    }
  },
  {
    "Changes114": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The global variables <code>tx.origin</code> and <code>msg.sender</code> have the type <code>address</code> instead of\n<code>address payable</code>. One can convert them into <code>address payable</code> by using an explicit\nconversion, i.e., <code>payable(tx.origin)</code> or <code>payable(msg.sender)</code>.This change was done since the compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible.Change <code>msg.sender.transfer(x)</code> to <code>payable(msg.sender).transfer(x)</code> or use a stored variable of <code>address payable</code> type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract AssetAllocator {\n    function allocateAsset() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/142.sol:1:104:\n  |\n1 | pragma solidity^0.8.0; contract AssetAllocator {     function allocateAsset() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                        ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueDistributor {\n    function distributeRevenue() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function extraProcess() public pure returns (int) { return 100; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/143.sol:1:112:\n  |\n1 |  ... Revenue() public payable {         msg.sender.transfer(msg.value);     }     function ext ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ExpenseRefunder {\n    function refundExpense() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function helper() public pure returns (string memory) { return \"Helper\"; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/144.sol:1:105:\n  |\n1 |  ... Expense() public payable {         msg.sender.transfer(msg.value);     }     function hel ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract BonusPayer {\n    function payBonus() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/145.sol:1:95:\n  |\n1 | pragma solidity^0.8.0; contract BonusPayer {     function payBonus() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                               ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ProfitHandler {\n    function handleProfit() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function doSomething() public pure returns (bool) { return true; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/146.sol:1:102:\n  |\n1 |  ... eProfit() public payable {         msg.sender.transfer(msg.value);     }     function doS ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract DonationCollector {\n    function collectDonation() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/147.sol:1:109:\n  |\n1 | pragma solidity^0.8.0; contract DonationCollector {     function collectDonation() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                             ^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract StipendIssuer {\n    function issueStipend() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/148.sol:1:102:\n  |\n1 | pragma solidity^0.8.0; contract StipendIssuer {     function issueStipend() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                      ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract RewardDisburser {\n    function disburseReward() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function additionalFeature() public pure {}\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/149.sol:1:106:\n  |\n1 |  ... eReward() public payable {         msg.sender.transfer(msg.value);     }     function add ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ScholarshipDistributor {\n    function distributeScholarship() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/150.sol:1:120:\n  |\n1 |  ... larship() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentHandler {\n    function handlePayment() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function utilityFunction() public pure returns (uint) { return 777; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/151.sol:1:104:\n  |\n1 |  ... Payment() public payable {         msg.sender.transfer(msg.value);     }     function uti ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract AssetAllocator {\n    function allocateAsset() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract RevenueDistributor {\n    function distributeRevenue() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function extraProcess() public pure returns (int) { return 100; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ExpenseRefunder {\n    function refundExpense() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function helper() public pure returns (string memory) { return \"Helper\"; }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract BonusPayer {\n    function payBonus() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ProfitHandler {\n    function handleProfit() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function doSomething() public pure returns (bool) { return true; }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract DonationCollector {\n    function collectDonation() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract StipendIssuer {\n    function issueStipend() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract RewardDisburser {\n    function disburseReward() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function additionalFeature() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ScholarshipDistributor {\n    function distributeScholarship() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract PaymentHandler {\n    function handlePayment() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function utilityFunction() public pure returns (uint) { return 777; }\n}"
      }
    }
  },
  {
    "Changes115": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The <code>chainid</code> builtin in inline assembly is now considered <code>view</code> instead of <code>pure</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainInterface {\n    function interfaceChain() public pure returns (uint256) {\n        uint256 cID;\n        assembly {\n            cID := chainid\n        }\n        return cID;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/152.sol:1:172:\n  |\n1 |  ...      assembly {             cID := chainid         }         return cID;      ...\n  |                                         ^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkPortal {\n    function portalNetwork() public pure returns (uint256) {\n        uint256 netID;\n        assembly {\n            netID := chainid\n        }\n        return netID;\n    }\n    function randomOne() public pure returns (uint256) { return 301; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/153.sol:1:174:\n  |\n1 |  ...    assembly {             netID := chainid         }         return netID;    ...\n  |                                         ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainRegistry {\n    function registryChain() public pure returns (uint256) {\n        uint256 registry;\n        assembly {\n            registry := chainid\n        }\n        return registry;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/154.sol:1:180:\n  |\n1 |  ... assembly {             registry := chainid         }         return registry; ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkCore {\n    function coreNetwork() public pure returns (uint256) {\n        uint256 coreID;\n        assembly {\n            coreID := chainid\n        }\n        return coreID;\n    }\n    function helperA() public pure returns (uint256) { return 505; }\n    function helperB() public pure returns (uint256) { return 506; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/155.sol:1:172:\n  |\n1 |  ...   assembly {             coreID := chainid         }         return coreID;   ...\n  |                                         ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainControl {\n    function controlChain() public pure returns (uint256) {\n        uint256 control;\n        assembly {\n            control := chainid\n        }\n        return control;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/156.sol:1:176:\n  |\n1 |  ...  assembly {             control := chainid         }         return control;  ...\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainMechanism {\n    function mechanismChain() public pure returns (uint256) {\n        uint256 mechanism;\n        assembly {\n            mechanism := chainid\n        }\n        return mechanism;\n    }\n    function extraA() public pure returns (uint256) { return 707; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/157.sol:1:184:\n  |\n1 |  ... ssembly {             mechanism := chainid         }         return mechanism ...\n  |                                         ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkInterface {\n    function interfaceNetwork() public pure returns (uint256) {\n        uint256 iface;\n        assembly {\n            iface := chainid\n        }\n        return iface;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/158.sol:1:180:\n  |\n1 |  ...    assembly {             iface := chainid         }         return iface;    ...\n  |                                         ^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainSystem {\n    function systemChain() public pure returns (uint256) {\n        uint256 system;\n        assembly {\n            system := chainid\n        }\n        return system;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/159.sol:1:172:\n  |\n1 |  ...   assembly {             system := chainid         }         return system;   ...\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ChainOperation {\n    function operationChain() public pure returns (uint256) {\n        uint256 operation;\n        assembly {\n            operation := chainid\n        }\n        return operation;\n    }\n    function unrelatedA() public pure returns (uint256) { return 809; }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/160.sol:1:184:\n  |\n1 |  ... ssembly {             operation := chainid         }         return operation ...\n  |                                         ^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract NetworkSignal {\n    function signalNetwork() public pure returns (uint256) {\n        uint256 signal;\n        assembly {\n            signal := chainid\n        }\n        return signal;\n    }\n}",
          "error message": "Error: Builtin function \"chainid\" must be called.\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/161.sol:1:176:\n  |\n1 |  ...   assembly {             signal := chainid         }         return signal;   ...\n  |                                         ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ChainInterface {\n    function interfaceChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract NetworkPortal {\n    function portalNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n    function randomOne() public pure returns (uint256) { return 301; }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ChainRegistry {\n    function registryChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract NetworkCore {\n    function coreNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n    function helperA() public pure returns (uint256) { return 505; }\n    function helperB() public pure returns (uint256) { return 506; }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ChainControl {\n    function controlChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ChainMechanism {\n    function mechanismChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function extraA() public pure returns (uint256) { return 707; }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract NetworkInterface {\n    function interfaceNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ChainSystem {\n    function systemChain() public view returns (uint256) {\n        return block.chainid;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ChainOperation {\n    function operationChain() public view returns (uint256) {\n        return block.chainid;\n    }\n    function unrelatedA() public pure returns (uint256) { return 809; }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract NetworkSignal {\n    function signalNetwork() public view returns (uint256) {\n        return block.chainid;\n    }\n}"
      }
    }
  },
  {
    "Changes116": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Unary negation cannot be used on unsigned integers anymore, only on signed integers.Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. <code>type(uint256).max - x + 1</code>, while ensuring that <code>x</code> is not zero)",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueFlipper {\n    function flipValue(uint param1) public pure returns (uint) {\n        return -param1;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/162.sol:1:128:\n  |\n1 | pragma solidity^0.8.0; contract ValueFlipper {     function flipValue(uint param1) public pure returns (uint) {         return -param1;     } }\n  |                                                                                                                                ^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ReverseLogic {\n    function reverse(uint param2) public pure returns (uint) {\n        return -param2;\n    }\n    function doSomething() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/163.sol:1:126:\n  |\n1 |  ... re returns (uint) {         return -param2;     }     function doSomething()  ...\n  |                                         ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract NumberNegator {\n    function negateNumber(uint param3) public pure returns (uint) {\n        return -param3;\n    }\n    function extraHelper() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/164.sol:1:132:\n  |\n1 |  ... re returns (uint) {         return -param3;     }     function extraHelper()  ...\n  |                                         ^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ValueInverter {\n    function invert(uint param4) public pure returns (uint) {\n        return -param4;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/165.sol:1:126:\n  |\n1 | pragma solidity^0.8.0; contract ValueInverter {     function invert(uint param4) public pure returns (uint) {         return -param4;     } }\n  |                                                                                                                              ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract UnsignedSubtractor {\n    function subtractFrom(uint param5) public pure returns (uint) {\n        return -param5;\n    }\n    function anotherExtra() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/166.sol:1:137:\n  |\n1 |  ... re returns (uint) {         return -param5;     }     function anotherExtra() ...\n  |                                         ^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract DirectNegation {\n    function directlyNegate(uint param6) public pure returns (uint) {\n        return -param6;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/167.sol:1:135:\n  |\n1 | pragma solidity^0.8.0; contract DirectNegation {     function directlyNegate(uint param6) public pure returns (uint) {         return -param6;     } }\n  |                                                                                                                                       ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract OppositeGenerator {\n    function generateOpposite(uint param7) public pure returns (uint) {\n        return -param7;\n    }\n    function unusedFunc() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/168.sol:1:140:\n  |\n1 |  ... re returns (uint) {         return -param7;     }     function unusedFunc() p ...\n  |                                         ^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract NegativeReturner {\n    function returnNegative(uint param8) public pure returns (uint) {\n        return -param8;\n    }\n    function simpleTask() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/169.sol:1:137:\n  |\n1 |  ... re returns (uint) {         return -param8;     }     function simpleTask() p ...\n  |                                         ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ZeroSubtractor {\n    function subtractZero(uint param9) public pure returns (uint) {\n        return -param9;\n    }\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/170.sol:1:133:\n  |\n1 | pragma solidity^0.8.0; contract ZeroSubtractor {     function subtractZero(uint param9) public pure returns (uint) {         return -param9;     } }\n  |                                                                                                                                     ^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract NegateValue {\n    function negate(uint param10) public pure returns (uint) {\n        return -param10;\n    }\n    function someFunction() public pure {}\n    function someOtherFunction() public pure {}\n}",
          "error message": "Error: Unary operator - cannot be applied to type uint256\n --> ./0.8/0.7-0.8/0.7-0.8-test-error/171.sol:1:125:\n  |\n1 |  ... re returns (uint) {         return -param10;     }     function someFunction() ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ValueFlipper {\n    function flipValue(uint param1) public pure returns (uint) {\n        return type(uint).max - param1 + 1;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ReverseLogic {\n    function reverse(uint param2) public pure returns (uint) {\n        return type(uint).max - param2 + 1;\n    }\n    function doSomething() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract NumberNegator {\n    function negateNumber(uint param3) public pure returns (uint) {\n        return type(uint).max - param3 + 1;\n    }\n    function extraHelper() public pure {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ValueInverter {\n    function invert(uint param4) public pure returns (uint) {\n        return type(uint).max - param4 + 1;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract UnsignedSubtractor {\n    function subtractFrom(uint param5) public pure returns (uint) {\n        return type(uint).max - param5 + 1;\n    }\n    function anotherExtra() public pure {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract DirectNegation {\n    function directlyNegate(uint param6) public pure returns (uint) {\n        return type(uint).max - param6 + 1;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract OppositeGenerator {\n    function generateOpposite(uint param7) public pure returns (uint) {\n        return type(uint).max - param7 + 1;\n    }\n    function unusedFunc() public pure {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract NegativeReturner {\n    function returnNegative(uint param8) public pure returns (uint) {\n        return type(uint).max - param8 + 1;\n    }\n    function simpleTask() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ZeroSubtractor {\n    function subtractZero(uint param9) public pure returns (uint) {\n        return type(uint).max - param9 + 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract NegateValue {\n    function negate(uint param10) public pure returns (uint) {\n        return type(uint).max - param10 + 1;\n    }\n    function someFunction() public pure {}\n    function someOtherFunction() public pure {}\n}"
      }
    }
  },
  {
    "Changes117": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractU {\n    byte itemU;\n    function deployItemU(byte newValue) public {\n        itemU = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/2.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractU {     byte itemU;     function deployItemU(byte newValue) public {         itemU = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractV {\n    byte itemV;\n    function saveItemV(byte newValue) public {\n        itemV = newValue;\n    }\n    function additionalFunctionV() public pure returns (uint) {\n        return 2024;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/3.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractV {     byte itemV;     function saveItemV(byte ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractW {\n    byte itemW;\n    function updateItemW(byte newValue) public {\n        itemW = newValue;\n    }\n    function extraFunctionW1() public pure returns (bool) {\n        return false;\n    }\n    function extraFunctionW2() public pure returns (uint) {\n        return 256;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/4.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractW {     byte itemW;     function updateItemW(by ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractX {\n    byte itemX;\n    function modifyItemX(byte newValue) public {\n        itemX = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/5.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractX {     byte itemX;     function modifyItemX(byte newValue) public {         itemX = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractY {\n    byte itemY;\n    function setItemY(byte newValue) public {\n        itemY = newValue;\n    }\n    function dummyFunctionY() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/6.sol:1:49:\n  |\n1 |  ... ty^0.8.0; contract ContractY {     byte itemY;     function setItemY(byte  ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractZ {\n    byte itemZ;\n    function adjustItemZ(byte newValue) public {\n        itemZ = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/7.sol:1:49:\n  |\n1 | pragma solidity^0.8.0; contract ContractZ {     byte itemZ;     function adjustItemZ(byte newValue) public {         itemZ = newValue;     } }\n  |                                                 ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractAA {\n    byte itemAA;\n    function changeItemAA(byte newValue) public {\n        itemAA = newValue;\n    }\n    function helperFunctionAA() public pure returns (uint) {\n        return 88;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/8.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractAA {     byte itemAA;     function changeItemAA( ...\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractBB {\n    byte itemBB;\n    function shiftItemBB(byte newValue) public {\n        itemBB = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/9.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractBB {     byte itemBB;     function shiftItemBB(byte newValue) public {         itemBB = newValue;     } }\n  |                                                  ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractCC {\n    byte itemCC;\n    function replaceItemCC(byte newValue) public {\n        itemCC = newValue;\n    }\n    function randomFunctionCC() public pure returns (int) {\n        return -7;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/10.sol:1:50:\n  |\n1 |  ... y^0.8.0; contract ContractCC {     byte itemCC;     function replaceItemCC ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ContractDD {\n    byte itemDD;\n    function refreshItemDD(byte newValue) public {\n        itemDD = newValue;\n    }\n}",
          "error message": "Error: Function, variable, struct or modifier declaration expected.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/11.sol:1:50:\n  |\n1 | pragma solidity^0.8.0; contract ContractDD {     byte itemDD;     function refreshItemDD(byte newValue) public {         itemDD = newValue;     } }\n  |                                                  ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ContractU {\n    bytes1 itemU;\n    function deployItemU(bytes1 newValue) public {\n        itemU = newValue;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ContractV {\n    bytes1 itemV;\n    function saveItemV(bytes1 newValue) public {\n        itemV = newValue;\n    }\n    function additionalFunctionV() public pure returns (uint) {\n        return 2024;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ContractW {\n    bytes1 itemW;\n    function updateItemW(bytes1 newValue) public {\n        itemW = newValue;\n    }\n    function extraFunctionW1() public pure returns (bool) {\n        return false;\n    }\n    function extraFunctionW2() public pure returns (uint) {\n        return 256;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ContractX {\n    bytes1 itemX;\n    function modifyItemX(bytes1 newValue) public {\n        itemX = newValue;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ContractY {\n    bytes1 itemY;\n    function setItemY(bytes1 newValue) public {\n        itemY = newValue;\n    }\n    function dummyFunctionY() public pure returns (string memory) {\n        return \"Extra\";\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ContractZ {\n    bytes1 itemZ;\n    function adjustItemZ(bytes1 newValue) public {\n        itemZ = newValue;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ContractAA {\n    bytes1 itemAA;\n    function changeItemAA(bytes1 newValue) public {\n        itemAA = newValue;\n    }\n    function helperFunctionAA() public pure returns (uint) {\n        return 88;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ContractBB {\n    bytes1 itemBB;\n    function shiftItemBB(bytes1 newValue) public {\n        itemBB = newValue;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ContractCC {\n    bytes1 itemCC;\n    function replaceItemCC(bytes1 newValue) public {\n        itemCC = newValue;\n    }\n    function randomFunctionCC() public pure returns (int) {\n        return -7;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ContractDD {\n    bytes1 itemDD;\n    function refreshItemDD(bytes1 newValue) public {\n        itemDD = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes118": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions from negative literals and literals larger than <code>type(uint160).max</code> to\n<code>address</code> are disallowed.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyOne {\n    function castNegativeOne() public pure returns (address) {\n        int exampleOne = -21;\n        return address(uint160(exampleOne));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/12.sol:1:170:\n  |\n1 |  ... eOne = -21;         return address(uint160(exampleOne));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyTwo {\n    function extractNegative() public pure returns (address) {\n        int exampleTwo = -22;\n        return address(uint160(exampleTwo));\n    }\n    function simpleAdd() public pure returns (uint) {\n        return 22;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/13.sol:1:170:\n  |\n1 |  ... eTwo = -22;         return address(uint160(exampleTwo));     }     function simpleAdd() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyThree {\n    function negativeToAddr() public pure returns (address) {\n        int exampleThree = -23;\n        return address(uint160(exampleThree));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/14.sol:1:173:\n  |\n1 |  ... hree = -23;         return address(uint160(exampleThree));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyFour {\n    function processNegInt() public pure returns (address) {\n        int exampleFour = -24;\n        return address(uint160(exampleFour));\n    }\n    function reportState() public pure returns (string memory) {\n        return \"Active\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/15.sol:1:170:\n  |\n1 |  ... Four = -24;         return address(uint160(exampleFour));     }     function reportState() ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyFive {\n    function convertNegToAddress() public pure returns (address) {\n        int exampleFive = -25;\n        return address(uint160(exampleFive));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/16.sol:1:176:\n  |\n1 |  ... Five = -25;         return address(uint160(exampleFive));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentySix {\n    function shiftToInt() public pure returns (address) {\n        int exampleSix = -26;\n        return address(uint160(exampleSix));\n    }\n    function getStatus() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/17.sol:1:165:\n  |\n1 |  ... eSix = -26;         return address(uint160(exampleSix));     }     function getStatus() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentySeven {\n    function transformToAddress() public pure returns (address) {\n        int exampleSeven = -27;\n        return address(uint160(exampleSeven));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/18.sol:1:177:\n  |\n1 |  ... even = -27;         return address(uint160(exampleSeven));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyEight {\n    function makeAddressFromNeg() public pure returns (address) {\n        int exampleEight = -28;\n        return address(uint160(exampleEight));\n    }\n    function getNumber() public pure returns (int) {\n        return 28;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/19.sol:1:177:\n  |\n1 |  ... ight = -28;         return address(uint160(exampleEight));     }     function getNumber() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyNine {\n    function convertIntToAddress() public pure returns (address) {\n        int exampleNine = -29;\n        return address(uint160(exampleNine));\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/20.sol:1:176:\n  |\n1 |  ... Nine = -29;         return address(uint160(exampleNine));     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ContractThirty {\n    function negativeIntegerToAddress() public pure returns (address) {\n        int exampleTen = -30;\n        return address(uint160(exampleTen));\n    }\n    function extraFunc() public pure returns (uint) {\n        return 30;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int256\" to \"uint160\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/21.sol:1:176:\n  |\n1 |  ... eTen = -30;         return address(uint160(exampleTen));     }     function extraFunc() p ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyOne {\n    function castNegativeOne() public pure returns (address) {\n        uint exampleOne = 21;\n        return address(uint160(exampleOne));\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyTwo {\n    function extractNegative() public pure returns (address) {\n        uint exampleTwo = 22;\n        return address(uint160(exampleTwo));\n    }\n    function simpleAdd() public pure returns (uint) {\n        return 22;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyThree {\n    function negativeToAddr() public pure returns (address) {\n        uint exampleThree = 23;\n        return address(uint160(exampleThree));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyFour {\n    function processNegInt() public pure returns (address) {\n        uint exampleFour = 24;\n        return address(uint160(exampleFour));\n    }\n    function reportState() public pure returns (string memory) {\n        return \"Active\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyFive {\n    function convertNegToAddress() public pure returns (address) {\n        uint exampleFive = 25;\n        return address(uint160(exampleFive));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ContractTwentySix {\n    function shiftToInt() public pure returns (address) {\n        uint exampleSix = 26;\n        return address(uint160(exampleSix));\n    }\n    function getStatus() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ContractTwentySeven {\n    function transformToAddress() public pure returns (address) {\n        uint exampleSeven = 27;\n        return address(uint160(exampleSeven));\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyEight {\n    function makeAddressFromNeg() public pure returns (address) {\n        uint exampleEight = 28;\n        return address(uint160(exampleEight));\n    }\n    function getNumber() public pure returns (int) {\n        return 28;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ContractTwentyNine {\n    function convertIntToAddress() public pure returns (address) {\n        uint exampleNine = 29;\n        return address(uint160(exampleNine));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ContractThirty {\n    function negativeIntegerToAddress() public pure returns (address) {\n        uint exampleTen = 30;\n        return address(uint160(exampleTen));\n    }\n    function extraFunc() public pure returns (uint) {\n        return 30;\n    }\n}"
      }
    }
  },
  {
    "Changes119": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and an integer type <code>T</code> are only allowed if the literal\nlies between <code>type(T).min</code> and <code>type(T).max</code>. In particular, replace usages of <code>uint(-1)</code>\nwith <code>type(uint).max</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyOne {\n    function obtainMaxInteger() public pure returns (uint) {\n        uint maxInteger = uint(-1);\n        return maxInteger;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/22.sol:1:140:\n  |\n1 |  ... (uint) {         uint maxInteger = uint(-1);         return maxInteger;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyTwo {\n    function deriveMax() public pure returns (uint) {\n        uint derivedMax = uint(-1);\n        return derivedMax;\n    }\n    function helperTwo() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/23.sol:1:133:\n  |\n1 |  ... (uint) {         uint derivedMax = uint(-1);         return derivedMax;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyThree {\n    function getBoundaryMax() public pure returns (uint) {\n        uint boundaryMax = uint(-1);\n        return boundaryMax;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/24.sol:1:141:\n  |\n1 |  ... uint) {         uint boundaryMax = uint(-1);         return boundaryMax;     } ...\n  |                                         ^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyFour {\n    function fetchTopLimit() public pure returns (uint) {\n        uint topLimit = uint(-1);\n        return topLimit;\n    }\n    function extraFunctionFour() public pure returns (string memory) {\n        return \"Extra data\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/25.sol:1:136:\n  |\n1 |  ... s (uint) {         uint topLimit = uint(-1);         return topLimit;     }    ...\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyFive {\n    function maxBoundary() public pure returns (uint) {\n        uint maximumBoundary = uint(-1);\n        return maximumBoundary;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/26.sol:1:141:\n  |\n1 |  ... ) {         uint maximumBoundary = uint(-1);         return maximumBoundary;   ...\n  |                                         ^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentySix {\n    function retrieveExtreme() public pure returns (uint) {\n        uint extreme = uint(-1);\n        return extreme;\n    }\n    function anotherExtra() public pure returns (int) {\n        return 5;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/27.sol:1:136:\n  |\n1 |  ... ns (uint) {         uint extreme = uint(-1);         return extreme;     }     ...\n  |                                         ^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentySeven {\n    function extractPeak() public pure returns (uint) {\n        uint peak = uint(-1);\n        return peak;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/28.sol:1:131:\n  |\n1 |  ... turns (uint) {         uint peak = uint(-1);         return peak;     } }\n  |                                         ^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyEight {\n    function captureMaximum() public pure returns (uint) {\n        uint captureMax = uint(-1);\n        return captureMax;\n    }\n    function extra() public pure returns (uint) {\n        return 789;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/29.sol:1:140:\n  |\n1 |  ... (uint) {         uint captureMax = uint(-1);         return captureMax;     }  ...\n  |                                         ^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyNine {\n    function getUltimateMax() public pure returns (uint) {\n        uint ultimateMax = uint(-1);\n        return ultimateMax;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/30.sol:1:140:\n  |\n1 |  ... uint) {         uint ultimateMax = uint(-1);         return ultimateMax;     } ...\n  |                                         ^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract ExampleThirty {\n    function pullPeakValue() public pure returns (uint) {\n        uint peakValue = uint(-1);\n        return peakValue;\n    }\n    function unrelatedFunction() public pure returns (uint) {\n        return 1234;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const -1\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/31.sol:1:133:\n  |\n1 |  ...  (uint) {         uint peakValue = uint(-1);         return peakValue;     }   ...\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyOne {\n    function obtainMaxInteger() public pure returns (uint) {\n        uint maxInteger = type(uint).max;\n        return maxInteger;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyTwo {\n    function deriveMax() public pure returns (uint) {\n        uint derivedMax = type(uint).max;\n        return derivedMax;\n    }\n    function helperTwo() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyThree {\n    function getBoundaryMax() public pure returns (uint) {\n        uint boundaryMax = type(uint).max;\n        return boundaryMax;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyFour {\n    function fetchTopLimit() public pure returns (uint) {\n        uint topLimit = type(uint).max;\n        return topLimit;\n    }\n    function extraFunctionFour() public pure returns (string memory) {\n        return \"Extra data\";\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyFive {\n    function maxBoundary() public pure returns (uint) {\n        uint maximumBoundary = type(uint).max;\n        return maximumBoundary;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentySix {\n    function retrieveExtreme() public pure returns (uint) {\n        uint extreme = type(uint).max;\n        return extreme;\n    }\n    function anotherExtra() public pure returns (int) {\n        return 5;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentySeven {\n    function extractPeak() public pure returns (uint) {\n        uint peak = type(uint).max;\n        return peak;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyEight {\n    function captureMaximum() public pure returns (uint) {\n        uint captureMax = type(uint).max;\n        return captureMax;\n    }\n    function extra() public pure returns (uint) {\n        return 789;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract ExampleTwentyNine {\n    function getUltimateMax() public pure returns (uint) {\n        uint ultimateMax = type(uint).max;\n        return ultimateMax;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract ExampleThirty {\n    function pullPeakValue() public pure returns (uint) {\n        uint peakValue = type(uint).max;\n        return peakValue;\n    }\n    function unrelatedFunction() public pure returns (uint) {\n        return 1234;\n    }\n}"
      }
    }
  },
  {
    "Changes120": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and enums are only allowed if the literal can\nrepresent a value in the enum.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example22 {\n    enum Status { Active, Inactive, Suspended }\n    Status public currentStatus;\n    function setStatus() public {\n        currentStatus = Status(5);\n    }\n    function extraInfo() public pure returns (string memory) {\n        return \"Extra Info\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example22.Status\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/32.sol:1:185:\n  |\n1 |  ... ) public {         currentStatus = Status(5);     }     function extraInfo() pu ...\n  |                                         ^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example23 {\n    enum Level { Easy, Intermediate, Hard }\n    Level public difficultyLevel;\n    function setLevel() public {\n        difficultyLevel = Level(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example23.Level\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/33.sol:1:183:\n  |\n1 |  ... public {         difficultyLevel = Level(4);     } }\n  |                                         ^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example24 {\n    enum State { Open, Closed, Locked }\n    State public doorState;\n    function toggleState() public {\n        doorState = State(3);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 3\" to \"enum Example24.State\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/34.sol:1:170:\n  |\n1 |  ... ate() public {         doorState = State(3);     } }\n  |                                         ^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example25 {\n    enum Grade { A, B, C, D, F }\n    Grade public studentGrade;\n    function assignGrade() public {\n        studentGrade = Grade(7);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 7\" to \"enum Example25.Grade\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/35.sol:1:169:\n  |\n1 |  ... () public {         studentGrade = Grade(7);     } }\n  |                                         ^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example26 {\n    enum Phase { Design, Development, Testing, Deployment }\n    Phase public projectPhase;\n    function nextPhase() public {\n        projectPhase = Phase(6);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 6\" to \"enum Example26.Phase\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/36.sol:1:194:\n  |\n1 |  ... () public {         projectPhase = Phase(6);     } }\n  |                                         ^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example27 {\n    enum Option { None, One, Multiple }\n    Option public choiceOption;\n    function selectOption() public {\n        choiceOption = Option(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example27.Option\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/37.sol:1:178:\n  |\n1 |  ... () public {         choiceOption = Option(4);     } }\n  |                                         ^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example28 {\n    enum Color { Red, Green, Blue }\n    Color public favoriteColor;\n    function setColor() public {\n        favoriteColor = Color(5);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example28.Color\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/38.sol:1:171:\n  |\n1 |  ... ) public {         favoriteColor = Color(5);     } }\n  |                                         ^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example29 {\n    enum Quantity { Zero, One, Two, Three }\n    Quantity public itemCount;\n    function updateQuantity() public {\n        itemCount = Quantity(6);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 6\" to \"enum Example29.Quantity\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/39.sol:1:180:\n  |\n1 |  ... ity() public {         itemCount = Quantity(6);     } }\n  |                                         ^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example30 {\n    enum Mood { Happy, Sad, Neutral }\n    Mood public currentMood;\n    function changeMood() public {\n        currentMood = Mood(4);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 4\" to \"enum Example30.Mood\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/40.sol:1:170:\n  |\n1 |  ... d() public {         currentMood = Mood(4);     } }\n  |                                         ^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example31 {\n    enum Size { Small, Medium, Large, ExtraLarge }\n    Size public tShirtSize;\n    function setSize() public {\n        tShirtSize = Size(5);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int_const 5\" to \"enum Example31.Size\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/41.sol:1:178:\n  |\n1 |  ... ze() public {         tShirtSize = Size(5);     } }\n  |                                         ^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example22 {\n    enum Status { Active, Inactive, Suspended }\n    Status public currentStatus;\n    function setStatus() public {\n        currentStatus = Status(2);\n    }\n    function extraInfo() public pure returns (string memory) {\n        return \"Extra Info\";\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example23 {\n    enum Level { Easy, Intermediate, Hard }\n    Level public difficultyLevel;\n    function setLevel() public {\n        difficultyLevel = Level(2);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example24 {\n    enum State { Open, Closed, Locked }\n    State public doorState;\n    function toggleState() public {\n        doorState = State(2);\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example25 {\n    enum Grade { A, B, C, D, F }\n    Grade public studentGrade;\n    function assignGrade() public {\n        studentGrade = Grade(4);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example26 {\n    enum Phase { Design, Development, Testing, Deployment }\n    Phase public projectPhase;\n    function nextPhase() public {\n        projectPhase = Phase(3);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example27 {\n    enum Option { None, One, Multiple }\n    Option public choiceOption;\n    function selectOption() public {\n        choiceOption = Option(2);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example28 {\n    enum Color { Red, Green, Blue }\n    Color public favoriteColor;\n    function setColor() public {\n        favoriteColor = Color(2);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example29 {\n    enum Quantity { Zero, One, Two, Three }\n    Quantity public itemCount;\n    function updateQuantity() public {\n        itemCount = Quantity(3);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example30 {\n    enum Mood { Happy, Sad, Neutral }\n    Mood public currentMood;\n    function changeMood() public {\n        currentMood = Mood(2);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example31 {\n    enum Size { Small, Medium, Large, ExtraLarge }\n    Size public tShirtSize;\n    function setSize() public {\n        tShirtSize = Size(3);\n    }\n}"
      }
    }
  },
  {
    "Changes121": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Explicit conversions between literals and <code>address</code> type (e.g. <code>address(literal)</code>) have the\ntype <code>address</code> instead of <code>address payable</code>. One can get a payable address type by using an\nexplicit conversion, i.e., <code>payable(literal)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example22 {\n    function provideFunding(address beneficiary, uint256 fundAmount) public {\n        address payable dest = address(0x555);\n        dest.transfer(fundAmount);\n    }\n\n    function calculatePercentage(uint total, uint part) public pure returns (uint) {\n        return part * 100 / total;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/42.sol:1:132:\n  |\n1 |  ... nt256 fundAmount) public {         address payable dest = address(0x555);         dest.transfer(fundAmount) ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example23 {\n    function depositCash(address depositor, uint depositAmount) public {\n        address payable bank = address(0x666);\n        bank.transfer(depositAmount);\n    }\n\n    function getEvenNumbers(uint limit) public pure returns (uint[] memory evens) {\n        uint[] memory nums = new uint[](limit/2);\n        uint j = 0;\n        for(uint i = 0; i < limit; i++) {\n            if(i % 2 == 0) {\n                nums[j] = i;\n                j++;\n            }\n        }\n        return nums;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/43.sol:1:127:\n  |\n1 |  ... nt depositAmount) public {         address payable bank = address(0x666);         bank.transfer(depositAmou ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example24 {\n    function payoutVendor(address vendor, uint256 paymentAmount) public {\n        address payable merchant = address(0x777);\n        merchant.transfer(paymentAmount);\n    }\n\n    function countPrimes(uint range) public pure returns (uint count) {\n        for (uint i = 2; i <= range; i++) {\n            bool prime = true;\n            for (uint j = 2; j * j <= i; j++) {\n                if (i % j == 0) {\n                    prime = false;\n                    break;\n                }\n            }\n            if (prime) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/44.sol:1:128:\n  |\n1 |  ... 56 paymentAmount) public {         address payable merchant = address(0x777);         merchant.transfer(payment ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example25 {\n    function sendDonations(address charity, uint256 amount) public {\n        address payable donationAccount = address(0x888);\n        donationAccount.transfer(amount);\n    }\n\n    function generateFibonacci(uint n) public pure returns (uint[] memory result) {\n        uint[] memory fibs = new uint[](n);\n        fibs[0] = 0;\n        if (n > 1) {\n            fibs[1] = 1;\n            for (uint i = 2; i < n; i++) {\n                fibs[i] = fibs[i - 1] + fibs[i - 2];\n            }\n        }\n        return fibs;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/45.sol:1:123:\n  |\n1 |  ... , uint256 amount) public {         address payable donationAccount = address(0x888);         donationAccount.transfer( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example26 {\n    function dispatchContributions(address participant, uint256 contribution) public {\n        address payable accountHolder = address(0x999);\n        accountHolder.transfer(contribution);\n    }\n\n    function multiplyArrayElements(uint[] memory arr) public pure returns (uint product) {\n        product = 1;\n        for (uint i = 0; i < arr.length; i++) {\n            product *= arr[i];\n        }\n        return product;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/46.sol:1:141:\n  |\n1 |  ... 256 contribution) public {         address payable accountHolder = address(0x999);         accountHolder.transfer(co ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example27 {\n    function transferToStakeholder(address stakeholder, uint256 stakeAmount) public {\n        address payable stakeholderAccount = address(0xAAA);\n        stakeholderAccount.transfer(stakeAmount);\n    }\n\n    function arraySum(uint[] memory data) public pure returns (uint sum) {\n        sum = 0;\n        for (uint i = 0; i < data.length; i++) {\n            sum += data[i];\n        }\n        return sum;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/47.sol:1:140:\n  |\n1 |  ... t256 stakeAmount) public {         address payable stakeholderAccount = address(0xAAA);         stakeholderAccount.transf ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example28 {\n    function remitToSupplier(address supplier, uint256 payment) public {\n        address payable supplierAccount = address(0xBBB);\n        supplierAccount.transfer(payment);\n    }\n\n    function calculateAverage(uint[] memory values) public pure returns (uint avg) {\n        uint total = 0;\n        for (uint i = 0; i < values.length; i++) {\n            total += values[i];\n        }\n        avg = total / values.length;\n        return avg;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/48.sol:1:127:\n  |\n1 |  ...  uint256 payment) public {         address payable supplierAccount = address(0xBBB);         supplierAccount.transfer( ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example29 {\n    function forwardToBeneficiary(address beneficiary, uint256 amount) public {\n        address payable beneficiaryAccount = address(0xCCC);\n        beneficiaryAccount.transfer(amount);\n    }\n\n    function findMax(uint[] memory values) public pure returns (uint max) {\n        max = values[0];\n        for (uint i = 1; i < values.length; i++) {\n            if (values[i] > max) {\n                max = values[i];\n            }\n        }\n        return max;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/49.sol:1:134:\n  |\n1 |  ... , uint256 amount) public {         address payable beneficiaryAccount = address(0xCCC);         beneficiaryAccount.transf ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example30 {\n    function allocateFundsToProject(address project, uint256 funding) public {\n        address payable projectAccount = address(0xDDD);\n        projectAccount.transfer(funding);\n    }\n\n    function findMin(uint[] memory values) public pure returns (uint min) {\n        min = values[0];\n        for (uint i = 1; i < values.length; i++) {\n            if (values[i] < min) {\n                min = values[i];\n            }\n        }\n        return min;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/50.sol:1:133:\n  |\n1 |  ...  uint256 funding) public {         address payable projectAccount = address(0xDDD);         projectAccount.transfer(f ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract Example31 {\n    function sendRewards(address winner, uint256 reward) public {\n        address payable winnerAccount = address(0xEEE);\n        winnerAccount.transfer(reward);\n    }\n\n    function arrayReverse(uint[] memory array) public pure returns (uint[] memory) {\n        uint[] memory reversed = new uint[](array.length);\n        for (uint i = 0; i < array.length; i++) {\n            reversed[array.length - 1 - i] = array[i];\n        }\n        return reversed;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/51.sol:1:120:\n  |\n1 |  ... , uint256 reward) public {         address payable winnerAccount = address(0xEEE);         winnerAccount.transfer(re ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract Example22 {\n    function provideFunding(address beneficiary, uint256 fundAmount) public {\n        address payable dest = payable(address(uint160(beneficiary)));\n        dest.transfer(fundAmount);\n    }\n\n    function calculatePercentage(uint total, uint part) public pure returns (uint) {\n        return part * 100 / total;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract Example23 {\n    function depositCash(address depositor, uint depositAmount) public {\n        address payable bank = payable(address(uint160(depositor)));\n        bank.transfer(depositAmount);\n    }\n\n    function getEvenNumbers(uint limit) public pure returns (uint[] memory evens) {\n        uint[] memory nums = new uint[](limit/2);\n        uint j = 0;\n        for(uint i = 0; i < limit; i++) {\n            if(i % 2 == 0) {\n                nums[j] = i;\n                j++;\n            }\n        }\n        return nums;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract Example24 {\n    function payoutVendor(address vendor, uint256 paymentAmount) public {\n        address payable merchant = payable(address(uint160(vendor)));\n        merchant.transfer(paymentAmount);\n    }\n\n    function countPrimes(uint range) public pure returns (uint count) {\n        for (uint i = 2; i <= range; i++) {\n            bool prime = true;\n            for (uint j = 2; j * j <= i; j++) {\n                if (i % j == 0) {\n                    prime = false;\n                    break;\n                }\n            }\n            if (prime) {\n                count++;\n            }\n        }\n        return count;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract Example25 {\n    function sendDonations(address charity, uint256 amount) public {\n        address payable donationAccount = payable(address(uint160(charity)));\n        donationAccount.transfer(amount);\n    }\n\n    function generateFibonacci(uint n) public pure returns (uint[] memory result) {\n        uint[] memory fibs = new uint[](n);\n        fibs[0] = 0;\n        if (n > 1) {\n            fibs[1] = 1;\n            for (uint i = 2; i < n; i++) {\n                fibs[i] = fibs[i - 1] + fibs[i - 2];\n            }\n        }\n        return fibs;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract Example26 {\n    function dispatchContributions(address participant, uint256 contribution) public {\n        address payable accountHolder = payable(address(uint160(participant)));\n        accountHolder.transfer(contribution);\n    }\n\n    function multiplyArrayElements(uint[] memory arr) public pure returns (uint product) {\n        product = 1;\n        for (uint i = 0; i < arr.length; i++) {\n            product *= arr[i];\n        }\n        return product;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract Example27 {\n    function transferToStakeholder(address stakeholder, uint256 stakeAmount) public {\n        address payable stakeholderAccount = payable(address(uint160(stakeholder)));\n        stakeholderAccount.transfer(stakeAmount);\n    }\n\n    function arraySum(uint[] memory data) public pure returns (uint sum) {\n        sum = 0;\n        for (uint i = 0; i < data.length; i++) {\n            sum += data[i];\n        }\n        return sum;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract Example28 {\n    function remitToSupplier(address supplier, uint256 payment) public {\n        address payable supplierAccount = payable(address(uint160(supplier)));\n        supplierAccount.transfer(payment);\n    }\n\n    function calculateAverage(uint[] memory values) public pure returns (uint avg) {\n        uint total = 0;\n        for (uint i = 0; i < values.length; i++) {\n            total += values[i];\n        }\n        avg = total / values.length;\n        return avg;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract Example29 {\n    function forwardToBeneficiary(address beneficiary, uint256 amount) public {\n        address payable beneficiaryAccount = payable(address(uint160(beneficiary)));\n        beneficiaryAccount.transfer(amount);\n    }\n\n    function findMax(uint[] memory values) public pure returns (uint max) {\n        max = values[0];\n        for (uint i = 1; i < values.length; i++) {\n            if (values[i] > max) {\n                max = values[i];\n            }\n        }\n        return max;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract Example30 {\n    function allocateFundsToProject(address project, uint256 funding) public {\n        address payable projectAccount = payable(address(uint160(project)));\n        projectAccount.transfer(funding);\n    }\n\n    function findMin(uint[] memory values) public pure returns (uint min) {\n        min = values[0];\n        for (uint i = 1; i < values.length; i++) {\n            if (values[i] < min) {\n                min = values[i];\n            }\n        }\n        return min;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract Example31 {\n    function sendRewards(address winner, uint256 reward) public {\n        address payable winnerAccount = payable(address(uint160(winner)));\n        winnerAccount.transfer(reward);\n    }\n\n    function arrayReverse(uint[] memory array) public pure returns (uint[] memory) {\n        uint[] memory reversed = new uint[](array.length);\n        for (uint i = 0; i < array.length; i++) {\n            reversed[array.length - 1 - i] = array[i];\n        }\n        return reversed;\n    }\n}"
      }
    }
  },
  {
    "Changes122": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/types.html#address-literals\"><span class=\"std std-ref\">Address literals</a> have the type <code>address</code> instead of <code>address\npayable</code>. They can be converted to <code>address payable</code> by using an explicit conversion, e.g.\n<code>payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract1 {\n    address payable public account1;\n    constructor() {\n        account1 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/52.sol:1:121:\n  |\n1 |  ... constructor() {         account1 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract2 {\n    address payable public account2;\n    constructor() {\n        account2 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random1() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/53.sol:1:121:\n  |\n1 |  ... constructor() {         account2 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random1() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract3 {\n    address payable public account3;\n    constructor() {\n        account3 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random2() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/54.sol:1:121:\n  |\n1 |  ... constructor() {         account3 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random2() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract4 {\n    address payable public account4;\n    constructor() {\n        account4 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/55.sol:1:121:\n  |\n1 |  ... constructor() {         account4 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract5 {\n    address payable public account5;\n    constructor() {\n        account5 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random3() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/56.sol:1:121:\n  |\n1 |  ... constructor() {         account5 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random3() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract6 {\n    address payable public account6;\n    constructor() {\n        account6 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/57.sol:1:121:\n  |\n1 |  ... constructor() {         account6 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract7 {\n    address payable public account7;\n    constructor() {\n        account7 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random4() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/58.sol:1:121:\n  |\n1 |  ... constructor() {         account7 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random4() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract8 {\n    address payable public account8;\n    constructor() {\n        account8 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/59.sol:1:121:\n  |\n1 |  ... constructor() {         account8 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract9 {\n    address payable public account9;\n    constructor() {\n        account9 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/60.sol:1:121:\n  |\n1 |  ... constructor() {         account9 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Contract10 {\n    address payable public account10;\n    constructor() {\n        account10 = 0xaBC1234567890DeFAbC1234567890DefABc12345;\n    }\n    function random5() public {}\n}",
          "error message": "Error: Type address is not implicitly convertible to expected type address payable.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/61.sol:1:124:\n  |\n1 |  ... onstructor() {         account10 = 0xaBC1234567890DeFAbC1234567890DefABc12345;     }     function random5() publ ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Contract1 {\n    address payable public account1;\n    constructor() {\n        account1 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Contract2 {\n    address payable public account2;\n    constructor() {\n        account2 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random1() public {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Contract3 {\n    address payable public account3;\n    constructor() {\n        account3 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random2() public {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Contract4 {\n    address payable public account4;\n    constructor() {\n        account4 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Contract5 {\n    address payable public account5;\n    constructor() {\n        account5 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random3() public {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Contract6 {\n    address payable public account6;\n    constructor() {\n        account6 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Contract7 {\n    address payable public account7;\n    constructor() {\n        account7 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random4() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Contract8 {\n    address payable public account8;\n    constructor() {\n        account8 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Contract9 {\n    address payable public account9;\n    constructor() {\n        account9 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Contract10 {\n    address payable public account10;\n    constructor() {\n        account10 = payable(0xaBC1234567890DeFAbC1234567890DefABc12345);\n    }\n    function random5() public {}\n}"
      }
    }
  },
  {
    "Changes123": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>address(uint)</code> and <code>uint(address)</code>: converting both type-category and width. Replace this by\n<code>address(uint160(uint))</code> and <code>uint(uint160(address))</code> respectively.Add intermediate explicit type conversions if required.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract Refactor {\n    function refactorUintToAddress(uint r) public pure returns (address) {\n        return address(r);\n    }\n    function additionalFunction() public pure returns (uint) {\n        return 500;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/62.sol:1:134:\n  |\n1 |  ... returns (address) {         return address(r);     }     function additionalFunc ...\n  |                                         ^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract Realign {\n    function realignAddressToUint(address s) public pure returns (uint) {\n        return uint(s);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/63.sol:1:132:\n  |\n1 | pragma solidity^0.8.0; contract Realign {     function realignAddressToUint(address s) public pure returns (uint) {         return uint(s);     } }\n  |                                                                                                                                    ^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract Recode {\n    function recodeUintToAddress(uint t) public pure returns (address) {\n        return address(t);\n    }\n    function extraMethod() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/64.sol:1:130:\n  |\n1 |  ... returns (address) {         return address(t);     }     function extraMethod()  ...\n  |                                         ^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract Remap {\n    function remapAddressToUint(address u) public pure returns (uint) {\n        return uint(u);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/65.sol:1:128:\n  |\n1 | pragma solidity^0.8.0; contract Remap {     function remapAddressToUint(address u) public pure returns (uint) {         return uint(u);     } }\n  |                                                                                                                                ^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract Regenerate {\n    function regenerateUintToAddress(uint v) public pure returns (address) {\n        return address(v);\n    }\n    function someUnusedFunction() public pure returns (string memory) {\n        return \"Random\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/66.sol:1:138:\n  |\n1 |  ... returns (address) {         return address(v);     }     function someUnusedFunc ...\n  |                                         ^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract Reassign {\n    function reassignAddressToUint(address w) public pure returns (uint) {\n        return uint(w);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/67.sol:1:134:\n  |\n1 | pragma solidity^0.8.0; contract Reassign {     function reassignAddressToUint(address w) public pure returns (uint) {         return uint(w);     } }\n  |                                                                                                                                      ^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract Redefine {\n    function redefineUintToAddress(uint x) public pure returns (address) {\n        return address(x);\n    }\n    function helperFunc() public pure returns (int) {\n        return 101;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/68.sol:1:134:\n  |\n1 |  ... returns (address) {         return address(x);     }     function helperFunc() p ...\n  |                                         ^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract Redirect {\n    function redirectAddressToUint(address y) public pure returns (uint) {\n        return uint(y);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/69.sol:1:134:\n  |\n1 | pragma solidity^0.8.0; contract Redirect {     function redirectAddressToUint(address y) public pure returns (uint) {         return uint(y);     } }\n  |                                                                                                                                      ^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract Reshape {\n    function reshapeUintToAddress(uint z) public pure returns (address) {\n        return address(z);\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 1024;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/70.sol:1:132:\n  |\n1 |  ... returns (address) {         return address(z);     }     function anotherFunctio ...\n  |                                         ^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract Reconfigure {\n    function reconfigureAddressToUint(address aa) public pure returns (uint) {\n        return uint(aa);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"address\" to \"uint256\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/71.sol:1:141:\n  |\n1 |  ... re returns (uint) {         return uint(aa);     } }\n  |                                         ^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract Refactor {\n    function refactorUintToAddress(uint r) public pure returns (address) {\n        return address(uint160(r));\n    }\n    function additionalFunction() public pure returns (uint) {\n        return 500;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract Realign {\n    function realignAddressToUint(address s) public pure returns (uint) {\n        return uint(uint160(s));\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract Recode {\n    function recodeUintToAddress(uint t) public pure returns (address) {\n        return address(uint160(t));\n    }\n    function extraMethod() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract Remap {\n    function remapAddressToUint(address u) public pure returns (uint) {\n        return uint(uint160(u));\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract Regenerate {\n    function regenerateUintToAddress(uint v) public pure returns (address) {\n        return address(uint160(v));\n    }\n    function someUnusedFunction() public pure returns (string memory) {\n        return \"Random\";\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract Reassign {\n    function reassignAddressToUint(address w) public pure returns (uint) {\n        return uint(uint160(w));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract Redefine {\n    function redefineUintToAddress(uint x) public pure returns (address) {\n        return address(uint160(x));\n    }\n    function helperFunc() public pure returns (int) {\n        return 101;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract Redirect {\n    function redirectAddressToUint(address y) public pure returns (uint) {\n        return uint(uint160(y));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract Reshape {\n    function reshapeUintToAddress(uint z) public pure returns (address) {\n        return address(uint160(z));\n    }\n    function anotherFunction() public pure returns (uint) {\n        return 1024;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract Reconfigure {\n    function reconfigureAddressToUint(address aa) public pure returns (uint) {\n        return uint(uint160(aa));\n    }\n}"
      }
    }
  },
  {
    "Changes124": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>payable(uint160)</code>, <code>payable(bytes20)</code> and <code>payable(integer-literal)</code>: converting both\ntype-category and state-mutability. Replace this by <code>payable(address(uint160))</code>,\n<code>payable(address(bytes20))</code> and <code>payable(address(integer-literal))</code> respectively. Note that\n<code>payable(0)</code> is valid and is an exception to the rule.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract FundAllocation {\n    function allocateFund(uint160 fund) public pure returns (address payable) {\n        return payable(fund);\n    }\n    function getAmount() public pure returns (uint256) {\n        return 500;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/72.sol:1:145:\n  |\n1 |  ... (address payable) {         return payable(fund);     }     function getAmount() pu ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentCollector {\n    function collectPayment(uint160 paymentId) public pure returns (address payable) {\n        return payable(paymentId);\n    }\n    function checkCollectorStatus() public pure returns (bool) {\n        return true;\n    }\n    function getVersionInfo() public pure returns (string memory) {\n        return \"v2.3\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/73.sol:1:154:\n  |\n1 |  ... (address payable) {         return payable(paymentId);     }     function checkCollector ...\n  |                                         ^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract InvestmentManager {\n    function manageInvestment(uint160 investment) public pure returns (address payable) {\n        return payable(investment);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/74.sol:1:158:\n  |\n1 |  ... (address payable) {         return payable(investment);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract DividendHandler {\n    function handleDividend(uint160 dividendAmount) public pure returns (address payable) {\n        return payable(dividendAmount);\n    }\n    function isActive() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/75.sol:1:158:\n  |\n1 |  ... (address payable) {         return payable(dividendAmount);     }     function isActive() pub ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract SalaryManager {\n    function manageSalary(uint160 salary) public pure returns (address payable) {\n        return payable(salary);\n    }\n    function countEmployees() public pure returns (uint) {\n        return 50;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/76.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(salary);     }     function countEmployees ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract BonusDistributor {\n    function distributeBonus(uint160 bonus) public pure returns (address payable) {\n        return payable(bonus);\n    }\n    function isHoliday() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/77.sol:1:151:\n  |\n1 |  ... (address payable) {         return payable(bonus);     }     function isHoliday() pu ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract CapitalController {\n    function controlCapital(uint160 capital) public pure returns (address payable) {\n        return payable(capital);\n    }\n    function getCapitalStatus() public pure returns (string memory) {\n        return \"Active\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/78.sol:1:153:\n  |\n1 |  ... (address payable) {         return payable(capital);     }     function getCapitalStat ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract TreasuryProcessor {\n    function processTreasury(uint160 treasuryAmount) public pure returns (address payable) {\n        return payable(treasuryAmount);\n    }\n    function extraMethod() public pure returns (uint) {\n        return 123;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/79.sol:1:161:\n  |\n1 |  ... (address payable) {         return payable(treasuryAmount);     }     function extraMethod()  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract PayoutManager {\n    function managePayout(uint160 payout) public pure returns (address payable) {\n        return payable(payout);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/80.sol:1:146:\n  |\n1 |  ... (address payable) {         return payable(payout);     } }\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract RevenueAllocator {\n    function allocateRevenue(uint160 revenue) public pure returns (address payable) {\n        return payable(revenue);\n    }\n    function logEvent() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint160\" to \"address payable\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/81.sol:1:153:\n  |\n1 |  ... (address payable) {         return payable(revenue);     }     function logEvent() pub ...\n  |                                         ^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract FundAllocation {\n    function allocateFund(uint160 fund) public pure returns (address payable) {\n        return payable(address(uint160(fund)));\n    }\n    function getAmount() public pure returns (uint256) {\n        return 500;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract PaymentCollector {\n    function collectPayment(uint160 paymentId) public pure returns (address payable) {\n        return payable(address(uint160(paymentId)));\n    }\n    function checkCollectorStatus() public pure returns (bool) {\n        return true;\n    }\n    function getVersionInfo() public pure returns (string memory) {\n        return \"v2.3\";\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract InvestmentManager {\n    function manageInvestment(uint160 investment) public pure returns (address payable) {\n        return payable(address(uint160(investment)));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract DividendHandler {\n    function handleDividend(uint160 dividendAmount) public pure returns (address payable) {\n        return payable(address(uint160(dividendAmount)));\n    }\n    function isActive() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract SalaryManager {\n    function manageSalary(uint160 salary) public pure returns (address payable) {\n        return payable(address(uint160(salary)));\n    }\n    function countEmployees() public pure returns (uint) {\n        return 50;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract BonusDistributor {\n    function distributeBonus(uint160 bonus) public pure returns (address payable) {\n        return payable(address(uint160(bonus)));\n    }\n    function isHoliday() public pure returns (bool) {\n        return true;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract CapitalController {\n    function controlCapital(uint160 capital) public pure returns (address payable) {\n        return payable(address(uint160(capital)));\n    }\n    function getCapitalStatus() public pure returns (string memory) {\n        return \"Active\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract TreasuryProcessor {\n    function processTreasury(uint160 treasuryAmount) public pure returns (address payable) {\n        return payable(address(uint160(treasuryAmount)));\n    }\n    function extraMethod() public pure returns (uint) {\n        return 123;\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract PayoutManager {\n    function managePayout(uint160 payout) public pure returns (address payable) {\n        return payable(address(uint160(payout)));\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract RevenueAllocator {\n    function allocateRevenue(uint160 revenue) public pure returns (address payable) {\n        return payable(address(uint160(revenue)));\n    }\n    function logEvent() public pure returns (bool) {\n        return true;\n    }\n}"
      }
    }
  },
  {
    "Changes125": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>int80(bytes10)</code> and <code>bytes10(int80)</code>: converting both type-category and sign. Replace this by\n<code>int80(uint80(bytes10))</code> and <code>bytes10(uint80(int80)</code> respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ConverterBeta {\n    function betaConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function extraFunction() public pure returns (uint256) {\n        return 250;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/82.sol:1:134:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function extraFunction( ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract DataModifier {\n    function modifyData(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function randomMethod() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/83.sol:1:132:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function randomMethod() ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract TypeAdapter {\n    function adaptType(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/84.sol:1:130:\n  |\n1 | pragma solidity^0.8.0; contract TypeAdapter {     function adaptType(bytes10 input) public pure returns (int80) {         return int80(input);     } }\n  |                                                                                                                                  ^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract SwiftConverter {\n    function swiftConversion(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function anotherHelper() public pure returns (int) {\n        return 123;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/85.sol:1:139:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function anotherHelper( ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract BytesToIntConverter {\n    function convertBytesToInt(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/86.sol:1:146:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract IntToBytesConverter {\n    function convertIntToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/87.sol:1:146:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract SimpleTransformation {\n    function simpleConvert(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function additionalMethod() public pure returns (string memory) {\n        return \"RandomString\";\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/88.sol:1:143:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function additionalMeth ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract BasicTypeConverter {\n    function convertTypeBasic(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/89.sol:1:144:\n  |\n1 |  ... e returns (int80) {         return int80(input);     } }\n  |                                         ^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract DataEncoder {\n    function encodeData(bytes10 input) public pure returns (int80) {\n        return int80(input);\n    }\n    function extraAction() public pure returns (uint) {\n        return 777;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"bytes10\" to \"int80\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/90.sol:1:131:\n  |\n1 |  ... e returns (int80) {         return int80(input);     }     function extraAction()  ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract DataDecoder {\n    function decodeData(int80 input) public pure returns (bytes10) {\n        return bytes10(input);\n    }\n    function dummyValue() public pure returns (bool) {\n        return true;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"int80\" to \"bytes10\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/91.sol:1:131:\n  |\n1 |  ... returns (bytes10) {         return bytes10(input);     }     function dummyValue() p ...\n  |                                         ^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ConverterBeta {\n    function betaConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function extraFunction() public pure returns (uint256) {\n        return 250;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract DataModifier {\n    function modifyData(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function randomMethod() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract TypeAdapter {\n    function adaptType(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract SwiftConverter {\n    function swiftConversion(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function anotherHelper() public pure returns (int) {\n        return 123;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract BytesToIntConverter {\n    function convertBytesToInt(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract IntToBytesConverter {\n    function convertIntToBytes(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract SimpleTransformation {\n    function simpleConvert(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function additionalMethod() public pure returns (string memory) {\n        return \"RandomString\";\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract BasicTypeConverter {\n    function convertTypeBasic(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract DataEncoder {\n    function encodeData(bytes10 input) public pure returns (int80) {\n        return int80(uint80(input));\n    }\n    function extraAction() public pure returns (uint) {\n        return 777;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract DataDecoder {\n    function decodeData(int80 input) public pure returns (bytes10) {\n        return bytes10(uint80(input));\n    }\n    function dummyValue() public pure returns (bool) {\n        return true;\n    }\n}"
      }
    }
  },
  {
    "Changes126": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "<code>Contract(uint)</code>: converting both type-category and width. Replace this by\n<code>Contract(address(uint160(uint)))</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleAlpha {\n    function encode(uint index) public pure returns (address) {\n        address result = address(index);\n        return result;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/92.sol:1:136:\n  |\n1 |  ... ddress) {         address result = address(index);         return result;     } }\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleBeta {\n    function shift(uint amount) public pure returns (address) {\n        address addr = address(amount);\n        return addr;\n    }\n    function randomMethod() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/93.sol:1:133:\n  |\n1 |  ... (address) {         address addr = address(amount);         return addr;     }     fu ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleGamma {\n    function reflect(uint variable) public pure returns (address) {\n        address res = address(variable);\n        return res;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/94.sol:1:137:\n  |\n1 |  ...  (address) {         address res = address(variable);         return res;     } }\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleDelta {\n    function convertValue(uint number) public pure returns (address) {\n        address value = address(number);\n        return value;\n    }\n    function additionalFunction() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/95.sol:1:142:\n  |\n1 |  ... address) {         address value = address(number);         return value;     }     f ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleEpsilon {\n    function mutate(uint num) public pure returns (address) {\n        address output = address(num);\n        return output;\n    }\n    function extraOne() public pure {}\n    function extraTwo() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/96.sol:1:136:\n  |\n1 |  ... ddress) {         address output = address(num);         return output;     }      ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleZeta {\n    function assign(uint data) public pure returns (address) {\n        address resultAddr = address(data);\n        return resultAddr;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/97.sol:1:138:\n  |\n1 |  ... ss) {         address resultAddr = address(data);         return resultAddr;     }  ...\n  |                                         ^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleEta {\n    function process(uint val) public pure returns (address) {\n        address addressVar = address(val);\n        return addressVar;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/98.sol:1:137:\n  |\n1 |  ... ss) {         address addressVar = address(val);         return addressVar;     }  ...\n  |                                         ^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleTheta {\n    function transition(uint input) public pure returns (address) {\n        address temp = address(input);\n        return temp;\n    }\n    function auxiliary() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/99.sol:1:138:\n  |\n1 |  ... (address) {         address temp = address(input);         return temp;     }     fu ...\n  |                                         ^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleIota {\n    function dispatch(uint quantity) public pure returns (address) {\n        address addressField = address(quantity);\n        return addressField;\n    }\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/100.sol:1:146:\n  |\n1 |  ... ) {         address addressField = address(quantity);         return addressField;      ...\n  |                                         ^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ModuleKappa {\n    function transform(uint factor) public pure returns (address) {\n        address transformed = address(factor);\n        return transformed;\n    }\n    function unusedMethod() public pure {}\n}",
          "error message": "Error: Explicit type conversion not allowed from \"uint256\" to \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/101.sol:1:145:\n  |\n1 |  ... s) {         address transformed = address(factor);         return transformed;     } ...\n  |                                         ^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ModuleAlpha {\n    function encode(uint index) public pure returns (address) {\n        address result = address(uint160(index));\n        return result;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ModuleBeta {\n    function shift(uint amount) public pure returns (address) {\n        address addr = address(uint160(amount));\n        return addr;\n    }\n    function randomMethod() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ModuleGamma {\n    function reflect(uint variable) public pure returns (address) {\n        address res = address(uint160(variable));\n        return res;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ModuleDelta {\n    function convertValue(uint number) public pure returns (address) {\n        address value = address(uint160(number));\n        return value;\n    }\n    function additionalFunction() public pure {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ModuleEpsilon {\n    function mutate(uint num) public pure returns (address) {\n        address output = address(uint160(num));\n        return output;\n    }\n    function extraOne() public pure {}\n    function extraTwo() public pure {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ModuleZeta {\n    function assign(uint data) public pure returns (address) {\n        address resultAddr = address(uint160(data));\n        return resultAddr;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ModuleEta {\n    function process(uint val) public pure returns (address) {\n        address addressVar = address(uint160(val));\n        return addressVar;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ModuleTheta {\n    function transition(uint input) public pure returns (address) {\n        address temp = address(uint160(input));\n        return temp;\n    }\n    function auxiliary() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ModuleIota {\n    function dispatch(uint quantity) public pure returns (address) {\n        address addressField = address(uint160(quantity));\n        return addressField;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ModuleKappa {\n    function transform(uint factor) public pure returns (address) {\n        address transformed = address(uint160(factor));\n        return transformed;\n    }\n    function unusedMethod() public pure {}\n}"
      }
    }
  },
  {
    "Changes127": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Function call options can only be given once, i.e. <code>c.f{gas: 10000}{value: 1}()</code> is invalid and has to be changed to <code>c.f{gas: 10000, value: 1}()</code>.Combine <code>c.f{gas: 10000}{value: 1}()</code> to <code>c.f{gas: 10000, value: 1}()</code>.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantManager {\n    address payable public grantee;\n    function issueGrant() public {\n        grantee.call{gas: 2500}{value: 2 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/102.sol:1:127:\n  |\n1 |  ... tion issueGrant() public {         grantee.call{gas: 2500}{value: 2 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract SponsorshipHandler {\n    address payable public sponsor;\n    function handleSponsorship() public {\n        sponsor.call{gas: 3000}{value: 3 ether}(\"\");\n    }\n    function additionalInfo() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/103.sol:1:140:\n  |\n1 |  ... ndleSponsorship() public {         sponsor.call{gas: 3000}{value: 3 ether}(\"\");     }     function additional ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract MerchandiseSales {\n    address payable public seller;\n    function sellMerchandise() public {\n        seller.call{gas: 4000}{value: 4 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/104.sol:1:135:\n  |\n1 |  ... sellMerchandise() public {         seller.call{gas: 4000}{value: 4 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ProfitRedistribution {\n    address payable public partner;\n    function redistributeProfits() public {\n        partner.call{gas: 5000}{value: 5 ether}(\"\");\n    }\n    function logActivity() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/105.sol:1:144:\n  |\n1 |  ... stributeProfits() public {         partner.call{gas: 5000}{value: 5 ether}(\"\");     }     function logActivit ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract InvestmentTracker {\n    address payable public investor;\n    function trackInvestment() public {\n        investor.call{gas: 6000}{value: 6 ether}(\"\");\n    }\n    function recordData() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/106.sol:1:138:\n  |\n1 |  ... trackInvestment() public {         investor.call{gas: 6000}{value: 6 ether}(\"\");     }     function recordData ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceDistributor {\n    address payable public distributor;\n    function distributeResources() public {\n        distributor.call{gas: 3500}{value: 3.5 ether}(\"\");\n    }\n    function calculateDistribution() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/107.sol:1:147:\n  |\n1 |  ... ributeResources() public {         distributor.call{gas: 3500}{value: 3.5 ether}(\"\");     }     function calculateD ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract EventPlanner {\n    address payable public planner;\n    function planEvent() public {\n        planner.call{gas: 4500}{value: 1 ether}(\"\");\n    }\n    function finalizeDetails() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/108.sol:1:126:\n  |\n1 |  ... ction planEvent() public {         planner.call{gas: 4500}{value: 1 ether}(\"\");     }     function finalizeDe ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract DebtRepayment {\n    address payable public debtor;\n    function repayDebt() public {\n        debtor.call{gas: 1500}{value: 1.5 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/109.sol:1:126:\n  |\n1 |  ... ction repayDebt() public {         debtor.call{gas: 1500}{value: 1.5 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ProjectFunding {\n    address payable public funder;\n    function fundProject() public {\n        funder.call{gas: 7000}{value: 7 ether}(\"\");\n    }\n    function reviewProject() public {}\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/110.sol:1:129:\n  |\n1 |  ... ion fundProject() public {         funder.call{gas: 7000}{value: 7 ether}(\"\");     }     function reviewProj ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract CapitalAllocation {\n    address payable public allocator;\n    function allocateCapital() public {\n        allocator.call{gas: 8000}{value: 8 ether}(\"\");\n    }\n}",
          "error message": "Error: Function call options have already been set, you have to combine them into a single {...}-option.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/111.sol:1:139:\n  |\n1 |  ... allocateCapital() public {         allocator.call{gas: 8000}{value: 8 ether}(\"\");     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract GrantManager {\n    address payable public grantee;\n    function issueGrant() public {\n        grantee.call{gas: 2500, value: 2 ether}(\"\");\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract SponsorshipHandler {\n    address payable public sponsor;\n    function handleSponsorship() public {\n        sponsor.call{gas: 3000, value: 3 ether}(\"\");\n    }\n    function additionalInfo() public {}\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract MerchandiseSales {\n    address payable public seller;\n    function sellMerchandise() public {\n        seller.call{gas: 4000, value: 4 ether}(\"\");\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ProfitRedistribution {\n    address payable public partner;\n    function redistributeProfits() public {\n        partner.call{gas: 5000, value: 5 ether}(\"\");\n    }\n    function logActivity() public {}\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract InvestmentTracker {\n    address payable public investor;\n    function trackInvestment() public {\n        investor.call{gas: 6000, value: 6 ether}(\"\");\n    }\n    function recordData() public {}\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ResourceDistributor {\n    address payable public distributor;\n    function distributeResources() public {\n        distributor.call{gas: 3500, value: 3.5 ether}(\"\");\n    }\n    function calculateDistribution() public {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract EventPlanner {\n    address payable public planner;\n    function planEvent() public {\n        planner.call{gas: 4500, value: 1 ether}(\"\");\n    }\n    function finalizeDetails() public {}\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract DebtRepayment {\n    address payable public debtor;\n    function repayDebt() public {\n        debtor.call{gas: 1500, value: 1.5 ether}(\"\");\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ProjectFunding {\n    address payable public funder;\n    function fundProject() public {\n        funder.call{gas: 7000, value: 7 ether}(\"\");\n    }\n    function reviewProject() public {}\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract CapitalAllocation {\n    address payable public allocator;\n    function allocateCapital() public {\n        allocator.call{gas: 8000, value: 8 ether}(\"\");\n    }\n}"
      }
    }
  },
  {
    "Changes128": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The global functions <code>log0</code>, <code>log1</code>, <code>log2</code>, <code>log3</code> and <code>log4</code> have been removed.Use inline assembly as a replacement for <code>log0</code>, \u2026, <code>log4</code>.13.These are low-level functions that were largely unused. Their behavior can be accessed from inline assembly.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract StateLogger {\n    function logState(uint256 stateInfo) public {\n        bytes memory stateBytes = abi.encodePacked(stateInfo);\n        assembly {\n            log0(stateBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/112.sol:1:191:\n  |\n1 |  ... o);         assembly {             log0(stateBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract MetricTracker {\n    function trackMetric(int256 metricValue) public {\n        bytes memory metricData = abi.encodePacked(metricValue);\n        assembly {\n            log1(metricData, metricValue)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/113.sol:1:199:\n  |\n1 |  ... e);         assembly {             log1(metricData, metricValue)         } ...\n  |                                         ^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ProfileLogger {\n    function logProfile(bytes32 profileData) public {\n        assembly {\n            log4(profileData, profileData, profileData, profileData, profileData)\n        }\n    }\n    function dummy() public pure {}\n}",
          "error message": "Error: Function expects 6 arguments but got 5.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/114.sol:1:134:\n  |\n1 |  ... c {         assembly {             log4(profileData, profileData, profileD ...\n  |                                         ^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ResourceLogger {\n    function logResource(uint256 resourceId) public {\n        bytes memory resourceBytes = abi.encodePacked(resourceId);\n        assembly {\n            log3(resourceBytes, resourceId, resourceId, resourceId)\n        }\n    }\n}",
          "error message": "Error: Function expects 5 arguments but got 4.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/115.sol:1:202:\n  |\n1 |  ... d);         assembly {             log3(resourceBytes, resourceId, resourc ...\n  |                                         ^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ActionLogger {\n    function logAction(uint256 actionId) public {\n        bytes memory actionBytes = abi.encodePacked(actionId);\n        assembly {\n            log2(actionBytes, actionId, actionId)\n        }\n    }\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/116.sol:1:192:\n  |\n1 |  ... d);         assembly {             log2(actionBytes, actionId, actionId)   ...\n  |                                         ^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract EventLogger {\n    function logEvent(uint256 eventId) public {\n        bytes memory eventBytes = abi.encodePacked(eventId);\n        assembly {\n            log0(eventBytes)\n        }\n    }\n    function helperFunction() public pure {}\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/117.sol:1:187:\n  |\n1 |  ... d);         assembly {             log0(eventBytes)         }     }     fu ...\n  |                                         ^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract WarningLogger {\n    function logWarning(string memory warningMessage) public {\n        bytes memory warningBytes = bytes(warningMessage);\n        assembly {\n            log0(warningBytes)\n        }\n    }\n}",
          "error message": "Error: Function expects 2 arguments but got 1.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/118.sol:1:202:\n  |\n1 |  ... e);         assembly {             log0(warningBytes)         }     } }\n  |                                         ^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract UpdateTracker {\n    function trackUpdate(uint256 updateValue) public {\n        bytes memory updateBytes = abi.encodePacked(updateValue);\n        assembly {\n            log1(updateBytes, updateValue)\n        }\n    }\n    function extraAction() public pure {}\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/119.sol:1:201:\n  |\n1 |  ... e);         assembly {             log1(updateBytes, updateValue)          ...\n  |                                         ^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract FeedbackRecorder {\n    function recordFeedback(uint256 feedbackId) public {\n        bytes memory feedbackBytes = abi.encodePacked(feedbackId);\n        assembly {\n            log2(feedbackBytes, feedbackId, feedbackId)\n        }\n    }\n}",
          "error message": "Error: Function expects 4 arguments but got 3.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/120.sol:1:207:\n  |\n1 |  ... d);         assembly {             log2(feedbackBytes, feedbackId, feedbac ...\n  |                                         ^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract NotificationTracker {\n    function trackNotification(string memory notification) public {\n        bytes memory notificationBytes = bytes(notification);\n        assembly {\n            log1(notificationBytes, notification)\n        }\n    }\n}",
          "error message": "Error: Function expects 3 arguments but got 2.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/121.sol:1:216:\n  |\n1 |  ... n);         assembly {             log1(notificationBytes, notification)   ...\n  |                                         ^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract StateLogger {\n    event State(uint256 stateInfo);\n    function logState(uint256 stateInfo) public {\n        emit State(stateInfo);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract MetricTracker {\n    event Metric(int256 metricValue);\n    function trackMetric(int256 metricValue) public {\n        emit Metric(metricValue);\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ProfileLogger {\n    event Profile(bytes32 profileData);\n    function logProfile(bytes32 profileData) public {\n        emit Profile(profileData);\n    }\n    function dummy() public pure {}\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ResourceLogger {\n    event Resource(uint256 resourceId);\n    function logResource(uint256 resourceId) public {\n        emit Resource(resourceId);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ActionLogger {\n    event Action(uint256 actionId);\n    function logAction(uint256 actionId) public {\n        emit Action(actionId);\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract EventLogger {\n    event Event(uint256 eventId);\n    function logEvent(uint256 eventId) public {\n        emit Event(eventId);\n    }\n    function helperFunction() public pure {}\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract WarningLogger {\n    event Warning(string warningMessage);\n    function logWarning(string memory warningMessage) public {\n        emit Warning(warningMessage);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract UpdateTracker {\n    event Update(uint256 updateValue);\n    function trackUpdate(uint256 updateValue) public {\n        emit Update(updateValue);\n    }\n    function extraAction() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract FeedbackRecorder {\n    event Feedback(uint256 feedbackId);\n    function recordFeedback(uint256 feedbackId) public {\n        emit Feedback(feedbackId);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract NotificationTracker {\n    event Notification(string notification);\n    function trackNotification(string memory notification) public {\n        emit Notification(notification);\n    }\n}"
      }
    }
  },
  {
    "Changes129": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Declarations with the name <code>this</code>, <code>super</code> and <code>_</code> are disallowed, with the exception of\npublic functions and events. The exception is to make it possible to declare interfaces of contracts\nimplemented in languages other than Solidity that do permit such function names.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseA {\n    uint256 public this;\n\n    function setThis(uint256 newValue) public {\n        this = newValue;\n    }\n\n    function randomAddition() public pure returns (uint256) {\n        return 42;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/122.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseA {     uint256 public this;      function setThis(uint256 new ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseB {\n    uint256 public super;\n\n    function updateSuper(uint256 value) public {\n        super = value;\n    }\n\n    function doNothing() public pure {}\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/123.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseB {     uint256 public super;      function updateSuper(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseC {\n    bool public _;\n\n    function flip_() public {\n        _ = !_;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/124.sol:1:48:\n  |\n1 | pragma solidity^0.8.0;  contract MisuseC {     bool public _;      function flip_() public {         _ = !_;     } }\n  |                                                ^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseD {\n    uint256 public this;\n\n    function changeThis(uint256 _new) public {\n        this = _new;\n    }\n\n    function extraMethodA() public pure returns (bool) {\n        return true;\n    }\n\n    function extraMethodB() public pure returns (uint256) {\n        return 123456;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/125.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseD {     uint256 public this;      function changeThis(uint256  ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseE {\n    uint256 public super;\n\n    function adjustSuper(uint256 newSuper) public {\n        super = newSuper;\n    }\n\n    function placeholderFunction() public pure returns (uint256) {\n        return 98765;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/126.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseE {     uint256 public super;      function adjustSuper(uint256 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseF {\n    int256 public _;\n\n    function set_(int256 newValue) public {\n        _ = newValue;\n    }\n\n    function checkPositive() public view returns (bool) {\n        return _ > 0;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/127.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseF {     int256 public _;      function set_(int256 newValu ...\n  |                                         ^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseG {\n    address public this;\n\n    function setThis(address newAddress) public {\n        this = newAddress;\n    }\n}",
          "error message": "Error: The name \"this\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/128.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseG {     address public this;      function setThis(address new ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseH {\n    bytes32 public super;\n\n    function updateSuper(bytes32 newSuper) public {\n        super = newSuper;\n    }\n\n    function someExtraLogic() public pure returns (string memory) {\n        return \"Nothing special\";\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/129.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseH {     bytes32 public super;      function updateSuper(bytes32 ...\n  |                                         ^^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseI {\n    uint256 public _;\n\n    function increment_() public {\n        _ += 1;\n    }\n\n    function decrement_() public {\n        _ -= 1;\n    }\n}",
          "error message": "Error: The name \"_\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/130.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseI {     uint256 public _;      function increment_() public ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\n\ncontract MisuseJ {\n    string public super;\n\n    function setSuper(string calldata newSuper) public {\n        super = newSuper;\n    }\n}",
          "error message": "Error: The name \"super\" is reserved.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/131.sol:1:48:\n  |\n1 |  ... ity^0.8.0;  contract MisuseJ {     string public super;      function setSuper(string cal ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\n\ncontract FixedA {\n    uint256 public value;\n\n    function setValue(uint256 newValue) public {\n        value = newValue;\n    }\n\n    function randomAddition() public pure returns (uint256) {\n        return 42;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\n\ncontract FixedB {\n    uint256 public value;\n\n    function updateValue(uint256 value) public {\n        value = value;\n    }\n\n    function doNothing() public pure {}\n}",
        "Example3": "pragma solidity ^0.8.0;\n\ncontract FixedC {\n    bool public state;\n\n    function flipState() public {\n        state = !state;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\n\ncontract FixedD {\n    uint256 public value;\n\n    function changeValue(uint256 _new) public {\n        value = _new;\n    }\n\n    function extraMethodA() public pure returns (bool) {\n        return true;\n    }\n\n    function extraMethodB() public pure returns (uint256) {\n        return 123456;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\n\ncontract FixedE {\n    uint256 public value;\n\n    function adjustValue(uint256 newValue) public {\n        value = newValue;\n    }\n\n    function placeholderFunction() public pure returns (uint256) {\n        return 98765;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\n\ncontract FixedF {\n    int256 public value;\n\n    function setValue(int256 newValue) public {\n        value = newValue;\n    }\n\n    function checkPositive() public view returns (bool) {\n        return value > 0;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\n\ncontract FixedG {\n    address public addressValue;\n\n    function setAddress(address newAddress) public {\n        addressValue = newAddress;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\n\ncontract FixedH {\n    bytes32 public value;\n\n    function updateValue(bytes32 newValue) public {\n        value = newValue;\n    }\n\n    function someExtraLogic() public pure returns (string memory) {\n        return \"Nothing special\";\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\n\ncontract FixedI {\n    uint256 public value;\n\n    function incrementValue() public {\n        value += 1;\n    }\n\n    function decrementValue() public {\n        value -= 1;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\n\ncontract FixedJ {\n    string public value;\n\n    function setValue(string calldata newValue) public {\n        value = newValue;\n    }\n}"
      }
    }
  },
  {
    "Changes130": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "Remove support for the <code>b</code>, <code>f</code>, and <code>v</code> escape sequences in code.\nThey can still be inserted via hexadecimal escapes, e.g. <code>x08</code>, <code>x0c</code>, and <code>x0b</code>, respectively.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemOne {\n    string public errorValueOne = \"Error value: \\b\";\n    function pullErrorValueOne() public view returns (string memory) {\n        return errorValueOne;\n    }\n    function extraCode() public pure returns (int) {\n        return 10;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/132.sol:1:82:\n  |\n1 |  ...      string public errorValueOne = \"Error value: \\b\";     function pullErrorValueOne() ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemTwo {\n    string public errorValueTwo = \"Error value: \\f\";\n    function pullErrorValueTwo() public view returns (string memory) {\n        return errorValueTwo;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/133.sol:1:82:\n  |\n1 |  ...      string public errorValueTwo = \"Error value: \\f\";     function pullErrorValueTwo() ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemThree {\n    string public errorValueThree = \"Error value: \\v\";\n    function pullErrorValueThree() public view returns (string memory) {\n        return errorValueThree;\n    }\n    function additionalFeature() public pure returns (bool) {\n        return false;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/134.sol:1:86:\n  |\n1 |  ...    string public errorValueThree = \"Error value: \\v\";     function pullErrorValueThree ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemFour {\n    string public errorValueFour = \"Error value: \\b\";\n    function pullErrorValueFour() public view returns (string memory) {\n        return errorValueFour;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/135.sol:1:84:\n  |\n1 |  ...     string public errorValueFour = \"Error value: \\b\";     function pullErrorValueFour( ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemFive {\n    string public errorValueFive = \"Error value: \\v\";\n    function pullErrorValueFive() public view returns (string memory) {\n        return errorValueFive;\n    }\n    function extraFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/136.sol:1:84:\n  |\n1 |  ...     string public errorValueFive = \"Error value: \\v\";     function pullErrorValueFive( ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemSix {\n    string public errorValueSix = \"Error value: \\f\";\n    function pullErrorValueSix() public view returns (string memory) {\n        return errorValueSix;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/137.sol:1:82:\n  |\n1 |  ...      string public errorValueSix = \"Error value: \\f\";     function pullErrorValueSix() ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemSeven {\n    string public errorValueSeven = \"Error value: \\b\";\n    function pullErrorValueSeven() public view returns (string memory) {\n        return errorValueSeven;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/138.sol:1:86:\n  |\n1 |  ...    string public errorValueSeven = \"Error value: \\b\";     function pullErrorValueSeven ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemEight {\n    string public errorValueEight = \"Error value: \\v\";\n    function pullErrorValueEight() public view returns (string memory) {\n        return errorValueEight;\n    }\n    function unrelatedFunction() public pure returns (string memory) {\n        return \"Nothing related\";\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/139.sol:1:86:\n  |\n1 |  ...    string public errorValueEight = \"Error value: \\v\";     function pullErrorValueEight ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemNine {\n    string public errorValueNine = \"Error value: \\f\";\n    function pullErrorValueNine() public view returns (string memory) {\n        return errorValueNine;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/140.sol:1:84:\n  |\n1 |  ...     string public errorValueNine = \"Error value: \\f\";     function pullErrorValueNine( ...\n  |                                         ^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract ErrorItemTen {\n    string public errorValueTen = \"Error value: \\b\";\n    function pullErrorValueTen() public view returns (string memory) {\n        return errorValueTen;\n    }\n}",
          "error message": "Error: Invalid escape sequence.\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/141.sol:1:82:\n  |\n1 |  ...      string public errorValueTen = \"Error value: \\b\";     function pullErrorValueTen() ...\n  |                                         ^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract ErrorItemOne {\n    string public errorValueOne = \"Error value: \\x08\";\n    function pullErrorValueOne() public view returns (string memory) {\n        return errorValueOne;\n    }\n    function extraCode() public pure returns (int) {\n        return 10;\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract ErrorItemTwo {\n    string public errorValueTwo = \"Error value: \\x0c\";\n    function pullErrorValueTwo() public view returns (string memory) {\n        return errorValueTwo;\n    }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract ErrorItemThree {\n    string public errorValueThree = \"Error value: \\x0b\";\n    function pullErrorValueThree() public view returns (string memory) {\n        return errorValueThree;\n    }\n    function additionalFeature() public pure returns (bool) {\n        return false;\n    }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract ErrorItemFour {\n    string public errorValueFour = \"Error value: \\x08\";\n    function pullErrorValueFour() public view returns (string memory) {\n        return errorValueFour;\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract ErrorItemFive {\n    string public errorValueFive = \"Error value: \\x0b\";\n    function pullErrorValueFive() public view returns (string memory) {\n        return errorValueFive;\n    }\n    function extraFunction() public pure returns (uint) {\n        return 200;\n    }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract ErrorItemSix {\n    string public errorValueSix = \"Error value: \\x0c\";\n    function pullErrorValueSix() public view returns (string memory) {\n        return errorValueSix;\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract ErrorItemSeven {\n    string public errorValueSeven = \"Error value: \\x08\";\n    function pullErrorValueSeven() public view returns (string memory) {\n        return errorValueSeven;\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract ErrorItemEight {\n    string public errorValueEight = \"Error value: \\x0b\";\n    function pullErrorValueEight() public view returns (string memory) {\n        return errorValueEight;\n    }\n    function unrelatedFunction() public pure returns (string memory) {\n        return \"Nothing related\";\n    }\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract ErrorItemNine {\n    string public errorValueNine = \"Error value: \\x0c\";\n    function pullErrorValueNine() public view returns (string memory) {\n        return errorValueNine;\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract ErrorItemTen {\n    string public errorValueTen = \"Error value: \\x08\";\n    function pullErrorValueTen() public view returns (string memory) {\n        return errorValueTen;\n    }\n}"
      }
    }
  },
  {
    "Changes131": {
      "Version Migration": "0.7->0.8",
      "Knowledge": "The global variables <code>tx.origin</code> and <code>msg.sender</code> have the type <code>address</code> instead of\n<code>address payable</code>. One can convert them into <code>address payable</code> by using an explicit\nconversion, i.e., <code>payable(tx.origin)</code> or <code>payable(msg.sender)</code>.This change was done since the compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible.Change <code>msg.sender.transfer(x)</code> to <code>payable(msg.sender).transfer(x)</code> or use a stored variable of <code>address payable</code> type.",
      "Uncompilable code": {
        "Example1": {
          "code": "pragma solidity ^0.8.0;\ncontract FundDisperser {\n    function disperseFunds() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/142.sol:1:103:\n  |\n1 | pragma solidity^0.8.0; contract FundDisperser {     function disperseFunds() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                       ^^^^^^^^^^^^^^^^^^^"
        },
        "Example2": {
          "code": "pragma solidity ^0.8.0;\ncontract TokenDistributor {\n    function distributeTokens() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function randomHelper() public pure returns (string memory) { return \"Just a helper\"; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/143.sol:1:109:\n  |\n1 |  ... eTokens() public payable {         msg.sender.transfer(msg.value);     }     function ran ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example3": {
          "code": "pragma solidity ^0.8.0;\ncontract CashDispatcher {\n    function dispatchCash() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function utilityOne() public pure returns (uint) { return 123; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/144.sol:1:103:\n  |\n1 |  ... tchCash() public payable {         msg.sender.transfer(msg.value);     }     function uti ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example4": {
          "code": "pragma solidity ^0.8.0;\ncontract FeeRedirector {\n    function redirectFees() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/145.sol:1:102:\n  |\n1 | pragma solidity^0.8.0; contract FeeRedirector {     function redirectFees() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                      ^^^^^^^^^^^^^^^^^^^"
        },
        "Example5": {
          "code": "pragma solidity ^0.8.0;\ncontract GrantDistributor {\n    function distributeGrant() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function someExtraLogic() public pure returns (bool) { return true; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/146.sol:1:108:\n  |\n1 |  ... teGrant() public payable {         msg.sender.transfer(msg.value);     }     function som ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example6": {
          "code": "pragma solidity ^0.8.0;\ncontract MoneySenderPlus {\n    function sendPlusMoney() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/147.sol:1:105:\n  |\n1 | pragma solidity^0.8.0; contract MoneySenderPlus {     function sendPlusMoney() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example7": {
          "code": "pragma solidity ^0.8.0;\ncontract CharityGiver {\n    function giveCharity() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/148.sol:1:100:\n  |\n1 | pragma solidity^0.8.0; contract CharityGiver {     function giveCharity() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                                                                                    ^^^^^^^^^^^^^^^^^^^"
        },
        "Example8": {
          "code": "pragma solidity ^0.8.0;\ncontract PaymentRefunder {\n    function refundPayment() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function doNothing() public pure {}\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/149.sol:1:105:\n  |\n1 |  ... Payment() public payable {         msg.sender.transfer(msg.value);     }     function doN ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example9": {
          "code": "pragma solidity ^0.8.0;\ncontract SubscriberFeeHandler {\n    function handleSubscriberFee() public payable {\n        msg.sender.transfer(msg.value);\n    }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/150.sol:1:116:\n  |\n1 |  ... iberFee() public payable {         msg.sender.transfer(msg.value);     } }\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        },
        "Example10": {
          "code": "pragma solidity ^0.8.0;\ncontract CommissionPayer {\n    function payCommission() public payable {\n        msg.sender.transfer(msg.value);\n    }\n    function anotherHelper() public pure returns (string memory) { return \"Another helper\"; }\n}",
          "error message": "Error: \"send\" and \"transfer\" are only available for objects of type \"address payable\", not \"address\".\n --> ./0.8/0.7-0.8/0.7-0.8-train-error/151.sol:1:105:\n  |\n1 |  ... mission() public payable {         msg.sender.transfer(msg.value);     }     function ano ...\n  |                                         ^^^^^^^^^^^^^^^^^^^"
        }
      },
      "Compilable code": {
        "Example1": "pragma solidity ^0.8.0;\ncontract FundDisperser {\n    function disperseFunds() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example2": "pragma solidity ^0.8.0;\ncontract TokenDistributor {\n    function distributeTokens() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function randomHelper() public pure returns (string memory) { return \"Just a helper\"; }\n}",
        "Example3": "pragma solidity ^0.8.0;\ncontract CashDispatcher {\n    function dispatchCash() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function utilityOne() public pure returns (uint) { return 123; }\n}",
        "Example4": "pragma solidity ^0.8.0;\ncontract FeeRedirector {\n    function redirectFees() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example5": "pragma solidity ^0.8.0;\ncontract GrantDistributor {\n    function distributeGrant() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function someExtraLogic() public pure returns (bool) { return true; }\n}",
        "Example6": "pragma solidity ^0.8.0;\ncontract MoneySenderPlus {\n    function sendPlusMoney() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example7": "pragma solidity ^0.8.0;\ncontract CharityGiver {\n    function giveCharity() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example8": "pragma solidity ^0.8.0;\ncontract PaymentRefunder {\n    function refundPayment() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function doNothing() public pure {}\n}",
        "Example9": "pragma solidity ^0.8.0;\ncontract SubscriberFeeHandler {\n    function handleSubscriberFee() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n}",
        "Example10": "pragma solidity ^0.8.0;\ncontract CommissionPayer {\n    function payCommission() public payable {\n        payable(msg.sender).transfer(msg.value);\n    }\n    function anotherHelper() public pure returns (string memory) { return \"Another helper\"; }\n}"
      }
    }
  }
]