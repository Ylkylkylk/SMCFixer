[
            "The functions <code>.call()</code>, <code>.delegatecall()</code>, <code>staticcall()</code>,\n<code>keccak256()</code>, <code>sha256()</code> and <code>ripemd160()</code> now accept only a single\n<code>bytes</code> argument. Moreover, the argument is not padded. This was changed to\nmake more explicit and clear how the arguments are concatenated. Change every\n<code>.call()</code> (and family) to a <code>.call(\"\")</code> and every <code>.call(signature, a,\nb, c)</code> to use <code>.call(abi.encodeWithSignature(signature, a, b, c))</code> (the\nlast one only works for value types).  Change every <code>keccak256(a, b, c)</code> to\n<code>keccak256(abi.encodePacked(a, b, c))</code>. Even though it is not a breaking\nchange, it is suggested that developers change\n<code>x.call(bytes4(keccak256(\"f(uint256)\")), a, b)</code> to\n<code>x.call(abi.encodeWithSignature(\"f(uint256)\", a, b))</code>.",
            "Functions <code>.call()</code>, <code>.delegatecall()</code> and <code>.staticcall()</code> now return\n<code>(bool, bytes memory)</code> to provide access to the return data.  Change\n<code>bool success = otherContract.call(\"f\")</code> to <code>(bool success, bytes memory\ndata) = otherContract.call(\"f\")</code>.",
            "Solidity now implements C99-style scoping rules for function local\nvariables, that is, variables can only be used after they have been\ndeclared and only in the same or nested scopes. Variables declared in the\ninitialization block of a <code>for</code> loop are valid at any point inside the\nloop.",
            "Explicit function visibility is now mandatory.  Add <code>public</code> to every\nfunction and constructor, and <code>external</code> to every fallback or interface\nfunction that does not specify its visibility already.",
            "Explicit conversions between unrelated contract types are now disallowed. You can only\nconvert from a contract type to one of its base or ancestor types. If you are sure that\na contract is compatible with the contract type you want to convert to, although it does not\ninherit from it, you can work around this by converting to <code>address</code> first.\nExample: if <code>A</code> and <code>B</code> are contract types, <code>B</code> does not inherit from <code>A</code> and\n<code>b</code> is a contract of type <code>B</code>, you can still convert <code>b</code> to type <code>A</code> using <code>A(address(b))</code>.\nNote that you still need to watch out for matching payable fallback functions, as explained below.",
            "The <code>address</code> type  was split into <code>address</code> and <code>address payable</code>,\nwhere only <code>address payable</code> provides the <code>transfer</code> function.  An\n<code>address payable</code> can be directly converted to an <code>address</code>, but the\nother way around is not allowed. Converting <code>address</code> to <code>address\npayable</code> is possible via conversion through <code>uint160</code>. If <code>c</code> is a\ncontract, <code>address(c)</code> results in <code>address payable</code> only if <code>c</code> has a\npayable fallback function. If you use the <a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/common-patterns.html#withdrawal-pattern\"><span class=\"std std-ref\">withdraw pattern</a>,\nyou most likely do not have to change your code because <code>transfer</code>\nis only used on <code>msg.sender</code> instead of stored addresses and <code>msg.sender</code>\nis an <code>address payable</code>.",
            "Conversions between <code>bytesX</code> and <code>uintY</code> of different size are now\ndisallowed due to <code>bytesX</code> padding on the right and <code>uintY</code> padding on\nthe left which may cause unexpected conversion results.  The size must now be\nadjusted within the type before the conversion.  For example, you can convert\na <code>bytes4</code> (4 bytes) to a <code>uint64</code> (8 bytes) by first converting the\n<code>bytes4</code> variable to <code>bytes8</code> and then to <code>uint64</code>. You get the\nopposite padding when converting through <code>uint32</code>. Before v0.5.0 any\nconversion between <code>bytesX</code> and <code>uintY</code> would go through <code>uint8X</code>. For\nexample <code>uint8(bytes3(0x291807))</code> would be converted to <code>uint8(uint24(bytes3(0x291807)))</code>\n(the result is <code>0x07</code>).",
            "Using <code>msg.value</code> in non-payable functions (or introducing it via a\nmodifier) is disallowed as a security feature. Turn the function into\n<code>payable</code> or create a new internal function for the program logic that\nuses <code>msg.value</code>.",
            "Constructors must now be defined using the <code>constructor</code> keyword.",
            "Calling base constructors without parentheses is now disallowed.",
            "<code>suicide</code> is now disallowed (in favor of <code>selfdestruct</code>).",
            "<code>sha3</code> is now disallowed (in favor of <code>keccak256</code>).",
            "<code>throw</code> is now disallowed (in favor of <code>revert</code>, <code>require</code> and\n<code>assert</code>).",
            "The unit denomination <code>years</code> is now disallowed due to complications and\nconfusions about leap years.",
            "Trailing dots that are not followed by a number are now disallowed.",
            "Combining hex numbers with unit denominations (e.g. <code>0x1e wei</code>) is now\ndisallowed.",
            "The prefix <code>0X</code> for hex numbers is disallowed, only <code>0x</code> is possible.",
            "Using <code>constant</code> as function state mutability modifier is now disallowed.",
            "Empty return statements for functions with one or more return values are now\ndisallowed."
]