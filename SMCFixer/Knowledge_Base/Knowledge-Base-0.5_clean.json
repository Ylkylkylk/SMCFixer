[
            "Signed right shift now uses proper arithmetic shift, i.e. rounding towards\nnegative infinity, instead of rounding towards zero.  Signed and unsigned\nshift will have dedicated opcodes in Constantinople, and are emulated by\nSolidity for the moment.",
            "The <code>continue</code> statement in a <code>do...while</code> loop now jumps to the\ncondition, which is the common behavior in such cases. It used to jump to the\nloop body. Thus, if the condition is false, the loop terminates.",
            "The functions <code>.call()</code>, <code>.delegatecall()</code> and <code>.staticcall()</code> do not\npad anymore when given a single <code>bytes</code> parameter.",
            "Pure and view functions are now called using the opcode <code>STATICCALL</code>\ninstead of <code>CALL</code> if the EVM version is Byzantium or later. This\ndisallows state changes on the EVM level.",
            "The ABI encoder now properly pads byte arrays and strings from calldata\n(<code>msg.data</code> and external function parameters) when used in external\nfunction calls and in <code>abi.encode</code>. For unpadded encoding, use\n<code>abi.encodePacked</code>.",
            "The ABI decoder reverts in the beginning of functions and in\n<code>abi.decode()</code> if passed calldata is too short or points out of bounds.\nNote that dirty higher order bits are still simply ignored.",
            "Forward all available gas with external function calls starting from\nTangerine Whistle.",
            "The functions <code>.call()</code>, <code>.delegatecall()</code>, <code>staticcall()</code>,\n<code>keccak256()</code>, <code>sha256()</code> and <code>ripemd160()</code> now accept only a single\n<code>bytes</code> argument. Moreover, the argument is not padded. This was changed to\nmake more explicit and clear how the arguments are concatenated. Change every\n<code>.call()</code> (and family) to a <code>.call(\"\")</code> and every <code>.call(signature, a,\nb, c)</code> to use <code>.call(abi.encodeWithSignature(signature, a, b, c))</code> (the\nlast one only works for value types).  Change every <code>keccak256(a, b, c)</code> to\n<code>keccak256(abi.encodePacked(a, b, c))</code>. Even though it is not a breaking\nchange, it is suggested that developers change\n<code>x.call(bytes4(keccak256(\"f(uint256)\")), a, b)</code> to\n<code>x.call(abi.encodeWithSignature(\"f(uint256)\", a, b))</code>.",
            "Functions <code>.call()</code>, <code>.delegatecall()</code> and <code>.staticcall()</code> now return\n<code>(bool, bytes memory)</code> to provide access to the return data.  Change\n<code>bool success = otherContract.call(\"f\")</code> to <code>(bool success, bytes memory\ndata) = otherContract.call(\"f\")</code>.",
            "Solidity now implements C99-style scoping rules for function local\nvariables, that is, variables can only be used after they have been\ndeclared and only in the same or nested scopes. Variables declared in the\ninitialization block of a <code>for</code> loop are valid at any point inside the\nloop.",
            "Explicit function visibility is now mandatory.  Add <code>public</code> to every\nfunction and constructor, and <code>external</code> to every fallback or interface\nfunction that does not specify its visibility already.",
            "Explicit conversions between unrelated contract types are now disallowed. You can only\nconvert from a contract type to one of its base or ancestor types. If you are sure that\na contract is compatible with the contract type you want to convert to, although it does not\ninherit from it, you can work around this by converting to <code>address</code> first.\nExample: if <code>A</code> and <code>B</code> are contract types, <code>B</code> does not inherit from <code>A</code> and\n<code>b</code> is a contract of type <code>B</code>, you can still convert <code>b</code> to type <code>A</code> using <code>A(address(b))</code>.\nNote that you still need to watch out for matching payable fallback functions, as explained below.",
            "The <code>address</code> type  was split into <code>address</code> and <code>address payable</code>,\nwhere only <code>address payable</code> provides the <code>transfer</code> function.  An\n<code>address payable</code> can be directly converted to an <code>address</code>, but the\nother way around is not allowed. Converting <code>address</code> to <code>address\npayable</code> is possible via conversion through <code>uint160</code>. If <code>c</code> is a\ncontract, <code>address(c)</code> results in <code>address payable</code> only if <code>c</code> has a\npayable fallback function. If you use the <a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/common-patterns.html#withdrawal-pattern\"><span class=\"std std-ref\">withdraw pattern</a>,\nyou most likely do not have to change your code because <code>transfer</code>\nis only used on <code>msg.sender</code> instead of stored addresses and <code>msg.sender</code>\nis an <code>address payable</code>.",
            "Conversions between <code>bytesX</code> and <code>uintY</code> of different size are now\ndisallowed due to <code>bytesX</code> padding on the right and <code>uintY</code> padding on\nthe left which may cause unexpected conversion results.  The size must now be\nadjusted within the type before the conversion.  For example, you can convert\na <code>bytes4</code> (4 bytes) to a <code>uint64</code> (8 bytes) by first converting the\n<code>bytes4</code> variable to <code>bytes8</code> and then to <code>uint64</code>. You get the\nopposite padding when converting through <code>uint32</code>. Before v0.5.0 any\nconversion between <code>bytesX</code> and <code>uintY</code> would go through <code>uint8X</code>. For\nexample <code>uint8(bytes3(0x291807))</code> would be converted to <code>uint8(uint24(bytes3(0x291807)))</code>\n(the result is <code>0x07</code>).",
            "Using <code>msg.value</code> in non-payable functions (or introducing it via a\nmodifier) is disallowed as a security feature. Turn the function into\n<code>payable</code> or create a new internal function for the program logic that\nuses <code>msg.value</code>.",
            "Constructors must now be defined using the <code>constructor</code> keyword.",
            "Calling base constructors without parentheses is now disallowed.",
            "<code>suicide</code> is now disallowed (in favor of <code>selfdestruct</code>).",
            "<code>sha3</code> is now disallowed (in favor of <code>keccak256</code>).",
            "<code>throw</code> is now disallowed (in favor of <code>revert</code>, <code>require</code> and\n<code>assert</code>).",
            "Explicit and implicit conversions from decimal literals to <code>bytesXX</code> types\nis now disallowed.",
            "Explicit and implicit conversions from hex literals to <code>bytesXX</code> types\nof different size is now disallowed.",
            "The unit denomination <code>years</code> is now disallowed due to complications and\nconfusions about leap years.",
            "Trailing dots that are not followed by a number are now disallowed.",
            "Combining hex numbers with unit denominations (e.g. <code>0x1e wei</code>) is now\ndisallowed.",
            "The prefix <code>0X</code> for hex numbers is disallowed, only <code>0x</code> is possible.",
            "Declaring empty structs is now disallowed for clarity.",
            "The <code>var</code> keyword is now disallowed to favor explicitness.",
            "Assignments between tuples with different number of components is now\ndisallowed.",
            "Values for constants that are not compile-time constants are disallowed.",
            "Multi-variable declarations with mismatching number of values are now\ndisallowed.",
            "Uninitialized storage variables are now disallowed.",
            "Empty tuple components are now disallowed.",
            "Detecting cyclic dependencies in variables and structs is limited in\nrecursion to 256.",
            "Fixed-size arrays with a length of zero are now disallowed.",
            "Using <code>constant</code> as function state mutability modifier is now disallowed.",
            "Empty return statements for functions with one or more return values are now\ndisallowed.",
            "Detecting cyclic dependencies in variables and structs is limited in\nrecursion to 256.",
            "Fixed-size arrays with a length of zero are now disallowed.",
            "New reserved keywords: <code>alias</code>, <code>apply</code>, <code>auto</code>, <code>copyof</code>,\n<code>define</code>, <code>immutable</code>, <code>implements</code>, <code>macro</code>, <code>mutable</code>,\n<code>override</code>, <code>partial</code>, <code>promise</code>, <code>reference</code>, <code>sealed</code>,\n<code>sizeof</code>, <code>supports</code>, <code>typedef</code> and <code>unchecked</code>."
]
