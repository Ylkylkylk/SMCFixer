[
    "The type <code>byte</code> has been removed. It was an alias of <code>bytes1</code>.Change <code>byte</code> to <code>bytes1</code>.",
    "Explicit conversions from negative literals and literals larger than <code>type(uint160).max</code> to\n<code>address</code> are disallowed.",
    "Explicit conversions between literals and an integer type <code>T</code> are only allowed if the literal\nlies between <code>type(T).min</code> and <code>type(T).max</code>. In particular, replace usages of <code>uint(-1)</code>\nwith <code>type(uint).max</code>.",
    "Explicit conversions between literals and enums are only allowed if the literal can\nrepresent a value in the enum.",
    "Explicit conversions between literals and <code>address</code> type (e.g. <code>address(literal)</code>) have the\ntype <code>address</code> instead of <code>address payable</code>. One can get a payable address type by using an\nexplicit conversion, i.e., <code>payable(literal)</code>.",
    "<a class=\"reference internal\" href=\"https://docs.soliditylang.org/en/v0.8.23/types.html#address-literals\"><span class=\"std std-ref\">Address literals</a> have the type <code>address</code> instead of <code>address\npayable</code>. They can be converted to <code>address payable</code> by using an explicit conversion, e.g.\n<code>payable(0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF)</code>.",
    "<code>address(uint)</code> and <code>uint(address)</code>: converting both type-category and width. Replace this by\n<code>address(uint160(uint))</code> and <code>uint(uint160(address))</code> respectively.Add intermediate explicit type conversions if required.",
    "<code>payable(uint160)</code>, <code>payable(bytes20)</code> and <code>payable(integer-literal)</code>: converting both\ntype-category and state-mutability. Replace this by <code>payable(address(uint160))</code>,\n<code>payable(address(bytes20))</code> and <code>payable(address(integer-literal))</code> respectively. Note that\n<code>payable(0)</code> is valid and is an exception to the rule.",
    "<code>int80(bytes10)</code> and <code>bytes10(int80)</code>: converting both type-category and sign. Replace this by\n<code>int80(uint80(bytes10))</code> and <code>bytes10(uint80(int80)</code> respectively.",
    "<code>Contract(uint)</code>: converting both type-category and width. Replace this by\n<code>Contract(address(uint160(uint)))</code>.",
    "Function call options can only be given once, i.e. <code>c.f{gas: 10000}{value: 1}()</code> is invalid and has to be changed to <code>c.f{gas: 10000, value: 1}()</code>.Combine <code>c.f{gas: 10000}{value: 1}()</code> to <code>c.f{gas: 10000, value: 1}()</code>.",
    "The global functions <code>log0</code>, <code>log1</code>, <code>log2</code>, <code>log3</code> and <code>log4</code> have been removed.Use inline assembly as a replacement for <code>log0</code>, \u2026, <code>log4</code>.13.These are low-level functions that were largely unused. Their behavior can be accessed from inline assembly.",
    "Declarations with the name <code>this</code>, <code>super</code> and <code>_</code> are disallowed, with the exception of\npublic functions and events. The exception is to make it possible to declare interfaces of contracts\nimplemented in languages other than Solidity that do permit such function names.",
    "Remove support for the <code>b</code>, <code>f</code>, and <code>v</code> escape sequences in code.\nThey can still be inserted via hexadecimal escapes, e.g. <code>x08</code>, <code>x0c</code>, and <code>x0b</code>, respectively.",
    "The global variables <code>tx.origin</code> and <code>msg.sender</code> have the type <code>address</code> instead of\n<code>address payable</code>. One can convert them into <code>address payable</code> by using an explicit\nconversion, i.e., <code>payable(tx.origin)</code> or <code>payable(msg.sender)</code>.This change was done since the compiler cannot determine whether or not these addresses are payable or not, so it now requires an explicit conversion to make this requirement visible.Change <code>msg.sender.transfer(x)</code> to <code>payable(msg.sender).transfer(x)</code> or use a stored variable of <code>address payable</code> type.",
    "The <code>chainid</code> builtin in inline assembly is now considered <code>view</code> instead of <code>pure</code>.",
    "Unary negation cannot be used on unsigned integers anymore, only on signed integers.Negate unsigned integers by subtracting them from the maximum value of the type and adding 1 (e.g. <code>type(uint256).max - x + 1</code>, while ensuring that <code>x</code> is not zero)"
]
